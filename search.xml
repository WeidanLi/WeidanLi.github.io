<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一个Java程序猿眼中的汇编</title>
    <url>//basic/%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96/index.html</url>
    <content><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>在计算机中，CPU只能识别二进制，当需要CPU做事情的时候，都需要通过二进制去指挥CPU做什么事情。古人觉得二进制实在是难以理解，所以才发明了汇编语言以及后面的高级语言，所以汇编语言可以称作为比较接近机器语言的语言了。 当然后面的古人依然觉得汇编语言难以理解，所以发明了C、C++、Java来解决难以理解的问题。所以后面的语言越来越偏于人类自然语言，并且使用面向对象的思想来设计程序。当然这期间经历的事情还挺多：C编译成汇编语言，汇编语言再翻译成二进制语言，这个过程即称为assembling。 学习汇编语言既需要下面两个概念的理解：<strong>内存模型</strong>和<strong>寄存器</strong></p>
<a id="more"></a>

<h2 id="二、内存模型"><a href="#二、内存模型" class="headerlink" title="二、内存模型"></a>二、内存模型</h2><h3 id="（一）内存模型的介绍"><a href="#（一）内存模型的介绍" class="headerlink" title="（一）内存模型的介绍"></a>（一）内存模型的介绍</h3><p>内存通常被程序分为两个部分：<strong>堆（Heap）</strong>和<strong>栈（Stack）</strong> 当一个程序开始运行的时候，系统通常会为改程序开辟一块内存空间，而这块内存空间在该程序运行的时候，也会被划分成为上面最常见的两块区域，通常他们的作用如下：</p>
<ol>
<li> 堆（Heap）：通常被动态的划分，用来存储程序运行的时候需要存储的数据，当程序结束以后，这块内存将被系统重新回收。当C语言中调用</li>
<li> 栈（Stack）：用于存储方法运行中需要使用到的临时变量的空间。Java中的栈，当需要的临时变量如果是对象的情况下，存储的是对象在堆中的引用地址，基本数据类型的话那就是直接存储数据了。</li>
</ol>
<h3 id="（二）堆空间的使用"><a href="#（二）堆空间的使用" class="headerlink" title="（二）堆空间的使用"></a>（二）堆空间的使用</h3><p>（内存模型引用阮老师的图片） 1.当一个程序被启动，系统中会在内存中为改程序划分一块空闲内存： </p>
<p><img src="/images/%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96.md/0.jpg"> </p>
<p>这块内存是从低到高进行划分的，当该程序需要分配对象的时候（使用<code>malloc</code>命令），系统将从这块内存的低位开始，按照对象的大小划分一块内存供这个对象存放： </p>
<p><img src="/images/%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96.md/1.jpg"></p>
<p> 图中的对象中用了32个字节： 具体计算（8进制）： <code>0x1000 + 32 = 0x1020</code> 堆空间必须手动释放或者通过程序的垃圾回收器，如果该对象被GC判定为无用的对象，那么GC将对这块内存进行释放。</p>
<h3 id="（三）栈空间的使用"><a href="#（三）栈空间的使用" class="headerlink" title="（三）栈空间的使用"></a>（三）栈空间的使用</h3><p>栈空间用于存储一个函数运行过程中需要用到的数据的内存。 栈和堆不同的是：栈是从高位开始占用内存的，而且遵从LIFO (Last-In-First-Out)原则。 为啥是先进后出：因为函数调用的时候，最后一个调用的函数是最先结束的： 举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">return</span> add_a_and_b(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，main函数先入栈，其次调用了<code>add_a_and_b(a, b)</code>，该函数入栈。那么是不是<code>add_a_and_b(a, b)</code>函数先执行完成，再把结果返回给<code>main</code>方法，<code>main</code>再运行结束。 栈空间： </p>
<p><img src="/images/%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96.md/2.jpg"></p>
<h2 id="三、寄存器"><a href="#三、寄存器" class="headerlink" title="三、寄存器"></a>三、寄存器</h2><h3 id="（一）寄存器的介绍"><a href="#（一）寄存器的介绍" class="headerlink" title="（一）寄存器的介绍"></a>（一）寄存器的介绍</h3><p>我们还要知道的另外一件事情是CPU只负责做事情，并不能够存储任何数据，包括运算过程中需要用到的临时数据，都需要通过缓存、内存以及寄存器来存储。 那么何为缓存：缓存是CPU能够够得到的第一级存储物质，再之是内存。为啥有内存了还需要这些东西呢，因为设计者认为，CPU的速度要远快于内存的速度，如果任何数据都通过去读取和写入内存操作的话，就会拖慢CPU的速度，所以在京东或者其他地方购买CPU的时候，是会出现缓存这个东西的： </p>
<p><img src="/images/%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96.md/3.jpg"></p>
<p> 现在普通一点的CPU都会自带一级缓存二级缓存（图中还有三级缓存= =），说的就是这个事情，当然这个缓存也不是越大越好，仔细想想如果这个缓存过大，那么在同步缓存和内存的数据的时候，是不是也会变慢。这个东西和jvm虚拟机中的堆和栈大小是一致的，如果jvm中堆栈过大，放数据是爽很多了，但是在进行垃圾清理的时候就是悲剧了。 接下来还有寄存器的概念：设计者认为每次需要数据的时候去读取数据，都需要寻址读取，那么还是会变慢很多，那如果把数据的地址存放在一个地方，需要的时候直接取出这个地址，然后再在缓存中去取出来，就会快很多，这个过程就是寄存器需要做的事情了。寄存器相当于用于寄放地址的地方，当程序指示CPU去读取什么数据的时候，CPU优先从寄存器中取出数据的地址，然后从缓存读取数据进行运算。 那么计算机运行的过程相当于： 1. 用户告诉CPU启动一个程序 2. 程序把数据放入系统为其开辟的一块内存空间 3. CPU从内存读取数据放入缓存，以及在寄存器放入缓存数据的地址 4. CPU通过协调内存、寄存器、CPU缓存完成用户继续给予的指令。</p>
<h3 id="（二）寄存器的种类"><a href="#（二）寄存器的种类" class="headerlink" title="（二）寄存器的种类"></a>（二）寄存器的种类</h3><p>一个CPU都会提供多种寄存器，用于存储不同的数据（不同程序使用不同的寄存器），在早期的x86处理器当中，CPU提供9种不同的寄存器，但是程序中可用的只有7中，其中2中用于做特殊作用：</p>
<blockquote>
<p>现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p>
</blockquote>
<ol>
<li> EAX</li>
<li> EBX</li>
<li> ECX</li>
<li> EDX</li>
<li> EDI</li>
<li> ESI</li>
<li> EBP</li>
<li> ESP 记录内存中栈空间的地址</li>
<li> EIP 记录当前指令执行的位置</li>
</ol>
<p>汇编语言要做的事情就是指挥这些寄存器中做的动作。</p>
<h2 id="四、一个简单的程序"><a href="#四、一个简单的程序" class="headerlink" title="四、一个简单的程序"></a>四、一个简单的程序</h2><p>现在使用一个C语言的代码来表述计算机做了什么事情：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> add_a_and_b(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add_a_and_b</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行编译，他将会被编译成以下的汇编语言：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_main:</span><br><span class="line">   push 3 ;                        把第二个参数&#x27;3&#x27;Push（推）进内存</span><br><span class="line">   push 2 ;                        把第一个参数&#x27;2&#x27;Push进内存</span><br><span class="line">   call _add_a_and_b ;     调用add_a_and_b 函数：并且让当前程序运行的指针（在EIP寄存器中）</span><br><span class="line">                                        指向函数的第一条指令（push %ebx）</span><br><span class="line">   add %esp, 8 ;              将esp指针在栈上向上移动8个字节，弹出我们上面压入的两个值，此时第一个值已经变成计算以后的值了。</span><br><span class="line">   ret ;                               返回到调用main函数的函数中。</span><br><span class="line"></span><br><span class="line">_add_a_and_b:</span><br><span class="line">   push %ebx ;                    程序准备修改ebx寄存器中的值, 所以程序需要将ebx推入栈中</span><br><span class="line">                                            以便让后面程序运行结束以后可以还原数据</span><br><span class="line">   mov %eax, [%esp+8] ;    将第一个参数移入EAX（详看下图可以知道为什么是+8）</span><br><span class="line">   mov %ebx, [%esp+12] ;  将第二个参数移入EBX</span><br><span class="line">   add %eax, %ebx ;           将eax和ebx中的值进行相加，并且把结果存储在eax中</span><br><span class="line">   pop %ebx ;                      将ebx中的值弹出，以便还原ebx中的数据</span><br><span class="line">   ret ;                                   返回到main函数. 这个步骤将会把下一步运行地址弹出到栈内存中</span><br><span class="line">                                             (当call执行完以后的下一步地址) 放入eip寄存器</span><br></pre></td></tr></table></figure>
<p>程序运行的时候，内存模型如下： </p>
<p><img src="/images/%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9C%BC%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96.md/4.jpg"> </p>
<p>第一步：当main开始运行的时候，需要先把临时的值压入栈内存中： 所以有两个参数<code>3和2</code>被压入占中，这就是栈内存中前两个的值的地址。 第二步：临时变量已经准备好了，我们要把main函数压入栈中，因为main函数一共有四条指令，而一条指令只用<code>4</code>个字节，所以一共有16个字节被压入栈中 第三步：因为在函数<code>_add_a_and_b</code>中，我们用到了中间寄存器用来计算ebx，所以ebx被压入栈中。 经过了这三个步骤，那么esp（程序运行指针）被多次往下移动了16个字节，其中包括main函数四条命令4个字节以及两个参数8个字节，还有一个临时寄存器使用了4个字节， 当然图中那么画还不够具体。</p>
<p>首先main函数入栈，将参数推入栈中。 然后运行到了<code>call _add_a_and_b</code>步骤，函数入栈，继续刚刚的操作 这里因为<code>call _add_a_and_b</code>中有个步骤是推入一个中间寄存器，所以esp在call部分又向下推一个4字节的空间。 所以在函数当中，需要访问第一个参数的时候，应该是通过<code>esp + 8</code>去获取，第二个就更需要<code>esp + 12</code>去获取了 这里有个重点，就是我们如何保证我们使用的寄存器不会被其他程序的执行而让我们的程序运行过程中遭到破坏。 很简单：当我们需要用到一个寄存器的时候，我们把一个寄存器的副本压入栈中，然后我们即可在函数中对这个寄存器进行使用以及清理。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">阮一峰《汇编语言入门教程》</a><br><a href="http://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/">Introduction to reverse engineering and Assembly.</a><br><a href="http://blog.csdn.net/daleiwang/article/details/50579776">堆栈的工作原理</a> </p>
]]></content>
      <categories>
        <category>技能</category>
        <category>基础</category>
        <category>编译</category>
      </categories>
  </entry>
  <entry>
    <title>Netty处理WebSocket，Nginx配置</title>
    <url>//netty/netty%E5%A4%84%E7%90%86websocket%EF%BC%8Cnginx%E9%85%8D%E7%BD%AE/index.html</url>
    <content><![CDATA[<h2 id="一-实时消息WebSocket"><a href="#一-实时消息WebSocket" class="headerlink" title="一.实时消息WebSocket"></a>一.实时消息WebSocket</h2><p>传统的 <code>WEB</code> 开发中，通常我们渲染数据或者请求增删改的时候，都需要通过发送 <code>HTTP</code> 请求。 而每次发送 <code>HTTP</code> 请求基本都需要经历下面的历程（其实和 <code>TCP</code> 大致相同）： <img src="https://liweidan.cn/wp-content/uploads/2019/08/HTTP-PROCESS.png" alt="image-20190804143610798"> 而当我们需要一些实时消息的需求的时候，比如聊天或者消息推送，那么我们有一种做法就是。浏览器每隔几秒轮训一次服务器（因为不请求服务器就没法回复消息），走一下上面的步骤，然后服务器如果有数据响应数据，没有数据就响应空的数据。哇啊啊啊啊你看这个过程，如果我的后台系统这个账号刚好没什么生意，基本很少需要推送有人下单的消息给我，可是我还是要走这些流程，服务器也还是需要处理我这个没用的卖家的请求。 当然并不是这种方式没人采用，还是有的，因为开发简单。但是性能其实并不怎么样，而且还要浪费一个服务来处理这个请求。 这个问题看起来还是比较棘手的而且很迫切的一个需求，于是乎我们的 <code>W3C</code> 组织站了出来，为浏览器新增了一个新的协议 <code>WebSocket</code> 协议，在 <code>HTML5</code> 发布的时候新增进去的。 <code>WebSocket</code> 跟 <code>HTTP</code> 在同一层，利用 <code>HTTP</code> 向服务器请求升级 <code>WebSocket</code>，服务器应答即可将当前的连接升级为 <code>WebSocket</code> 连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET ws://localhost:9999/ HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket # 请求升级WebSocket</span><br><span class="line">Connection: Upgrade # 同样</span><br><span class="line">Origin: http://localhost:8000</span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>服务器如果答应了，就会响应：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br></pre></td></tr></table></figure>
<p>这时候相当于说，我浏览器和服务器经历了三次握手，然后在中间建设了一个管道。 这个管道，谁都可以随时使用，客户端和服务端都可以同时发送消息。也就是说在上面订单通知的例子中，我服务器收到了一个订单支付成功，即可立马发送一条消息给你客户端。</p>
<a id="more"></a>
<h2 id="二-Netty处理WebSocket"><a href="#二-Netty处理WebSocket" class="headerlink" title="二.Netty处理WebSocket"></a>二.Netty处理WebSocket</h2><p>OK，接下来轮到 <code>Netty</code> 来干活了。 我们知道 <code>Netty</code> 基本是由一堆 <code>Handler</code> 组成一个链条来处理请求的。</p>
<h3 id="2-1-Netty的WebSocket解码器"><a href="#2-1-Netty的WebSocket解码器" class="headerlink" title="2.1 Netty的WebSocket解码器"></a>2.1 Netty的WebSocket解码器</h3><p>所以我们组装 <code>Pipeline</code> 的时候需要安装一个 <code>WebSocketServerProtocolHandler</code> 处理器，他会将 <code>WebSocket</code> 请求处理并且传递给下一个 <code>handler</code>（一般是我们的业务处理器）。构造器需要指定 <code>WebSocket</code> 处理的 <code>uri</code>。 安装：<code>pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/&quot;));</code> 具体详细的引导安装下面再说。</p>
<h3 id="2-2-编写我们自己的Handler"><a href="#2-2-编写我们自己的Handler" class="headerlink" title="2.2 编写我们自己的Handler"></a>2.2 编写我们自己的Handler</h3><p>因为浏览器发送的数据也是二进制的进行，有自己的帧规则，而上一步我们安装了 <code>Netty</code> 提供的处理器以后，这时候我们已经可以取出来浏览器发送的字符串了，所以我们自己的处理器需要处理 <code>TextWebSocketFrame</code>。这是一个数据封装的包裹（前面说的 <code>ByteBuf</code>，只不过内部已经进行了翻译）所以我们可以很简单的根据业务需求封装一些请求类以及响应类，这里为了简单不做进一步封装。 我现在有个需求，连接了 <code>Netty</code> 服务器，发送一个消息后，假装服务器有通知需要发送，每隔 <code>2</code> 秒就给浏览器发送，浏览器打印。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(text));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 每隔2秒发送一个消息 */</span></span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;你有一个新的淘金订单，请尽快处理&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实应该不是很难理解这个代码…</p>
<h3 id="2-3-引导安装服务器"><a href="#2-3-引导安装服务器" class="headerlink" title="2.3 引导安装服务器"></a>2.3 引导安装服务器</h3><p>我们知道 <code>WebSocket</code> 是通过 <code>HTTP</code> 来升级的，所以这时，<code>HTTP</code> 处理器还是不能少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ServerBootstrap</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">NotifyHandler</span> <span class="variable">notifyHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotifyHandler</span>();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">9999</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                  <span class="comment">/** 新增HTTP处理器，处理请求升级问题 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">                  <span class="comment">/** 安装 WebSocket 处理器 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">                  <span class="comment">/** 安装我自己的Handler */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(notifyHandler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后启动，进行测试。</p>
<h3 id="2-4-测试WebSocket接口"><a href="#2-4-测试WebSocket接口" class="headerlink" title="2.4 测试WebSocket接口"></a>2.4 测试WebSocket接口</h3><p>在开发的时候发现了这个很有用的小工具 <a href="http://www.websocket-test.com/">在线测试WebSocket</a> OK，我们的端口是 <code>9999</code>，这时候只要在左侧窗口的连接地址写 <code>ws://localhost:9999/</code>，然后尝试写消息给服务器，让服务器不断的写消息给我们。 </p>
<p><img src="/images/netty%E5%A4%84%E7%90%86websocket%EF%BC%8Cnginx%E9%85%8D%E7%BD%AE.md/2.gif"></p>
<h2 id="三-开发实时通知页面"><a href="#三-开发实时通知页面" class="headerlink" title="三.开发实时通知页面"></a>三.开发实时通知页面</h2><p>服务端有了，现在需要页面来做对接呀。 直接上代码好了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;TEST-WEBSOCKET&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    let retry = null</span><br><span class="line">    let wbs = null</span><br><span class="line">    function openWebSocket() &#123;</span><br><span class="line">        /** 创建WebSocket客户端 */</span><br><span class="line">        wbs = new WebSocket(&quot;ws://localhost:9999/&quot;)</span><br><span class="line">        /** 定义接收消息弹窗显示 */</span><br><span class="line">        wbs.onmessage = (evt) =&gt; &#123;</span><br><span class="line">            /** 弹窗打印服务器发送的消息内容 */</span><br><span class="line">            alert(evt.data)</span><br><span class="line">        &#125;</span><br><span class="line">        /** 定义连接打开后需要发送的消息 */</span><br><span class="line">        wbs.onopen = () =&gt; &#123;</span><br><span class="line">            console.log(&quot;WebSocket连接已打开&quot;)</span><br><span class="line">            /** 打开连接即发送消息 */</span><br><span class="line">            wbs.send(&quot;HELLO&quot;);</span><br><span class="line"></span><br><span class="line">            /** 打开后如果重试还在 清楚重试对象 */</span><br><span class="line">            if (retry !== null) &#123;</span><br><span class="line">                clearInterval(retry)</span><br><span class="line">                retry = null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 */</span><br><span class="line">        wbs.onclose = () =&gt; &#123;</span><br><span class="line">            console.log(&#x27;WebSocket被关闭了&#x27;)</span><br><span class="line">            if (null === retry) &#123;</span><br><span class="line">                retry = setInterval(function () &#123;</span><br><span class="line">                    console.log(&quot;尝试重连....&quot;)</span><br><span class="line">                    openWebSocket()</span><br><span class="line">                &#125;, 3000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openWebSocket();</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/netty%E5%A4%84%E7%90%86websocket%EF%BC%8Cnginx%E9%85%8D%E7%BD%AE.md/3.gif"></p>
<h2 id="四-Nginx反向代理"><a href="#四-Nginx反向代理" class="headerlink" title="四.Nginx反向代理"></a>四.Nginx反向代理</h2><p><code>Nginx</code> 通常在生产中被用作反向代理服务器，什么意思咧，相当于请求进门，进门之前，证书什么的都在这里配置。 我跟往常一样在这里配置 <code>WebSocket</code> 服务端的证书呀反向代理服务器呀。 唯独没有关注连接超时被断开的问题，上了测试，我的 <code>Web</code> 项目居然过了 <code>1</code> 分钟就总是偷偷断开。导致后面用户接受不到订单的更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 升级请求</span><br><span class="line">map $http_upgrade $connection_upgrade &#123;  </span><br><span class="line">    default upgrade;  </span><br><span class="line">    &#x27;&#x27; close;  </span><br><span class="line">&#125;  </span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on ;</span><br><span class="line">    server_name wbs.liweidan.com;</span><br><span class="line">    ssl_certificate   XXXXX.pem;</span><br><span class="line">    ssl_certificate_key  XXXXX.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:9999/;  </span><br><span class="line">        proxy_http_version 1.1;  </span><br><span class="line">                proxy_connect_timeout 4s; </span><br><span class="line">        proxy_read_timeout 1200s; # 20分钟没有接受请求才超时断开</span><br><span class="line">        proxy_send_timeout 12s; # 十二秒没有发送成功即发送超时</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">        proxy_set_header Connection &quot;Upgrade&quot;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Emm，没错，有中文注释的是配置关键点。表示 <code>20分钟</code> 没有数据读取才关闭连接。 但是有些需求不需要关闭连接啊，怎么办，来个 <code>PING</code> <code>PONG</code> 心跳咯： 然而浏览器没有这个机制啊，而且只认得服务器发送的 <code>PONG</code> 帧。也就是说，我们需要服务端发送一个 <code>PONG</code> 他浏览器会返回一个 <code>PING</code>（怪怪的然而事实就是这样） 可是我不想服务器来做这个事情，因为毕竟连接的都有时间差嘛。所以我准备在前端发送 <code>PING</code> 服务端收到后返回 <code>PONG</code> 即可。 改一改我们自己的处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotifyHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;PING&quot;</span>.equals(text)) &#123;</span><br><span class="line">      ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;PONG&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 省略代码 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再改一改前端：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> retry = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> ping = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wbs = <span class="literal">null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">openWebSocket</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/** 创建WebSocket客户端 */</span></span><br><span class="line">  wbs = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:9999/&quot;</span>)</span><br><span class="line">  <span class="comment">/** 定义接收消息弹窗显示 */</span></span><br><span class="line">  wbs.<span class="property">onmessage</span> = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/** 弹窗打印服务器发送的消息内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (evt.<span class="property">data</span> !== <span class="string">&#x27;PONG&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(evt.<span class="property">data</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(evt.<span class="property">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 定义连接打开后需要发送的消息 */</span></span><br><span class="line">  wbs.<span class="property">onopen</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebSocket连接已打开&quot;</span>)</span><br><span class="line">    <span class="comment">/** 打开连接即发送消息 */</span></span><br><span class="line">    wbs.<span class="title function_">send</span>(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 打开后如果重试还在 清楚重试对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (retry !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(retry)</span><br><span class="line">      retry = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 连接后启动 PING，PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === ping) &#123;</span><br><span class="line">      <span class="comment">/** 7分钟心跳一次，注意这个值需要设置的比 Nginx 设置的值要小，不然被关闭了就没意义了。 */</span></span><br><span class="line">      ping = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        wbs.<span class="title function_">send</span>(<span class="string">&quot;PING&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">60000</span> * <span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 */</span></span><br><span class="line">  wbs.<span class="property">onclose</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WebSocket被关闭了&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === retry) &#123;</span><br><span class="line">      retry = <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;尝试重连....&quot;</span>)</span><br><span class="line">        <span class="title function_">openWebSocket</span>()</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 连接被关闭后停止 PING-PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> !== ping) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(ping)</span><br><span class="line">      ping = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">openWebSocket</span>();</span><br></pre></td></tr></table></figure>
<p>测试： </p>
<p><img src="/images/netty%E5%A4%84%E7%90%86websocket%EF%BC%8Cnginx%E9%85%8D%E7%BD%AE.md/4.png"></p>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p><code>WebSocket</code> 相关内容完结。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>Nginx</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty之ByteBuf以及编解码器</title>
    <url>//netty/netty%E4%B9%8Bbytebuf%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/index.html</url>
    <content><![CDATA[<h2 id="一-数据传输的容器ByteBuf"><a href="#一-数据传输的容器ByteBuf" class="headerlink" title="一.数据传输的容器ByteBuf"></a>一.数据传输的容器ByteBuf</h2><h3 id="1-1-简单理解一下"><a href="#1-1-简单理解一下" class="headerlink" title="1.1. 简单理解一下"></a>1.1. 简单理解一下</h3><p>OK，上一篇文章我们大致了解了 <code>Netty</code> 在运行过程中所需要的一些组件。接下来需要慢慢的深入了解这些容器了。 为了方便回忆，我先贴一段上一篇的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">in</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> in.toString(Charset.defaultCharset());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在服务端代码中，使用了 <code>ByteBuf</code> 来读取客户端所传递的消息，然后实现逻辑，再使用 <code>ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes(Charset.defaultCharset().name()));</code> 来将处理后的数据重新封装成字节，从而写出去，传递给客户端。 所以大概猜一下，<code>ByteBuf</code> 是一个装载着数据字节的容器，在 <code>Netty</code> 中通过网络进行传输。客户端又重新解码，读取出服务端返回的数据。 其实，<code>jdk</code> 自己的 <code>NIO</code> 也有个类似的类 <code>ByteBuffer</code>，但是这个类，他不太灵活，所以 <code>Netty</code> 才决定重写这个类，从而达到一些比较灵活的目的：</p>
<ol>
<li> 可以被自定义缓冲区类型拓展；</li>
<li> 通过内置的符合缓冲区类型实现透明的零拷贝；</li>
<li> 容量可以自增；</li>
<li> 读写模式不需要来回切换（得益于读写指针）；</li>
<li> 支持链式调用、引用计数以及池化计数。<a id="more"></a>
<h3 id="1-2-深入读写指针"><a href="#1-2-深入读写指针" class="headerlink" title="1.2. 深入读写指针"></a>1.2. 深入读写指针</h3></li>
</ol>
<p>上一节说了，读写模式不需要来回切换，是因为 <code>ByteBuf</code> 内部提供了两个索引 <code>readIndex</code> 以及 <code>writeIndex</code>。当我们从 <code>ByteBuf</code> 读取数据的时候，<code>readIndex</code> 会慢慢的递增已经被读取的字节数，而写入时 <code>writeIndex</code> 同样也会进行移动。 </p>
<p><img src="/images/netty%E4%B9%8Bbytebuf%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8.md/0.png"> </p>
<p>如上图所示，一个16字节的 <code>ByteBuf</code>，刚开始什么都没有的时候，读索引和写索引同在第 <code>0</code> 位上，随着数据慢慢写入，写索引会向右进行移动。这时候没有读取的发生，所以读索引还停留在第 <code>0</code> 位上，而随着我们业务的需求，会读取消息，所以读指针慢慢向后移动，但是这里有个需要注意的地方是，读索引不能超过写索引的位数（即使超过了读后面的消息也没什么意义），如果强行超过，<code>Netty</code> 会给你来一个 <code>IndexOutOfBoundsException</code>。 <code>ByteBuf</code> 自带有一些方法，通过调用 <code>read</code> 和 <code>write</code> 开头的方法，将会推进这两个相对应的索引位置，而如果说我们不想要推动索引而是想直接读取，则可以通过调用 <code>get</code> <code>set</code> 开头的方法，便可以直接操作 <code>ByteBuf</code> 中相对应位置的数据。 可以指定 <code>ByteBuf</code> 的最大容量，如果不指定默认是 <code>Integer.MAX_VALUE</code>。</p>
<h3 id="1-3-不同内存下的-ByteBuf"><a href="#1-3-不同内存下的-ByteBuf" class="headerlink" title="1.3. 不同内存下的 ByteBuf"></a>1.3. 不同内存下的 <code>ByteBuf</code></h3><h4 id="1-1-3-1-堆缓冲区的ByteBuf"><a href="#1-1-3-1-堆缓冲区的ByteBuf" class="headerlink" title="1.1.3.1 堆缓冲区的ByteBuf"></a>1.1.3.1 堆缓冲区的ByteBuf</h4><p>最常用的模式下是堆缓冲区的 <code>ByteBuf</code>，顾名思义堆缓冲区 <code>ByteBuf</code> 是用于存储在 <code>JVM</code> 堆内存中的缓冲区。这种模式称为 <code>支撑数组</code>。他可以在 <code>Java</code> 程序中快速的创建以及被垃圾回收器回收，但是，如果需要写出到 <code>IO设备</code> 则需要经过以下这么几个步骤。 </p>
<p><img src="/images/netty%E4%B9%8Bbytebuf%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8.md/1.png"> </p>
<p>上图所示，<code>Netty</code> 需要先将堆上的数据逐一拷贝到系统直接缓冲区，然后再发送出去。会造成多了一步拷贝的过程。 但是，<code>Java</code> 可以直接操作堆缓冲区的数据呀：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (heapBuf.hasArray()) &#123;</span><br><span class="line">    <span class="type">byte</span>[] arrays = heapBuf.array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-3-2-直接缓冲区"><a href="#1-1-3-2-直接缓冲区" class="headerlink" title="1.1.3.2 直接缓冲区"></a>1.1.3.2 直接缓冲区</h4><p><code>JDK 1.4</code> 以后官方提供了直接向系统申请内存的方法，申请后的内存也不在垃圾回收器清理范围以内，所以当我们申请了直接内存缓冲区的时候，都需要进行手动释放，否则将会造成系统内存溢出。 直接缓冲区的优点刚好是堆缓冲区最不擅长的点，可以直接调用本地 <code>IO</code> 设备，不需要通过拷贝从而将数据传输出去。 但是另外的缺点也有：相比堆缓冲区，如果程序需要读取操作缓冲区的数据的时候，则需要跟以上第一步逆相反的步骤，将直接内存缓冲区的数据拷贝到堆缓冲区才可以进行操作。而且向系统申请和释放内存也会造成性能的降低。</p>
<h4 id="1-1-3-3-复合缓冲区"><a href="#1-1-3-3-复合缓冲区" class="headerlink" title="1.1.3.3 复合缓冲区"></a>1.1.3.3 复合缓冲区</h4><p><code>jdk</code> 完全没有的一个功能，可以提供消息体复用的优势。 比如 <code>HTTP</code> 协议传输消息的时候，我们知道 <code>HTTP</code> 头部很多时候是相似或者说相同的，那么头部就可以存储在直接内存中，使用复合缓冲区 <code>CompositeByteBuf</code> 来聚合直接缓冲区中的头部信息以及堆内存中的消息体，然后进行写出。</p>
<blockquote>
<p>因为可能包含直接内存分配和非直接内存分配，如果只存在一个聚合ByteBuf元素，那么调用 <code>hasArray()</code> 将直接返回这个元素的结果，否则会返回 <code>false</code></p>
</blockquote>
<p>创建复合缓冲区：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">compBuf</span> <span class="operator">=</span> Unpooled.compositeBuffer();</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">head</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">body</span> <span class="operator">=</span> ...;</span><br><span class="line">compBuf.addComponents(head, body);</span><br></pre></td></tr></table></figure>
<p>访问缓冲区数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">compBuf</span> <span class="operator">=</span> Unpooled.compositeBuffer();</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> compBuf.readableBytes();</span><br><span class="line"><span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">compBuf.getBytes(compBuf.readerIndex(), arr);<span class="comment">// 读取数据到数组中</span></span><br></pre></td></tr></table></figure>
<h4 id="1-1-3-4-池化缓冲区"><a href="#1-1-3-4-池化缓冲区" class="headerlink" title="1.1.3.4 池化缓冲区"></a>1.1.3.4 池化缓冲区</h4><p>一般来说，我们需要池化缓冲区，达到可以复用的效果，也可以减少计算机资源的开销，所以 <code>Netty</code> 提供了 <code>ByteBufAllocator</code> 来实现缓冲区的池化效果。 我们可以通过 <code>ByteBufAllocator.DEFAULT</code> 来获取 <code>ByteBufAllocator</code> 对象，从而调用以下方法，建立我们所需要的缓冲区：</p>
<p>方法名称</p>
<p>说明</p>
<p>buffer()<br>buffer(int initialCapacity)<br>buffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆或者直接内存的 <code>ByteBuf</code></p>
<p>heapBuffer()<br>heapBuffer(int initialCapacity)<br>heapBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆缓冲区的 <code>ByteBuf</code></p>
<p>directBuffer()<br>directBuffer(int initialCapacity)<br>directBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于直接内存缓冲区的 <code>ByteBuf</code></p>
<p>compositeBuffer()<br>compositeBuffer(int maxNumComponents)<br>compositeDirectBuffer()<br>compositeDirectBuffer(int maxNumComponents)<br>compositeHeapBuffer()<br>compositeHeapBuffer(int maxNumComponents)</p>
<p>返回指定最大元素的基于堆或者直接内存的<br>缓冲区视图</p>
<p>ioBuffer()</p>
<p>返回基于 <code>Socket</code> 的 <code>IO</code> 操作的 <code>ByteBuf</code></p>
<p>运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ByteBuf&gt; byteBufs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ByteBuf&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">  <span class="type">ByteBuf</span> <span class="variable">byteBuf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">200</span>);</span><br><span class="line">  byteBuf2.writeBytes(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name()));</span><br><span class="line">  byteBufs.add(byteBuf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/netty%E4%B9%8Bbytebuf%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8.md/2.png"> </p>
<p>可以看到，内存一直不断飙升，直到系统拒绝给出内存，抛出异常，程序终止，进程被干掉才结束。</p>
<h4 id="1-1-3-5-非池化缓冲区"><a href="#1-1-3-5-非池化缓冲区" class="headerlink" title="1.1.3.5 非池化缓冲区"></a>1.1.3.5 非池化缓冲区</h4><p>即我第一篇中用到的 <code>Unpooled</code> 类，<code>api</code> 跟上面差不多，不再重复。 主要提供给其他不需要使用 <code>Netty</code> 的项目使用。</p>
<h4 id="1-1-3-6-ByteBufUtil"><a href="#1-1-3-6-ByteBufUtil" class="headerlink" title="1.1.3.6 ByteBufUtil"></a>1.1.3.6 ByteBufUtil</h4><p>主要提供两个方法使用： <code>hexdump()</code> : 主要用于将缓冲区内容写入日志，易于调试，也可以还原成字节数组。 <code>equals(ByteBuf, ByteBuf)</code> : 传递两个 <code>ByteBuf</code> 用于比较相等性。</p>
<h4 id="1-1-3-7-引用计数（TODO）"><a href="#1-1-3-7-引用计数（TODO）" class="headerlink" title="1.1.3.7 引用计数（TODO）"></a>1.1.3.7 引用计数（TODO）</h4><p>这块放在后面 <code>ChannelPipeline</code> 再说。</p>
<h2 id="二-解码和编码"><a href="#二-解码和编码" class="headerlink" title="二.解码和编码"></a>二.解码和编码</h2><h3 id="2-1-啰嗦一下什么是编解码器"><a href="#2-1-啰嗦一下什么是编解码器" class="headerlink" title="2.1 啰嗦一下什么是编解码器"></a>2.1 啰嗦一下什么是编解码器</h3><p>本来应该不需要这个的，但是还是为了篇幅的完整性还是啰嗦一下。 我们知道在传递消息的时候，我们的 <code>Java</code> 对象是不能够实现网络传输的，必须将对象序列化成某种格式（Byte数组），然后网卡再编码成 <code>10101…</code> 传输给另外一台服务器，另外的一台服务器再从 <code>10101...</code> 去重新解码，解成我们所序列化后的数组，然后传递到我们程序再使用我们自己的规则去重新把对象信息还原回来（当然此时客户端的对象的元信息跟服务器端的没有半毛钱关系） 大白话说就是，通过某种规则，在客户端机器上创建一个数据一毛一样的对象。 我们网络开发常见的编解码器有哪些比较耳濡目染的，大概就是 <code>JSON</code> 了吧，可读性强，兼容性棒（各个语言都支持），都 <code>9012</code> 年了就不要来一句 <code>XML</code> 了吧，如果还说 <code>XML</code> 我立马把43码的鞋子pia到你脸上去。 然而，除了 <code>JSON</code> 格式，如果不需要考虑兼容性最强的话，我们也可以使用同行语言都懂的 <code>Byte</code> 数组进行传输，总的来说，使用 <code>Byte</code> 数组可以达到效率更高（编码和解码），传输容量更小，传输速度更快的目的。因为 <code>JSON</code> 格式毕竟都是字符串，传输容量还是属于比较大的，而且频繁操作 <code>String</code> 编码和解码的效率也更低。</p>
<h3 id="2-2-Netty自带的编解码器"><a href="#2-2-Netty自带的编解码器" class="headerlink" title="2.2 Netty自带的编解码器"></a>2.2 Netty自带的编解码器</h3><ol>
<li> ByteToMessageDecoder 和 ReplayingDecoder；</li>
<li> MessageToMessageDecoder；</li>
</ol>
<h4 id="2-2-1-ByteToMessageDecoder"><a href="#2-2-1-ByteToMessageDecoder" class="headerlink" title="2.2.1 ByteToMessageDecoder"></a>2.2.1 ByteToMessageDecoder</h4><p><code>ByteToMessageDecoder</code> 是一个抽象的基类，通过我们做解码的方式去拓展。 我们可以编写自己的解码类，继承 <code>ByteToMessageDecoder</code> 类，需要编写以下的编码方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span><br><span class="line">          <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
<p>比如，我们需要读取多个 <code>int</code> 值，我们也知道一个 <code>int</code> 值的长度是 <code>4</code>，所以我们在读取的时候，就需要判断 <code>ByteBuf</code> 的可读长度是否达到了 <code>4</code> ，才开始读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToIntegerDecoderHandler</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span><br><span class="line">          <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (byteBuf.readableBytes() &gt; <span class="number">4</span>) &#123;</span><br><span class="line">      list.add(byteBuf.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递的参数中，<code>List&lt;Object&gt; list</code> 是用来保存解码信息的，当我们解码一个对象的时候，信息将保存在这里，<code>Netty</code> 将会为我们把这个 <code>list</code> 传递给 <code>ChannelPipeline</code> 的下一个 <code>ChannelInboundHandler</code> 处理器中。 当然，<code>ByteToMessageDecoder</code> 还提供了一个 <code>decodeLast</code> 方法，用来当 <code>Channel</code> 变成非活动状态的时候，调用最后一次解码。 来个例子： 现在有个需求，要求客户端发送 <code>RandomNum</code> 给服务端，服务端返回 <code>16</code> 个 <code>int</code> 类型的随机数，客户端接收并打印：</p>
<h5 id="服务端Handler"><a href="#服务端Handler" class="headerlink" title="服务端Handler"></a>服务端Handler</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机数处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">in</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">if</span> (message.equals(<span class="string">&quot;RandomNumber&quot;</span>)) &#123;</span><br><span class="line">      <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> ctx.channel().alloc().heapBuffer();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        byteBuf.writeInt(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt() * <span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="服务端引导代码"><a href="#服务端引导代码" class="headerlink" title="服务端引导代码"></a>服务端引导代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerLaunch</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IntegerHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntegerHandler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ServerBootstrap</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端解码器"><a href="#客户端解码器" class="headerlink" title="客户端解码器"></a>客户端解码器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * .</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 一个 int 是 4 个字节 */</span></span><br><span class="line">    <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      out.add(in.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端处理Handler"><a href="#客户端处理Handler" class="headerlink" title="客户端处理Handler"></a>客户端处理Handler</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;List&lt;Object&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;RandomNumber&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="客户端引导代码"><a href="#客户端引导代码" class="headerlink" title="客户端引导代码"></a>客户端引导代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端启动类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientLaunch</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Bootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">      b.group(group)</span><br><span class="line">              .channel(NioSocketChannel.class)</span><br><span class="line">              .remoteAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>))</span><br><span class="line">              .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(<span class="keyword">new</span> <span class="title class_">ToIntegerDecoder</span>(), <span class="keyword">new</span> <span class="title class_">RequestHandler</span>());</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> b.connect().sync();</span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h5><p><img src="/RandomNettyDemo.gif"></p>
<h4 id="2-2-2-ReplayingDecoder"><a href="#2-2-2-ReplayingDecoder" class="headerlink" title="2.2.2 ReplayingDecoder"></a>2.2.2 ReplayingDecoder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title class_">ReplayingDecoder</span>&lt;Void&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    out.add(in.readInt());</span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>ReplayingDecoder</code> 有个泛型，表示需要处理的状态类型，使用 <code>Void</code> 表示没有状态需要处理。 与之前不同的是，每读取一次就会调用一次后面的处理器，因为每次解码都会发送。 需要注意 <code>ReplayingDecoder</code> 并不是支持所有的 <code>ByteBuf</code> 操作，如果调用不支持的方法，将会抛出异常。而且效率较上面的解码器比较低下。</p>
<h4 id="2-2-3-MessageToMessageDecoder"><a href="#2-2-3-MessageToMessageDecoder" class="headerlink" title="2.2.3 MessageToMessageDecoder"></a>2.2.3 MessageToMessageDecoder</h4><p>这个的作用是将一种消息的格式转换为另外一种消息的格式。 不多说上代码就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageDecoder</span>&lt;Integer&gt; &#123;<span class="comment">// 泛型表示传入的类型</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span></span><br><span class="line">          <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    out.add(<span class="string">&quot;String:&quot;</span> + String.valueOf(msg));</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-TooLongFrameException"><a href="#2-2-4-TooLongFrameException" class="headerlink" title="2.2.4 TooLongFrameException"></a>2.2.4 TooLongFrameException</h4><p>这是一个异常类，用于让我们自定义抛出异常的，主要作用是为了保护 <code>Netty</code> 程序的内存不至于被过大的消息体耗尽，所以我们可以定义一个 <code>Decoder</code>，用于判断消息体是否超出我们的需求，如果超出可以直接抛出异常，终止调用链的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RejectTooLongDecoder</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ALLOW_LENGTH</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readableBytes</span> <span class="operator">=</span> in.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (readableBytes &gt; ALLOW_LENGTH) &#123;</span><br><span class="line">        <span class="comment">// 清空ByteBuf</span></span><br><span class="line">      in.skipBytes(readableBytes);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooLongFrameException</span>(<span class="string">&quot;Bytes Too Long!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-5-MessageToByteEncoder-MessageToMessageEncoder"><a href="#2-2-5-MessageToByteEncoder-MessageToMessageEncoder" class="headerlink" title="2.2.5 MessageToByteEncoder/MessageToMessageEncoder"></a>2.2.5 MessageToByteEncoder/MessageToMessageEncoder</h4><p>其实与解码器相对应，方法参数差不多，偷懒不打算写了。</p>
<h4 id="2-2-6-编解码一体"><a href="#2-2-6-编解码一体" class="headerlink" title="2.2.6 编解码一体"></a>2.2.6 编解码一体</h4><p>项目上，我们一般都会把编解码这种粗活交给一个 <code>Maven</code> 模块来做，当然这样子的话就需要在客户端服务端重复安装编解码器了。 聚合在一起的一种方式是使用 <code>ByteToMessageCodec</code>，通过集成他重写编码和解码两个方法达到重用。 还有另外一种方法是通过继承 <code>CombinedChannelDuplexHandler</code> ，在泛型中指定编解码的类来实现。 当然这两种方式看个人喜好使用，我的话偏向于后者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinedIntegerCodec</span> <span class="keyword">extends</span> <span class="title class_">CombinedChannelDuplexHandler</span>&lt;IntegerDecoder, IntegerEncoder&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CombinedIntegerCodec</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">IntegerDecoder</span>(), <span class="keyword">new</span> <span class="title class_">IntegerEncoder</span>())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完待续……</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty组件以及入门体验</title>
    <url>//netty/netty%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/index.html</url>
    <content><![CDATA[<h2 id="零-Netty"><a href="#零-Netty" class="headerlink" title="零.Netty"></a>零.Netty</h2><p>其实了解到 <code>Netty</code> 已经很久了，一直想用，但是因为之前的水平还不够格，回调事件 <code>TCP</code> 什么的还没感觉，所以学起来一头雾水，加上官网的文档，哎呀，官网貌似就没有文档只有示例代码，读不懂。 写了挺多的回调函数，渐渐地有了感觉（通常使用 <code>CompleteFuture</code> 来请求其他服务的数据信息，请求完在执行自己的业务）。其实我也不知道我做了什么，貌似什么没做就突然融会贯通了，所以我感觉理解回调还是蛮重要的一点吧。 突然看到自己的书本库有本书《Netty实战》翻起来阅读，还是蛮好的，这篇文章其实是我读这本书，加上自己的一些理解写出来的。 <code>Netty</code> 是什么应该没人不会知道吧，就是 <code>Java</code> 行业中一个能够顶级处理网络通讯的轻量级框架，如果公司在使用 <code>Dubbo</code> 或者 <code>Thrift</code> 的话，那么也是间接在使用 <code>Netty</code> 框架了。所以学一学无伤大雅还可以了解一些很有趣的东西。</p>
<h2 id="一-Netty服务端"><a href="#一-Netty服务端" class="headerlink" title="一.Netty服务端"></a>一.Netty服务端</h2><p>所有 <code>Netty服务器</code> 通常需要以下两部分：</p>
<ol>
<li> 至少一个 <code>ChannelHandler</code> 来接手客户端的数据以及处理数据；</li>
<li> 引导服务器启动的配置，配置启动参数，这个就没啥好说的了。</li>
</ol>
<p><code>ChannelHandler</code> 是 <code>Netty</code> 中一个接口族的父接口，它主要负责接收和响应事件通知。 在 <code>Netty</code> 中 <code>ChannelHandler</code> 有很多默认实现，用来处理服务器中常见的数据传输问题。 因为服务器会响应传入的消息，所以需要实现 <code>ChannelInboundHandler</code> 接口，用来定义响应入站事件的方法。由于刚开始的程序只需要简单的方式即可，所以我们实现 <code>ChannelInboundHandlerAdapter</code> 即可，他提供了 <code>ChannelInboundHandler</code> 接口的默认实现。 我现在想要简单的实现一个服务，就是能够把把我发送的字符串，给反转过来，即发送 <code>abc</code> 服务器给我响应 <code>cba</code>。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转服务器的处理逻辑类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringReverseHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">in</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(<span class="string">&quot;Server Receive Message: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">newMsg</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] strings = message.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      newMsg += strings[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用工具类构建 ByteBuf 对象写出去 */</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> Unpooled.copiedBuffer(newMsg.getBytes());</span><br><span class="line">    ctx.writeAndFlush(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来需要编写服务的引导类，这个引导类主要实现两大功能：</p>
<ol>
<li> 绑定哪个端口；</li>
<li> 绑定上面写的 <code>Handler</code> 实现业务处理.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoop;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerLaunch</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StringReverseHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReverseHandler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ServerBootstrap</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此服务端任务就完成了，这时候只要启动服务端，等待客户端的介入即可处理业务。</p>
<h2 id="二-Netty客户端"><a href="#二-Netty客户端" class="headerlink" title="二.Netty客户端"></a>二.Netty客户端</h2><p>同上，所有的 <code>Netty客户端</code> 基本也是跟服务端差不多的事情：</p>
<ol>
<li> 连接服务端；</li>
<li> 发送消息；</li>
<li> 获取服务端处理的结果；</li>
<li> 关闭连接.</li>
</ol>
<p>同服务端处理一致，客户端也拥有一个 <code>ChannelInboundHandler</code> 来处理我们需要请求的业务。我们暂时可以使用 <code>SimpleChannelInboundHandler</code> 来执行我们必须的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.deploy.net.CrossDomainXML;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ByteBuf&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 服务端发送消息后执行的逻辑，直接打印 */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Client Receive Message: &quot;</span> + byteBuf.toString(Charset.defaultCharset()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要实现客户端的启动器，除了客户端需要使用 <code>OIO</code> 传输以外，其他需要做的事情基本是一致的。</p>
<h2 id="三-运行服务端和客户端"><a href="#三-运行服务端和客户端" class="headerlink" title="三.运行服务端和客户端"></a>三.运行服务端和客户端</h2><p><img src="/SimpleNettyDemoTest.gif"> </p>
<p>OK，我们分别启动 <code>服务端</code> 和 <code>客户端</code>，可见 <code>客户端</code> 在连接完成的时候，像 <code>服务端</code> 发送了 <code>HelloWorld</code>，服务端处理完成后，客户端即接收到 <code>Client Receive Message: dlroWolleH</code></p>
<h2 id="三-Netty组件"><a href="#三-Netty组件" class="headerlink" title="三.Netty组件"></a>三.Netty组件</h2><p>OK，硬着头皮写到这里，项目也运行还算正常，感觉还不错。那么接下来就需要来了解一下各个组件了。</p>
<h3 id="3-1-Netty主要组件"><a href="#3-1-Netty主要组件" class="headerlink" title="3.1 Netty主要组件"></a>3.1 Netty主要组件</h3><p>组件的顺序是从业务处理器，再到软件启动引导：</p>
<ol>
<li> <code>ChannelHandler</code></li>
<li> <code>EventLoopGroup</code></li>
<li> <code>Channel</code></li>
<li> <code>ServerBootstrap</code> 服务端启动类，而客户端使用的是 <code>Bootstrap</code></li>
<li> <code>ChannelInitializer</code> 主要用来初始化注册安装 <code>ChannelHandler</code></li>
<li> <code>ChannelPipeline</code> 存放 <code>ChannelHandler</code> 的链表容器</li>
</ol>
<p>而下面的顺序则没有按照上面的顺序，因为我想从里面了解到外面，里面相对看起来比较简单。</p>
<h3 id="3-2-ChannelHandler和ChannelPipeline"><a href="#3-2-ChannelHandler和ChannelPipeline" class="headerlink" title="3.2 ChannelHandler和ChannelPipeline"></a>3.2 ChannelHandler和ChannelPipeline</h3><h4 id="3-2-1-ChannelHandler"><a href="#3-2-1-ChannelHandler" class="headerlink" title="3.2.1 ChannelHandler"></a>3.2.1 ChannelHandler</h4><p>从上面的例子上可以看到，我们在服务端使用了继承 <code>ChannelHandler</code> 的方式去做业务逻辑，其实这块一般也是业务的重要地方，需要做什么处理，然后写出什么数据，跟 <code>Controller</code> 的作用相同。 在上面的服务端例子中，业务处理通过继承 <code>ChannelInboundHandlerAdapter</code>（是一个 <code>ChannelHandler</code> 的子类，下面说） 的方式来处理，它的作用是：</p>
<ol>
<li> 接收入站事件和数据；</li>
<li> 处理完以后，冲刷数据到客户端；</li>
<li> 可以关闭连接的方式来结束客户端的连接。</li>
</ol>
<p>通常来说，一个项目会有多个 <code>ChannelInboundHandler</code> 在运行着，处理着业务数据。</p>
<h4 id="3-2-1-ChannelPipeline"><a href="#3-2-1-ChannelPipeline" class="headerlink" title="3.2.1 ChannelPipeline"></a>3.2.1 ChannelPipeline</h4><p>在服务端和客户端都可以看到 <code>socketChannel.pipeline().addLast(new RequestHandler())</code> 这段代码，那么根据编码经验来说，他应该是个容器。 没错，他还真的是一个容器，一个链表容器，里面装着一个一个的 <code>ChannelHandler</code> 。 具体过程是：</p>
<ol>
<li> 启动的时候定义 <code>ChannelInitializer</code>，他将在 <code>Bootstrap</code> 或者 <code>ServerBootstrap</code> 启动的时候进行初始化操作；</li>
<li> 当 <code>initChannel</code> 被调用的时候，我们即可安装我们自己的 <code>ChannelHandler</code> 实现，来处理数据传输；</li>
<li> <code>ChannelInitializer</code> 将自己从 <code>ChannelPipeline</code> 中移除。</li>
</ol>
<p><code>ChannelHandler</code> 以及子类：</p>
<p><img src="/images/netty%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C.md/0.png"></p>
<p><img src="/images/netty%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C.md/1.png"></p>
<p>数据入站的时候，将按照安装的顺序，依次执行 <code>ChannelInboundHandler</code> 中的逻辑，其实说到底就是处理链吧，当数据到达 <code>Pipeline</code> 尾端的时候，表示数据处理已经结束。 数据的出站运动（正在被写的数据）则是从 <code>Pipeline</code> 末端开始执行，与 <code>ChannelInboundHandler</code> 执行顺序相反的情况下依次处理。</p>
<blockquote>
<p>Netty 中 提供了 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 两个适配类，其实这两个类就是已经解决了简单顺序传值的问题，Netty 会简单的帮你按照上面的顺序执行 ChannelHandler 我们只需要覆写与业务相关的处理即可。所以如果我们只是想简单的传递的话可以直接使用这两个类。</p>
</blockquote>
<p>在覆写我们感兴趣的函数的时候，通常都可以看到有一个 <code>ChannelHandlerContext</code> 而且示例中也是使用他来写出消息的，除了这种方法写出消息，还有另外一种方法就是使用 <code>Channel</code> 写出（调用：<code>ctx.channel().writeAndFlush()</code>）。前者写出会将消息写到下一个 <code>ChannelHandler</code> 而后者则是让消息从上图中的 <code>ChannelPipeline</code> 末端开始走（与上面区别就是跳过下一个 <code>ChannelInboundHandler</code>）</p>
<h3 id="3-3-Channel和EventLoop"><a href="#3-3-Channel和EventLoop" class="headerlink" title="3.3 Channel和EventLoop"></a>3.3 Channel和EventLoop</h3><h4 id="3-3-1-Channel"><a href="#3-3-1-Channel" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h4><h5 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h5><p>说到 <code>Channel</code> 就要说到 <code>Java NIO</code> ，说到 <code>NIO</code> 就要说到 <code>Selector</code> 和 <code>Socket</code>。 说到 <code>NIO</code> 就要先说说这个有趣的名字~</p>
<blockquote>
<p>NIO 刚开始我感觉就是 New IO，可是这么多年过去了，再叫 New IO 就有点不合适了。 所以现在大多数人认为应该叫 Non-blocking IO，而阻塞IO则是 block IO 或者 old IO (BIO/OIO)</p>
</blockquote>
<p>其实聊到 <code>NIO</code> 就应该是，传统的 <code>IO</code> 如果同时执行同一个业务的话，而且想要多人都可以同时并行处理的话，那么就需要开启多个线程来同时执行。 </p>
<p><img src="/images/netty%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C.md/2.png"> </p>
<p>那么每一个新的客户端进来，我就需要预留一个线程来处理，线程中 <code>BIO</code> 在读取文件或者其他 <code>IO</code> 输入的时候，需要阻塞进入等待，这都算是一种资源浪费（CPU还需要切换线程去查看哪个线程已经阻塞完成了）。据我们所知，一个线程占用栈空间 <code>64k</code> - <code>1m</code>，理论线程越多每个线程拿到的栈空间就更少了。这时候线程他就在那里等待了什么事情都不做，然后还占用了系统上一个线程的位置（系统限制可开启线程数）。如果小数量的线程数（用户数）那么勉强还是撑得过去的，而且工作的也还不错。那么如果上万个用户上十万个用户呢，这时候，<code>CPU</code> 需要浪费很大的力气来切换轮询。 于是乎这时候，<code>NIO</code> 横空出世（其实系统早就支持了，在 <code>jdk1.4</code> 之前都没有支持） <code>NIO</code> 有个很牛逼的管理员 <code>Selector</code>，他的任务就是提交 <code>IO</code> 任务并且告诉系统，他做完了告诉我，我会执行下一步操作。于是乎模型就编程这样：</p>
<p> <img src="/images/netty%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C.md/3.png"> </p>
<p>这个模型只要一个线程就够了，他找 <code>Selector</code> 要已经完成 <code>IO</code> 操作的名单，然后放到自己的线程开始执行我们的业务逻辑，如果没有 <code>IO</code> 那么这个线程还可以去做其他的事情。</p>
<h5 id="Netty中的Channel"><a href="#Netty中的Channel" class="headerlink" title="Netty中的Channel"></a>Netty中的Channel</h5><p>在 <code>Netty</code> 中，一个 <code>Channel</code> 代表一个实体（硬件设备，文件，Socket，能够执行一个或不同 <code>IO</code> 操作的程序组件）的连接。这里可以套用 <code>Linux</code> 中万物皆文件的理念，只要是一个物，他就有输入输出，那么她就是 <code>Channel</code>。 而 <code>Channel</code> 中我们实现了他的一些方法如 <code>channelRead</code> <code>channelReadComplete</code>，其实这些是回调事件，我们也可以称实现这些动作是实现回调事件。那么啥是回调事件：</p>
<blockquote>
<p>某件事情执行时间很长，你让他执行完告诉你你去接收他的参数并且接下去做。 比如洗衣服，你扔进洗衣机，洗衣机一般要洗1个小时，洗完了发出滴滴滴的声音。这就是回调了，在这1个小时里面你这个线程就可以去做其他事情，他滴滴滴响了你拿到了结果（衣服洗完了）再去执行一个函数：晾衣服。</p>
</blockquote>
<p>如果你熟悉 <code>JavaScript</code> 那么这一切都很自然，异步请求 <code>Promise</code> 类，<code>Promise.then((result) =&gt; &#123;...&#125;)</code> 里面的 <code>function</code> 她就是回调函数。 <code>jdk8</code> 中提供了很好的回调事件方式的线程类 <code>CompleteFuture</code> 就是用来做这个事情的，你可以使用这个类来体验一下回调事件的感受。（参考文章：<a href="https://liweidan.cn/java/jdk8/2017/10/25/141/">jdk8 多线程处理的使用</a>） 而 <code>Netty</code> 时代 <code>jdk</code> 还没有到 <code>j8</code> 呀，只提供了 <code>CompleteFuture</code> 的爸爸 <code>Future</code>，那怎么办嘛，<code>Netty</code> 就自己写提个，这就是 <code>ChannelFuture</code> 的出现了。<code>ChannelFuture</code> 也提供了可以自定义的 <code>ChannelFutureListener</code> 来拓展，可以说比 <code>jdk8</code> 的 <code>CompleteFuture</code> 还厉害，可以监听连接完成时做什么（比如检查连接是否正常，远程服务是否能够正确返回信息）。只需要在引导代码里面，使用 <code>ChannelFuture.addListener</code> 即可添加相对应的逻辑。这么说的话，那么 <code>ChannelFutureListener</code> 就是 <code>Future</code> 生命周期中执行的钩子函数。</p>
<h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>Channel</tag>
        <tag>ChannelHandler</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】一. MySQL存储引擎</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%80-mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/index.html</url>
    <content><![CDATA[<h2 id="一-MySQL介绍"><a href="#一-MySQL介绍" class="headerlink" title="一.MySQL介绍"></a>一.MySQL介绍</h2><p>作为 <code>MySQL</code> 系列的开篇，我觉得还是有必要说说大家熟悉的 <code>MySQL</code> 数据库的一些东西。 <code>MySQL</code> 我想作为开发者应该没有人不认识或者不熟悉了吧。不管所在的厂子是大中小，基本上很多时候都会采用 <code>MySQL</code> 作为我们数据的存储介质。当然政府项目很多都会采用 <code>Oracle</code> 数据库，不过最近看来，这个事情貌似也不是绝对。也有很多政府的项目已经决定采用 <code>MySQL</code> 或者其他厂商封装的 <code>MySQL</code> 分支了。 作为数据库，其实定义是这样的：</p>
<ul>
<li>  数据库：文件或者其他文件类型的集合，在 <code>MySQL</code> 中，文件被存储为 <code>frm</code> <code>myd</code> <code>ibd</code> 等多种形式的文件。而有些存储引擎比如 <code>NDB</code> 他的数据信息则是被存储在内存之中的，并不会持久化到硬盘上面，所以他不需要文件来进行存储。速度稍稍快但数据库出现异常重启的话，数据就会丢失。</li>
<li>  数据库实例或软件：其实就是运行的，可以读取以上数据库文件的软件进程，他可能是一个也可能是多个，日常开发经常是运行一个的情形。我们运行 <code>SQL</code> 或者其他操作的，其实都是在跟数据库实例进行交互，数据库实例会根据命令，计算出来比较高效的查询策略在硬盘上进行数据查询。<a id="more"></a>
<h2 id="二-MySQL体系结构"><a href="#二-MySQL体系结构" class="headerlink" title="二.MySQL体系结构"></a>二.MySQL体系结构</h2></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103500.png"></p>
<p> 数据库由上面几大部分组成，每一部分基本上所做的事情都非常多，而且对数据操作过程中都起着非常重要的作用。<code>MySQL</code> 还有个特点就是存储引擎采用插件式的方式，只要我们按照 <code>MySQL</code> 规范去开发引擎，即可引入数据库软件然后进行启动存储。引擎不是存储数据的地方，而是定义怎么存储数据的地方。而且存储引擎的细粒度是表，也就是说我们新建一个数据库（database），可以使用多个存储引擎来建表。</p>
<h2 id="三-MySQL存储引擎"><a href="#三-MySQL存储引擎" class="headerlink" title="三.MySQL存储引擎"></a>三.MySQL存储引擎</h2><p>由于我们经常使用的无非就是 <code>InnoDB</code> 和 <code>MyISAM</code> 两种引擎，所以其他的我并不打算细讲，稍微带过去就可以了。</p>
<h3 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h3><p><code>InnoDB</code> 支持数据库事务（<code>SQL</code> 要么一起成功要么一起失败）现在 <code>MySQL</code> 版本默认的存储引擎，支持行级锁，支持外键，以及支持非锁定读（读取不会产生锁）。 通过多版本并发控制 <code>MVCC</code> 来获得高并发性，并且实现 <code>SQL</code> 标准的 <code>4</code> 种隔离机制，默认隔离机制是 <code>REPEATABLE</code>，同时使用一种 <code>next-key locking</code> 策略（简单说就是版本控制）来避免幻读的产生。 说到这得回忆一下 <code>MySQL</code> 的四种隔离级别：</p>
<p>隔离级别</p>
<p>说明</p>
<p><code>Serializable</code></p>
<p>最严格的级别，有事务一个一个来，最慢也最安全</p>
<p><code>REPEATABLE READ</code></p>
<p>避免修改另外一个事务读取但未修改的数据，但不能避免幻读</p>
<p><code>READ COMMITTED</code></p>
<p>大多数数据库采用的级别，避免脏读但不避免幻读和不可重复读</p>
<p><code>Read Uncommitted</code></p>
<p>事务会读取到另外一个事物已修改但未提交的数据</p>
<blockquote>
<ul>
<li>  脏读：读取到了其他事务已修改但未提交的数据，如A读取到了B事务修改后的数据X，但是B事务进行了回滚，这时候说明A事务产生了脏读。</li>
<li>  不可重复读：事务A读取一条数据，后面B事务修改了这条数据，A再次读取时发现数据不匹配，这就是不可重复读</li>
<li>  幻读：事务A根据某个条件读取N条数据，事务B改变了其他数据使之满足A的搜索条件，事务再次读取发现有大于N条的数据</li>
</ul>
</blockquote>
<p><code>InnoDB</code> 存数数据的时候是按照主键（如果没有设置主键，<code>InnoDB</code> 会偷偷的给一个主键）的顺序进行存储，形成 <code>B+</code> 树结构，根据其他索引查询的时候需要回表，即回到最原始的这棵树进行匹配再返回所有数据。</p>
<h3 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h3><p><code>InnoDB</code> 支持的事务、表锁他都不支持，也不支持全文索引。由 <code>MYD</code> 和 <code>MYI</code> 文件共同协助。前者存储数据后者存储索引。支持全文索引。</p>
<h3 id="3-NDB"><a href="#3-NDB" class="headerlink" title="3.NDB"></a>3.NDB</h3><p>集群存储引擎，<code>NDB</code> 是将数据全部放置于内存中（<code>5.1</code> 之后可以将非索引数据放置于硬盘），因此主键查找很快，也可以新增节点提高性能。但是连接操作是在 <code>MySQL</code> 数据库层，并非引擎完成（其实就是说连接的时候不能真正的连接而是需要一个一个查询连接）效率较低。</p>
<h3 id="4-Memory"><a href="#4-Memory" class="headerlink" title="4.Memory"></a>4.Memory</h3><p>也是数据存储于内存的引擎，使用哈希索引进行查询。但有些限制：不支持 <code>VARCHAR</code> 使用 <code>CHAR</code> 的形式进行存储，也不支持大文本数据。临时表会使用该引擎进行查询，但是如果临时表有大文本或者超过容量设置，就会降级至 <code>MyISAM</code> 进行存储到硬盘，由于 <code>MyISAM</code> 不支持缓存数据文件，因此此时临时表可能会拖慢查询速度。</p>
<h3 id="5-Archive"><a href="#5-Archive" class="headerlink" title="5.Archive"></a>5.Archive</h3><p>只支持 <code>INSERT</code> 和 <code>SELECT</code> 的引擎，对数据进行压缩，压缩比高，适合存储归档数据如日志信息等。其目的是压缩。</p>
<h3 id="6-Federated"><a href="#6-Federated" class="headerlink" title="6.Federated"></a>6.Federated</h3><p>不存放数据的引擎，指向一台远程的 <code>MySQL</code> 数据库服务器的表。</p>
<h3 id="7-Maria"><a href="#7-Maria" class="headerlink" title="7.Maria"></a>7.Maria</h3><p><code>MyISAM</code> 的后续版本，支持缓存数据和索引文件，行级锁设计、提供 <code>MVCC</code> 功能，支持事务，以及更好的 <code>BLOB</code> 字符类型的处理性能。 <code>MySQL</code> 支持哪些存储引擎可以通过语句 <code>SHOW ENGINES\G</code> 来查看。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103458.png"></p>
<h2 id="四-连接MySQL"><a href="#四-连接MySQL" class="headerlink" title="四.连接MySQL"></a>四.连接MySQL</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>可以说最常见的连接方式了，使用 <code>IP</code> <code>用户名</code> <code>密码</code> 进行连接基本是我们调试，生产一直使用的方式。请求连接时 <code>MySQL</code> 数据库实例会判断当前用户是否拥有权限进行连接，一般来说，会限制用户只能从哪个 <code>IP</code> 进行连接。</p>
<h3 id="命令管道和共享内存"><a href="#命令管道和共享内存" class="headerlink" title="命令管道和共享内存"></a>命令管道和共享内存</h3><p>在 <code>Windows</code> 系列上，如果客户端和服务端同属于一台服务器上，那么可以通过配置文件配置 <code>--enable-named-pipe</code> 选项开启命令管道，当然这些方法都不常用，不细说。</p>
<h3 id="UNIX管道"><a href="#UNIX管道" class="headerlink" title="UNIX管道"></a>UNIX管道</h3><p>首先使用 <code>TCP/IP</code> 进行数据库连接，运行 <code>SHOW VARIABLES LIKE &#39;socket&#39;</code> 命令查看 <code>Socket</code> 管道所在的位置，然后我们就可以通过 <code>mysql -uroot -S /tmp/mysql.sock</code> 从而使用 <code>UNIX管道</code> 的方式进行数据库连接。</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><p>了解 <code>MySQL</code> 术语； 了解 <code>MySQL</code> 体系架构； 了解 <code>MySQL</code> 支持的引擎系列； 了解 <code>MySQL</code> 的连接方式。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】七.MySQL-InnoDB的数据库事务介绍</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%83-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/index.html</url>
    <content><![CDATA[<h2 id="一-数据库事务"><a href="#一-数据库事务" class="headerlink" title="一.数据库事务"></a>一.数据库事务</h2><p>刚开始接触编程，要写业务代码的时候我们知道。某个业务动作必须通过 <code>事务</code> 完成对数据库的修改。那么这个事务是什么，<code>InnoDB</code> 是怎样实现事务的要求的，就是接下来老夫想说的内容。</p>
<a id="more"></a>
<p>那么事务是怎样的，也就是说，我们在做业务操作的时候，最简单的比如用户下单：</p>
<ol>
<li>用户按下下单的按钮，开始请求后端进行创建订单；</li>
<li><code>Java</code> 开始着手创建订单的信息对象；</li>
<li>与此同时，产品的库存需要扣减比如 iPhone 的库存需要减掉 10 个；</li>
<li>插入订单 + 扣减库存，在 <code>MySQL</code> 中开始执行；</li>
</ol>
<p>结果：此时针对最后一步来看，我们要求两个操作的 <code>SQL</code> 操作必须一并成功，或者一并失败，而且要求数据库发生故障重启的时候数据还存在，而且数据是准确的。</p>
<p>上面这句话包含太多数据库事务的内容了，我们需要一个一个来说。</p>
<p>这个数据库事务的概念就是我们常说的 <code>ACID</code>。</p>
<h3 id="1-1-A-Atomicity-原子性"><a href="#1-1-A-Atomicity-原子性" class="headerlink" title="1.1 A-Atomicity-原子性"></a>1.1 A-Atomicity-原子性</h3><p>每个点我打算拆分上面的执行结果来说，何为 <code>原子性</code>，对应我那句话：<code>插入订单 + 扣减库存必须一并成功，或者一并失败</code>。原子性就是两个操作，插入订单和扣减库存，对应数据库操作是一个 <code>INSERT</code> 和一个 <code>UPDATE</code>，那么这两个语句要么同时都对我们的数据表成功的修改，如果其中有一个失败了，另外一个语句<strong>必须不执行</strong>，<strong>或者已经执行了，必须把修改的数据还原成修改前的数据</strong>。这就说创建订单和扣减库存是一个原子操作。我们的业务不可能允许创建了订单但是没有扣减库存，这时候后续的用户下单了就没有库存发货了，那程序就没什么意义，也不允许扣减了库存但是没有创建订单，要不然赚什么钱。</p>
<p>所以开启事务后，我们必须满足，在这个事务里面执行的语句要么一并成功，要么全部回滚。</p>
<h3 id="1-2-C-Consistency-一致性"><a href="#1-2-C-Consistency-一致性" class="headerlink" title="1.2 C-Consistency-一致性"></a>1.2 C-Consistency-一致性</h3><p>我们知道，我们的业务代码是现实生活的映射，所以在上面扣减库存的动作中，订单下了 15 个 iPhone，那库存就应该扣减 15 个，而不是其他任何数字，更不可能是一个负数。当然现在的编码生活中，留给数据库处理的事情越来越少，所以这个一致性在某种意义上需要我们程序去保证，数据库只能够帮助我们同时执行一个语句并保证他们的执行是原子性的。</p>
<h3 id="1-3-I-Isolation-隔离性"><a href="#1-3-I-Isolation-隔离性" class="headerlink" title="1.3 I-Isolation-隔离性"></a>1.3 I-Isolation-隔离性</h3><p>这个东西可能我们在程序中最注重的了。上面的例子已经不足以说明。那就拓展一下这个例子。</p>
<p>iPhone 总库存只有 <code>15</code> 台，<code>A用户</code> 和 <code>B用户</code> 同时下单 <code>10台</code>。</p>
<p>那么按照我们现实生活中的例子，就是两个用户看谁先排队在前面，就可以先买到 <code>10</code> 台 iPhone。</p>
<p>而程序则不是，他有可能就是这样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103631.jpeg"></p>
<p>OK，老板卖了 <code>20台</code> 还剩下 <code>5台</code> 可以卖！</p>
<p>所以，我们在处理这个问题的时候，思路又跟生活靠近，买同一个产品的客户，你们排队，这样上面的流程将会被撸成串行（即排队），而买一个 iPhone 和一个 小米，又可以使用上面的方式处理，即提高处理速度又不担心超卖的问题。</p>
<p>所以如果两个请求在操作同一条数据的时候，即库存这条数据，我们需要让这两个用户读取到的数据是具有隔离性质的，也就是 <code>A用户</code> 完成一系列原子性操作的时候，才可以让 <code>B用户</code> 来执行其他的操作。</p>
<h3 id="1-4-D-Durability-持久性"><a href="#1-4-D-Durability-持久性" class="headerlink" title="1.4 D-Durability-持久性"></a>1.4 D-Durability-持久性</h3><p>这个很好理解，我的业务进行后，数据状态被修改了，当系统关机或者因为其他原因导致突然暂停的时候，我的数据要恢复成宕机前的亚子。</p>
<h2 id="二-InnoDB事务状态"><a href="#二-InnoDB事务状态" class="headerlink" title="二.InnoDB事务状态"></a>二.InnoDB事务状态</h2><p><code>InnoDB</code> 将事务分为五个状态，分别是：<code>活动的</code>、<code>部分提交的</code>、<code>失败的</code>、<code>中止的</code>、<code>提交的</code>。</p>
<p>那这五个状态分别对应哪些事情，</p>
<p><code>活动的</code>：对应开启事务的时候，也就是 <code>START TRANSACTION;</code></p>
<p>此时，如果我们输入 <code>COMMIT</code>，那么该事务就是 <code>部分提交的</code>，为啥，因为在之前说过 <code>BufferPool</code> 的事情，就是说我们提交了修改，修改的还只是内存中的数据，还没有刷到硬盘，所以我们提交的时候就是 <code>部分提交的</code>。</p>
<p>那如果我们 <code>ROLLBACK</code> 呢，就是 <code>中止的</code> 的状态了，也就是回滚修改的时候。</p>
<p><code>失败的</code> 我们日常应该很少遇到，就是我们在事务处于 <code>活动的</code> 或者 <code>部分提交的</code> 状态，导致内存中的数据没有持久化到硬盘（注意是持久化，后面会说），那这个事务就是 <code>失败的</code>。</p>
<p><code>提交的</code> 数据已经完完全全被保存到硬盘中，就算重启或者宕机都不用害怕，就说这个事务是 <code>提交的</code>。</p>
<hr>
<h2 id="三-事务并发执行可能出现的问题"><a href="#三-事务并发执行可能出现的问题" class="headerlink" title="三.事务并发执行可能出现的问题"></a>三.事务并发执行可能出现的问题</h2><p>通常来说，我们的数据库不可能只有一条连接在执行业务。而一条连接就是一个会话（<code>Session</code>），所以下面遇到的问题基本是多个 <code>Session</code> 在同时操作数据库时可能会出现的问题。</p>
<p>那我依然使用上面下单扣库存的例子来说说这些问题：</p>
<h3 id="3-1-脏写（Dirty-Write）"><a href="#3-1-脏写（Dirty-Write）" class="headerlink" title="3.1 脏写（Dirty Write）"></a>3.1 脏写（<code>Dirty Write</code>）</h3><p>脏写基本是所有数据库都不允许的，但是为了完整还是说下。</p>
<p>脏写可以理解成两个用户同时下单一个产品时可能出现的问题：</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
<td align="center">其他操作</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>COMMIT;</code></td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center">由于其他操作失败 <code>ROLLBACK;</code></td>
</tr>
<tr>
<td align="center">此时，<code>A客户</code> 下单了 <code>10</code> 台 iPhone，并且顺利提交，但是 <code>B客户</code> 可能由于其他问题，比如是个黑号，下单失败，回滚了，那么导致 <code>A客户</code> 提交的库存只有 <code>10</code> 台 iPhone 这条修改也不见了，称为 <code>脏写</code>。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>那么怎么看，所有业务，基本都不可能容许这种错误的存在吧，所以下面聊隔离级别的时候，基本排除这个错误的发生。</p>
<h3 id="3-2-脏读（Dirty-Read）"><a href="#3-2-脏读（Dirty-Read）" class="headerlink" title="3.2 脏读（Dirty Read）"></a>3.2 脏读（<code>Dirty Read</code>）</h3><p>如果 <code>客户A</code> 读取到的数据是 <code>客户B</code> 未提交的数据，我们成为 <code>脏读</code>。乍一想扣库存的时候，好像挺好的，但是如果 <code>客户B</code> 回滚数据呢，那数据就完全混乱了呀：</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>10</code></td>
<td align="center">其他操作</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center">由于其他操作失败 <code>ROLLBACK;</code></td>
</tr>
</tbody></table>
<h3 id="3-3-不可重复读（Non-Repeatable-Read）"><a href="#3-3-不可重复读（Non-Repeatable-Read）" class="headerlink" title="3.3 不可重复读（Non-Repeatable Read）"></a>3.3 不可重复读（<code>Non-Repeatable Read</code>）</h3><p>指的是一个事务重复读取一个 <code>SQL</code> 时，因为其他事务提交了数据，导致在此次事务读取两次的数据不一样，成为 <code>不可重复读</code>。<br>| 执行步骤 |           Session_A_客户           |    Session_B客户     |<br>| :——: | :——————————–: | :——————: |<br>|    1     |        <code>START TRANSACTION;</code>        | <code>START TRANSACTION;</code> |<br>|    2     | <code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code> | — |<br>|    3     |        —        | <code>UPDATE prod_stock SET stock = 10</code> |<br>| 4 |     —       |  <code>COMMIT</code> |<br>| 5 | <code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>10</code> |  —|</p>
<h3 id="3-4-幻读（Phantom）"><a href="#3-4-幻读（Phantom）" class="headerlink" title="3.4 幻读（Phantom）"></a>3.4 幻读（<code>Phantom</code>）</h3><p>跟不可重复读有点相似，但是这个是由于另外的事务插入数据导致本事务相同条件读到的数据条目数不一样。</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code></td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">—</td>
<td align="center"><code>INSERT INTO prod_stock VALUES (XXX, 10)</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center"><code>COMMIT</code></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code> 和 <code>10</code></td>
<td align="center">—</td>
</tr>
</tbody></table>
<p><code>客户A</code> 准备下单在读取产品的库存数据，这时候 <code>客户B</code> 新增了一个其他类型的库存记录，<code>客户A</code> 重新查询的时候，被查出来了，所以就可以说这个事务产生了 <code>幻读</code>。</p>
<h2 id="三-InnDB事务隔离级别"><a href="#三-InnDB事务隔离级别" class="headerlink" title="三.InnDB事务隔离级别"></a>三.InnDB事务隔离级别</h2><p>那么 <code>SQL标准</code> 就规定了四种隔离机制，<code>InnoDB</code> 也同时对这几个隔离级别做了支持：</p>
<ol>
<li><code>READ UNCOMMITTED</code>：读未提交的</li>
<li><code>READ COMMITTED</code>：读已提交的</li>
<li><code>REPEATABLE READ</code>：可重复读</li>
<li><code>SERIALIZABLE</code>：串行化</li>
</ol>
<p>当然因为 <code>脏写</code> 产生的后果是 <code>所有业务都不允许发生</code> 的，所以并不在讨论范围之内，因为所有的级别都不允许发生 <code>脏写</code></p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>我们可以看到，<code>串行化</code> 是效果最好的，但是因为是 <code>串行化</code>（俗话说就是每个请求都要排队，等前面做好了再来做下一个），所以性能也是最低的。</p>
<p><code>MySQL_InnoDB</code> 的默认隔离机制是 <code>REPEATABLE READ</code>，也就是可重复读。</p>
<p>可重复读会出现幻读，但是 <code>InnoDB</code> 又把 <code>幻读</code> 的问题给解决了，所以可以说 <code>MySQL_InnoDB</code> 用了一些手段，将数据库事务的性能提高又不影响数据的准确性。</p>
<p>怎么解决的，简单的说在查询的时候判断当前事务开启时，会生成一个 <code>ReadView</code>，这个 <code>ReadView</code> 会记录当前事务的信息，然后在查询的时候，只需要判断查询到的数据的所有版本在当前 <code>ReadView</code> 中是否可见，如果可见就显示出来，不可见就隐藏掉。那么就相当于解决了 <code>REPEATABLE READ</code>：可重复读 这个级别的 <code>幻读</code> 问题。至于怎么比较的，现在还不是时候知道，因为需要先知道 <code>REDO</code> 和 <code>UNDO</code> 日志。</p>
<h2 id="四-完"><a href="#四-完" class="headerlink" title="四. 完"></a>四. 完</h2><p>OK，有了 <code>事务</code> 的一些相关内容以后，就可以来深入 <code>事务</code> 的执行原理了。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 8.0.15 主从复制配置</title>
    <url>//mysql/mysql-8-0-15-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%85%8D%E7%BD%AE/index.html</url>
    <content><![CDATA[<h2 id="MySQL-主从复制"><a href="#MySQL-主从复制" class="headerlink" title="MySQL 主从复制"></a>MySQL 主从复制</h2><p>BasicIn: <code>MySQL 8.0.15</code> 看过 <code>Redis</code> 的主从复制，其实 <code>MySQL</code> 的原理也差不多。都是通过一个中间文件(记录操作)进行传播，达到数据相同的结果。 开启主从复制有以下几个好处：</p>
<ol>
<li> 提高吞吐量，启动 <code>MySQL</code> 主从复制以后，写操作一般将是发生在主数据库(当然要求实时性特别高的读操作也会发生在主数据库上)，而读操作一般会发生在从数据库；</li>
<li> 数据安全性，数据多了几个地方存储了，自然提高了数据丢失的安全性；</li>
<li> 提升数据分析性能，数据分析一般都是占用较大的资源，我们可以把数据分析步骤放在其中一个或者多个从数据库上进行；</li>
<li> 长距离的数据拷贝，无需与主数据库进行长连接的复制远程数据库的数据<h2 id="主从复制方式"><a href="#主从复制方式" class="headerlink" title="主从复制方式"></a>主从复制方式</h2></li>
</ol>
<p><code>MySQL</code> 经历了这么多的版本迭代以来，已经支持多种方式进行主从数据复制了。 <code>MySQL</code> 支持以下方式进行：</p>
<ol>
<li> 同步复制：即主数据库数据发生变化的时候，需要所有的从数据库表示已经写入才返回，效率低</li>
<li> 半同步复制：即主数据库数据发生变化的时候，至少一个从数据库表示已经写入才返回，效率较高，数据安全性也适中；</li>
<li> 全异步复制：主库写入完成即返回，不关心从数据库是否成功。<a id="more"></a>
<h2 id="主从复制的格式"><a href="#主从复制的格式" class="headerlink" title="主从复制的格式"></a>主从复制的格式</h2></li>
</ol>
<ul>
<li>  SBR：基于 <code>SQL</code> 语句描述的文档</li>
<li>  RBR：基于<strong>数据行</strong>描述的文档</li>
<li>  MBR：上面两者混合的文档</li>
</ul>
<p>以上两种方式其实各有优缺点。</p>
<h3 id="SBR-格式"><a href="#SBR-格式" class="headerlink" title="SBR 格式"></a>SBR 格式</h3><p>优点：</p>
<ol>
<li> 妥当，毕竟已经经历很久的考验了</li>
<li> 不需要记录大量的数据</li>
<li> 文档包含了所有的 <code>SQL</code> 语句</li>
</ol>
<p>缺点：</p>
<ol>
<li>不是所有修改数据的语句都能够被复制，一些语句会被定义不安全性的，包含以下项目的将会被定义成不安全：<ul>
<li>  需要使用自定义函数返回 <code>SQL</code> 参数的语句</li>
<li>  <code>UPDATE</code> 和 <code>DELETE</code> 语句中使用了分页但是没有使用排序语句</li>
<li>  读写锁(<code>SELECT ... FOR UPDATE</code> and <code>SELECT ... FOR SHARE</code>)</li>
<li>  需要从数据库有确定性返回值的函数的时候</li>
<li>  使用以下函数的时候：<code>LOAD_FILE()</code>、<code>UUID(), UUID_SHORT()</code>、<code>USER()</code>、<code>FOUND_ROWS()</code>、<code>SYSDATE() (unless both the master and the slave are started with the --sysdate-is-now option)</code>、<code>GET_LOCK()</code>、<code>IS_FREE_LOCK()</code>、<code>IS_USED_LOCK()</code>、<code>MASTER_POS_WAIT()</code>、<code>RAND()</code>、<code>RELEASE_LOCK()</code>、<code>SLEEP()</code>、<code>VERSION()</code>；除了这些其他函数都能够被正确复制，包括 <code>NOW()</code>。如果 <code>SQL</code> 出现 <code>[Warning] Statement is not safe to log in statement format.</code> 也将不能被复制</li>
</ul>
</li>
<li> <code>INSERT ... SELECT</code> 会比 <code>RBR</code> 锁住更多的数据行</li>
<li> <code>update</code> 语句需要全表扫描，会比 <code>RBR</code> 锁住更多的数据行</li>
<li> <code>InnoDB</code> 下插入自增的数据会锁住</li>
<li> 复杂语句下，从数据库都会重新执行一次</li>
<li> 如果复杂语句执行时间过长，从数据库可能好报过长时间</li>
<li> 执行过程函数执行 <code>NOW()</code> 的时候会产生同样的数据，如果存储过程要求实时性的话，那么会出现问题</li>
<li> 函数都需要部署到从数据库</li>
<li> 表格式主从数据库都需要相同</li>
</ol>
<h3 id="RBR-格式"><a href="#RBR-格式" class="headerlink" title="RBR 格式"></a>RBR 格式</h3><p>优点：</p>
<ol>
<li> 所有的修改都会被查看到</li>
<li>使用以下语句会锁住主数据库的一些数据行<ul>
<li>  <code>INSERT...SELECT</code></li>
<li>  自增插入</li>
<li>  没有使用列条件的 <code>UPDATE</code> 和 <code>DELETE</code>，或者不影响大多数行的语句</li>
</ul>
</li>
</ol>
<p>缺点：</p>
<ol>
<li> 当语句影响了很多行数据的时候，日志文档会变得很大，从数据库同步将会需要更长的时间</li>
<li> 从数据库查看不了语句执行情况，不过可以查看 <code>binlog</code> 中数据的变化情况</li>
<li> <code>MyISAM</code> 格式下，<code>INSERT</code> 语句会导致锁表。</li>
</ol>
<h2 id="实战主从复制"><a href="#实战主从复制" class="headerlink" title="实战主从复制"></a>实战主从复制</h2><h3 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h3><blockquote>
<p>Linux系统：CentOSKU7 MySQL版本：8.0</p>
</blockquote>
<h4 id="第一步-安装数据库软件"><a href="#第一步-安装数据库软件" class="headerlink" title="第一步 安装数据库软件"></a>第一步 安装数据库软件</h4><p>下载 <a href="https://dev.mysql.com/downloads/repo/yum/">MySQL8.0 yum 仓库</a> 文档，放入 <code>root</code> 文件夹中。然后在服务器上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum localinstall mysql80-community-release-el7-2.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>程序会自动更新服务器中的 <code>yum</code> 仓库，并且安装一些证书认证等等。 然后执行以下命令安装 <code>MySQL 8.0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure>
<p>注意配置好防火墙配置，因为是开发环境我索性关闭了防火墙：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>
<h4 id="第二步-修改root密码"><a href="#第二步-修改root密码" class="headerlink" title="第二步 修改root密码"></a>第二步 修改root密码</h4><p>接下来查看 <code>MySQL</code> 初次启动生成的密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
<p>进入 <code>MySQL</code> 客户端修改数据库的密码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pXXX</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="第三步-配置允许远程连接"><a href="#第三步-配置允许远程连接" class="headerlink" title="第三步 配置允许远程连接"></a>第三步 配置允许远程连接</h4><p>查看原有的用户列表以及允许连接的 <code>host</code>，可以发现，目前 <code>root</code> 命令只允许 <code>localhost</code> 连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select user, host from user</span><br><span class="line">    -&gt; ;</span><br><span class="line">+------------------+-----------+</span><br><span class="line"> user              host      </span><br><span class="line">+------------------+-----------+</span><br><span class="line"> mysql.infoschema  localhost </span><br><span class="line"> mysql.session     localhost </span><br><span class="line"> mysql.sys         localhost </span><br><span class="line"> root              localhost </span><br><span class="line">+------------------+-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>通过以下指令进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update user set host = &#x27;%&#x27; where user = &#x27;root&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;;</span><br><span class="line">ERROR 1410 (42000): You are not allowed to create a user with GRANT</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; FLUSH   PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>然后我这里陷入一个坑，就是我习惯性使用 <code>IDEA</code> 连接数据库死活连不上去，以为是我数据库的配置出现了问题。后来换个 <code>Navicat</code> 就连上去了。驱动也是换了，<code>IDEA</code> 就是连不上去。</p>
<h3 id="主数据库配置"><a href="#主数据库配置" class="headerlink" title="主数据库配置"></a>主数据库配置</h3><h4 id="第一步-查看logbin有没有开启"><a href="#第一步-查看logbin有没有开启" class="headerlink" title="第一步 查看logbin有没有开启"></a>第一步 查看logbin有没有开启</h4><p>查看数据库的 <code>log_bin</code> 功能有没有开启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show VARIABLES  LIKE &#x27;%log_bin%&#x27;;</span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line"> Variable_name                    Value                       </span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line"> log_bin                          ON                          </span><br><span class="line"> log_bin_basename                 /var/lib/mysql/binlog       </span><br><span class="line"> log_bin_index                    /var/lib/mysql/binlog.index </span><br><span class="line"> log_bin_trust_function_creators  OFF                         </span><br><span class="line"> log_bin_use_v1_row_events        OFF                         </span><br><span class="line"> sql_log_bin                      ON                          </span><br><span class="line">+---------------------------------+-----------------------------+</span><br><span class="line">6 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>如上所示，第一个数据表示 <code>ON</code> 则已经开启了。 如果没有开启，需要在 <code>/etc/my.cnf</code> 中指定 <code>log-bin=mysql-bin</code> 进行开启</p>
<h4 id="第二步-设置数据库的server-id"><a href="#第二步-设置数据库的server-id" class="headerlink" title="第二步 设置数据库的server_id"></a>第二步 设置数据库的server_id</h4><p>同样是在 <code>/etc/my.cnf</code> 文件中，加入 <code>server-id=1</code>。可接受范围是 <code>1 到 2^32−1</code>，设置其他值可能会出现不必要的坑。建议可以设置成当前数据库所在服务器 <code>ip</code> 最后一个字段的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...省略其他设置</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">server-id=127</span><br></pre></td></tr></table></figure>
<p>OK，这两个步骤做完主数据库的设置也就好了。接下来配置从数据库连接主数据库即可。</p>
<h4 id="第三步-准备一个同步的账号"><a href="#第三步-准备一个同步的账号" class="headerlink" title="第三步 准备一个同步的账号"></a>第三步 准备一个同步的账号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 官方示例</span><br><span class="line">mysql&gt; CREATE USER &#x27;repl&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;Liweidan1@#&#x27;;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#x27;repl&#x27;@&#x27;%&#x27;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<h3 id="从数据库配置"><a href="#从数据库配置" class="headerlink" title="从数据库配置"></a>从数据库配置</h3><h4 id="第一步-配置server-id"><a href="#第一步-配置server-id" class="headerlink" title="第一步 配置server_id"></a>第一步 配置server_id</h4><p>同上面 <code>Master</code> 的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">server-id=154</span><br></pre></td></tr></table></figure>
<h4 id="第二步-在主数据库准备一个用来同步的账号"><a href="#第二步-在主数据库准备一个用来同步的账号" class="headerlink" title="第二步 在主数据库准备一个用来同步的账号"></a>第二步 在主数据库准备一个用来同步的账号</h4><h4 id="第三步-导出主库数据"><a href="#第三步-导出主库数据" class="headerlink" title="第三步 导出主库数据"></a>第三步 导出主库数据</h4><p>使用 <code>FLUSH TABLES WITH READ LOCK;</code> 锁住表格。然后使用上面的两个工具将数据进行同步。并且使用 <code>SHOW MASTER STATUS;</code> 来查看数据执行的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主数据库操作</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">FLUSH TABLES WITH READ LOCK;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW MASTER STATUS;</span></span><br><span class="line">+---------------+----------+--------------+------------------+-------------------+</span><br><span class="line"> File           Position  Binlog_Do_DB  Binlog_Ignore_DB  Executed_Gtid_Set </span><br><span class="line">+---------------+----------+--------------+------------------+-------------------+</span><br><span class="line"> binlog.000004       846                                                    </span><br><span class="line">+---------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出数据</span></span><br><span class="line">[root@localhost ~]# mysqldump -uroot -p&#x27;Liweidan1@#&#x27; -S /var/lib/mysql/mysql.sock --all-databases &gt; ~/mysql_bak.$(date +%F).sql</span><br><span class="line">mysqldump: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">[root@localhost ~]# ll</span><br><span class="line">total 908</span><br><span class="line">-rw-------. 1 root root   1225 Mar  7 03:40 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--. 1 root root  25892 Mar 19 06:29 mysql80-community-release-el7-2.noarch.rpm</span><br><span class="line">-rw-r--r--. 1 root root 894115 Mar 19 11:31 mysql_bak.2019-03-19.sql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">传递给从服务器</span></span><br><span class="line">[root@localhost ~]scp -r ~/mysql_bak.2019-03-19.sql root@192.168.1.154:~/</span><br></pre></td></tr></table></figure>
<h4 id="第四步-从库导入主库数据"><a href="#第四步-从库导入主库数据" class="headerlink" title="第四步 从库导入主库数据"></a>第四步 从库导入主库数据</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p&#x27;Liweidan1@#&#x27; -S /var/lib/mysql/mysql.sock &lt; ~/mysql_bak.2019-03-19.sql</span><br></pre></td></tr></table></figure>
<h4 id="第五步-配置从库同步"><a href="#第五步-配置从库同步" class="headerlink" title="第五步 配置从库同步"></a>第五步 配置从库同步</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">CHANGE MASTER TO</span></span><br><span class="line">    -&gt;     MASTER_HOST=&#x27;192.168.1.127&#x27;, # 主库IP</span><br><span class="line">    -&gt;     MASTER_USER=&#x27;repl&#x27;, # 主库配置给从库的用户名</span><br><span class="line">    -&gt;     MASTER_PASSWORD=&#x27;Liweidan1@#&#x27;, # 主库中的从库密码</span><br><span class="line">    -&gt;     MASTER_LOG_FILE=&#x27;binlog.000004&#x27;, # 上面查询主库binlog的文件名</span><br><span class="line">    -&gt;     MASTER_LOG_POS=846; # 上面查询主库binlog的Position</span><br></pre></td></tr></table></figure>
<p>完整命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.1.127&#x27;,MASTER_USER=&#x27;repl&#x27;,MASTER_PASSWORD=&#x27;Liweidan1@#&#x27;,MASTER_LOG_FILE=&#x27;binlog.000004&#x27;,MASTER_LOG_POS=846;</span><br><span class="line">start slave;</span><br><span class="line">mysql&gt; show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 192.168.1.127</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: binlog.000004</span><br><span class="line">          Read_Master_Log_Pos: 4486</span><br><span class="line">               Relay_Log_File: localhost-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 319</span><br><span class="line">        Relay_Master_Log_File: binlog.000004</span><br><span class="line">             Slave_IO_Running: Yes (这一项和下面一项如果都是YES表示主从设置成功)</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h4 id="第六步-启动从库同步进程"><a href="#第六步-启动从库同步进程" class="headerlink" title="第六步 启动从库同步进程"></a>第六步 启动从库同步进程</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure>
<h4 id="第七步-释放主库的读锁"><a href="#第七步-释放主库的读锁" class="headerlink" title="第七步 释放主库的读锁"></a>第七步 释放主库的读锁</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; UNLOCK TABLES;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="测试同步"><a href="#测试同步" class="headerlink" title="测试同步"></a>测试同步</h2><p><img src="https://liweidan.cn/wp-content/uploads/2019/04/databse-async.gif"> <img src="https://liweidan.cn/wp-content/uploads/2019/04/table-async.gif"> <img src="https://liweidan.cn/wp-content/uploads/2019/04/data-async.gif"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>从数据库同步的状态，如果发现同步有问题，可以通过以上的 <code>show slave status\G</code> 来查看日志问题。 这里说我遇到的问题，因为我是使用虚拟机来做的主从服务器，所以从数据库是直接从主数据库下克隆出来的镜像，这里就导致了出现同步的问题：<code>The slave I/O thread stops because master and slave have equal MySQL server UUIDs;</code> 即使我们设置 <code>server_id</code> 但是这两个值也不可以一致。解决也很简单，关闭从 <code>mysql</code>，删除 <code>mysql Data</code> 目录下（<code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 可以查看 <code>Data</code> 目录的路径）的 <code>auto.cnf</code> ，启动 <code>MySQL</code> 服务即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/kylinlin/p/5258719.html">Mysql主从同步（复制）</a> </p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>主从同步</tag>
        <tag>数据库</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>TODO【聊聊MySQL】三.InnoDB的表结构和行记录结构</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%89-innodb%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/index.html</url>
    <content><![CDATA[<h2 id="一-InnoDB的表和数据"><a href="#一-InnoDB的表和数据" class="headerlink" title="一.InnoDB的表和数据"></a>一.InnoDB的表和数据</h2><p><code>InnoDB</code> 是怎样存储数据的，表是大概怎样的一种格式，表中的数据行又是怎样的一种格式。如果想要大概知道 <code>B+</code> 索引的执行过程，这块基本是跳不过去的。当然关于 <code>表</code> 和 <code>数据行</code> 的东西特别多，没办法涵盖所有，所以我只能将我学的，大概知道的重要部分取出来说一说。</p>
<p>这里先大概说下后面才说的 <code>索引</code> 问题，<code>B+索引</code> 其实利用了表中的 <code>行记录头</code>（可以想象是 <code>HTTP</code> 请求的请求头），然后进行数据结构组织实现快速检索的一种结构。所以不用说啦，<code>行记录头</code> 一些必要的属性，基本要知道的，也可以优化数据库的占用空间。</p>
<a id="more"></a>


<p><code>Innodb</code> 存储引擎表在创建的时候，如果没有显示定义主键（<code>Primary Key</code>），则会通过以下的规则创建主键：</p>
<ol>
<li>如果表中有非空的唯一索引，则该列为主键；</li>
<li>如果 <code>1</code> 不满足，则在你看不见的地方（行头）创建一个 <code>6</code> 字节大小的指针。</li>
</ol>
<p>我先从宏观的表空间进入，到段、区，到页，到行，那么这样看完行的时候，可以直接感受下一篇讲索引使用的行中的信息，也算是有一定的逻辑顺序吧。</p>
<p>他们的大致关系是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103511.png"></p>
<h2 id="二-表空间"><a href="#二-表空间" class="headerlink" title="二.表空间"></a>二.表空间</h2><h3 id="2-1-表的物理存储"><a href="#2-1-表的物理存储" class="headerlink" title="2.1 表的物理存储"></a>2.1 表的物理存储</h3><p><strong>数据、表、数据库文件</strong></p>
<p>至于要找到表结构的文件，我们至少需要先知道数据文件存在哪个地方，所以我们可以直接通过 <code>SQL</code> 语句进行查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#x27;datadir&#x27;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | /var/lib/mysql/ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>OK，结果返回，我们的数据存储在 <code>/var/lib/mysql/</code> 中，所以我们现在进去瞅一瞅是什么东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd /var/lib/mysql/</span><br><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql       20 9月  23 00:00 demo</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>
<p>为了能够继续说下去，我需要建立一些数据库以及表来做演示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database innodb_study;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> use innodb_study;</span><br><span class="line">Database changed</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> table_file_user (id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">10</span>));</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>
<p>好了，创建了一个 <code>innodb_study</code> 的数据库以及一个 <code>table_file_user</code> 的表，现在我们重新来看看数据文件里面多了些什么东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:44 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 10月  9 22:44 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:42 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql       74 10月  9 22:44 innodb_study # 多了这个数据库文件夹</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>
<p>好了进去 <code>innodb_study</code> 瞅瞅有哪些东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost innodb_study]# ll</span><br><span class="line">总用量 112</span><br><span class="line">-rw-r-----. 1 mysql mysql    65 10月  9 22:43 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql  8586 10月  9 22:44 table_file_user.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 98304 10月  9 22:44 table_file_user.ibd</span><br></pre></td></tr></table></figure>
<ol>
<li><code>db.opt</code> 猜一下，应该是数据库的设定，比如字符集啊，使用的存储引擎啊等等；</li>
<li><code>table_file_user.frm</code> 则是我创建的用户表的结构文件了；</li>
<li><code>table_file_user.ibd</code> 是 <code>InnoDB</code> 存储引擎的数据库文件；</li>
</ol>
<p>首先我们先来看看 <code>db.opt</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost innodb_study]# cat db.opt</span><br><span class="line">default-character-set=latin1</span><br><span class="line">default-collation=latin1_swedish_ci</span><br></pre></td></tr></table></figure>
<p>可以看到，我刚刚在创建这个数据库的时候，一切用的是默认的，所以默认的字符集以及排序规则都是 <code>latin1</code> 相关的。</p>
<p><a href="https://baike.baidu.com/item/latin1/1183590?fr=aladdin">latin1百科</a></p>
<p><code>table_file_user.frm</code> 则无法直接使用 <code>cat</code> 进行查看，需要通过  <a href="https://pdf.us/2019/01/10/2620.html">MySQL管理工具集 MySQL Utilities</a> 的方式进行查看，不过在这里我就不演示了。</p>
<p><code>table_file_user.ibd</code> 则就是数据库文件了，存储的是数据库数据，后面再说。</p>
<p><strong>表空间设置参数</strong></p>
<p>针对 <code>table_file_user.ibd</code> 有个参数需要提一下 <code>innodb_file_per_table</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#x27;innodb_file_per_table&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>什么意思咧，就是每个表的数据都存储在独立的表空间，<code>5.7</code> 以前默认是 <code>off</code> 的，后面的版本就默认开启了。如果是 <code>off</code> 的话，所有表的数据都会记录在一个文件里面。但是即使开启了独立表空间的参数，也只是记录表的数据、索引、插入缓冲等信息，其他的回滚日志还是会存储在公共的空间中的。</p>
<p><strong>定义表空间文件大小位置</strong></p>
<p>可以通过定义 <code>my.cnf</code> 中的配置，来定义存储的表空间文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path = /db/ibdata1:2000M;/db/ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>
<p>我们可以这样定义由两个文件组成表空间，后面的文件容量大小限定表示文件限制大小，而 <code>ibdata2</code> 增长到 <code>2000M</code> 的时候还可以自动增长。</p>
<h3 id="2-1-表的逻辑存储"><a href="#2-1-表的逻辑存储" class="headerlink" title="2.1 表的逻辑存储"></a>2.1 表的逻辑存储</h3><p>接下来简单说下上图中，表空间的下级几个东西：</p>
<p><strong>段</strong></p>
<p>表空间由很多个段组成，段又有数据段、索引段、回滚段等等。因为 <code>InnoDB</code> 存储数据本质上就是利用索引树进行存储的，所以数据段即是 <code>B+树</code> 的<code>叶节点</code>，而索引段即为<code>非叶子节点</code>。</p>
<p><strong>区</strong></p>
<p>每个区由 <code>64个页</code> 组成，每页大小 <code>16KB</code>，因此每个区是 <code>1MB</code>。针对需要插入大数据段的操作，<code>InnoDB</code> 每次至多申请 <code>4个区</code>。</p>
<p>我们启用 <code>innodb_file_per_table</code> 参数的时候，创建表的时候即段的开始，<code>InnoDB</code> 先使用 <code>32个页</code> 的碎片页来存放数据，当这些数据存储完了才会申请上面说的 <code>64个页</code>。</p>
<p>具体其他创建的时候怎么创建的细节，因为对我们使用数据库的时候帮助不是很大，这里就不再阐述（可以参考《MySQL技术内幕：InnoDB存储引擎》的 <code>4.2.3</code> 小节）</p>
<p><strong>页</strong></p>
<p>页太重要了，请允许我现在马上提取到大标题来讲！</p>
<p><strong>行</strong></p>
<p>行和页一样，太重要了，现在也一样马上提取到大标题来讲！</p>
<h2 id="三-InnoDB的数据页"><a href="#三-InnoDB的数据页" class="headerlink" title="三. InnoDB的数据页"></a>三. InnoDB的数据页</h2><p>页是 <code>MySQL InnoDB</code> 与服务器硬盘打交道的单位，当我们需要查询数据的时候，数据库每次至少加载 <code>一个页</code> 的数据到内存进行查找，而在前面说的刷新脏数据的时候，每次至少刷新 <code>一个页</code> 的数据，而页在 <code>区</code> 中说的，是 <code>16KB</code>。所以交互不会太小导致频繁 <code>IO</code> 也不会因为太大导致读取太慢。</p>
<p>页不仅有数据页，所有的页包含有：</p>
<ol>
<li>数据页（<code>B-tree Node</code>）；</li>
<li>Undo页（<code>Undo Log Page</code>）；</li>
<li>系统页（<code>System Page</code>）；</li>
<li>事务数据页（<code>Transaction system Page</code>）；</li>
<li>插入缓冲位图页（<code>Insert Buffer Bitmap</code>）；</li>
<li>插入缓冲空闲列表页（<code>Insert Buffer Free List</code>）；</li>
<li>未压缩的二进制大对象页（<code>Uncompress BLOB Page</code>）；</li>
<li>压缩的二进制大对象页（<code>Compressed BLOB Page</code>）。</li>
</ol>
<blockquote>
<p>第四节数据页的结构和第五节数据行的结构应该是并行了解，也就是两者共同构成搜索数据的基础，阅读建议是数据页格式先有个大概的概念，然后数据行，再两个并起来聊聊数据查询的内部原理.</p>
</blockquote>
<h2 id="四-数据页的结构"><a href="#四-数据页的结构" class="headerlink" title="四. 数据页的结构"></a>四. 数据页的结构</h2><p>这是一个页的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103511.png" alt="image-20191120152749956"></p>
<p>OK，现在我们知道了，<code>InnoDB 数据页</code> 一共由 <code>7</code> 个部分组成。其中 <code>User Records 数据行</code> 存储的是我们用户的数据，他会按照 <code>Table</code> 指定的 <code>Row Format 行格式</code> 的规定进行存储。然而当一个页没有数据页格式的时候，是不存在 <code>User Records</code> 空间的，也就是说 <code>Free Space</code> 将会占领图中 <code>User Records</code> 那部分的空间。</p>
<p>好了，我们先摊开来每部分，大致的说一下是什么功能：</p>
<h3 id="4-1-FileHeader-文件头信息"><a href="#4-1-FileHeader-文件头信息" class="headerlink" title="4.1 FileHeader 文件头信息"></a>4.1 FileHeader 文件头信息</h3><p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
<p>在页头信息里面有个 <code>FILE_PAGE_TYPE</code>，它主要有以下几种类型：</p>
<ol>
<li><code>FILE_PAGE_INDEX</code> ：<code>B+树</code> 叶节点</li>
<li><code>FILE_PAGE_UNDO_LOG</code> ：<code>Undo Log</code> 页</li>
<li><code>FILE_PAGE_INODE</code> ：索引节点</li>
<li><code>FILE_PAGE_IBUF_FREE_LIST</code> ：<code>Insert Buffer</code> 空闲列表</li>
<li><code>FILE_PAGE_TYPE_ALLOCATED</code> ：最新分配的页</li>
<li><code>FILE_PAGE_BITMAP</code> ：<code>Insert Buffer</code> 位图</li>
<li><code>FILE_PAGE_SYS</code> ：系统页</li>
<li><code>FILE_PAGE_TRX_SYS</code> ：事务系统数据</li>
<li><code>FILE_PAGE_FSP_HDR</code> ：File Space Header</li>
<li><code>FILE_PAGE_XDES</code> ：拓展描述页</li>
<li><code>FILE_PAGE_BLOB</code> ：<code>BLOB</code> 页</li>
</ol>
<h3 id="4-2-PageHeader-页头信息"><a href="#4-2-PageHeader-页头信息" class="headerlink" title="4.2 PageHeader 页头信息"></a>4.2 PageHeader 页头信息</h3><p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
<h3 id="4-3-Infimum-和-Supremum-最值记录"><a href="#4-3-Infimum-和-Supremum-最值记录" class="headerlink" title="4.3 Infimum 和 Supremum 最值记录"></a>4.3 Infimum 和 Supremum 最值记录</h3><p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
<h3 id="4-4-User-Records-用户记录-和-Free-Space-空闲空间"><a href="#4-4-User-Records-用户记录-和-Free-Space-空闲空间" class="headerlink" title="4.4 User Records 用户记录 和 Free Space 空闲空间"></a>4.4 User Records 用户记录 和 Free Space 空闲空间</h3><p>这两个放在一起说是有原因的，因为一个空的页，是没有 <code>User Records</code> 的，全部都是 <code>Free Space</code>。慢慢的插入数据的时候，<code>User Records</code> 慢慢增大，<code>Free Space</code> 慢慢减小，直到这个页塞满了数据，就开启下一页。</p>
<p>想了想，弄个动图演示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103511.png"></p>
<h3 id="4-5-Page-Director-页目录"><a href="#4-5-Page-Director-页目录" class="headerlink" title="4.5 Page Director 页目录"></a>4.5 Page Director 页目录</h3><p>页目录 <code>Page Director</code> 存储了很多槽，用来存储最大最小记录的槽，<code>InnoDB</code> 就是通过这些槽来提高查询的速度的，下面会详细说。</p>
<h3 id="4-6-File-Trailer-页尾部"><a href="#4-6-File-Trailer-页尾部" class="headerlink" title="4.6 File Trailer 页尾部"></a>4.6 File Trailer 页尾部</h3><p>校验页数据用的地方，这个页有两个部分：</p>
<ol>
<li>页的校验和</li>
</ol>
<p>与 <code>FileHeader</code> 中的 <code>FILE_PAGE_SPACE_OR_CHKSUM</code> 值相对应，因为 <code>FileHeader</code> 在页的头部，被首先写入硬盘，当写入硬盘的过程中发现错误导致页不完整的时候，头部和尾部的值就会出现不相同的情况，这时候就需要根据日志来重新做这个页。</p>
<ol start="2">
<li>被最后修改时对应的日志序列位置（LSN）</li>
</ol>
<p>也是用来做校验的，后面会说到。</p>
<h2 id="五-数据行"><a href="#五-数据行" class="headerlink" title="五. 数据行"></a>五. 数据行</h2><p>我们知道了，一个数据页是 <code>16kb</code> 的大小，而数据页中有一个很重要的部分就是 <code>User Record</code> 区域就是用来存放我们的数据的地方。我们所插入的数据，<code>InnoDB</code> 会根据规则，转变成一定的 <code>行格式</code> 插入到数据页中去，行格式除了存储我们生产的数据以外，还存储着一些额外的信息，用于加快<strong>查数据</strong>的速度（当然删和改也都以来着查，新增也会以来查来确定主要的位置，所以查是一个数据库中至关重要的功能）。</p>
<p><code>MySQL</code> 发展到现在，已经有好几种 <code>数据行</code> 的格式了，分别有：<code>Compact</code> <code>Redundant</code> <code>Dynamic</code> 和 <code>Compressed</code>。</p>
<p><code>Redundant</code> 是为了解决与之前版本的兼容性问题而存在的，剩下的 <code>Dynamic</code> 和 <code>Compressed</code> 本质上是 <code>Compact</code> 格式，只不过在处理溢出页的时候不同，只要说了 <code>Compact</code> 就相当于说了三种，至于什么是溢出页，在下面会详细说到。</p>
<p>首先来看看 <code>Compact</code> 的数据行包含了什么鬼：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103511.png" alt="image-20191121094525787"></p>
<h3 id="5-1-额外信息"><a href="#5-1-额外信息" class="headerlink" title="5.1 额外信息"></a>5.1 额外信息</h3><p>这部分是 <code>InnoDB</code> 为了方便快速查找统计而新加进去的一些记录行额外信息，主要用来标记可变长字段的长度（比如 <code>varchar</code> 占用多长）、哪些定义可为 <code>NULL</code> 的列在这条记录中出现了 <code>NULL</code> 以及一部分有用的记录头信息。</p>
<p>接下来一个一个来看这些有什么作用，为了防止标题太多层级我直接使用跟这里一样的标题。</p>
<h3 id="5-1-1-可变长字段的长度列表"><a href="#5-1-1-可变长字段的长度列表" class="headerlink" title="5.1.1 可变长字段的长度列表"></a>5.1.1 可变长字段的长度列表</h3><p>在 <code>Compact</code> 中，把表定义的可变长字段，在当前数据行中所占用的实际长度，按照 <strong>逆序</strong> 存储他们当前的长度。</p>
<p>怎么说呢，举个例子来做吧：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_db(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  addr <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  sex <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">) CHARSET<span class="operator">=</span>ascii ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure>
<p>这个表包含一个主键、一个不为空的 <code>name</code>，一个可为空的 <code>addr</code>，还有一个不可变长可为空的 <code>sex</code>。字符集是 <code>ascii</code>（就是包含简单字母的那个），以及指定行格式是 <code>Compact</code>。</p>
<p>然后我插入 <code>5</code> 个数据来玩玩：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_db (id, name, addr, sex)</span><br><span class="line">	<span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;goudan&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">	(<span class="number">2</span>, <span class="string">&#x27;gousheng&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>, <span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">	(<span class="number">3</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="keyword">null</span>, <span class="keyword">null</span>),</span><br><span class="line">	(<span class="number">4</span>, <span class="string">&#x27;adan&#x27;</span>, <span class="string">&#x27;tianhe&#x27;</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT * FROM user_db;</span></span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">| id | name     | addr      | sex  |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">|  1 | goudan   | NULL      | b    |</span><br><span class="line">|  2 | gousheng | guangzhou | g    |</span><br><span class="line">|  3 | xiaoming | NULL      | NULL |</span><br><span class="line">|  4 | adan     | tianhe    | NULL |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>好，终于搞定 <code>demo</code> 数据。</p>
<p>我们回到可变长字段的长度列表来看，就拿 <code>id = 2</code> 的数据来看吧：</p>
<p>因为在这个表中 <code>name</code> <code>addr</code> 都是可变长字段，<code>name</code> 的长度是 <code>8</code>，<code>addr</code> 的长度是 <code>9</code> 他们通过十六进制表示分别是：<code>0×08</code> <code>0×09</code> ，然后，可变长字段存储是逆序的，所有，存储在可变长字段列表里面的数据就是 <code>0908</code></p>
<p>这里有两个地方需要注意的是</p>
<ol>
<li>如果这个可变长的列，他的真实值是 <code>NULL</code>，则他不会被记录在此列表中，也就是说在 <code>id = 3</code> 的记录中，可变长字段的长度列表只需要记录 <code>name</code> 列的长度即可；</li>
<li>这个长度列表可能需要 <code>1字节</code> 也可能因为记录不下，而开辟了 <code>2字节</code> 的长度来记录，怎么说呢：</li>
</ol>
<p>我们知道 <code>1字节</code> 数的二进制是 <code>8</code> 位，然后，第一位像 <code>Protobuf</code> 一样用来记录后面还有没有位数，所以真实使用存储长度的是后 <code>7</code> 位。而 <code>7</code> 位最大能表示多大长度呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103511.png" alt="image-20191121105157176"></p>
<p>所以，如果这个长度他需要记录 <strong>小于等于</strong> <code>127</code> 的长度的时候，使用 <code>1字节</code>，而如果记录的值 <strong>大于</strong> <code>127</code> 的时候则使用 <code>2字节</code>。<code>8位</code> 的第一位用来标记，我后面还有没有 <code>1字节</code> 来一起记录长度，如果是 <code>0</code> 则表示我当前字节已经记录完所有的了，如果是 <code>1</code> 则表示我后面的 <code>1字节</code> 也是用来记录长度的。而如果长度，他 <code>1字节 = 255</code> 可以存储完毕，则使用 <code>1字节</code>。</p>
<p>那怎么大概计算字段占用多少字节的长度呢：</p>
<p>因为上面的 <code>user_db</code> 使用的是 <code>ascii</code> 来做记录的，让我们用臭名远扬的 <code>utf-8</code> 来说，我们知道，<code>MySQL</code> 中的 <code>utf-8</code> 是个假的，他其实只使用了 <code>3字节</code> 一个字符的方法来存储。</p>
<p>我们假设这个表只有一个列(varchar(MAXLEN))，那如果字符串的最大字节占用长度 = <code>MAXLEN * 3</code>，则如果最大占用字节 <strong>小于等于</strong> <code>255</code> 的时候，使用一个字节来存储，如果他大于 <code>255</code> 则根据他是否 <strong>小于等于</strong> <code>127</code> 也就是 <code>127 / 3 = 42</code> 个字符来看，如果小于等于127，则使用 <code>1字节</code>，否则使用 <code>2字节</code>。好累，弄个伪代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 占用的最大字节数，LocalCharsetLeng是当前字符集的最大字节长度 */</span></span><br><span class="line"><span class="keyword">let</span> maxByteLeng = <span class="title class_">LocalCharsetLeng</span> * <span class="variable constant_">MAXLEN</span>;</span><br><span class="line"><span class="comment">/** 可变长字段列表的长度 */</span></span><br><span class="line"><span class="keyword">let</span> lengthOfVariableColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (maxByteLeng &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">  lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/** 她当前数据行存储的长度 */</span></span><br><span class="line">  <span class="keyword">let</span> lengthOfData = ...</span><br><span class="line">  <span class="keyword">let</span> byteLengthOfData = <span class="title class_">LocalCharsetLeng</span> * lengthOfData;</span><br><span class="line">  <span class="keyword">if</span> (byteLengthOfData &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-NULL值列表"><a href="#5-1-2-NULL值列表" class="headerlink" title="5.1.2 NULL值列表"></a>5.1.2 NULL值列表</h3><p><code>NULL值列表</code> 也是按照列中可以为NULL的列逆序来排放的，直接上图更清晰：</p>
<p>我们加入要看 <code>id = 3</code> 的数据，他的 <code>addr</code> 和 <code>sex</code> 都为 <code>NULL</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103511.png" alt="image-20191121151849940"></p>
<p>所以从最后一位开始，对应列中第一个可以为 <code>NULL</code> 的列（被 <code>NOT NULL</code> 修饰的列），如果是 <code>NULL</code> 则为 <code>1</code> 否则为 <code>0</code>。</p>
<p>所以，<code>NULL</code> 值并不会占用存储空间。</p>
<h3 id="5-1-3-记录头信息"><a href="#5-1-3-记录头信息" class="headerlink" title="5.1.3 记录头信息"></a>5.1.3 记录头信息</h3><p>这个可就很重要，因为他是构成索引搜索条件的基础。</p>
<p>记录头有以下这些头部信息，共占用 <code>40字节</code> 不同的字节数作用都不相同：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>占位符1</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>占位符2</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>delete_flag</td>
<td>1</td>
<td>标记记录是否被删除（也就是我们开发常说的逻辑删除）</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000普通记录 001B+树节点指针 010Infimum<br/>011Supremum 1xx保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>页中玉东道下一条记录需要的偏移量</td>
</tr>
</tbody></table>
<p>OK一起说完真实记录再来看看怎么搜索数据的吧</p>
<h3 id="5-2-真实数据"><a href="#5-2-真实数据" class="headerlink" title="5.2 真实数据"></a>5.2 真实数据</h3><p>真实数据的存储，都是存储有效的数据，即如果某个值没有数据，则不做存储。那他怎么知道谁是有的谁是没的，这就需要结合上面可变长字段列表、NULL值列表以及下一条记录的偏移量来确定了。</p>
<p>其实真实数据中，<code>InnoDB</code> 还会在真实数据的头部增加两个列：<code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> 分别是事务的指针以及回滚的指针（用于重做？）。如果当前的表没有定义主键的话，那么 <code>InnoDB</code> 还会真实数据的头部增加 <code>ROW_ID</code> 这个隐藏列来作为主键（为啥一定要主键？后面索引会说说的）</p>
<p>所以记录应该是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103510.png"></p>
<h3 id="5-3-溢出页"><a href="#5-3-溢出页" class="headerlink" title="5.3 溢出页"></a>5.3 溢出页</h3><p>针对 <code>VARCHAR</code> 定义的数据列最多能存储多少个数据？一个记录最大能存储 <code>65535</code> 个字节的数据，但是并不是真的可以存储，因为在上面看来，还需要记录变长字段以及 <code>NULL值列表</code>，如果被 <code>NOT NULL</code> 修饰，则还可以节省 <code>1字节</code>，所以假设我这个表只有一个列的情况下分为下面两种情况：</p>
<ol>
<li>被 <code>NOT NULL</code> 修饰，存储 <code>65533</code> 个字节；</li>
<li>没有修饰，存储 <code>65532</code> 个字节。</li>
</ol>
<p>那如果存储的数据超出一个页 <code>16kb</code> 的定义怎么办，那就需要额外的溢出页来存储数据了。</p>
<p>但是 <code>Compact</code> 格式的数据有点纠结，如果占用的字节数小于 <code>768</code> 字节的时候，存储在本页，如果超出了，则该页依然会记录前 <code>768字节</code> 的数据，然后再使用 <code>20字节</code> 来存储溢出页的地址以及字节数大小。</p>
<p>而 <code>MySQL 5.7</code> 使用的 <code>InnoDB Plugin</code> 默认的格式 <code>Dynamic</code> 以及新增的 <code>Compress</code> 格式则不同，他们只在当前记录这里记录溢出页的位置，将所有的数据都放在溢出页里面，而 <code>Compress</code> 还会将溢出页进行压缩处理，减少存储空间。</p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>主要了解了表的逻辑存储、数据页、数据行的格式。不过不用太担心没记住，后面我都会重复这里的内容来说接下来的所有事情的，毕竟这里面的一堆属性都是为后面 <code>MySQL</code> 的功能做铺垫。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】九.MySQL-InnoDB的数据库事务的执行之UNDO_LOG</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B9%9D-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bundo-log/index.html</url>
    <content><![CDATA[<h2 id="一-UNDO-LOG"><a href="#一-UNDO-LOG" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<a id="more"></a>
<h2 id="二-想象中的回滚"><a href="#二-想象中的回滚" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务"><a href="#三-找到对应的事务" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式"><a href="#四-UNDO通用日志格式" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103609.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类"><a href="#五-UNDO日志分类" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log"><a href="#5-1-insert-undo-log" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103610.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除"><a href="#5-2-update-undo-log-之删除" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103628.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li> 第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li> 第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103630.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="type">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">    s_code <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">null</span> ,</span><br><span class="line">    s_username <span class="type">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> index datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>
<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(&quot;111&quot;, &quot;001&quot;, &quot;Weidan&quot;);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid <span class="operator">=</span> <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103611.gif"> </p>
<p>步骤：</p>
<ol>
<li> 首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li> 然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103624.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li> 更新后的值跟原来的值的长度一样：就地更新；</li>
<li> 否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103620.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）"><a href="#5-2-update-undo-log-之更新（更新主键的情况）" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表"><a href="#六-UNDO-LOG数据页链表" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构"><a href="#6-1-数据页链表结构" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103621.jpeg"></p>
<ol>
<li> 上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li> <code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li> 第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li> 每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页"><a href="#6-2-事务并发执行的链表页" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103622.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用"><a href="#6-3-undo-log页的重用" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li> <code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li> 事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li> 只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li> 而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段"><a href="#七-回滚段" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103627.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103608.jpeg"></p>
<h3 id="回滚段分类"><a href="#回滚段分类" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结"><a href="#八-小结" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】二. InnoDB体系结构</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%BA%8C-innodb%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/index.html</url>
    <content><![CDATA[<h2 id="一-InnoDB存储引擎"><a href="#一-InnoDB存储引擎" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li> 支持完整 <code>ACID</code> 事务；</li>
<li> 行锁设计，可提高并发；</li>
<li> 支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li> 支持外键；</li>
<li> 优秀的 <code>B+</code> 索引。<a id="more"></a>
<h2 id="二-InnoDB体系架构"><a href="#二-InnoDB体系架构" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103632.jpeg"> <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程"><a href="#2-1-后台线程" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li> <code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li> <code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li> …</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">=====================================</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">=====================================</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I/O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I/O thread 0 state: waiting for i/o request (insert buffer thread)</span><br><span class="line">I/O thread 1 state: waiting for i/o request (log thread)</span><br><span class="line">I/O thread 2 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 3 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 4 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 5 state: waiting for i/o request (read thread)</span><br><span class="line">I/O thread 6 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 7 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 8 state: waiting for i/o request (write thread)</span><br><span class="line">I/O thread 9 state: waiting for i/o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i/o&#x27;s:, sync i/o&#x27;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches/s, 0.00 non-hash searches/s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i/o&#x27;s done, 0.00 log i/o&#x27;s/second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID=99, Main thread ID=123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>
<h3 id="2-2-内存使用"><a href="#2-2-内存使用" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li> 缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li> 重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li> 额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.64 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I/O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103634.png"></p>
<h2 id="三-一个一直在循环的主线程"><a href="#三-一个一直在循环的主线程" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情"><a href="#3-1-每一秒做的事情" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">noUserAct</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个一个来看看吧：</p>
<ol>
<li> 刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li> 合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li> 刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务"><a href="#3-2-每十秒做的任务" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">noUserAct</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程"><a href="#3-3-后台活动线程" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">noUserAct</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="literal">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程"><a href="#3-4-5-7Innodb的后台线程" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write"><a href="#四-Double-Write" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103633.png"></p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_dblwr%&#x27;</span>\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        <span class="keyword">Value</span>: <span class="number">1865308</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        <span class="keyword">Value</span>: <span class="number">248718</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line"><span class="keyword">No</span> query specified</span><br></pre></td></tr></table></figure>
<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引"><a href="#五-自适应哈希索引" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE HASH INDEX</span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: size <span class="number">1</span>, <span class="keyword">free</span> list len <span class="number">0</span>, seg size <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged operations:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded operations:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">796871</span>, node heap has <span class="number">691</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">796871</span>, node heap has <span class="number">112</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">796871</span>, node heap has <span class="number">307</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">796871</span>, node heap has <span class="number">481</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">796871</span>, node heap has <span class="number">463</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">796871</span>, node heap has <span class="number">281</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">796871</span>, node heap has <span class="number">410</span> buffer(s)</span><br><span class="line">Hash <span class="keyword">table</span> size <span class="number">796871</span>, node heap has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> hash searches<span class="operator">/</span>s, <span class="number">42.04</span> non<span class="operator">-</span>hash searches<span class="operator">/</span>s</span><br></pre></td></tr></table></figure>
<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置"><a href="#六-MySQL-InnoDB启动关闭行为的配置" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown"><a href="#6-1-innodb-fast-shutdown" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery"><a href="#6-2-innodb-force-recovery" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>mysql</tag>
        <tag>B+</tag>
        <tag>MasterThread</tag>
        <tag>Redo</tag>
        <tag>Undo</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】五.MySQL-子查询的过程</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%BA%94-mysql-%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B/index.html</url>
    <content><![CDATA[<h2 id="一-子查询"><a href="#一-子查询" class="headerlink" title="一.子查询"></a>一.子查询</h2><p>我们平时在查询数据的时候，特别是报表数据的时候，或多或少都会接触到 <code>子查询</code> 这个东西的吧。因为有些数据，他就是需要前套一层 <code>子查询</code> 来先拿到部分数据，然后再结合这部分的数据接着进行查询。</p>
<a id="more"></a>
<h2 id="二-子查询出现的位置"><a href="#二-子查询出现的位置" class="headerlink" title="二.子查询出现的位置"></a>二.子查询出现的位置</h2><p>子查询出现的位置，如果平时没有去总结一下的话，还真的不知道可以在这么多的地方出现。具体来说呢，好像每个地方都可以出现。</p>
<h3 id="2-1-SELECT位置"><a href="#2-1-SELECT位置" class="headerlink" title="2.1 SELECT位置"></a>2.1 SELECT位置</h3><p>比如 <code>SELECT (SELECT * FROM business_order);</code>，当然这个语句好像并没有什么意义。</p>
<h3 id="2-2-FROM位置"><a href="#2-2-FROM位置" class="headerlink" title="2.2 FROM位置"></a>2.2 FROM位置</h3><p>有个场景，比如订单表在已经支付的时候我们需要批量的去修改其他列的数据，那么我们会写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> business_order <span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;DEL&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> business_order <span class="keyword">WHERE</span> xxx);</span><br></pre></td></tr></table></figure>
<p>这条语句乍一看没有问题，但是 <code>MySQL</code> 会给你报个错误：<code>You can&#39;t specify target table &#39;student&#39; for update in FROM clause</code>，意思大概就是无法对查询的表进行更新。 那么我们这个需求又必须要实现咋办呢，在条件中套多一层：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> business_order <span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;DEL&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> a.id <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> business_order <span class="keyword">WHERE</span> xxx) a</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>那么上面的 <code>SELECT a.id FROM (SELECT id FROM business_order WHERE xxx) a</code> 语句有另外一个子查询出现在 <code>FROM</code> 位置</p>
<h3 id="2-3-WHERE位置"><a href="#2-3-WHERE位置" class="headerlink" title="2.3 WHERE位置"></a>2.3 WHERE位置</h3><p>详见 <code>FROM位置</code> 里面的示例，<code>WHERE id IN ( SELECT a.id FROM (SELECT id FROM business_order WHERE xxx) a);</code> 就是一个出现在 <code>WHERE</code> 位置的 <code>子查询</code>。</p>
<h3 id="2-4-其他没有意义的地方"><a href="#2-4-其他没有意义的地方" class="headerlink" title="2.4 其他没有意义的地方"></a>2.4 其他没有意义的地方</h3><p><code>ORDER BY</code> <code>GROUP BY</code> 都是可以出现子查询的，但是并没有什么意义，就不说了。</p>
<h2 id="三-子查询的分类"><a href="#三-子查询的分类" class="headerlink" title="三.子查询的分类"></a>三.子查询的分类</h2><blockquote>
<p>单独看分类这一节并没有什么意义，但因为在下面讨论查询方式的时候，需要用到这些名字。所以大概记住一个名字代表什么意思然后带着这个名字去看下面就好了。</p>
</blockquote>
<p>划分维度有几个，不过我直接挑出来常用的就好了。 其实就是一个问题：<code>跟外查询有没有关系？</code></p>
<h3 id="3-1-有关系：相关子查询"><a href="#3-1-有关系：相关子查询" class="headerlink" title="3.1 有关系：相关子查询"></a>3.1 有关系：相关子查询</h3><p>为了有个例子，我憋着气也要写一个可以执行的带有子查询的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line">student stu </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> stu_id </span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">scope</span> scp </span><br><span class="line">  <span class="keyword">WHERE</span> scp.stu_id <span class="operator">=</span> stu.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>（我怎么会写这么无聊的代码…….. 可以看到吧，<code>子查询</code> 中的 <code>scope</code> 条件中出现了依赖外部表 <code>student</code> 的条件，这种查询方法就是 <code>相关子查询</code>。</p>
<h3 id="3-2-没有关系：非相关子查询"><a href="#3-2-没有关系：非相关子查询" class="headerlink" title="3.2 没有关系：非相关子查询"></a>3.2 没有关系：非相关子查询</h3><p>这个简单，就是子查询直接拿到外部，还可以继续执行的语句，因为并不需要依赖外部表的值。</p>
<h2 id="四-子查询执行过程"><a href="#四-子查询执行过程" class="headerlink" title="四.子查询执行过程"></a>四.子查询执行过程</h2><p>上面是关联的方式，那接下来需要根据不同的查询方式进行分类。</p>
<h3 id="4-1-标量子查询"><a href="#4-1-标量子查询" class="headerlink" title="4.1 标量子查询"></a>4.1 标量子查询</h3><p>举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line">student stu </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> stu_id <span class="keyword">FROM</span> <span class="keyword">scope</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>就是外部表的一个列等于（或者其他 <code>bool表达式</code> 如 <code>&gt;</code> <code>&lt;</code> ）另外一个子查询的时候，就是 <code>标量子查询</code>。</p>
<h3 id="4-2-行子查询"><a href="#4-2-行子查询" class="headerlink" title="4.2 行子查询"></a>4.2 行子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line">student stu </span><br><span class="line"><span class="keyword">WHERE</span> (id, name) <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> stu_id, stu_name <span class="keyword">FROM</span> <span class="keyword">scope</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="4-3-标量子查询和行子查询的两种不同子查询"><a href="#4-3-标量子查询和行子查询的两种不同子查询" class="headerlink" title="4.3 标量子查询和行子查询的两种不同子查询"></a>4.3 标量子查询和行子查询的两种不同子查询</h3><h4 id="4-3-1-不相关子查询"><a href="#4-3-1-不相关子查询" class="headerlink" title="4.3.1 不相关子查询"></a>4.3.1 不相关子查询</h4><p>那标量子查询、行子查询是怎么进行不相关子查询的，其实不是很难： 就当成两个简单的查询就好了，先执行 <code>SELECT stu_id FROM scope</code> 然后再执行 <code>SELECT * FROM student stu WHERE id = 上面结果集</code></p>
<h4 id="4-3-2-相关子查询"><a href="#4-3-2-相关子查询" class="headerlink" title="4.3.2 相关子查询"></a>4.3.2 相关子查询</h4><p>相关子查询就比较麻烦了，需要两个表每个记录去循环，看是否同时满足外部查询和内部查询的条件，如果满足才加入结果集。 比如这个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> </span><br><span class="line">student stu </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> stu_id </span><br><span class="line">  <span class="keyword">FROM</span> <span class="keyword">scope</span> scp </span><br><span class="line">  <span class="keyword">WHERE</span> scp.stu_id <span class="operator">=</span> stu.id <span class="keyword">AND</span> scp.scope <span class="operator">&gt;</span> <span class="number">90</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>会先从 <code>student</code> 拿出 <code>id=1</code> 的记录，加入成绩表的查询，看看成绩是否大于90分，如果大于90分加入结果集返回，然后再拿出 <code>id=2</code> 的记录。</p>
<h3 id="4-4-IN子查询"><a href="#4-4-IN子查询" class="headerlink" title="4.4 IN子查询"></a>4.4 IN子查询</h3><h4 id="4-4-1-临时表查询"><a href="#4-4-1-临时表查询" class="headerlink" title="4.4.1 临时表查询"></a>4.4.1 临时表查询</h4><p><code>IN</code> 查询和上面两种方式不一样，因为为了防止一些问题，比如 <code>IN ...some sql</code> 中，后面 <code>SQL</code> 语句查询出来的结果集很大，可能会导致内存不足，也会因为结果集过于庞大，外部表在查询的时候无法有效的使用到索引。 所以，<code>IN子查询</code> 会通过一些方式，将语句转换成 <code>内连接</code> 的形式来进行查询。 怎么转，通过 <code>物化表</code> 来做，例子说：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student stu</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> stu_id</span><br><span class="line">  <span class="keyword">FROM</span> student_parent stu_par</span><br><span class="line">  <span class="keyword">WHERE</span> stu_par.name <span class="keyword">LIKE</span> <span class="string">&#x27;李%&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>首先执行子查询，即查询学生的父母姓李的所有 <code>stu_id</code> 数据。 那么假设，这个系统刚运行没多久，那么这个结果集（只有一列因为我们指定了查询 <code>stu_id</code>，并且已经去重，比如某学生的父母都姓李，那么这张临时表只会保存一个 <code>stu_id</code>）将会被变为一张临时表（物化成一张表）存储在内存中，并且这个表是基于 <code>HASH索引</code> 而存在的，然后，将 <code>student</code> 表与内存中的这张表进行连接，比如内存中这张物化表的名字是 <code>student_parent_memory</code> 那么上面这条内连接的 <code>SQL</code> 将进一步变成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stu.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student stu </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> student_parent_memory spm <span class="keyword">ON</span> stu.id <span class="operator">=</span> spm.<span class="operator">*</span>;</span><br></pre></td></tr></table></figure>
<p>再假设，系统运行的不错，一直在运行着，那么子查询的表查询出来的结果集已经超过了数据库系统设置的 <code>tmp_table_size</code> 和 <code>max_heap_table_size</code>。那么这个临时表存储的位置将发生了变化，表来是内存的基于 <code>HASH索引</code> 的表，现在就变成了硬盘中基于 <code>B+树</code> 的表而存在。 至于后续如何进行，就是上一节中说的连接基于成本来判断使用哪张表做 <code>驱动表</code> 以及 <code>被驱动表</code> 的策略了。</p>
<h4 id="4-4-2-半连接"><a href="#4-4-2-半连接" class="headerlink" title="4.4.2 半连接"></a>4.4.2 半连接</h4><p>半连接可以说，为了不像上面一样创建临时表或者优化创建的临时表，然后去进行查询的一种策略。 <strong>仅适用于不相关子查询</strong> <strong>方式一</strong> <code>Table Pullout</code> 把表拉出去 如果关联查询的子查询的结果集的那个列是唯一索引，那么子查询将被跳过生成临时表的步骤，然后被拉到外面直接内连查询！ <strong>方式二</strong> <code>DuplicateWeedout execution strategy</code> 消除重复值 生成一个只有一个列并且这个列 <code>PRIMARY KEY</code>，然后根据外部表的列来排除已经被加入到结果集的数据（因为这个列是唯一的）这种方式可以用于统计省市情况，由于满足某个条件（比如人口大于某个比率），而省可能包含很多个市，可能这个省多个市可以加入结果集，那么就可以使用这种方式来消除重复的省结果集。 <strong>方式三</strong> <code>LooseScan execution strategy</code> 松散策略</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> order_info oi</span><br><span class="line"><span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> deliver_bill db <span class="keyword">WHERE</span> db.order_id <span class="keyword">LIKE</span> <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line">)</span><br><span class="line"># deliver_bill 中 order_id 是二级索引</span><br></pre></td></tr></table></figure>
<p>那么在执行子查询查发货单表的时候，由于 <code>order_id</code> 模糊查询，而且在发货单中可能存在很多重复的记录，那么在使用发货单二级索引的时候，就可以直接跳过这些重复的订单号值，拿到不重复的值就可以了。 <strong>方式四</strong> <code>Semi-join Materialization execution strategy</code> 这是上面临时表策略 <strong>方式五</strong> <code>FirstMatch execution strategy</code> 匹配字表跳出字表查询 从外表取出记录去一次一次匹配字表的记录，是一种最原始的方式。如果这条记录已经满足了条件，那么假如结果集，不再去匹配子表而是回到外表，继续下一条记录。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103635.png" alt="img"><br> 图来自 <a href="https://www.cnblogs.com/abclife/p/10895624.html">semi-join子查询优化 – FirstMatch策略</a></p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】八.MySQL-InnoDB的数据库事务的执行之REDO_LOG</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AB-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bredo-log/index.html</url>
    <content><![CDATA[<h2 id="一-REDO-LOG"><a href="#一-REDO-LOG" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式"><a href="#二-高效且持久化的方式" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式"><a href="#三-日志格式" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<a id="more"></a>
<h3 id="3-1-装载数据的通用格式"><a href="#3-1-装载数据的通用格式" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103513.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103514.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式"><a href="#3-2-插入数据时日志格式" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103519.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103539.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容"><a href="#3-2-REDO-日志内容" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103522.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’"><a href="#四-重做LOG的’事务’" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103524.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区"><a href="#五-重做LOG缓冲区" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103516.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103518.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘"><a href="#六-触发重做LOG刷盘" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里"><a href="#七-重做LOG刷到哪些文件里" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系"><a href="#八-重做LOG缓冲页与日志文件的关系" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式"><a href="#8-1-重做日志文件的格式" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103520.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number"><a href="#8-2-LSN-Log-Swquence-Number" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103525.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘"><a href="#8-4-日志缓冲数据刷盘" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103511.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN"><a href="#8-5-flush链表和LSN" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103515.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103527.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103537.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint"><a href="#8-6-Checkpoint" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103523.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页"><a href="#九-崩溃重做数据页" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别"><a href="#十-配置重做日志的级别" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】十.MySQL-InnoDB的数据库事务的执行之MVCC</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bmvcc/index.html</url>
    <content><![CDATA[<h2 id="一-事务的隔离"><a href="#一-事务的隔离" class="headerlink" title="一.事务的隔离"></a>一.事务的隔离</h2><p>刚开始我们说了事务的四个特性：<code>原子性</code> <code>一致性</code> <code>隔离性</code> <code>持久性</code>。</p>
<p>我们简单的分一下类： <code>redo log</code> 可以保证事务的 <code>原子性</code> 和 <code>持久性</code>，<code>undo log</code> 可以保证事务的 <code>一致性</code>，那么剩下的 <code>隔离性</code> 就由我们现在要说的 <code>MVCC</code> 来保证了。</p>
<a id="more"></a>
<p>那么隔离性是个啥，之前说过了，也就是可能出现 <code>脏写</code> <code>脏读</code> <code>幻读</code> <code>不可重复读</code> 等等这些状况。</p>
<p>简单回顾下：</p>
<ul>
<li>脏写：A事务提交的数据是B事务 <code>UPDATE</code> 的值 ，这个无论如何都不允许；</li>
<li>脏读：A事务中读取到了B事务中 <code>UPDATE</code> 的值（B事务未提交）；</li>
<li>不可重复读：A事务中两次读取，第二次读取到B事务已经提交的 <code>UPDATE</code> 的值（注意跟 <code>脏读</code> 的区别）；</li>
<li>幻读：A事务两次读取，第二次读取到B事务中提交的 <code>INSERT</code> 的值，但是如果A事务两次读取，第二次读不到B事务 <code>DELETE</code> 的数据，不属于幻读，幻读强调第二次读取的时候，多了数据；</li>
</ul>
<h2 id="二-MVCC"><a href="#二-MVCC" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><p><code>MVCC</code> 表示 <code>Multi-Version Concurrency Control</code>，<code>多版本并发控制</code>。也就是说在多个事务执行的情况下，可以控制事务读取到的数据版本的问题。</p>
<p>而 <code>MVCC</code> 的关键就在于之前 <code>undo log</code> 所说的 <code>版本链</code> 上。</p>
<h3 id="2-1-版本链"><a href="#2-1-版本链" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103540.jpeg"></p>
<p>之前说过这个图，第一次插入的时候，生成了第一条 <code>undo_insert_rec</code>，而对这个数据行做删除的时候，就会把数据行中的 <code>roll_pointer</code> 打断，连接到删除的 <code>undo log</code> 上，而 <code>undo log</code> 中的 <code>old_roll_pointer</code> 又指向了前一个插入的 <code>undo log</code> 中。</p>
<p>由于上面太乱我重新画张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103541.jpeg"></p>
<p>OK，这是一个产品入库的过程。两个事务对这个条数据发生了更新，假设事务A和事务B（事务A的 <code>trx_id=20</code>，事务B的 <code>trx_id=10</code>）。事务B修改库存为 <code>600</code>，而事务A做了两次修改，第一次是 <code>850</code> 第二次是 <code>1000</code>。所以上图中，比较低层的是旧的数据，比较高层的是新的数据。这个列表串起来就是一条数据的 <code>版本链</code>。</p>
<p>有了这个版本链还不够，还需要一个 <code>ReadView</code> 来辅助查询。</p>
<h3 id="2-2-ReadView"><a href="#2-2-ReadView" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>这个名字也很好理解了：<code>读取视图</code>。他发生在 <code>SELECT</code> 的时候，每次 <code>SELECT</code> 都会从数据表中生成一个 <code>ReadView</code>。</p>
<p><code>ReadView</code> 有几个非常重要的属性：</p>
<ul>
<li><code>m_ids</code>：生成时活跃的读写事务 <code>trx_id</code> 列表；</li>
<li><code>min_trx_id</code>：上面 <code>m_ids</code> 最小的值；</li>
<li><code>max_trx_id</code>：生成时应该分配给下一个事务的 <code>trx_id值</code>；</li>
<li><code>creator_trx_id</code>：当前事务的 <code>trx_id值</code>；</li>
</ul>
<p>那我们要查询上面的某条记录的时候，就需要根据 <code>ReadView</code> 中的那些值与 <code>undo log</code> 或者 <code>数据行</code> 中的 <code>trx_id</code> 比较，来拿到满足条件的最新一条的记录，就是当前事务可以访问到的数据。</p>
<p>怎么判断：</p>
<ol>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 与当前事务 <code>id</code> 相等，也就是与 <code>creator_trx_id</code> 说明这条数据在当前事务发生更改，所以当前事务可以访问；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 小于 <code>min_trx_id</code> 说明这个数据的改动在这个事务之前已经提交，所以可以被访问到；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 大于或等于 <code>max_trx_id</code>，说明该版本在这个事务之后发生的更改，所以这个版本不可见，继续遍历下一个版本；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 介于 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则需要判断事务是否存在于 <code>m_ids</code> 中：<ol>
<li>如果存在，说明创建的时候事务还在活跃中，数据版本不可见；</li>
<li>如果不存在，说明已经提交了，则数据版本可见</li>
</ol>
</li>
</ol>
<p>然后我们知道，数据库有不同的隔离级别，<code>MySQL</code> 有 <code>READ UNCOMMITTED</code> <code>READ COMMITTED</code> <code>REPEATABLE READ</code> <code>SERIALIZABLE</code>：</p>
<p><code>READ UNCOMMITTED</code>：所有遇到的问题情况都允许，所以不用考虑；</p>
<p><code>SERIALIZABLE</code>：所有查询写入均需要串行执行，所以也不用考虑。</p>
<p>那么主要就是 <code>READ COMMITTED</code> <code>REPEATABLE READ</code> 这两个隔离级别通过不同的方式来使用 <code>ReadView</code>。<code>READ COMMITTED</code> 是在每一次 <code>SELECT</code> 的时候生成 <code>ReadView</code>，而 <code>REPEATABLE READ</code> 则是在每次事务开始的时候生成的。</p>
<h3 id="2-3-查询示例"><a href="#2-3-查询示例" class="headerlink" title="2.3 查询示例"></a>2.3 查询示例</h3><p>来举个栗子吧，我们假设当前的隔离级别是 <code>READ COMMITTED</code>：</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">事务A(trx=1)</th>
<th align="center">事务B(trx=2)</th>
<th align="center">事务C(trx=3)</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>BEGIN;INSERT INTO(1, 1, 0);COMMIT;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>BEGIN;</code> <code>trx=4</code></td>
<td align="center"><code>UPDATE quantity = 100</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"><code>UPDATE quantity = 200</code></td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"><code>UPDATE quantity = 300</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>200</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>300</code></td>
</tr>
</tbody></table>
<p>分步骤来说：</p>
<ol>
<li>第 <code>1</code> 步，<code>事务A</code> 开启一个事务插入一条数据，这时候 <code>数据行的 trx_id = 1</code>；</li>
<li>第 <code>2</code> 步，<code>事务B</code> 和 <code>事务C</code> 分别开启事务，准备对这条数据蠢蠢欲动；</li>
<li>第 <code>3</code> 步：<ul>
<li><code>事务A</code> 又开启一个事务，分配了 <code>trx_id =  4</code>；</li>
<li>同时 <code>事务B</code> 更新了数量 <code>100</code>；</li>
</ul>
</li>
<li>第 <code>4</code> 步：<ul>
<li><code>事务B</code> 又更新了数量 <code>200</code>；</li>
</ul>
</li>
<li>第 <code>5</code> 步：<code>事务C</code> 也更新了数量 <code>300</code>，<code>事务A</code> 查询了数量，这时候 <strong>结果是</strong> <code>0</code>；</li>
<li>第 <code>6</code> 步：<code>事务B</code> 进行了提交；</li>
<li>第 <code>7</code> 步：<code>事务A</code> 查询了数量，<strong>结果是</strong> <code>200</code>；</li>
<li>第 <code>8</code> 步：<code>事务C</code> 提交；</li>
<li>第 <code>9</code> 步：<code>事务A</code> 查询数量，<strong>结果是</strong> <code>300</code>。</li>
</ol>
<p>那接下来讨论的就是上面的步骤中，<code>三次查询</code> 的结果：</p>
<p>第一次，发生在第 <code>5</code> 步：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103543.jpeg"></p>
<p><code>事务A</code> 查询的时候创建了 <code>ReadView</code>，这时候根据上面的判断，迭代目前的数据版本：</p>
<p>我们看看第一个结果 <code>0</code>，发生在 <code>第 5 步</code>：</p>
<ol>
<li><p>第一条数据：</p>
<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li><p>第二条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第三条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第四条数据</p>
<p><code>trx_id = 1</code> 明显小于 <code>min_trx_id</code>，所以这条数据可以被 <code>事务A</code> 访问，返回数据 <code>0</code>。</p>
</li>
</ol>
<p>接下来看看第二个结果 <code>200</code>，发生在 <code>第 7 步</code>，这时候，<code>事务B</code> 已经提交了，所以 <code>ReadView</code> 的情况就是下面这种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103547.jpeg"></p>
<ol>
<li>第一条数据：<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li>第二条数据：<ol>
<li><code>trx_id = 2</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以返回这条数据，所以查询到的 <code>quantity = 200</code></li>
</ol>
</li>
</ol>
<p>然后，随着 <code>事务C</code> 也提交了，这时候系统中没有正在运行的事务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103542.jpeg"></p>
<p>那么第一条数据做第一个判断的时候，发现当前已经没有事务在运行了，所以这条记录是这个事务之前提交的，就会被访问到，直接返回 <code>300</code>。</p>
<p><strong>所以需要注意的是： <code>READ COMMITTED</code> 每次查询都会生成一个新的 <code>ReadView</code> 所以就发生了 <code>不可重复读</code>。</strong></p>
<p>那如果是 <code>REPEATABLE READ</code> ，他会在查询的时候就根据目前事务的情况创建 <code>ReadView</code> 了，也就是说，查询的时候，创建 <code>ReadView</code>，然后三次查询，都使用下图这个 <code>ReadView</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103543.jpeg"></p>
<p>所以在这个事务结束之前，每次查询的结果，都只能拿到 <code>quantity = 0</code> 这条数据。</p>
<p>那之前我们说过，这个级别 <code>InnoDB</code> 实际上已经解决了幻读的问题，也是因为这个 <code>ReadView</code> 的原因，思考下，创建 <code>ReadView</code> 的时候，查询过程中就已经被限制返回为 <code>NULL</code> 了，所以没有 <code>幻读</code> 问题。</p>
<h2 id="三-更新数据时undo-log的清理"><a href="#三-更新数据时undo-log的清理" class="headerlink" title="三.更新数据时undo_log的清理"></a>三.更新数据时undo_log的清理</h2><p>那么 <code>undo log</code> 的日志会越堆积越多，总不能没有被清理的时候把。这个时间点就要把握在，接下来所有事务 <code>都不需要</code> 再访问这个 <code>undo log</code> 版本的时候，后台线程会清理掉。大概什么时候，就是 <code>UPDATE</code> 提交以后，后面的事务已经一致返回的是比当前这个 <code>UPDATE</code> 数据还要新的数据的时候，就已经可以清理掉了。</p>
<h2 id="四-小小结"><a href="#四-小小结" class="headerlink" title="四.小小结"></a>四.小小结</h2><p>通过 <code>版本并发控制管理MVCC</code> 来隔离数据。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】六.MySQL-InnoDB的数据库事务背景_BufferPool</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AD-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E8%83%8C%E6%99%AF-bufferpool/index.html</url>
    <content><![CDATA[<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览"><a href="#一-BufferPool总览" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<a id="more"></a>
<h2 id="二-BufferPool查询数据的作用"><a href="#二-BufferPool查询数据的作用" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用"><a href="#三-BufferPool更改数据的作用" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li> 数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li> <code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li> 在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li> 开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103507.png"> </p>
<p>图片来源：<a href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成"><a href="#四-BufferPool内部组成" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表"><a href="#4-1-BufferPool数据页链表" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103506.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103508.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103504.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表"><a href="#4-2-BufferPool-的-free-数据缓存链表" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103505.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure>
<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103502.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li> 线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li> 随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>  全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表"><a href="#4-4-BufferPool-的-flush-链表" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li> 后台线程轮询到的时候；</li>
<li> 查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例"><a href="#五-配置多个BufferPool实例" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>
<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控"><a href="#六-BufferPool状态监控" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>
<h2 id="七-配置BufferPool"><a href="#七-配置BufferPool" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置"><a href="#7-1-总大小配置" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size = 3298295808</span><br></pre></td></tr></table></figure>
<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置"><a href="#7-2-预读配置" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">innodb_read_ahead_threshold=56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead=off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>
<h3 id="7-3-LRU配置"><a href="#7-3-LRU配置" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct = 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time=1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>
<h2 id="八-完结"><a href="#八-完结" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】十一.MySQL-InnoDB的数据库事务锁</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81%E4%B8%80-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%94%81/index.html</url>
    <content><![CDATA[<h2 id="一-InnoDB锁"><a href="#一-InnoDB锁" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<a id="more"></a>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写"><a href="#1-1-写写" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103550.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103551.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103603.jpeg"></p>
<h3 id="1-2-读和写"><a href="#1-2-读和写" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; <span class="operator">/</span><span class="operator">/</span> 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;<span class="operator">/</span><span class="operator">/</span> 共享锁</span><br></pre></td></tr></table></figure>
<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型"><a href="#二-锁的类型" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁"><a href="#2-1-行级锁" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁"><a href="#2-2-表级锁" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁"><a href="#2-3-特殊的锁–AUTO-INC锁" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁"><a href="#三-深入行级锁" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks"><a href="#3-1-Record-Locks" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103607.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103558.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103601.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁"><a href="#3-2-GAP锁" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103554.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity <span class="operator">&lt;</span> <span class="number">200</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>
<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks："><a href="#3-3-Next-Key-Locks：" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁"><a href="#3-4-Insert-Intention-Locks-插入意向锁" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103555.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁"><a href="#3-5-隐形的锁" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构"><a href="#四-锁结构" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103556.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线"><a href="#五-手动分割线" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁"><a href="#六-SELECT语句加锁" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	id <span class="type">BIGINT</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">	prod_id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	quantity <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="keyword">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="keyword">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="keyword">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="keyword">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="keyword">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="keyword">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="6-1-普通读"><a href="#6-1-普通读" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103602.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读"><a href="#6-2-等值锁定读" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103548.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity <span class="operator">=</span> <span class="number">200</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id <span class="operator">=</span> <span class="number">99</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103552.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103604.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103605.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读"><a href="#6-3-范围锁定读" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读"><a href="#6-4-全表扫描读" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读"><a href="#6-5-等值锁定读" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103559.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103600.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读"><a href="#6-6-范围锁定读" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103553.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描"><a href="#6-7-全表扫描" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况"><a href="#七-INSERT的情况" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103555.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁"><a href="#七-死锁" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁"><a href="#7-1-普通资源锁" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103557.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁"><a href="#7-2-插入GAP锁" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁"><a href="#7-3-更新索引锁" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【聊聊MySQL】四.MySQL-InnoDB表索引和B+树</title>
    <url>//mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%9B%9B-mysql-innodb%E8%A1%A8%E7%B4%A2%E5%BC%95%E5%92%8Cb%E6%A0%91/index.html</url>
    <content><![CDATA[<h2 id="一-InnoDB表数据"><a href="#一-InnoDB表数据" class="headerlink" title="一.InnoDB表数据"></a>一.InnoDB表数据</h2><p>上面聊了这么多这个结构，那个结构的。现在是不是有点好奇，<code>InnoDB</code> 是把数据存在哪里的。答案也很简单，存在一颗 <code>B+</code> 树种。</p>
<p>在 <code>InnoDB</code> 中，数据所在的位置没有其他地方，就只有一颗 <code>B+</code> 树。而我们自己建立的索引，也是一颗 <code>B+</code> 树。存储完整数据的 <code>B+</code> 树也叫 <code>聚簇索引</code>，而我们自定义的列索引的 <code>B+</code> 树，则称为 <code>非聚簇索引</code>。</p>
<p>OK，大概明白了这两个东西以后，我们一个一个拆开来说说。</p>
<a id="more"></a>
<h2 id="二-B-树是什么"><a href="#二-B-树是什么" class="headerlink" title="二.B+树是什么"></a>二.B+树是什么</h2><p>关乎数据结构的东西了，如果觉得很简单，或者说已经学过脑袋有印象，可以跳过这段一个非计算机老男人写的废话。</p>
<p>说 <code>B+</code> 树，一切要从一个最简单的例子开始，就是二分查找法。</p>
<h3 id="2-1-二分查找法"><a href="#2-1-二分查找法" class="headerlink" title="2.1 二分查找法"></a>2.1 二分查找法</h3><p>我们在聚合的时候，估计都玩过一个游戏，叫做大冒险。确定谁来大冒险，有个方式就是猜数字：由上一轮中的倒霉鬼，来确定一个数字，然后围成一圈的小伙伴们来猜。猜中了，就是下一个倒霉鬼。</p>
<p>那怎么猜的呢，这个倒霉鬼在手机上输入一个数字，盖在地上防止修改。然后从一圈中某个人开始，说一个数字，那么那个站在台上的倒霉蛋就会缩小范围，让下一个人继续猜：</p>
<p>比如数字是69。</p>
<p>那么就有下面的对话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A: 50</span><br><span class="line">倒霉：50 - 100</span><br><span class="line">B：75</span><br><span class="line">倒霉：50 - 75</span><br><span class="line">C：69</span><br><span class="line">倒霉：恭喜你答对了balabala</span><br></pre></td></tr></table></figure>
<p>这个过程咧，有没有很熟悉，对，就是 <code>二分查找法</code>。</p>
<hr>
<p>那为啥使用二分查找法呢，肯定是因为性能好啊。</p>
<p>那比如我有个 <strong>有序</strong> 数组：<code>[18, 53, 55, 147, 151, 495, 551, 606, 638, 728]</code>。</p>
<p>我一次查询每一个数字，平均次数是 <code>(1+2+3+4+5+6+7+8+9+10)/10 = 5.5次</code>，而使用二分查找法则是 <code>4+3+2+4+3+1+4+3+2+3)/10 = 2.9次</code>。顺序查找最坏的情况也要 <code>10</code> 次，而二分查找最坏是 <code>4</code> 次。这么好的查找效率没有理由不用他。</p>
<h3 id="2-2-二叉查找树"><a href="#2-2-二叉查找树" class="headerlink" title="2.2 二叉查找树"></a>2.2 二叉查找树</h3><p>那二分查找和树什么关系，这里就要说到 <code>二叉查找树</code>，根据百度百科的定义：</p>
<blockquote>
<p>一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>：</p>
<p>（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>（3）左、右子树也分别为二叉排序树；</p>
<p>（4）没有键值相等的结点。</p>
</blockquote>
<p>那么我现在把上面的数组转换成 <code>二叉查找树</code>，并且给予一个查找的动图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103736.gif"></p>
<p>查询看起来是很方便，但是对数据的增删查改就不是这样的了。有时候，数据插入多了，如果不调整可能会所有都放在了左边或者右边，这样性能就会越来越接近顺序查找。那么，数学家就提出了 <code>平衡二叉树</code> 和 <code>最优二叉树</code> 的定义。</p>
<h3 id="2-3-平衡二叉树"><a href="#2-3-平衡二叉树" class="headerlink" title="2.3 平衡二叉树"></a>2.3 平衡二叉树</h3><p>平衡二叉树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1。这样子就可以让树变得矮胖矮胖的好身材，至于为啥矮胖矮胖才是好身材，因为这样子的话，查询效率才高啊。</p>
<p>比如下面这颗，查找大于 <code>495</code> 的时候，简直就是线性查找的效率了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103755.png" alt="image-20200113155115465"></p>
<p>那长得丑怎么办，整容（旋转跳跃我闭着眼）啊，不过需要钱（性能）。</p>
<p>那我现在就按照 <code>二叉查找树</code> 那一颗，来插入一个 <code>999</code>，平衡二叉树是在增删改的时候通过旋转来平衡树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103717.gif"></p>
<p>那么有长得帅的读者就要问了，这个跟 <code>B+树</code> 是什么关系。</p>
<h3 id="2-4-B-树"><a href="#2-4-B-树" class="headerlink" title="2.4 B+树"></a>2.4 B+树</h3><p>因为 <code>B+树</code> 跟上面的思想差不多，所以，现在就来说说 <code>B+树</code>。</p>
<p><code>B+树</code> 她不是二叉树，但是查询跟 <code>二叉树</code> 差不多，我先放一颗 <code>B+树</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103749.jpeg"></p>
<p>这是一颗高度为 <code>2</code> 扇出为 <code>5</code> 的 <code>B+树</code>。</p>
<p>那这个怎么实现查找的呢，现在比方说我要查找 <code>606</code> 这条数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103639.gif"></p>
<p>那么 <code>B+树</code> 是怎么实现新增，然后平衡的呢，跟上面一样发生旋转。旋转的规则如下：</p>
<p>叶子节点是第二层的数据，索引节点是第一层查找时用到的数据。那旋转的情况就是节点页有没有满了：</p>
<table>
<thead>
<tr>
<th align="center">叶子节点</th>
<th align="center">索引节点</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">×</td>
<td align="center">×</td>
<td>直接插入</td>
</tr>
<tr>
<td align="center">√</td>
<td align="center">×</td>
<td>1. 拆分叶子节点；<br/>2. 中间节点值存入索引节点；<br/>3. 小于中间节点的数据放左叶子，大于或等于放入右叶子。</td>
</tr>
<tr>
<td align="center">√</td>
<td align="center">√</td>
<td>1. 按照上面情况拆分叶子节点；<br/>2. 然后根据相同的操作再拆分索引节点</td>
</tr>
</tbody></table>
<p>第一种就不用演示了，比如新增 <code>1000</code> 直接存入最后边的叶子节点就好了。</p>
<p>接下来我演示第二种，那我就插入 <code>645</code> 这个数字吧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103652.gif"></p>
<p>可以从图中看到，拆分页是多么耗性能的一个东西了，所以我们经常说顺序插入是最好的性能，也要求主键一般呈递增的状态。</p>
<blockquote>
<p>但是当左右兄弟节点可能没有满的时候，InnoDB不会急着去拆分数据页，而是会通过旋转的方式来让树达到平衡。这里就不说了。</p>
</blockquote>
<p>那如果是第三种情况呢，拆分索引页跟拆分数据页是同样的道理，我就不画出来了，只要知道如果是第三种，性能还要比第二种低一倍，因为不仅拆分数据页，还拆分索引页了。</p>
<p>那如果页中有记录被删除呢，怎么去平衡，这时候就有一个东西叫做 <code>计算因子</code>，如果删除后的页的记录数量小于 <code>计算因子*总页数</code> 的时候，<code>B+</code> 树会去做 <code>合并操作</code>。那我就继续用这一组数据来做示例。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103714.jpeg"></p>
<p>删除 <code>606</code> <code>638</code> 以后，<code>B+</code> 树就会变成下面这个样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103748.jpeg"></p>
<p>所以说，<code>B+</code> 树在发生了修改以后，为了保证查询效率，会对某个一部分的节点进行整容。</p>
<h2 id="三-InnoDB是怎么用B-树"><a href="#三-InnoDB是怎么用B-树" class="headerlink" title="三.InnoDB是怎么用B+树"></a>三.InnoDB是怎么用B+树</h2><p>好，结合上一篇的 <code>InnoDB表结构</code> 中的页和数据行的结构，以及刚刚所说的 <code>B+树</code>，现在我们就可以来看看一个表中的数据，是怎样被存储以及怎样被查询的。</p>
<p>从之前我们知道，数据是按照数据页的方式进行存放的，而数据页里面除了记录我们的用户记录行意外，还有一些额外的属性用来表示这一页的类型（所以数据页不仅仅是存放数据的页，也可能是 <code>undo页</code> 等等），而数据行里面也有一些额外的属性来辅助查找。</p>
<h3 id="3-1-查找数据所在的页"><a href="#3-1-查找数据所在的页" class="headerlink" title="3.1 查找数据所在的页"></a>3.1 查找数据所在的页</h3><p>之前已经系统的列举过 <code>数据页</code> 和 <code>数据行</code> 的所有属性，现在我就挑在索引中需要用到的属性放在图中就可以了，放上其他的没什么用处，也占用地方。</p>
<p>那我现在就假设，上一节中的叶子节点中的数据（如下图），就是我们一条记录的主键 <code>id</code>，因为我们的记录肯定不止有主键这么简单，所以应该还有其他数据，我暂时使用一些占位的方框做代替。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103753.jpeg"></p>
<p>那么这时候上面在数据在 <code>MySQL</code> 数据页中的结构，应该是这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103636.jpeg"></p>
<p>叶子节点之间的关系，记录类型中：<code>2</code> 表示最小记录，<code>3</code> 表示最大记录，<code>0</code> 表示用户记录。那如果这棵树没有非叶子节点的话，搜索就是线性的需要一个一个遍历，这时候怎么办咧，<code>B+树</code> 的结构就出现了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103637.jpeg"></p>
<p>这个结构，就是上面 <code>B+树</code> 在 <code>InnoDB</code> 中数据页的结构了。</p>
<h3 id="3-2-查找真实数据"><a href="#3-2-查找真实数据" class="headerlink" title="3.2 查找真实数据"></a>3.2 查找真实数据</h3><p>那么，上面我演示的一个页有三个记录，但其实不止三个记录，我就假设一个页有 <code>16</code> 条记录（其实不止，根据数据的大小）吧。那通过索引只能找到这一页呀，难道要一个一个遍历查询相对应的数据，这时候使用遍历还是有点早了（毕竟遍历并没有那么高效），所以在每个数据页中，又使用了一个槽进行分区。</p>
<p>那现在把镜头切换到一个页中来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103754.jpeg"></p>
<p><code>InnoDB</code> 会把一个页中的所有数据根据一个很小的基数，比如 <code>4</code> 个记录为一组，去划分分组。那么每个组在数据页中都有对应的槽来记录分组的最大值。</p>
<p>那按照上面的数据，比如我要查询 <code>55</code>。</p>
<p><code>槽0</code> = 18，<code>槽1</code> = 54，<code>槽2</code> = 64，<code>槽3</code> = 77。</p>
<p>怎么找呢，类似于上面那个二分查找的游戏，<code>槽0</code> 说 <code>18</code>，老大说 <code>18-77</code> 之间，<code>槽1</code> 说 <code>54</code>，老大说 <code>54-77</code>，直到最后，确定数字是在 <code>槽1</code> 和 <code>槽2</code> 之间，因为 <code>槽2 = 64</code> 大于 <code>55</code>，而 <code>槽1 = 54</code> 小于 <code>55</code>。所以从 <code>槽1</code> 的最大值 <code>54</code> 开始寻找下一条记录，遍历分组里面的数据行（因为这时候需要遍历的长度已经被切到很小了，所以是时候用遍历来做了，因为用其他算法的次数跟遍历差不多），取出 <code>55</code> 这条数据。</p>
<p>那整个查询过程中，需要跟硬盘交互的并不多，我们知道，<code>InnoDB</code> 是通过数据页来进行硬盘与内存的沟通的，查找效率高就意味着，我需要从硬盘取数据的次数越少。</p>
<h3 id="3-3-删除记录"><a href="#3-3-删除记录" class="headerlink" title="3.3 删除记录"></a>3.3 删除记录</h3><p>删除记录时，<code>InnoDB</code> 是怎么做的，就是在之前提到的数据行的头信息的 <code>delete_flag</code> 设置为 <code>1</code>，这条记录就会被放入 <code>垃圾链表</code>，当又需要插入新数据的时候，会判断是否合适放在这个位置，再把原来的数据给覆盖掉。</p>
<p>为什么这么做无非就是减少 <code>硬盘IO</code>。如果真的删除的话，需要去同步硬盘，这个过程并不是很重要，所以先标记就好了。</p>
<p>然后这条记录的上一条记录的 <code>next_record</code> 字段将被重新指向当前删除记录的下一条记录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103756.gif"></p>
<h2 id="四-聚簇索引"><a href="#四-聚簇索引" class="headerlink" title="四.聚簇索引"></a>四.聚簇索引</h2><p>那聚簇索引是什么，其实看了上面的图，加点料就可以了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103750.jpeg"></p>
<p>其实上面的例子我使用的是 <code>id</code> 来做例子，但是每条记录还带有其他所有列的信息（非 <code>NULL</code>）的，如果有 <code>NULL</code> 则会被记录在记录头信息，然后节省了存储数据的空间。</p>
<p>而这种索引，叫做 <code>聚簇索引</code>，意思是什么咧，就是一条记录保存了完整的数据信息，非聚簇则不是。而每条数据都会有一个 <code>primary key</code>，如果没有，<code>InnoDB</code> 会自动加上这个隐藏的列。这也是 <code>MySQL_InnoDB</code> 结构的库保存数据的方式。</p>
<p>所以可以这么说，<code>InnoDB</code> 就是 <code>B+树</code> 构成的。而根节点从建立表开始将会被记录，之后每次查询都会从这个根节点开始查询。</p>
<h2 id="五-非聚簇索引"><a href="#五-非聚簇索引" class="headerlink" title="五.非聚簇索引"></a>五.非聚簇索引</h2><h3 id="5-1-简单非聚簇索引"><a href="#5-1-简单非聚簇索引" class="headerlink" title="5.1 简单非聚簇索引"></a>5.1 简单非聚簇索引</h3><p>那 <code>非聚簇索引</code> 和 <code>聚簇索引</code> 有什么区别，区别在于 <code>非聚簇索引</code> 并没有存放整条记录的所有数据，只是存放了 <code>索引列</code> 和 <code>主键</code> 而已。所以当我们通过 <code>非聚簇索引</code> 查询一条数据行的所有列的时候，就需要 <code>回表</code> 去查询其他列的信息了，也就是说需要 <code>两次查询</code> 才完成这个需求。</p>
<p>比方一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> trbac_user (</span><br><span class="line">  id <span class="type">BIGINT</span> auto_increase,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  mobile <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>那我使用 <code>name</code> 来做非聚簇索引，这时候 <code>InnoDB</code> 就有一颗以 <code>name</code> 来查询的 <code>B+树</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103751.jpeg"></p>
<p>那我们可以看到，数据行并没有覆盖所有数据，只有 <code>name</code> + <code>id</code>。那比如我们只是查询 <code>name</code> 或者 <code>id</code> 列，就可以直接在这里返回去了。</p>
<p>但是如果我还想要知道 <code>mobile</code> 列的话，这时候就需要在上面那棵树拿到 <code>id</code>，然后再去 <code>id</code> 那棵树查询其他的列信息。</p>
<p>需要从下面的主键的数据页来查询其他数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103651.jpeg"></p>
<p>那这里有个什么经验呢…就是我们可以根据经常使用常用的列来建立索引，先拿到 <code>id</code>，然后再去缓存命中，再走数据库~</p>
<p>单列聚簇索引还有个需要注意的点，就是这个列的辨识度要搞，如果这个列只有 <code>MAN</code> 和 <code>WOMAN</code> 的话，为这个列建立索引根本就没有什么用处，因为跟全表扫描一样的效率，优化器更偏向于全表扫描，所以切记不要给列值只有寥寥几个的列建立索引，纯属浪费。</p>
<h3 id="5-2-多列非聚簇索引"><a href="#5-2-多列非聚簇索引" class="headerlink" title="5.2 多列非聚簇索引"></a>5.2 多列非聚簇索引</h3><p>如果是 <code>name</code> + <code>mobile</code> 联合索引的话，需要注意的点就有点多了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20231205103716.jpeg"></p>
<p>每个数据页的排序就会变成，先按照 <code>name</code> 进行排序，然后再按照 <code>mobile</code> 进行排序。</p>
<h3 id="5-4-什么时候不会使用索引"><a href="#5-4-什么时候不会使用索引" class="headerlink" title="5.4 什么时候不会使用索引"></a>5.4 什么时候不会使用索引</h3><p><strong>1.不满足最左匹配</strong></p>
<p>我想大家都听过 <code>最左匹配原则</code>，就是这个意思，因为我的索引是先根据 <code>name</code> 排序再根据 <code>mobile</code> 进行排序的。那么查询的时候，如果加上 <code>order by</code> 的话，这个排序同样也是派上用场的。</p>
<p>但是如果说查询条件只是写了 <code>WHERE mobile = &#39;13800x1&#39;</code>，那上面的索引就完全派不上用场。</p>
<p>怎么说，因为我这个索引是结合了 <code>name</code> 先做排序然后索引的，你只是查询 <code>mobile</code> 的话，就需要遍历整个索引，拿到 <code>id</code> 后还需要回表，这个过程跟直接扫描 <code>聚簇索引</code> 相比，耗费的资源更多，所以，如果一个 <code>name</code> + <code>mobile</code> 的索引，只应用于带有 <code>name</code> 开始的查询条件。因为 <code>name</code> 在前面。这就是 <code>最左匹配原则</code>。</p>
<p><strong>2.排序一个列使用升序一个使用降序</strong></p>
<p>比如 <code>WHERE name like &#39;xxx%&#39; ORDER BY name DESC,mobile ASC</code>，这样的情况只能用到 <code>name</code> 列的索引（也就是所有 <code>mobile</code> 失去了效果），然后再把所有列重新整理，依据 <code>mobile</code> 重新排序。</p>
<p>如果两个都是同一个方向的排序就不会出现这种情况。</p>
<p><strong>3.<code>VARCHAR</code> 匹配前缀查询</strong></p>
<p><code>WHERE name like &#39;%狗蛋&#39;</code> 这种情况为什么不能使用索引呢，因为你前面未知啊，根据 <code>name</code> 排序的索引查询跟全表扫描有什么区别，还少了 <code>回表</code> 的操作，所以只能全表扫描，取出满足 <code>xxx狗蛋</code> 的数据了。</p>
<p><strong>4.排序用到索引中没有的列</strong></p>
<p>这个理解了 <strong>区别在于 <code>非聚簇索引</code> 并没有存放整条记录的所有数据，只是存放了 <code>索引列</code> 和 <code>主键</code> 而已</strong> 这句话，就知道为什么了，因为索引中的排序并不适合 <code>SQL</code> 指定的顺序。</p>
<p><strong>5.使用函数修饰值的时候</strong></p>
<p>比如 <code>WHERE LOWER(name) = &#39;aa&#39;</code>，每个列都需要通过函数调用，那就跟全表扫描没什么区别了。</p>
<hr>
<p>那如果 <code>SQL</code> 语句中，条件出现的顺序没有和多列索引的顺序一致的话，会怎么样：</p>
<p>完全不必担心这个问题，因为 <code>SQL</code> 在执行之前还会交给一个叫做 <code>优化器</code> 的东西进行整理，下面会说到，现在就只要知道他会把 <code>SQL</code> 条件整理成跟索引一样的顺序就好了。</p>
<p>既然多列索引可以帮忙查询条件中满足最左匹配的 <code>SQL</code> 语句，是不是越多越好，答案并不是，我觉得应该根据权重来区分，因为 <code>非聚簇索引</code> 他的索引列并不会像自增 <code>ID</code> 的索引树一样，顺序的插入数据（历史原因导致我们项目使用 <code>UUID</code> 做主键的哭晕在厕所），而是经常的造成 <code>页拆分</code>（也就是上面拆分的动图），所以 <code>非聚簇索引</code> 多了，<code>增删改</code> 需要维护这棵树平衡所做的 <code>整容</code> 就越多，严重的话会影响 <code>增删改</code> 的效率。</p>
<hr>
<h3 id="5-5-什么时候命中索引"><a href="#5-5-什么时候命中索引" class="headerlink" title="5.5 什么时候命中索引"></a>5.5 什么时候命中索引</h3><p>那什么时候用到了索引，自然就是避免上面的情况就可以了，就有这些情况，包括但不局限于：</p>
<ol>
<li>条件覆盖了索引的最左列；</li>
<li>常量查询，<code>WHERE name = &#39;xxx&#39;</code> ；</li>
<li>范围查询，满足 <code>1</code> 的情况下，比如 <code>name &gt; &#39;AA&#39;</code> 或者 <code>name = &#39;AA&#39; AND mobile &gt; &#39;13800&#39;</code>;</li>
<li>排序，但是需要用到的排序列是同一个方向进行排序的。</li>
<li>分组，依然需要满足 <code>1</code> 条件，如果用到了 <code>group by name</code>，<code>InnoDB</code> 会先将相同的 <code>name</code> 放在一起，然后再继续根据其他条件进行运算。</li>
</ol>
<h3 id="5-6-回表代价"><a href="#5-6-回表代价" class="headerlink" title="5.6 回表代价"></a>5.6 回表代价</h3><p>可以这么说，如果回表的代价过高，<code>InnoDB解析器</code> 可能直接决定，不要使用索引，直接全表扫描。</p>
<p>怎么回事，就是 <code>非聚簇</code> 索引他的值都是连在一起的，查询的时候，称为 <code>顺序I/O</code>，而 <code>非聚簇索引</code> 查询出来的 <code>id</code> 并不会连在一起，所以回表去查询 <code>id</code> 数据的时候，称为 <code>随机I/O</code>。而 <code>随机I/O</code> 的效率是很低的，所以当命中索引的数据行总是较多的时候，不如 <code>全表扫描</code> 来的快，所以可能出现 <code>SQL</code> 已经完全命中这个索引但是解析器他就是不使用。</p>
<p>怎么防止这种情况发生，就是让查询索引返回的数量少，比如我们可以 <code>LIMIT 100</code> 去限定只查询 <code>100</code> 条数据，或者我们只要查询索引中出现的列，比如 <code>id</code> 然后再在程序中，根据 <code>id</code> 列表去命中缓存，名不中的再一次性批量查库就可以了。</p>
<h3 id="5-7-文件排序"><a href="#5-7-文件排序" class="headerlink" title="5.7 文件排序"></a>5.7 文件排序</h3><p>有时候我们去解析 <code>EXPLAIN</code> 我们的 <code>SQL</code> 语句的时候，会出现 <code>File Sort</code> 类型，这个类型指的是，查询出来的结果不是按照我们 <code>SQL</code> 指定的顺序来的，所以需要在内存中（必要时借助硬盘）来重新对数据进行排序，这个过程就是 <code>File Sort</code>，那如何避免这个类型出现，那就是防止上面不命中索引的情况。</p>
<h3 id="5-8-索引合并"><a href="#5-8-索引合并" class="headerlink" title="5.8 索引合并"></a>5.8 索引合并</h3><p><strong>使用等值且命中两个索引的列</strong></p>
<p>比方说我的用户表有 <code>name</code> 索引 和 <code>mobile</code> 索引，那这个条件 <code>WHERE name = &#39;Weidan&#39; AND mobile = &#39;18588777777&#39;</code> 就可以使用两个索引，然后取 <code>id</code> 的 <strong>交集</strong>，然后回表查询。但是如果 <code>name &gt; &#39;Weidan&#39;</code> 这种条件，就不会使用到合并。</p>
<p>但是但是，如果是主键列是范围的话，是可以的，因为他们合并的时候也会操作主键嘛。</p>
<p>不过有没有使用到，还要看成本，如果一个索引命中的数据太多，依然不会使用合并索引。</p>
<p><strong>合并两个索引的列</strong></p>
<p>依然需要满足 <strong>列都是等值查询</strong> 这个条件，比如 <code>WHERE name = &#39;Weidan&#39; OR mobile = &#39;18588777777&#39;</code>，会合并两个主键再统一回表查询。</p>
<p><strong>范围搜索合并查询</strong></p>
<p>不过如果我们是范围查询，又想使用两个索引怎么办，我们可以把 <code>name &gt; &#39;Weidan&#39;</code> 以及 <code>monile &gt; &#39;18588777777&#39;</code> 先查询出来 <code>id</code> 然后 <code>union</code> 在一起，再通过 <code>id</code> 去寻找我们想要的数据。</p>
<p>但是还是建议把需要合并的列作为一个 <code>非聚簇</code> 索引来覆盖，效率要高。</p>
<h2 id="七-表连接查询"><a href="#七-表连接查询" class="headerlink" title="七.表连接查询"></a>七.表连接查询</h2><p>首先就以最经典的学生、成绩来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;狗蛋&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;狗剩&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;翠花&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">scope</span>`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">scope</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `subject` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="keyword">scope</span>` <span class="type">int</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `stu_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">scope</span>` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="number">80</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">scope</span>` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="number">98</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">scope</span>` <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="number">59</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">scope</span>` <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">&#x27;政治&#x27;</span>, <span class="number">79</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-1-连表查询"><a href="#7-1-连表查询" class="headerlink" title="7.1 连表查询"></a>7.1 连表查询</h3><p>那么先列举一个连表很普通的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student, <span class="keyword">scope</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----+---------+-------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> id <span class="operator">|</span> subject <span class="operator">|</span> <span class="keyword">scope</span> <span class="operator">|</span> stu_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----+---------+-------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗蛋   <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 语文    <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 狗剩   <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 语文    <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 翠花   <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 语文    <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗蛋   <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 数学    <span class="operator">|</span>    <span class="number">98</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 狗剩   <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 数学    <span class="operator">|</span>    <span class="number">98</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 翠花   <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 数学    <span class="operator">|</span>    <span class="number">98</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗蛋   <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 英语    <span class="operator">|</span>    <span class="number">59</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 狗剩   <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 英语    <span class="operator">|</span>    <span class="number">59</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 翠花   <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 英语    <span class="operator">|</span>    <span class="number">59</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗蛋   <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 政治    <span class="operator">|</span>    <span class="number">79</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 狗剩   <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 政治    <span class="operator">|</span>    <span class="number">79</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 翠花   <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 政治    <span class="operator">|</span>    <span class="number">79</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----+---------+-------+--------+</span></span><br><span class="line"><span class="number">12</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>可以看到，如果我们不加任何条件，直接就连接两张表的话，取出来的结果就是第一张表所有的数据，去搭配第二张表所有的数据，也就是第一张表有 <code>3</code> 条数据，第二张表有 <code>4</code> 条记录，结果就有 <code>3 ✖ 4 = 12</code> 条记录。这个过程也称为 <code>笛卡尔积</code>。这种情况在日常编程中应该也没人会这么写的吧，仔细想想，如果两张表都是百万级别的数据，笛卡尔积是多恐怖的一件事情。</p>
<h3 id="7-2-内连接"><a href="#7-2-内连接" class="headerlink" title="7.2 内连接"></a>7.2 内连接</h3><p>就是由于上面的结果集一般我们都不需要，所以我们会加上一些条件加以限制：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stu.<span class="operator">*</span>, scp.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student stu, <span class="keyword">scope</span> scp</span><br><span class="line"><span class="keyword">WHERE</span> stu.id <span class="operator">=</span> scp.stu_id;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----+---------+-------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> id <span class="operator">|</span> subject <span class="operator">|</span> <span class="keyword">scope</span> <span class="operator">|</span> stu_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----+---------+-------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗蛋   <span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 语文    <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗蛋   <span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 数学    <span class="operator">|</span>    <span class="number">98</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 狗剩   <span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 英语    <span class="operator">|</span>    <span class="number">59</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 狗剩   <span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> 政治    <span class="operator">|</span>    <span class="number">79</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+----+---------+-------+--------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>这就是我们想要的结果集，所有参考学生的考试成绩。</p>
<p>而 <code>InnoDB</code> 是怎样的实现两个表连接的呢，这时候，优化器会根据查询成本确定 <code>驱动表</code> 和 <code>被驱动表</code>。</p>
<ul>
<li><p>驱动表：先查询的那个表，这里假设是 <code>student</code> 表，所以执行的时候，第一步执行 <code>SELECT * FROM student;</code>；</p>
</li>
<li><p>被驱动表：查询出来驱动表所有的数据以后，就会根据驱动表中每一条数据，去执行被驱动表。</p>
<ul>
<li>比如我现在 <code>student</code> 有三条记录，分别 <code>id</code> 是 <code>1</code> <code>2</code> <code>3</code>；</li>
<li>然后对三条记录分别执行 <code>SELECT * FROM scope WHERE stu_id = ?</code>；</li>
<li>因为 <code>scope</code> 表中不存在 <code>翠花</code> 的成绩，所以 <code>SELECT * FROM scope WHERE stu_id = 3</code> 并没有展示出来，因为这个语句相当于 <code>SELECT * FROM scope WHERE stu_id NOT NULL AND stu_id = 3</code></li>
</ul>
</li>
</ul>
<p>那如果上面的语句加上其他条件会怎么样，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询成绩 <span class="number">90</span> 分以上的学生成绩信息</span><br><span class="line"><span class="keyword">SELECT</span> stu.<span class="operator">*</span>, scp.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student stu, <span class="keyword">scope</span> scp</span><br><span class="line"><span class="keyword">WHERE</span> stu.id <span class="operator">=</span> scp.stu_id</span><br><span class="line">  <span class="keyword">AND</span> scp.scope <span class="operator">&gt;</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>
<p>那在访问驱动表 <code>student</code> 的时候同上面一样，但是针对驱动表中每一条数据执行被驱动表的时候，就会变成：</p>
<p><code>SELECT * FROM scope WHERE stu_id NOT NULL AND stu_id = ? AND scope &gt; 90;</code></p>
<p>一句话就是说，这些条件针对哪个表，在执行那个表的时候就会带上指定的条件。</p>
<p>内连接推荐写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stu.<span class="operator">*</span>, scp.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student stu <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">scope</span> scp <span class="keyword">ON</span> stu.id <span class="operator">=</span> scp.stu_id</span><br><span class="line"><span class="keyword">WHERE</span> scp.scope <span class="operator">&gt;</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>
<p>效率没有变高，但是可读性变好，在我看来，特定的限定功能就需要放在特定的位置，连接条件在 <code>ON</code> 后面，而查询条件在 <code>WHERE</code> 后面，也可以很好的跟下面的外连接写法统一。</p>
<h3 id="7-3-外连接"><a href="#7-3-外连接" class="headerlink" title="7.3 外连接"></a>7.3 外连接</h3><p>外连接的目的是将连接在一起查询的表中，以某个表为主要目的，查询他在另外一个表的所有信息，包括不存在的信息。比如还是上面的例子，翠花她是个坏学生，一个科目都没有参加考试，但是老师如果通过上面的内连接查询来看的话，可能都不知道还有这个人的存在。这就麻烦大了啊，家长上门投诉，我给你钱了，她没参加考试你都不管管的吗。所以这时候，就需要外连接来做这个事情了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">scope</span> scp <span class="keyword">ON</span> scp.stu_id <span class="operator">=</span> stu.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+---------+-------+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> id   <span class="operator">|</span> subject <span class="operator">|</span> <span class="keyword">scope</span> <span class="operator">|</span> stu_id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+---------+-------+--------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗蛋   <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> 语文    <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 狗蛋   <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> 数学    <span class="operator">|</span>    <span class="number">98</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 狗剩   <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> 英语    <span class="operator">|</span>    <span class="number">59</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> 狗剩   <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> 政治    <span class="operator">|</span>    <span class="number">79</span> <span class="operator">|</span>      <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> 翠花   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>  <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+---------+-------+--------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)			</span><br></pre></td></tr></table></figure>
<p>这个时候，嗯哼，一抓一个准，没有来考试的，在 <code>scope</code> 表的字段中，显示为 <code>NULL</code>。</p>
<p>关于 <code>驱动表</code> 和 <code>被驱动表</code> 的含义已经在上面内连接的内容中指定，那么如果说 <code>内连接</code> 是根据成本来指定 <code>驱动表</code> 的，那 <code>外连接</code> 就是我们来指定驱动表。</p>
<p>以 <code>驱动表</code> 所有满足我们条件的数据，来查询 <code>被驱动表</code>，如果 <code>被驱动表</code> 不存在 <code>驱动表</code> 中某条数据的关联，显示为 <code>NULL</code>。</p>
<p>那么关键点在哪里，就在这个 <code>ON</code> 后面的条件，<code>ON</code> 后面的条件，是指定 <code>被驱动表</code> 中不满足 <code>ON</code> 条件情况下依然要显示的关键。（在内连接中连接条件放 <code>ON</code> 和放 <code>WHERE</code> 效果一样）</p>
<p>如果外连接有几层，比如说三层：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> teacher t</span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">ON</span> t.id <span class="operator">=</span> stu.into</span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">scope</span> scp <span class="keyword">ON</span> stu.id <span class="operator">=</span> scope.stu_id;</span><br></pre></td></tr></table></figure>
<p>那么上面这条查询需要怎么走呢，先查询老师所有的学生，得到一张中间表以后，再以这张中间表作为 <code>驱动表</code> 来查询 <code>scope</code>。</p>
<h2 id="八-复杂条件查询"><a href="#八-复杂条件查询" class="headerlink" title="八.复杂条件查询"></a>八.复杂条件查询</h2><p><code>MySQL InnoDB</code> 中存在着 <code>SQL解析器</code>，解析器可谓为了查询正确的数据而费尽心思，目的只有一个，就是较快的查询出来正确的数据。其实这里也可以联想到 <code>jvm编译器</code>，为了执行效率比较快，会对字节码进行一些顺序的重新编排，什么 <code>happen before</code> 规则都出来了。</p>
<p>而什么东西查询最快呢，那就是查询常量的时候了。</p>
<h3 id="8-1-整理查询语句"><a href="#8-1-整理查询语句" class="headerlink" title="8.1 整理查询语句"></a>8.1 整理查询语句</h3><p>首先就是去除不必要的括号，因为括号如果没有意义存在，那移除了就更有利于优化器的解析了。</p>
<p>比如 <code>WHERE (id = 1)</code> 会被优化成 <code>WHERE id = 1</code>。这个好像也没什么好说的。</p>
<p>复杂一点的 <code>WHERE (id = 1 AND name = &#39;WEIDAN&#39;) AND age = 20</code> 则会被优化成 <code>WHERE id = 1 AND name = &#39;WEIDAN&#39; AND age = 20</code>。</p>
<h3 id="8-2-简化查询条件"><a href="#8-2-简化查询条件" class="headerlink" title="8.2 简化查询条件"></a>8.2 简化查询条件</h3><p><code>WHERE age &gt; 18 AND real_age &gt; age</code> 则直接变成 <code>WHERE age &gt; 18 AND real_age &gt; 18</code></p>
<h3 id="8-3-删除废话条件"><a href="#8-3-删除废话条件" class="headerlink" title="8.3 删除废话条件"></a>8.3 删除废话条件</h3><p>像我之前老师教的，在写 <code>MyBatis Mapper.xml</code> 的时候，因为 <code>WHERE</code> 总是需要动态的条件，所以前面会加一个 <code>WHERE 1 = 1</code>（为啥不用标签，因为标签可读性其实不怎么高）。</p>
<p>那么，如果我写的是 <code>WHERE 1 = 1 AND name LIKE &#39;Weidan%&#39;</code>，那么语句将会被直接优化为 <code>WHERE name LIKE &#39;Weidan%&#39; </code>。这么想想好像直接写 <code>WHERE 1 = 1</code> 除了解析器多了点工作，好像也没什么所谓了。</p>
<h3 id="8-4-计算表达式"><a href="#8-4-计算表达式" class="headerlink" title="8.4 计算表达式"></a>8.4 计算表达式</h3><p><code>WHERE age = 9 + 9</code> 那么解析器会直接给你个 <code>WHERE age = 18</code>。不过如果这些计算方式放在了列名上，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> <span class="operator">-</span>age <span class="operator">=</span> <span class="number">-18</span></span><br><span class="line"><span class="keyword">WHERE</span> to_days(age) <span class="operator">=</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>解析器害怕他也优化错了，所以也会放弃优化，一个简单的记忆就是函数发生在等号后面的常量值上，可以优化，但是如果需要依赖列的计算的话，那就放弃优化了。</p>
<h3 id="8-5-必要时转换外连接到内连接"><a href="#8-5-必要时转换外连接到内连接" class="headerlink" title="8.5 必要时转换外连接到内连接"></a>8.5 必要时转换外连接到内连接</h3><p><code>右外连接</code>会被转换为<code>左外连接</code>，毕竟 <code>左外连接</code> 更好确定 <code>驱动表</code> 和 <code>被驱动表</code>。</p>
<p>那如果我们在查询 <code>左外连接</code> 的时候，暗示着我得出的结果中，被驱动表不含 <code>NULL</code> 的值，聪明的暖男解析器将会 GET 到这个信息，把 <code>外连接</code> 优化成 <code>内连接</code>。</p>
<p>比如上面的例子中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">scope</span> scp <span class="keyword">ON</span> scp.stu_id <span class="operator">=</span> stu.id</span><br><span class="line">  <span class="keyword">AND</span> scp.id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">scope</span> scp <span class="keyword">ON</span> scp.stu_id <span class="operator">=</span> stu.id;</span><br><span class="line">  <span class="keyword">AND</span> scp.id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>那么上面两个语句中是不是就都暗示解析器中，拿到的 <code>scope</code> 中的 <code>id</code> 不能为空。</p>
<p>所以！直接变成这条语句执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student stu <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">scope</span> scp <span class="keyword">ON</span> scp.stu_id <span class="operator">=</span> stu.id</span><br><span class="line">  <span class="keyword">AND</span> scp.id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student stu <span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">scope</span> scp <span class="keyword">ON</span> scp.stu_id <span class="operator">=</span> stu.id;;</span><br></pre></td></tr></table></figure>
<h2 id="九-完"><a href="#九-完" class="headerlink" title="九.完"></a>九.完</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>熟悉又陌生的TCP/IP</title>
    <url>//network/2-TCP-IP-PROTOCOL/index.html</url>
    <content><![CDATA[<h1 id="TCP-IP协议的诞生"><a href="#TCP-IP协议的诞生" class="headerlink" title="TCP/IP协议的诞生"></a>TCP/IP协议的诞生</h1><p>说到 <strong>TCP/IP协议</strong> 我相信各位光头们并不陌生，那他怎么变得如此流行的，我想有个很重要的原因，刚好生在他应该诞生的时机。</p>
<p>期初，军用方面的应用，需要进行信息的交换，所以有一套这样的网络：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/0.png" alt="网络"></p>
<p>这样就有一个问题，如果中心节点被敌人偷袭了，那么整套军用系统就全部瘫痪。那为了防止这种事情的发生，我们可以多加几个中心节点：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/1.png"></p>
<p>这样的话如果中心的节点被袭击了（变成红色表示故障），那么其他计算机还可以通过比较远的输送距离将数据传达到彼此。</p>
<a id="more"></a>

<p>这种网络，叫做 <strong>Advanced Research Projects Agency Network 阿帕网</strong>，其实这个翻译完全覆盖了他的意思，英文翻译过来应该是 <strong>可重新查找项目的网络</strong>。</p>
<p>那么这个网络，由于连接的不稳定性，就需要有一个协议来保证传输的完整，那么这个 <strong>阿帕网</strong> 中的一些研究机构，就研究出了 <strong>TCP/IP协议</strong>。这时候，他还没那么流行。这时候很多大学和研究机构开始使用一款叫做 <strong>BSD UNIX</strong> 的操作系统，由于这套系统中实现了 <strong>TCP/IP协议</strong>，并且随着互联网的发展，这个系统受众越来越多，这就导致了很多网络设备供应商不得不去适配 <strong>TCP/IP协议</strong>，所以到如今才使 <strong>TCP/IP协议</strong> 的应用变得如此广泛。</p>
<h1 id="TCP-IP协议的内容"><a href="#TCP-IP协议的内容" class="headerlink" title="TCP/IP协议的内容"></a>TCP/IP协议的内容</h1><p><strong>TCP/IP协议</strong> 并不单单只是包含 <strong>TCP</strong> 和 <strong>IP</strong> 两个部分，其实他是一个族：</p>
<ul>
<li>应用协议：HTTP、SMTP、FTP、TELNET……</li>
<li>传输协议：TCP、UDP</li>
<li>路由控制协议：RIP、OSPF、BGP……</li>
<li>网络协议：IP、ICMP、ARP……</li>
</ul>
<p>每一部分内容单独拎出来都是一大块的内容。</p>
<p>其二，他与 <strong>OSI七层模型协议</strong> 不同，但是有其对应的地方，引用一张图（via 《图解TCP/IP》)</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/2.png" alt="与七层模型的匹配"></p>
<p>可以看出，<strong>OSI七层模型协议</strong> 被简化了很多东西：</p>
<ol>
<li>数据链路层（包含网卡+电缆）：这一层肯定必不可少的，不然没有通电就无法传输数据，其中的网卡 <strong>MAC地址</strong> 会被用来确认当前接收的数据是否需要交给本机进行处理，如果跟当前本机的 <strong>MAC地址</strong> 不相符合，那么传送过来的数据包将会被抛弃掉；</li>
<li>互联网层：IP，在上面说 <strong>OSI七层模型协议</strong> 的时候我们有说过，当 <strong>数据链路层</strong> 接收到数据的时候，此时还不能确定数据包就是当前机器需要接收的数据包，还需要判断 <strong>IP地址</strong> 是否指向本机，我们知道一台机器我们是可以在操作系统上面指定分配多个 <strong>IP地址</strong> 的，如果判断是的话紧接着将数据上送给传输层；</li>
<li>传输层：传输层我们通常需要指定数据需要到达的端口，现代计算机一般都是同时运行好几个程序，更别说端口占用的那就更加多了，端口刚好就是可以指定数据要交给哪个应用程序进行处理的方式。除了端口的作用，还有保证数据是否需要判断接收成功失败的作用，比如 <strong>TCP协议</strong> 或者 <strong>UDP协议</strong>；</li>
<li>应用层：在 <strong>TCP/IP协议模型</strong> 中，将之前所说的 <strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong> 都集中在这一层中进行处理，如果开发过 <strong>Netty</strong> 相关项目的同学就知道，我们通常需要处理 <strong>粘包</strong> <strong>丢包</strong> 等问题，如果有时候需要加快传输速度但又不允许丢失数据的时候，通常需要 <strong>UDP协议</strong> + <strong>我们自己的校验</strong> 去验证数据是否传输完整。常见的应用层协议有：<strong>HTTP</strong>、<strong>FTP</strong>、<strong>SSH</strong>、<strong>SMTP</strong> 等；</li>
</ol>
<p>那么数据是怎么流动的呢，跟 <strong>OSI七层模型协议</strong> 模式是一样的，不过不需要包 <strong>七层</strong> 的头部数据。</p>
<ol>
<li><p>在这里我们通常只需要应用将数据进行包装，然后以一定的编码进行处理（通常是 <strong>UTF-8</strong>）交给 <strong>传输层</strong>；</p>
</li>
<li><p>然后 <strong>传输层</strong> 将会根据不同的协议（一般是 <strong>TCP</strong> 或者 <strong>UDP</strong>）将我们的应用数据再包上一层协议本身的 <strong>Header</strong>；然后交给 <strong>互联网层</strong>，<strong>互联网层</strong> 则再包上 <strong>IP头</strong> 将数据交给 <strong>数据链路层</strong>，注意了，在这一层，如果尚未知道下一层所需要的 <strong>MAC地址</strong> 的话，会利用 <strong>ARP（Address Resolution Protocol）</strong> 进行对端的 <strong>MAC地址</strong> 查找，然后再交给下一层；</p>
</li>
<li><p><strong>数据链路层</strong> 则是包上相关的 <strong>MAC地址</strong> 信息，然后交给驱动进行网卡适配，然后发送数据。</p>
</li>
</ol>
<p>最后数据将会被包成这样发出去（via 《图解TCP/IP》)：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/3.png" alt="传输数据结构"></p>
<p>而接受数据方面：</p>
<ol>
<li><strong>数据链路层</strong> 接收到数据以后，会判断 <strong>头部</strong> 的 <strong>Header</strong> 是否是给自己的，如果不是则会抛弃数据，有时候收到的不是 <strong>IP数据包</strong> 而其他协议，则会相对应的交给对应的模块进行处理（例如：<strong>ARP</strong> 协议）；</li>
<li><strong>互联网层</strong> 也跟 <strong>数据链路层</strong> 处理方式相似，但是如果接收端的地址与本机地址不符合的话，会借助路由器的 <strong>路由控制表</strong>，调查下一个应该到达的主机或者其他设备以后将数据进行转发；</li>
<li><strong>传输层</strong> 则会对接收到的数据进行校验，并且根据接收到的数据包的序列化重新排序，交给对应端口的 <strong>应用层</strong> 进行处理，同时通知 <strong>发送端</strong> 告知数据已经接收完成，如果这个接收通知不能到达 <strong>发送端</strong> 则 <strong>发送端</strong> 会不停的重发数据直到被告知数据接收完整；</li>
<li><strong>应用层</strong> 这方面就太熟悉了，可以正确接收正确处理，也可能引起一些其他协议方面或者业务方面的错误，从而处理出现异常，比如我们常常遇到的 <strong>404 Not Found</strong>。</li>
</ol>
<p>OK，那现在开始先从低层架构开始了解。</p>
<hr>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><blockquote>
<p>数据链路层对于我们开发来说其实不是特别重点，所以只需要简单的了解一些基础内容即可。</p>
</blockquote>
<h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><p>数据链路层其实就是连接世界上所有计算机的基础，我们了解到，其实计算机的机器码是 <code>1</code> 和 <code>0</code>，那么人们发现这个跟电路中的 <code>正</code> 和 <code>负</code> 可以对应起来，所以我们就可以使用电平的 <code>正</code> 和 <code>负</code> 来表示机器码信息，从而利用电路等物理介质将计算机信息传递给另外一台计算机。（如果是光纤则可以使用 <code>亮</code> 和 <code>灭</code> 这两种信号来表示 <code>1</code> 和 <code>0</code>）</p>
<p>然而，物理层也不是单纯的发送 <code>1</code> 和 <code>0</code> 信号，而是把这些数据通过一定的规则，集合起来，作为 <code>帧</code> 去发送数据（<code>帧</code> 的内容会在后面细说）。</p>
<h2 id="连接拓扑"><a href="#连接拓扑" class="headerlink" title="连接拓扑"></a>连接拓扑</h2><p>一共有四种连接的拓扑方式：</p>
<h3 id="1-总线型"><a href="#1-总线型" class="headerlink" title="1. 总线型"></a>1. 总线型</h3><p><img src="/images/2-TCP-IP-PROTOCOL.md/4.png" alt="总线型"></p>
<p>就是中间一条总的网线，然后在不同的接口处连接计算机，这种方式应该算是比较古老的，如果总线某一段发生故障的话，那么被影响的计算机也不确定。</p>
<h3 id="2-环形"><a href="#2-环形" class="headerlink" title="2. 环形"></a>2. 环形</h3><p><img src="/images/2-TCP-IP-PROTOCOL.md/5.png" alt="环形"></p>
<p>环形中的计算机并不相互连接，那么如果我们发送数据到不连接的计算机的时候，就需要其他计算机来参与传送。比如说，将数据从 <code>A计算机</code> 发送到 <code>C计算机</code>，那么数据得先发送给 <code>B计算机</code>，然后 <code>B计算机</code> 再判断数据是否是给我这个网卡的（利用 <strong>MAC地址</strong>），如果不是，则顺着网线传输给下一台计算机 <code>C</code>。这时候 <code>计算机C</code> 才算是接收到数据。但是如果这个过程中，<code>计算机B</code> 发生了故障或者硬件支撑不住的话，那么 <code>计算机C</code> 接收数据将会受到影响。</p>
<h3 id="3-星型"><a href="#3-星型" class="headerlink" title="3. 星型"></a>3. 星型</h3><p><img src="/images/2-TCP-IP-PROTOCOL.md/6.png" alt="星型"></p>
<p>这种方式应该是目前最流行的方式了吧。无论是办公室或者网吧等等，都可以使用这种连接方式。每台计算机只要专注自己要做的事情即可，不用管其他的问题。但是有个最主要的点就是需要保证中央集线器的正常运行，如果中央集线器挂了，那么所有计算机都无法进行数据的传输。</p>
<h3 id="4-混合型"><a href="#4-混合型" class="headerlink" title="4. 混合型"></a>4. 混合型</h3><p><img src="/images/2-TCP-IP-PROTOCOL.md/7.png" alt="混合型"></p>
<p>顾名思义，混合不同的连接方式，这种可以根据我们的日常工作需求，用于降低计算机连接成本，当然按照目前硬件的价格低廉的特性，一般都是使用 <strong>星型</strong> 的架构来混合。</p>
<p>以上几种方式的计算机连接是 <strong>网线</strong> 中布局的方式，先简单的记忆即可，然后我们来看看微观的数据是怎么传送运输的。</p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>用于与网络连接的设备，诸如 <strong>网卡</strong>、<strong>无线LAN</strong>、<strong>蓝牙模块</strong> 均拥有 <strong>MAC地址</strong>。<strong>MAC地址</strong> 是由生产该设备的厂家规定的，并且烧录到硬件设备的 <strong>ROM（Read Only Memory）</strong> 中。任何网卡的 <strong>MAC地址</strong> 均是世界性的唯一的（类似于我们的身份证）</p>
<p>而世界性唯一这个性质也不是说就是绝对的，如果两个相同 <strong>MAC地址</strong> 位于不同的数据链路中，那么他们一般也不会相互影响到。比如中国的网卡 和 美国的网卡，共用了一个 <strong>MAC地址</strong> 通常来说除非这两台计算机组成了一个什么虚拟云才会相互影响，不然一般都可以正常的工作。</p>
<p><strong>MAC地址</strong> 一共 <strong>48位</strong>。</p>
<p>不同的位数表达不同的内容：</p>
<ol>
<li>第 <strong>1</strong> 位：0表示单播地址，1表示多播地址；</li>
<li>第 <strong>2</strong> 位：0表示全局地址，1表示本地地址；</li>
<li>第 <strong>3 - 24</strong> 位：由 <strong>IEEE（美国电气和电子工程师协会）</strong> 管理并且保证各个厂家之间不发生重复；</li>
<li>第 <strong>25 - 48</strong> 位：由厂家管理保证产品之间不重复。</li>
</ol>
<p>然而在这里我感觉得先弄清楚 <strong>比特位</strong> 和 <strong>字节</strong> 之间的区别：</p>
<blockquote>
<p>比特位：由 0 和 1 两种信息表示，比如 101010 则拥有 6 个位</p>
<p>字节：一般情况下，1个字节有 8 个比特位，比如 10101010 表示 1 个字节</p>
<p>所以这里的 48 位表示 6 个字节数。</p>
</blockquote>
<p>而 <strong>数据比特流</strong> 在网络中的流动顺序，是按照 <strong>每一个字节</strong> 倒序传输的，一个图解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是我们要传输的数据：0 0 0 0 0 0 0 1 | 1 0 0 0 0 0 0 0 </span><br><span class="line">这是比特流中流动数据：1 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 1</span><br></pre></td></tr></table></figure>


<p>那么我们的数据已经来到了目前计算机的网卡了，接下来肯定就要进入介质了，所以我们来看看介质的传输过程。</p>
<h2 id="介质传播数据"><a href="#介质传播数据" class="headerlink" title="介质传播数据"></a>介质传播数据</h2><p>介质传播的分类，我们可以按照上面 <strong>拓扑连接</strong> 来进行简单的分类：</p>
<h3 id="共享介质型网络"><a href="#共享介质型网络" class="headerlink" title="共享介质型网络"></a>共享介质型网络</h3><p>共享介质一般出现在 <strong>总线型</strong> 和 <strong>环形</strong> 的拓扑连接方式里面，<strong>总线型</strong> 就是多台计算机共享一个网络传输介质（多为网线）的方式，那么这种工作方式就出现了一种问题：需要争抢共享的资源。所以这种方式是一种 <strong>半双工</strong> 的工作方式（就是说只能单独处理发或者收）</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/8.png"></p>
<p>如图，在某个时刻，<strong>计算机B</strong> 需要传输数据给 <strong>计算机C</strong>，那么他会观察总线上是否有数据正在传输，而此时并没有数据进行传输，所以他就占用了总线这个资源，向其他计算机分别发送了数据包。</p>
<p>此时其他数据包接收到数据包的时候，就需要判断数据包包含的 <strong>MAC地址</strong> 是否指向了当前计算机的 <strong>MAC地址</strong>，如果不是，则将数据进行丢弃。而 <strong>计算机C</strong> 接收到数据包后，判断是 <strong>MAC地址</strong> 指向了自己，所以就开始处理数据。</p>
<p>而如果 <strong>计算机B</strong> 在发送数据的时候，<strong>计算机C</strong> 也需要发送数据的话，就需要主动放弃数据，释放载波信道，等到 <strong>总线</strong> 中的电压稳定以后，再重新发送数据。</p>
<p>而另外一种 <strong>共享介质</strong> 的拓扑结构就是环形结构，为了有效提高数据的传输效率，提出了令牌的说法，即在环形中所有的计算机如果需要发送数据，则需要先获取令牌才可以向其他计算机发送数据：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/9.png"></p>
<p>以上两种方式看起来都是蛮老的技术了，简单分析就可以知道，网络的利用率很低。所以衍生出了下面这种方式。</p>
<h3 id="非共享介质型网络"><a href="#非共享介质型网络" class="headerlink" title="非共享介质型网络"></a>非共享介质型网络</h3><p><strong>非共享介质</strong> 的网络则采用一种设备：<strong>交换机</strong>。交换机可以单独连接不同的计算机，然后计算机都是可以通过 <strong>全双工</strong> 的方式进行数据传输的。交换机本身拥有一些功能，可以将数据缓存，然后自动的判断闲时，将数据发送给对应的计算机。</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/10.png"></p>
<p><strong>计算机A</strong> 发送的数据中会标明 <strong>原地址为A目标地址为C</strong>，交换机拿到这条数据以后，只要根据 <strong>目标地址</strong> 的标签来发送数据就可以了。这样就可以很明显的提高网络的传输效率。</p>
<p>现代的交换机都会带有 <strong>自学习</strong> 的功能，也就是自学哪个端口连接了哪台计算机，<strong>MAC地址</strong> 是多少，这样就可以很高效的对数据进行转发。相当于已经自带路由表。</p>
<h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><p>这一层属于软件层面上的管理了。意思是即使在一个区域内，计算机都连接到同一个交换机上，我们也可以通过软件管理，将这些连接的计算机根据我们自己的日常需求，划分为不同的子网段。这样做的好处就是，即使我们的日常计算机发生了功能上的变更，管理员不用去更改网络拓扑的结构，只需要在软件层面上对这部分计算机进行网络功能的划分即可。</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/11.png"></p>
<p>即使是两个 <strong>交换机</strong>，也可以组成同一个网段：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/12.png"></p>
<p>即使两台 <strong>交换机</strong> 连接的不同计算机，也可以通过网络管理组成在同一个网段中。</p>
<h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><p>我们前面的内容基本说的是一个局域网的连接，那如果需要访问远程的资源，我们就需要一个网络，称为 <strong>以太网（Ethernet）</strong> 了。而以太网可以说就是使用多个 <strong>交换机</strong> 连接在一起，成为一个很大的 <strong>局域网</strong>。每一个以太网连接着多台计算机。每台计算机又运行着不同的 <strong>WEB程序</strong>。这样我们需要不同业务需求的时候比如 <strong>买票</strong> <strong>发邮件</strong> 只要通过网络到达能够实现功能的计算机即可。</p>
<p>而不同的以太网版本，又有不同的物理实现方式（via《图解TCP/IP》）：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/13.png" alt="以太网不同版本的物理介质"></p>
<p>而如果需要延长距离的话，则需要加上之前说过的设备：<strong>中继器</strong> 或者其他可以放大信号的设备。</p>
<h2 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h2><p>以太网帧以一个叫做 <strong>前导码</strong> 的数据开始，这个 <strong>前导码</strong> 占用 <strong>8字节（64位）</strong> 空间，以 <code>1010...</code> 的形式开始，而使用 <code>11</code> 这两位结束 ，比如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="number">10101010</span> <span class="number">10101010</span> <span class="number">10101010</span> <span class="number">10101010</span> <span class="number">10101010</span> <span class="number">10101010</span> <span class="number">10101010</span> <span class="number">10101011</span> 后面紧接着帧本体（<span class="number">14</span>字节）</span><br></pre></td></tr></table></figure>
<p>帧本体占用 <strong>14字节</strong>，前 <strong>6字节</strong> 记录 <strong>目标MAC地址（上面说了MAC地址是48位数）</strong>，紧接着 <strong>6字节</strong> 记录 <strong>源MAC地址</strong>，然后 <strong>2字节</strong> 记录上层协议类型，帧尾则以一个 <strong>4字节</strong> 的叫做 <strong>FCS（Frame Check Sequence）</strong> 的数据进行结尾（类似于我们的 <strong>MD5</strong> 验证数据的完整性），用于目标机器验证数据是否完整或者是否遭到破坏。</p>
<p>所以一个完整的帧：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/14.png" alt="以太网帧"></p>
<p>那我们可以计算得出，一个 <strong>以太网帧</strong> 能够传送 <strong>70-1524</strong> 字节的数据（每一位做什么事情都被安排的明明白白），大概是 <strong>1.5m</strong>。但是需要除去一些必要的头部信息，所以其实留给应用程序的空间并不是很多。</p>
<p>上面只能算是一个 <strong>通用的帧格式</strong>，而如果根据协议的不同（比如 <strong>VLAN</strong> 还会重新规划），则会大概的重新规划 <strong>协议</strong> 和 <strong>数据</strong> 这两部分的空间利用。目的当然是为了提高网络的传输速率。</p>
<p>哦对了，协议我们常见的编码对应是（via《图解TCP/IP》）：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/15.png" alt="协议版本"></p>
<p>这里是 <strong>16进制</strong> 注意需要转换成 <strong>2进制</strong> 的，比如 <strong>IP</strong> 对应的 <strong>0800</strong>，转换成 <strong>2进制</strong> 则是 <strong>00001000 00000000</strong>。</p>
<h1 id="无线通信"><a href="#无线通信" class="headerlink" title="无线通信"></a>无线通信</h1><p>这部分其实还是蛮好理解的，我们只需要提供一种设备用于接收 <strong>电磁波</strong> 或者无线信号，然后转成以太网的格式即可介入以太网。</p>
<p>常见的电磁波信号（via《图解TCP/IP》）：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/16.png" alt="常见的电波信号"></p>
<p>分层结构（via《图解TCP/IP》）：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/17.png" alt="无线通信分层结构"></p>
<p>这里有个冷知识：微波炉使用的是 <strong>2.4GHz频段</strong> 的微波，如果在一台正在工作的微波炉旁边，我们的路由器设置 <strong>2.4GHz频段</strong> 的话，则传输数据的信号会受到干扰。</p>
<h1 id="PPP（Point-to-Point-Protocol）"><a href="#PPP（Point-to-Point-Protocol）" class="headerlink" title="PPP（Point-to-Point Protocol）"></a>PPP（Point-to-Point Protocol）</h1><p><strong>PPP协议</strong> 可以解决一系列的问题：验证你有没有交费、给你分配一个网络IP等问题，所以一直是 <strong>ISP</strong> 用来提供给用户上网的一种形式。</p>
<p>我们打开 <strong>宽带连接</strong>，点击连接的时候，通常是把用户名和密码进行压缩发送给 <strong>ISP</strong> 进行验证，然后 <strong>ISP</strong> 会分配一个 <strong>IP地址</strong> 给到客户端，然后我们客户端就可以网上冲浪了。</p>
<p>连接过程（via《图解TCP/IP》）：</p>
<p><img src="/images/2-TCP-IP-PROTOCOL.md/18.png" alt="PPP连接过程"></p>
<p>说完了 <strong>链路层</strong> 的事情以后，我们可以上升一层了，来说说 <strong>IP</strong> 的事情。</p>
<p>下一节再说。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层的协议-IP协议簇</title>
    <url>//network/3-IP/index.html</url>
    <content><![CDATA[<h1 id="互联网层-IP协议簇"><a href="#互联网层-IP协议簇" class="headerlink" title="互联网层-IP协议簇"></a>互联网层-IP协议簇</h1><p>上一节聊完了数据链路层，我们知道，两台计算机如果需要进行通讯的话，就需要先知道彼此的 <strong>MAC地址</strong>，然后将数据封装成 <strong>以太网帧</strong> 进行传输。但是我们的野心并没有止于此，因为需要更多的计算机参与网络（这个数量是+∞），那总不能把所有计算机的 <strong>MAC地址</strong> 在每一台上面都存储一份吧，即使这样，物理介质的互通也不现实。所以还能怎么办，那就包多一层嘛。</p>
<p>所以，<strong>IP协议</strong> 这一层又应运而生。</p>
<p>那么我们可以重新看一下分层模型：</p>
<p><img src="/images/3-IP.md/0.png" alt="与七层模型的匹配（via《图解TCP/IP》）"></p>
<p>他主要位于互联网层，那他在这一层主要解决的问题就是数据的走向问题，也仅仅是走向的问题，不会对数据进行纠错，也不会负责重发的动作（即使数据丢失的话）。而这些问题会在再上一层的 <strong>传输层</strong> 进行补充解决。</p>
<a id="more"></a>
<h1 id="简单的描述"><a href="#简单的描述" class="headerlink" title="简单的描述"></a>简单的描述</h1><p>那就从传输层开始，假设我们现在的应用使用的是 <strong>TCP协议</strong>，那么 <strong>TCP数据包</strong> 将会传递给 <strong>IP协议（互联网层）</strong>，但是数据链路层是需要知道彼此的 <strong>MAC地址</strong> 的，不过目前我没有那个地址。所以就需要一个东西来辅助了：<strong>路由控制</strong>。每一个主机上（包括电脑、手机、路由器等等）都会内置一个路由控制表，他会指明所需要请求的 <strong>IP</strong> 应该通向哪一台 <strong>路由器</strong> 或者在最后一级的时候通向哪台提供服务的 <strong>计算机</strong>，所以我们的主机下一步需要在数据链路上填上相连接的 <strong>路由器</strong> 的 <strong>MAC地址</strong>。</p>
<p>这个过程就很像我们日常使用的快递服务了，众所周知（当然我也不知道你们知不知），快递公司是有省级转运仓，市级转运仓，还有各区县镇转运仓的，这些转运仓我们可以比作 <strong>路由器</strong>，我们将快递交给快递员的时候，当然快递员不知道怎么走而且他也只负责他区域内部的事情而已，所以他交给 <strong>镇转运仓</strong>，<strong>转运仓</strong> 就比较忙了，他需要根据快递包裹上的地址省市区（<strong>IP地址</strong> 的分段管理）再分拨给其他转运仓，比方说是市内的，就直接转给其他的 <strong>各区县镇转运仓</strong>，然后他们需要依据后面的详细地址，将快递派出去；而如果是省外的，就需要 <strong>省转运仓</strong> 去分拨，那么自然的会将包裹往 <strong>省转运仓</strong> 转运。</p>
<p>所以一个快递的运输上，省市区地址是用来 <strong>分区</strong> 的，详细地址是最后用来定位具体位置的，整个过程跟 <strong>IP数据包</strong> 的走向有异曲同工之妙。</p>
<p>那么这中间就涉及 <strong>IP地址</strong>、<strong>路由控制</strong>、<strong>路由监控</strong> 等内容了。</p>
<h1 id="IP地址要点"><a href="#IP地址要点" class="headerlink" title="IP地址要点"></a>IP地址要点</h1><h2 id="IP地址的定义"><a href="#IP地址的定义" class="headerlink" title="IP地址的定义"></a>IP地址的定义</h2><p>那么我们在公司经常会有路由器进行 <strong>IP自动获取</strong>，获取到这个 <strong>IP</strong> 呢，大概就是这个样子：<strong>192.168.1.7</strong>。</p>
<p>下面关于 <strong>二进制</strong> 跟 <strong>十进制</strong> 的转换，请灵活使用系统自带的 <strong>计算器</strong> 进行计算：</p>
<p><img src="/images/3-IP.md/1.png" alt="MacOS自带的计算器"></p>
<p>当然，我们用的是 <strong>十进制</strong> 的表示方法，其实 <strong>IP</strong> 在网络中传输是要求 <strong>二进制</strong> 的，也就是类似于这样子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1100 0000 1010 1000 0000 0001 0000 0111</span><br></pre></td></tr></table></figure>
<p>上面表示的 <strong>IP</strong> 翻译成 <strong>十进制</strong> 的话，刚好是 <strong>192.168.1.7</strong>。</p>
<p>但是我们讨论的时候需要基于 <strong>二进制</strong> 的，<strong>IP</strong> 规定总长度是 <strong>32</strong> 位 <strong>二进制</strong> 数（如上面我的 <strong>IP地址</strong>）</p>
<h2 id="IP地址组成部分"><a href="#IP地址组成部分" class="headerlink" title="IP地址组成部分"></a>IP地址组成部分</h2><p><strong>IP地址</strong> 从左往右，由 <strong>网络标识</strong> 和 <strong>主机地址</strong> 两个部分进行组成。我们知道，路由器是可以将网络中的计算机进行网络分段的，以便应用程序利用 <strong>网络分段</strong> 进行数据的传输。如果网络中有多个路由器的话，也可以通过 <strong>网络标识</strong> 进行数据的分类传输。可以通过斜杆 <strong>/</strong> 记录前几位表示网络标识，例如：<code>192.168.1.7/24</code> 表示前 <strong>24</strong> 位（二进制位）标记网络标识，而剩余的其他位数标记 <strong>主机地址</strong>。</p>
<p>当然，现在大部分的做法是使用 <strong>子网掩码</strong> 来做分割，但是 <strong>IP地址分割法</strong> 的做法依然会存在某些小型企业中。</p>
<h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p>简单记一下即可，不用强记。</p>
<p><strong>A类地址</strong>：首位 <strong>0</strong> 开始，前 <strong>8</strong> 位（包括强制性 <strong>0</strong> 的那一位）表示网络标识，后 <strong>24</strong> 位表示主机地址，可以容纳 <strong>16777214</strong> 个主机；</p>
<p><strong>B类地址</strong>：首位 <strong>10</strong> 开始，前 <strong>16</strong> 位（包括强制性 <strong>10</strong> 的那两位）表示网络标识，后 <strong>16</strong> 位表示主机地址，可以容纳 <strong>65534</strong> 个主机；</p>
<p><strong>C类地址</strong>：首位 <strong>110</strong> 开始，前 <strong>24</strong> 位（包括强制性 <strong>110</strong> 的那三位）表示网络标识，后 <strong>8</strong> 位表示主机地址，可以容纳 <strong>254</strong> 个主机；</p>
<p><strong>D类地址</strong>：首位 <strong>1110</strong> 开始， <strong>32</strong> 位（包括强制性 <strong>1110</strong> 的那四位）表示网络标识，没有主机标识，常用语 <strong>多播</strong>。</p>
<p>éi，为啥都少 <strong>两台主机</strong>（比方说 <strong>A类地址</strong>，有 <strong>24</strong> 位表示主机，应该是 <strong>16777216</strong> 台主机才对，那是因为主机地址不可以包含全部为 <strong>1</strong> 或者 <strong>0</strong> 的情况，所以基本都会淘汰掉 <strong>2</strong> 台主机的 <strong>IP地址</strong>。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>虽然经过上面对 <strong>组成结构</strong> 和 <strong>分类</strong> 的讨论，但是 <strong>IP地址</strong> 还是枯竭了，不够所有全人类的计算机使用，而 <strong>分类</strong> 也只是简单的按照 <strong>8</strong> 位，<strong>16</strong> 位，<strong>24</strong> 位 进行划分，所以这时候需要一个更加灵活的划分方式，以便于制造更多的 <strong>IP地址</strong> 出来供计算机使用。</p>
<p>子网掩码长度也是 <strong>32</strong> 位，每一位与 <strong>IP地址</strong> 相对应，连续的 <strong>1</strong> 表示连续的几位 <strong>IP</strong> 均为网络表示，连续的 <strong>0</strong> 则表示主机的位置，来看看这个：</p>
<p><img src="/images/3-IP.md/2.png" alt="IP和子网掩码"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址：192.168.1.14</span><br><span class="line">子网掩码：255.255.255.0</span><br><span class="line">---- 二进制法 ----</span><br><span class="line">1100 0000 1010 1000 0000 0001 0000 1110 &lt;-- IP地址</span><br><span class="line">1111 1111 1111 1111 1111 1111 0000 0000 &lt;-- 子网掩码</span><br></pre></td></tr></table></figure>
<p>此时表示的是前 <strong>24</strong> 位为网络标识，那我们转换一下思路，要表示 <strong>26</strong> 位怎么办，此时状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111 1111 1111 1111 1111 1111 1100 0000 &lt;-- 子网掩码二进制</span><br><span class="line">255.255.255.192                         &lt;-- 子网掩码十进制</span><br></pre></td></tr></table></figure>
<p>所以子网掩码的基本思路就是，通过二进制的来标记随便的几位作为网络标识，以便可以拓展 <strong>IP地址</strong> 的分类，灵活放缩可以容纳主机的 <strong>IP</strong> 地址个数。而目前基本是使用这种方式来对网络中的计算机进行分段。</p>
<h2 id="IP广播和多播"><a href="#IP广播和多播" class="headerlink" title="IP广播和多播"></a>IP广播和多播</h2><p>广播，即对一个网络端内的所有主机都发送同一个数据包。对同一个网段内的主机发送广播称为 <strong>本地广播</strong>，而需要跨网段的广播称为 <strong>直接广播</strong>。</p>
<p>本地广播只要对诸如 <strong>192.168.1.255/24</strong> 发送数据即可将数据发送到网段为 <strong>192.168.1</strong> 的所有主机。</p>
<p>而直接广播比如本机地址 <strong>192.168.1.25</strong> 要对 <strong>192.168.2</strong> 的所有主机发送数据，则对 <strong>192.168.2.255</strong> 发送数据包即可。</p>
<h2 id="全局地址和私有地址"><a href="#全局地址和私有地址" class="headerlink" title="全局地址和私有地址"></a>全局地址和私有地址</h2><p>OK，上面其实我一直用的是 <strong>私有地址</strong> 来做示例，那有哪些范围属于 <strong>私有地址</strong>，一般规定如下：</p>
<p><strong>A类</strong>：10.0.0.0 ~ 10.255.255.255（10/8）</p>
<p><strong>B类</strong>：172.16.0.0 ~ 172.31.255.255（172.16/12）</p>
<p><strong>C类</strong>：192.168.0.0 ~ 192.168.255.255（192.168/16）</p>
<p>那么不在以上范围内的，均属于 <strong>全局地址</strong>。</p>
<p>而在连接互联网的时候咧，我们在所在的网络里边只需要有一台机器可以连接互联网，即可使用 <strong>NAT技术</strong> 对 <strong>私有地址</strong> 和 <strong>全局地址</strong> 进行互换，即可实现局域网内所有计算机可以进行联网的需求。这也就很好的解决了 <strong>全局地址</strong> 将要枯竭的问题。</p>
<p>而全局地址一般由 <strong>ISP</strong> 进行动态提供，在联网那一瞬间将会获取一个可用的 <strong>IP全局地址</strong>，然后进行联网。</p>
<h1 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h1><p>OK，说了这么多关于 <strong>IP</strong> 的东西，我们也知道了可以将 <strong>IP</strong> 随意的切分 <strong>网络标识</strong>（也就是常说的网段），那么大概到这里就需要路由器来参与我们数据的传输了。</p>
<p>可以这么说，每个设备都有一个自己的路由表，比如当前我电脑上的情况：</p>
<p><img src="/images/3-IP.md/3.png" alt="MacOS路由表查询"></p>
<p>可以看到一个 <strong>default</strong> 的路由，那么无论什么 <strong>IP</strong>，如果没有在下面列出来的话，就会发送至这个路由器中，然后路由器再继续的根据他目前存储的路由表进行线路的路由。</p>
<p><img src="/images/3-IP.md/4.png" alt="via《图解TCP/IP》"></p>
<p>甚至我们可以查看我们访问一个地址的时候，跳转了多少路由：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">traceroute liweidan.cn</span><br></pre></td></tr></table></figure>
<p><img src="/images/3-IP.md/5.png" alt="traceroute结果"></p>
<p>***** 表示被防火墙屏蔽了，得不到一些具体的数据。</p>
<h1 id="最大传输单元MTU（Maximum-Transmission-Unit）"><a href="#最大传输单元MTU（Maximum-Transmission-Unit）" class="headerlink" title="最大传输单元MTU（Maximum Transmission Unit）"></a>最大传输单元MTU（Maximum Transmission Unit）</h1><p>鉴于之前说过现在大多数的连接方式是使用以太网的链路进行传输，并且说过了一个以太网帧能够容纳的数据大小大概为 <strong>1500字节</strong>。</p>
<p>所以当我们在内网将大的数据包比如说 <strong>5000字节</strong> 发送给路由器的时候，路由器就需要进行分包再通过以太网帧发送出去，而如果请求路径中有更小的 <strong>MTU</strong> 的时候，中间商的路由器又需要对已经分包号的数据包进行分包，这会导致很多性能浪费在路由器上面。</p>
<p>所以现行的规范基本规定，<strong>发送端</strong> 去自动发现路径中最小可传的 <strong>MTU</strong> 并且将这些 <strong>数据包</strong> 依据这个 <strong>MTU</strong> 进行分割以后再进行发送（木桶定理），这样途中所经历的所有路由器，将不再需要对数据进行分割，一次性提升传输性能。</p>
<p>步骤大致如下：</p>
<ol>
<li>发送端发送一个 <strong>5000字节</strong> 的数据给路由器，路由器直接拒绝丢包，并且通过 <strong>ICMP协议</strong> 告诉发送端：<strong>最大处理1500字节</strong>；</li>
<li>发送端重新整理数据，分包，一个一个发送给路由器。</li>
</ol>
<p>发送端将会缓存这个 <strong>最大MTU值</strong>，时长则需要根据不同系统而定。</p>
<p><img src="/images/3-IP.md/6.png" alt="MacOS默认的MTU"></p>
<h1 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h1><p>上面一直说的 <strong>IP</strong> 其实是 <strong>IPv4</strong> 的协议内容，因为 <strong>IPv4</strong> 地址的枯竭，所以急需要另外一种协议来替代 <strong>IPv4</strong>，所以 <strong>IPv6</strong> 就是解决 <strong>IP地址</strong> 不足的问题的。</p>
<p>怎么解决呢，加长度……<strong>IPv6</strong> 是 <strong>128位</strong> 的，相比 <strong>IPv4</strong>，其容量扩大至 <strong>4倍</strong>。</p>
<h2 id="IPv6标记方法"><a href="#IPv6标记方法" class="headerlink" title="IPv6标记方法"></a>IPv6标记方法</h2><p><strong>IPv4</strong> 是由 <strong>4个</strong> <strong>8位</strong> 组成的，所以可以标记 <strong>4个</strong> 正整数。但是如果 <strong>IPv6</strong> 需要表示 <strong>16</strong> 个正整数的话，就显得有点麻烦：<code>我的IP地址是 192.168.1.7.192.168.1.7.192.168.1.7.192.168.1.7</code></p>
<p>所以，就使用 <strong>16进制</strong> 的形式进行表示，分别是每 <strong>2个8位</strong> 作为一组表示出来，如果中间连续出现多个 <strong>16进制位</strong> 是 <strong>0</strong> 的话，还可以使用两个 <strong>:</strong> 进行表示（但是一个地址中只允许省略一次，毕竟省略多次就无法推算了嘛）。</p>
<p>比如：<strong>FEDC:0:0:0:8:3210:200C:417A</strong></p>
<p>那省略的写法就是：<strong>FEDC::8:3210:200C:417A</strong></p>
<h2 id="IPv6地址组成部分"><a href="#IPv6地址组成部分" class="headerlink" title="IPv6地址组成部分"></a>IPv6地址组成部分</h2><p><strong>IPv6</strong> 有多种使用方式：</p>
<ul>
<li><p>唯一本地地址：局域网中可以使用，生成一个随机数融合到地址当中；</p>
</li>
<li><p>链路本地单播地址：不使用路由器的情况下，可以直接使用 <strong>链路本地单播地址</strong> 进行通讯；</p>
</li>
<li><p>全局单播地址：即互联网上分配的唯一 <strong>IP地址</strong>。</p>
</li>
</ul>
<p>一个 <strong>IPv6地址</strong> 的 <strong>前64位</strong> 属于 <strong>网络标识</strong>，<strong>后64位</strong> 属于 <strong>主机标识</strong>。其中，<strong>网络标识</strong> 还包含了 <strong>全局路由前缀</strong> 和 <strong>子网ID</strong>，而 <strong>主机标识</strong> 保存着 <strong>64位比特版</strong> 的 <strong>MAC地址</strong>，当然如果不愿意被识别设备，还可以将这个 <strong>MAC地址</strong> 通过随机生成的方式进行保存（操作系统的工作）。</p>
<p>而如果是 <strong>链路本地单播地址</strong> 的话，<strong>前64位</strong> 则没有保存什么实质性的内容，这 <strong>64位</strong> 中前面 <strong>10位</strong> 做了标记，而后面的 <strong>54位</strong> 则填充 <strong>0</strong>。</p>
<p>以至于 <strong>MTU</strong>，默认均以 <strong>1280字节</strong> 进行分片然后发送数据。</p>
<h1 id="IP数据包的内容"><a href="#IP数据包的内容" class="headerlink" title="IP数据包的内容"></a>IP数据包的内容</h1><p>现在我们主要了解一下 <strong>IPv4</strong> 的数据包长什么样即可，但是由于内容还是比较多的，无论是一行或者一列都无法表示完整，所以使用表格从左到右从上到下的进行表示吧（貌似很多资料都是这样的），图中横向一个单元格表示 <strong>1个比特位</strong>，不是字节哦：</p>
<p><img src="/images/3-IP.md/7.png" alt="IP数据包图示"></p>
<ol>
<li>版本Version：占用 <strong>4个比特位</strong> ，<strong>IPv4</strong> 则填写 <strong>4</strong> 或 <strong>IPv6</strong> 则填写 <strong>6</strong>；</li>
<li>首部长度Internet Header Length：占用 <strong>4个比特位</strong> ，这个字段所表示数的单位是32位字长（1个32位字长是4字节），也就是说如果四位是 <strong>1111</strong> 的话，表示十进制15，首部长度就达到60字节（15 * 4 = 60），并且这个数字永远是 <strong>4</strong> 的倍数，如果 <strong>IP头部数据</strong> 不足 <strong>4</strong> 的倍数的话，利用下面的 <strong>填充位</strong> 进行填充；</li>
<li>区分服务：这个值通常没有被使用，因为控制起来很麻烦，内容表示有 <strong>优先度</strong>、<strong>最低时延</strong> 等通讯质量，后期有人提出使用 <strong>6位长的DSCP段 + 2位长的ECN段</strong>，<strong>DSCP字段</strong> 的值越大表示优先级越高，而 <strong>ECN</strong> 分为两位，主要服务于上一层的协议；</li>
<li>总长度：顾名思义表示 <strong>整个IP包</strong> 的长度，占用 <strong>16位</strong>，可以表示到 <strong>65535</strong> 字节的长度（当然目前永远都不会有这么长）；</li>
<li>标识：占用 <strong>16个比特位</strong>，跟下面的 <strong>源IP地址</strong> 和 <strong>目标IP地址</strong> 共同识别分片，如果三个值一样，表示是同一个数据包的分片；</li>
<li>标志：用来标记分片情况，占用 <strong>3个比特位</strong>，第一位填充 <strong>0</strong>，第二位则表示是否可以分片 <strong>0表示可以1表示不可以</strong>，第三位则表示当前这个包是否是最后的一个数据包 <strong>0表示最后一个分片包1表示中段的包</strong>；</li>
<li>片偏移量：占用 <strong>13个比特位</strong>，表示当前这个包在用户数据起点后的第几位开始，注意的是这个值表示多少个 <strong>8位</strong>，比方说 <strong>13个比特位</strong> 全部都是 <strong>1</strong>，表示 <strong>8192</strong>，则表示原始数据起点的 *<em>8192 * 8 = 65536*</em> 的位置开始，所以除了最后一个分包，其他用户数据的位置均在 <strong>8的倍数</strong> 中切割；</li>
<li>生存时间：之前是指定在 <strong>路由器</strong> 跳转中的总时间，如果时间小于 <strong>1</strong>，则将这个数值减去 <strong>1</strong>。而现在基本指定的是在网路中跳转路由器的次数（路由器中的一跳），由于占用 <strong>8位</strong>，所以可以表示的最大值是 <strong>255</strong>，如果超过这个值，路由器则会将这个数据包给抛弃掉；</li>
<li>协议Protocol：指的是数据部分的上层协议，用于 <strong>IP协议</strong> 处理器可以判断交给哪个程序进行处理；</li>
<li>首部校验和：占16位。这个字段只检验数据报的首部，但不包括数据部分；</li>
<li>可选字段：一些其他功能的选项，1 - 40位不等，后面的位数用 <strong>0</strong> 进行填充，填充到长度为 <strong>4</strong> 的倍数</li>
</ol>
<h1 id="—-分割线-—"><a href="#—-分割线-—" class="headerlink" title="— 分割线 —"></a>— 分割线 —</h1><p>以下均为辅助 <strong>IP协议</strong> 的一些技术</p>
<h1 id="DNS技术"><a href="#DNS技术" class="headerlink" title="DNS技术"></a>DNS技术</h1><p>由于使用 <strong>IP地址</strong> 来记忆实在是太麻烦了，所以人类又发明了一项技术：<strong>DNS解析</strong> 用以映射 <strong>域名</strong> 和 <strong>IP地址</strong> 的关系。我们从浏览器输入一串域名比如 <strong><a href="https://ssn.liweidan.cn/">https://ssn.liweidan.cn</a></strong>，那么浏览器会先在本机 <strong>hosts</strong> 文件搜索有没有映射的 <strong>IP地址</strong>，如果没有，则会跑去 <strong>DNS服务器</strong> 进行搜索，从而返回 <strong>IP地址</strong> 再进行资源的访问。</p>
<p>目前我们常见的顶级域名就有 <strong>com</strong>、<strong>cn</strong>、<strong>net</strong> 等等，由 <strong>ICANN（一个非盈利的Internet管理组织）</strong> 托管，而我们国家会管理着 <strong>cn</strong> 域名的注册信息，那我们请求一个域名，就会将请求转移到 <strong>ISP</strong> 的服务器中，<strong>ISP</strong> 为了加快响应速度，则会缓存所有已经被请求过的域名映射记录，但是这里有个缺点，就是如果我们修改域名的解析记录的话，同步到各地区的 <strong>ISP</strong> 需要一定的时间，这也就是为什么我们修改一条解析记录通常会提示生效需要 <strong>2小时</strong> 左右。</p>
<p>由于解析记录有是多种，有 <strong>A记录</strong> <strong>MX记录</strong> <strong>CNAME记录</strong> <strong>TXT记录</strong> 等等，那这里只列举常用的几个：</p>
<p><img src="/images/3-IP.md/8.png" alt="域名解析"></p>
<p><strong>A记录</strong>：用于映射域名跟 <strong>IP地址</strong>；</p>
<p><strong>CNAME记录</strong>：用于将域名映射到另外一个域名的记录；</p>
<p><strong>MX记录</strong>：映射邮件服务器的记录（如果有域名可以映射到QQ邮箱，<a href="/images/3-IP.md/9.com/s?id=1669389745509038972&wfr=spider&for=pc">QQ邮箱中使用个人域名作为域名邮箱</a></p>
<h1 id="ARP技术"><a href="#ARP技术" class="headerlink" title="ARP技术"></a>ARP技术</h1><p>那么根据之前所说的数据链路传输所说，发送数据是需要知道对方的 <strong>MAC地址</strong> 的，但是我们现在是在上面套了一层 <strong>IP地址</strong>，那就需要 <strong>ARP技术</strong> 来拿到对应的 <strong>MAC地址</strong> 了，这个方式有点像上面的 <strong>DNS解析</strong>。</p>
<p>怎么获取咧，就是当前如果在缓存中找不到 <strong>IP地址</strong> 和 <strong>MAC地址</strong> 的对应记录，就需要对网络中所有的设备发送一个 <strong>ARP包</strong>，当目标地址的设备拿到这个 <strong>ARP包</strong> 的时候将会将结果响应回去，而如果匹配不到当前的机子，则会将这个 <strong>ARP包</strong> 抛弃掉。</p>
<p>那为啥中间还要套一层 <strong>IP层</strong> 咧，直接用 <strong>MAC地址</strong> 不行咩，那就要涉及到我们上面所说的 <strong>IP分段</strong> 技术了，这一项技术是在 <strong>IP协议</strong> 层实现的，所以有必要套这一层，要不然我们要获取一个 <strong>MAC地址</strong> 就需要向全世界每一台计算机发送 <strong>ARP包</strong> 了。当然连接了 <strong>路由器</strong> 的话，第一条请求到的 <strong>MAC地址</strong> 就是 <strong>路由器</strong> 的了，并非目标计算机的 <strong>MAC地址</strong>。</p>
<p><strong>IPv6</strong> 无法使用这些技术，需要用 <strong>ICMPv6</strong> 来获取。</p>
<h1 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h1><p>常用于小型的机器例如打印机需要获取自己的 <strong>IP地址</strong> 的情况（或者其他不支持 <strong>DHCP</strong> 的设备），打印机发送自己的 <strong>MAC地址</strong> 去 <strong>RARP服务器</strong> 询问 <strong>IP地址</strong>，从而将返回的信息设置为自己的 <strong>IP</strong>。</p>
<h1 id="ICMP信息描述"><a href="#ICMP信息描述" class="headerlink" title="ICMP信息描述"></a>ICMP信息描述</h1><p>这个可以理解为 <strong>Java</strong> 中的 <strong>异常信息栈</strong>，指出 <strong>数据包</strong> 在发送过程中遇到了什么问题，为什么没有到达目的地，封装成 <strong>ICMP通知消息</strong> 给发送端，通常用于辅助调试网络设备。</p>
<p>也可以用于 <strong>TTL超时</strong> 的时候返回错误信息，也可以用于判断发送的数据包是否已经成功到达对端（常用的 <strong>ping</strong> 就是基于这个技术实现的）</p>
<h1 id="IP自动分配–DHCP"><a href="#IP自动分配–DHCP" class="headerlink" title="IP自动分配–DHCP"></a>IP自动分配–DHCP</h1><p>一般现在的 <strong>路由器</strong> 都内置了 <strong>DHCP服务器</strong> 的功能，用于设备开机联网的时候可以询问 <strong>IP地址</strong> <strong>子网掩码</strong> 等必要的联网信息，并且会定时的延长 <strong>IP地址</strong> 的使用期限。</p>
<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p><strong>NAT（Network Address Transfer）</strong> 是一项本地网络使用私有地址，而联网的时候将私有地址转换为 <strong>全局IP地址</strong> 的一项技术。而且在传输层的 <strong>TCP</strong> 和 <strong>UDP</strong> 还出现了 <strong>NAPT（Network Address Ports Transfer）</strong> 用于转换端口的技术。<strong>NAT技术</strong> 实则是为了解决 <strong>IPv4地址</strong> 枯竭而发明的，也正是现在用的最多的技术。</p>
<p>按照这个逻辑，那当然还是交给 <strong>路由器</strong> 啦（心疼路由器）。它内部会生成一张表，用来转换 <strong>私有地址</strong> 和 <strong>全局地址</strong>。当然如果 <strong>IP地址</strong> 的转换还不够用的话，那估计还需要将 <strong>端口</strong> 参与一起转换（此时使用的是 <strong>NAPT</strong>）</p>
<p>尔后为了 <strong>IPv4</strong> 和 <strong>IPv6</strong> 的转换，又有了一项信息的 <strong>NAT</strong> 规范：<strong>NAT-PT</strong>。</p>
<p>但是普通的 <strong>NAT技术</strong> 并没办法让外部服务器连接内部服务器，所以又出了一项 <strong>NAT穿越</strong> 的技术，就好像我们日常调试公众号的时候，可以使用一些软件将外部的请求重定向到我们本机进行调试一样。</p>
<h1 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h1><p><strong>IP隧道</strong> 一般架设在 <strong>两个IPv6网络之间</strong>，由于 <strong>两个IPv6网络之间</strong> 需要通讯，但是他们中间只有一个支持 <strong>IPv4</strong> 的网络连接，就可以使用 <strong>IPv4包着IPv6</strong> 的方式，将数据传输过去。发送端使用 <strong>IPv4协议</strong> 用户数据包着 <strong>IPv6</strong> 的所有数据（包括 <strong>IP头部</strong>），接收端再将外壳（<strong>IPv4</strong>）拆掉，用 <strong>v6</strong> 的方式进行解析即可。</p>
<h1 id="其他IP协议"><a href="#其他IP协议" class="headerlink" title="其他IP协议"></a>其他IP协议</h1><p><strong>IP多播相关技术</strong>：<strong>MLD</strong>，通知路由器表示自己想要接收多播消息，以及向集线器请求接收多播的地址；</p>
<p><strong>IP任播</strong>：发送一个请求，被不定向的服务器接收，比如我们在请求 <strong>DNS解析记录</strong> 的时候，就需要发送一个任播请求，响应的可以是地区的 <strong>DNS服务器</strong>，也可以是其他的比较接近的服务器（最靠近那个宕机的情况）</p>
<p><strong>通信质量控制</strong>：<strong>QoS</strong> 用于衡量 <strong>IP传输</strong> 质量的参数。<strong>IP协议</strong> 一般只负责 <strong>尽力传输</strong>，而如果遇到路由器的 <strong>Buffer</strong> 过大导致宕机，则会引起丢包的问题。所以使用 <strong>QoS</strong> 参数进行衡量。当发生网络拥堵时，可以使用 <strong>ECN</strong> 来显式通知发送端，一般存在返回的 <strong>TCP</strong> 首部中，记录在发送出去的 <strong>IP首部</strong>，网络层和传输层共同协助实现拥塞通知的功能。</p>
<p><strong>Mobile IP</strong>：手机肯定是不断移动的设备，但是如果每移动到一个地方就需要重新获取 <strong>IP地址</strong> 将会对上层传输层的开发造成很大的麻烦，所以我们就需要一个固定不变的 <strong>IP地址</strong>，所以就需要使用到 <strong>IP隧道</strong> 类似的技术，将数据进行转发。移动设备分配到的 <strong>IP地址</strong> 属于归属地址，而每个地方有不同的 <strong>归属代理</strong>，会进行 <strong>分配到的IP地址</strong> 与 <strong>归属到的IP地址</strong> 进行转换，从而有一种即使移动了换了 <strong>代理</strong> 了，但是 <strong>IP地址</strong> 也没有进行改变的错觉。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>阐述了 <strong>IP地址</strong> 的组成结构，<strong>IP数据包</strong> 的内容，但是这些并不完成 <strong>重发</strong> <strong>校验</strong> 等功能，只负责最大能力的 <strong>运输数据</strong>，而 <strong>重发</strong> <strong>校验</strong> 可以说是能够传输数据后保证数据完整性的重中之重，但是这些内容将放在 <strong>传输层</strong> 进行处理。那就有 <strong>TCP</strong> 和 <strong>UDP</strong> 协议的诞生，下节再说吧。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>初识计算机网络</title>
    <url>//network/1-Find-Computer-Network/index.html</url>
    <content><![CDATA[<h1 id="生活中熟悉又陌生的网络"><a href="#生活中熟悉又陌生的网络" class="headerlink" title="生活中熟悉又陌生的网络"></a>生活中熟悉又陌生的网络</h1><p>在我刚开始了解算计网络之前，我一直认为计算机网络应该指的是：<strong>一台电脑连着网线，他可以通过操作系统上的各个软件访问网络上的资源</strong> 才叫网络。但是其实不是，作为一个 <code>94</code> 年出生的臭男人，其实在小的时候就已经接触到了网络了。那就是电视。</p>
<p>以前我家里的电视大概是这种（图片来自百度）：</p>
<p><img src="/images/1-Find-Computer-Network.md/0.png"></p>
<p>以前这台电视可贵了，<code>3000</code> 多块，可以想象在 <code>1994</code> 年的时候，是什么样的概念。</p>
<a id="more"></a>

<p>那么既然有电视，不可能是单机运行（其实他也运行不了什么）。那么 <code>网络</code> 在哪个地方出现了，那就是 <code>有线电视台</code>。家里的大人去电视台说我家要拉电视线，那边的工作人员就会过来，然后拉了一条线进家里，大概就是这种线（图片来自百度）：</p>
<p><img src="/images/1-Find-Computer-Network.md/1.png"></p>
<p>接上去，我们的电视就可以收看 <code>56个</code> 妇科广告的节目。</p>
<p>当然，现在这种线我们终于知道了，有个专业的名字，叫做 <strong>同轴电缆</strong>。这也我最早见到的 <code>计算机网络7层</code> 协议中的第一层 <strong>物理层</strong> 的连接线了。</p>
<p>那么后来，在我读小学的时候，家里装了电话机，那么这时候，又一条网络接入我家里来，而我们肯定知道，当我们的电话在通话的时候，别人如果想要连接进来的话，是实现不了的，会一直提示（宁波打的电话正在通话中…）</p>
<p>这种线长这个样子（图片来自百度）：</p>
<p><img src="/images/1-Find-Computer-Network.md/2.png"></p>
<p>那他现在也有个正经名字：<strong>双绞线缆</strong>。</p>
<p>后来家里入了电脑，毕竟为了 <strong>玩游戏</strong> 嘛。印象深刻的就是又是拉电话的那个大叔，挎着个包进来我家门，然后在电话线那里插上一个类似于 <strong>一分二</strong> 的接口，一个接口接电话，另外一个接口则是接上 <strong>猫（英文名Modem，是一款调制解调器）</strong> 然后再把 <strong>猫</strong> 的一个网线接口接上电脑，再在电脑上配置一波，然后跟我说以后电脑开机需要上网的话就需要先启动一下这个，然后点击 <strong>连接</strong> 才可以进行上网：</p>
<p><img src="/images/1-Find-Computer-Network.md/3.png"></p>
<p>OK，等师傅走了以后，我就打开浏览器，输入 <strong>9744。com</strong> 进行快乐的网上冲浪了。</p>
<p>那么搁现在用专业名词讲，那就是 <strong>拨号连接</strong>，协议使用的是 <strong>PPPoE</strong>。怎么说呢，我们的运营商要收钱，要收钱就需要验证你现在要上网时的用户名和密码，那么就需要通过拨号软件将这些信息提供给运营商的 <strong>ISP服务器</strong>，然后后续我们的电脑将需要上传给服务器的数据通过 <strong>PPP协议</strong> 的编码方式进行编码（依赖 <code>CPU</code>，还会消耗计算机的性能），然后发送给 <strong>ISP服务器</strong>，<strong>ISP服务器</strong> 是互联网中的一员，所以就可以将 <strong>IP数据包</strong> 发送出去从而提供互联网服务。</p>
<p>那么曾经那个在网上冲浪学习的 <strong>精壮少年</strong> 长大了，这时候网络已经发展到 <strong>光纤</strong> 时代，曾经的电话线 <code>2m</code> 的速度跟现在办卡送宽带的 <code>300m</code> 光纤已经没法比了，这时候的线（来自百度）：</p>
<p><img src="/images/1-Find-Computer-Network.md/4.png"></p>
<p>师傅调试的时候，用一个 <strong>手电筒</strong> 插到线的一头上，即可在楼下查找与其连通的另外一端。</p>
<p>光纤的原理粗糙的说，就是通过光的反射来传递数据，而这个牛逼的东西出自一个牛逼的华裔物理学家 —— 高锟。光速是目前所发现的自然界物体运动的最大速度，那么用他来传递数据速度肯定不用说的了。</p>
<h1 id="计算机模型——OSI七层协议"><a href="#计算机模型——OSI七层协议" class="headerlink" title="计算机模型——OSI七层协议"></a>计算机模型——OSI七层协议</h1><h2 id="分层预览"><a href="#分层预览" class="headerlink" title="分层预览"></a>分层预览</h2><p>OK，上面聊了这么多我跟网络的往事，那么目的就是为了把 <strong>计算机网络基础</strong> 聊清楚，那么我们来看个熟悉又陌生的 <strong>osi七层模型</strong>，然后我们分层慢慢来说。</p>
<p><img src="/images/1-Find-Computer-Network.md/5.png"></p>
<p>那其实这七层协议中，再结合上面的宝贵的 <strong>人生经历</strong> 中，我们通常看到的，只有上面的 <strong>应用层</strong> 和 下面的 <strong>物理层</strong> 我们可以看个基础。应用层这个不用说，就是应用嘛，<code>QQ</code>、<code>微信</code>、<code>浏览器</code> 等等就是我们的应用层了，而 <strong>物理层</strong> 则是上面提到的那些线和调节器（猫）。</p>
<p>我看了这个分层好几年了，没能理解，最近刚好终于理解了他存在的意义：这个分层只是一个 <strong>参考模型</strong>，他提供的是 <strong>应用数据</strong> 到 <strong>电平</strong> 的转换模型，实际我们应用的并没有这么多层，而是把一些好几个都合并到一个层去了，也就是后面我们会说到的 <strong>TCP/IP协议</strong>。但是这个模型还是能够很好的帮我们理解我们日常操作的数据是怎么在 <strong>操作系统</strong> 中翻译并且传递到另外一个计算机去的。</p>
<h2 id="分层的作用"><a href="#分层的作用" class="headerlink" title="分层的作用"></a>分层的作用</h2><p>鲁大爷曾经说过：<strong>计算机世界中的任何问题，没有什么是包一层解决不了的，如果有，那就包两层</strong></p>
<p><img src="/images/1-Find-Computer-Network.md/6.png"></p>
<p>所以现在你终于知道为什么包了 <strong>7层</strong> 了趴。</p>
<p>那首先我们从第 <code>7</code> 层开始阐述。</p>
<ol>
<li>应用层：应用层就是我们熟悉的应用了，每一个应用都会有自己的协议，比如最简单的 <code>HTTP协议</code>（<code>Header</code>、<code>body</code>）这些是必要的，他在发送端就是将用户数据进行包装，而在接收端则需要将上一层的数据进行解包展现在界面上；</li>
<li>表示层：那么表示层是一层只为 <strong>应用层</strong> 以及 <strong>会话层</strong> 服务的分层，他负责将应用层上送过来的数据进行编码、加密、压缩等等操作，比如使用 <strong>UTF-8</strong> 编码将上面的信息进行编码，然后将包装以后的数据加上自己的 <code>Header</code> 转发给下一层的 <strong>会话层</strong>；</li>
<li>会话层：他管理着连接何时开始打招呼，何时保持连接、断开连接以及发送数据的顺序，然后他将表示层传递过来的数据继续包一层自己的 <code>Header</code> 然后往下一层的 <strong>传输层</strong> 进行传递；</li>
<li>传输层：会话层已经对何时连接这些问题进行了管理，那么这一层是需要对数据的完整性进行检查的，两边的传输层会互相确认：“这个数据接收完整了吗？”，如果不完整，那么传输层将会对这个数据进行重发，继续包一层自己的 <code>Header</code> 进行传递给网络层；</li>
<li>网络层：这一层做的事情就跟数据无关了，而是跟目的地有关，就是找出目标服务器的地址，或者中转服务器的地址（相当于一个快递从北京过来广东，需要经过很多中转点），然后将数据包一层 <code>Header</code> 发出去，至于发出去的下一个中转站的位置，就有可能由接下去连接的路由器或者运营商的服务器进行转发了；</li>
<li>数据链路层：这个就是上面所说的一系列的 <strong>连接线</strong>（同轴电缆、双绞线、光纤线等等）</li>
<li>物理层：数据在我们熟知的生活介质中的表达方式，比如电平的正负极怎么表示机器码中的0和1，多少个正极连在一起就是一个整体等等</li>
</ol>
<p>然后我们现在可以回过头来看看这个图了：</p>
<p><img src="/images/1-Find-Computer-Network.md/7.png"></p>
<p>接收端接收到物理层的状态的时候，就需要逆向向上翻译，从而将信息展现在接收端的机器上（控制台啊屏幕啊什么的）</p>
<h1 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h1><p>那我们假想上面的 <code>OSI七层协议</code> 是两台计算机之间传递数据的方式，这时候镜头要拉远一点了，在广东的小男生是怎么访问到远在不知道哪个地方的学习网站的。</p>
<p>那么接下来就需要说三个问题：</p>
<ol>
<li>数据传输过程中的可靠性；</li>
<li>数据怎么去目的地（<strong>IP地址</strong>）；</li>
<li>宏观网络的构成（众多的转发器的连接方式）。</li>
</ol>
<h2 id="数据传输的可靠性"><a href="#数据传输的可靠性" class="headerlink" title="数据传输的可靠性"></a>数据传输的可靠性</h2><p>我们熟悉的 <code>TCP</code> 和 <code>UDP</code>（这两个不属于七层的内容），区别就是有无连接：</p>
<p><img src="/images/1-Find-Computer-Network.md/8.png"></p>
<h2 id="数据的目的地"><a href="#数据的目的地" class="headerlink" title="数据的目的地"></a>数据的目的地</h2><p>那么目前的解决方案就是：<strong>IP地址</strong> + <strong>端口号</strong>。</p>
<p>IP地址规定了去到哪台计算机，而端口号则是在定位到某台计算机的情况下，将数据传输给某个应用进行处理。</p>
<h3 id="地址必须具备唯一性（在一个网络内）"><a href="#地址必须具备唯一性（在一个网络内）" class="headerlink" title="地址必须具备唯一性（在一个网络内）"></a>地址必须具备唯一性（在一个网络内）</h3><p>那么结合我们生活中遇到的问题来说，在同一个区域之内，地址是不允许重复的，要不然我们在寻找某个地址的时候就很容易出现迷惑：到底应该去哪一个。而这个也可以结合下面将要说的分层来确定唯一性。比方说：在珠海，金湾区有个地点叫做 <strong>湖心路口</strong>，而在 <strong>吉林大学珠海学院</strong> 里，也有一个 <strong>湖心路口</strong>，那么我们就需要在不同的场景之下定义他的唯一性：我去金湾区的湖心路口或者我去吉珠的湖心路口。</p>
<h3 id="地址的分层"><a href="#地址的分层" class="headerlink" title="地址的分层"></a>地址的分层</h3><p>我们熟悉的 <code>IPv4</code> 地址是有 <code>4</code> 个部分组成的，比如 <code>192.168.1.1</code> 就是指定当前网络中的某台计算机，而前面的 <strong>几个部分</strong> 可以先简单粗略的认为是分区，比如 <code>广东省广州市天河区</code> 这样，那么数据在网络中进行转发的时候，就可以一层一层的传递到目标主机去。</p>
<h3 id="宏观网络的构成"><a href="#宏观网络的构成" class="headerlink" title="宏观网络的构成"></a>宏观网络的构成</h3><p>那么一台计算机（不仅仅指的是电脑）在实现访问世界上任何资源的时候，总是会或多或少具备这几个东西：<strong>网卡</strong>、<strong>中继器</strong>、<strong>网桥</strong>、<strong>路由器</strong>。</p>
<p>那么我们先来一个表总结一下这些元件，后面会指出代表 <code>OSI模型</code> 的哪些层，顺序是由 <strong>高层</strong> 到 <strong>低层</strong>。</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>OSI模型层</th>
<th>简要作用</th>
</tr>
</thead>
<tbody><tr>
<td>网卡</td>
<td>数据链路层、物理层</td>
<td>连接计算机和网络设备的中间设备</td>
</tr>
<tr>
<td>中继器</td>
<td>数据链路层、物理层</td>
<td>延长物理层网络的设备</td>
</tr>
<tr>
<td>网桥</td>
<td>网络层、数据链路层、物理层</td>
<td>连接两个网络的设备，根据MAC地址转发</td>
</tr>
<tr>
<td>路由器</td>
<td>网络层、数据链路层、物理层</td>
<td>可以根据IP地址转发</td>
</tr>
<tr>
<td><strong>4-7</strong> 层交换机</td>
<td>可以跨越所有层</td>
<td>分析收发数据，进行特殊处理</td>
</tr>
<tr>
<td>网关</td>
<td>可以跨越所有层</td>
<td>翻译协议并转发数据</td>
</tr>
</tbody></table>
<h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><p>这个就没什么好说的了，每一次组装电脑，网卡都是必不可少的东西。他连接着我们的主板和网线，反正又是 <strong>套了一层</strong>，并且负责将线路中的物理信息翻译成我们的机器码，以供CPU和操作系统进行处理。</p>
<h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>可以套在不同的传输介质中间进行翻译的器件，比如我们安装了光纤，那么我们就可以将家里普通网线的 <strong>0和1</strong> 两种不同的信号翻译成光信号，而他做的事情就是这个，就算我们传输数据的过程中，数据出现了错误，他也会一五一十的将其翻译并且传输出去。比如我们的 <strong>猫（Modem）</strong>，也可以是无线电翻译成网络运营商的信号（比如无线路由器中的模块）</p>
<h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>他可以将两个不同的网络端连接起来，比方说，我们在一个小区里边，一栋楼（老式，不高，网络端口不多的那种），那么一栋楼就可以归为一个局域网。然后比方说我们从 <strong>A栋</strong> 连接到 <strong>B栋</strong>，那么这时候就可以使用网桥的方式。</p>
<p>网桥也有自己的内存，他可以将接收到的网络数据储存起来，然后生成一个全新的数据发送给相连的另外一个网段。而有些网桥还可以 <strong>自学</strong>，他会学习 <strong>A网段</strong> 中有哪些网卡的 <strong>MAC地址</strong>（不一定是终端电脑），并且决定此时接收的数据包需不需要发送给隔壁的 <strong>B网段</strong>。</p>
<h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p>路由器其实作用跟 <strong>网桥</strong> 差不了多少，但是唯一区别就是，路由器是根据 <code>IP地址</code> 进行终端寻找的，所以在 <code>TCP/IP模型</code> 中，经典的 <strong>OSI网络层</strong> 就变成了 <strong>IP地址</strong>。</p>
<p>现在的路由器功能也很多，比如我家里的那个，可以连接 <strong>花生壳</strong> 还可以在通网络运营商中通过 <strong>IP</strong> 访问到我电脑上的资源等等。</p>
<h4 id="4-7-层交换机"><a href="#4-7-层交换机" class="headerlink" title="4-7 层交换机"></a><strong>4-7</strong> 层交换机</h4><p>这个功能就很多了，可以负责所有层的数据，并且识别一些恶意请求，将合法请求传输到指定的服务器等功能。例如我们熟悉的 <strong>F5负载均衡</strong> 方案，就是可以在服务器之前假设这样的一层设备，用于流量之间的负载均衡。价格嘛，还是比较昂贵的。</p>
<p>所以我们现在编程过程中一般用软件来实现负载均衡这个功能。</p>
<p><img src="/images/1-Find-Computer-Network.md/9.jpeg"></p>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>这个我们现在就很少见到了，但是我们的编程模型中就有 <code>Spring-Cloud-Gateway</code> 或者 <code>Spring-Cloud-Zuul</code> 这种网关框架，作用就是可以对我们的数据进行一些转发保护以及记录，也不在这里做重点。一般数据进来就是客户端与这个网关交互，至于网关怎么用请求数据做什么，包装啊什么的，然后调用后端隐藏的应用进行处理，用户是感知不到的。最后网关拿到返回数据的时候，又重新包装，返回给客户端。</p>
<hr>
<p>说了这么多模型，那么有些 <strong>长得帅但憨憨</strong> 网友就要问了，你可以说一下小区的网络模型鸭：</p>
<p><img src="/images/1-Find-Computer-Network.md/10.png"></p>
<p>把上面几个设备拼来拼去就行了呗，反正不同地区的模型内涵差不多但可能用的设备顺序方法又不一样。</p>
<hr>
<h1 id="现代网络协议-TCP-IP"><a href="#现代网络协议-TCP-IP" class="headerlink" title="现代网络协议 TCP/IP"></a>现代网络协议 TCP/IP</h1><p>聊了这么多基础性的东西，其实是我想聊 <strong>TCP/IP协议</strong> 的。那么是时候进行转换了。</p>
<p><strong>TCP/IP协议</strong> 是由 <strong>IETF组织(The Internet Engineering Task Force,简称 <em>IETF</em>)</strong> 讨论制定的，他的过程更趋向于实用性和开放性，而且是基于邮件进行讨论，并且制定了一些规则来淘汰没有意义的讨论，所以当一些特性被写入规范的时候，都已经进行过深度的测试和实现的，所以可以说是先有程序，再制定规范的一种协议。</p>
<p>参考文档：</p>
<p><a href="http://www.ruanyifeng.com/blog/2011/03/ietf.html">阮一峰——IETF：互联网精神的典范</a></p>
<p>而这个组织呢，会针对网络连接各个要素进行讨论，并且形成 <strong>RFC（Request For Comment）</strong>，可以当成是一种会议记录，详细的记录了每一种协议（比如 <strong>TCP</strong> <strong>IP</strong> 等等）的内容、实现、以及运用的相关信息。所有人都可以查询，并且加入讨论。然后关于文档的管理方式也很 <strong>区块链</strong>：一旦这个文档形成加入 <strong>RFC</strong>，将不能对这个文档进行任意的修改，如果需要拓展修改，则需要生成新的 <strong>RFC</strong> 提交并且对旧的 <strong>RFC</strong> 标记作废。我们可以通过 <a href="https://www.rfc-editor.org/">这个网址</a> 访问所有的 <strong>RFC</strong> 内容。</p>
<p>一个方案一般会经历以下的几个阶段：草案，提议，标准化。一个草案的有效期一般是 <strong>6个月</strong>，如果这个时间内还没有得出结果，那么这个草案将会被消除。而如果经过了充分的讨论，并且得到 <strong>IETE</strong> 主要成员的认可，那么即可编入 <strong>RFC文档</strong>。然后如果这个标准被众多的设备所应用，并且没有什么奇奇怪怪的问题，那么即可成为一种 <strong>标准</strong>。如果有问题，那么又要经过修订生成新的 <strong>RFC文档</strong>。而开山之作 <strong>TCP/IP</strong> 比较牛逼，他并没有经过这些过程，而是先在设备中使用了，然后被编入标准的。</p>
<p>关于 <strong>TCP/IP</strong> 的内容，放在下一篇继续聊。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层的协议-TCP/UDP</title>
    <url>//network/4-TCP-UDP/index.html</url>
    <content><![CDATA[<h1 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h1><p>既然了解了 <strong>IP协议</strong> 的内容，上一篇通篇没有说到数据的安全性，因为 <strong>IP协议</strong> 只负责将数据运输到对应的计算机而已，不会对数据做任何操作，也不会验证数据是否完整到达或者有没有被破坏，或者交给哪个程序进行处理。而这些操作，是由 <strong>传输层协议</strong> 来做保证的。</p>
<p>传输层目前我们最流行的协议应该是 <strong>TCP</strong> 和 <strong>UDP</strong> 了吧。前者是有连接的情况下传输数据，而后者则不会考虑数据是否完整到达，但是效率会比 <strong>TCP</strong> 略胜一筹。当然两者都有合适的使用场景。<strong>TCP</strong> 很多时候会用于设备之间的连接和数据传递，比如仓库 PDA 的使用。而 <strong>UDP</strong> 则多用于通话、视频方面的应用，还有我们熟知的 <strong>微信QQ</strong>，也是使用 <strong>UDP</strong> 作为传输协议的，他利用了 <strong>UDP</strong> 的效率，然后在 <strong>应用层</strong> 适配了数据完整性的校验。所以很多时候我们会有这种场景，我这边发送的消息显示个红色的❌，但是其实对方已经接受到刚刚发送的消息了，但是我们以为没有接收到又重新发了一次。还有直播类型的 <strong>应用层协议</strong> 多用 <strong>UDP协议</strong>。</p>
<p>那，既然 <strong>IP协议</strong> 已经将数据传送到当前服务器了，服务器就应该具有一定的程序进行处理，要不然服务器也会懵逼。这个过程就通过解开客户端发送的数据，里面包含了一个参数称为 <strong>端口号</strong>，服务器系统就会交给监听这个 <strong>端口</strong> 对应的应用程序进行处理。依然是拿快递行业做类比，我们知道我们的地址一般会写到家里或者附近的地方，<strong>IP协议</strong> 就是负责将这个件送给对应的这个区域而已，但是这个区域有那么多人，根本不知道要交给谁，所以这时候快递员就需要用电话联系快递单号上的收件人电话，然后将件交给收件人。那么这个 <strong>收件人电话</strong> 就相当于端口号了。</p>
<p>这些服务端处理的 <strong>程序</strong>，将会监听着服务器系统上的 <strong>空闲端口</strong>。当这些端口有数据进来的时候，自然他们就可以接收到数据进行处理。当然如果这个 <strong>端口</strong> 被占用的话，程序是会启动失败的。但是不同的协议是可以监听同一个端口的，比方说当前有个 <strong>Tomcat</strong> 程序监听着 <strong>8080</strong>，我们还可以用另外一个程序，以 <strong>UDP</strong> 的协议继续监听这个 <strong>端口</strong>。</p>
<p>一般来说，<strong>0 ~ 1023</strong> 留给一些知名程序进行处理（比如 <strong>sshd</strong> <strong>HTTP</strong>），如果我们需要占用端口，一般从 <strong>1024</strong> 开始，最大的端口号是 <strong>65535</strong>。当然这些端口也可能被我们启动的某些比较有名的程序占用，比如 <strong>Redis</strong> 占用 <strong>6379</strong>，<strong>Tomcat</strong> 占用 <strong>8080</strong> 等等。但是通常如果不需要这些程序的话，我们是可以使用这些端口的。</p>
<a id="more"></a>
<h1 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h1><p><strong>UDP（User Datagram Protocol）</strong> 的内容比较简单，先来说说 <strong>UDP</strong>。</p>
<p><strong>UDP协议</strong> 一般用来做 <strong>效率要求第一但数据不要求一定要完整</strong> 的场景，比如 <strong>通话</strong> <strong>视频直播</strong>。这两项总不能用 <strong>TCP</strong> 来做，加入用 <strong>TCP</strong> 来做的话，有可能这个包不完整然后发送端又重新发了，那么将会导致 <strong>视频</strong> 重复播放某一帧，这显然是不允许的。</p>
<p><strong>UDP协议</strong> 只实现了最简单的功能，也就是 <strong>应用程序</strong> 数据的传输，它可以保证收到的数据是完整的（先放下分包的问题），但是不能保证一定能到达接收方。因此我们也不用在我们自己的消息体中设置一个分隔符或者消息长度，因为收到的消息基本是一个固定的包，客户端是怎样的，接收端就是怎样的。</p>
<h2 id="UDP首部信息"><a href="#UDP首部信息" class="headerlink" title="UDP首部信息"></a>UDP首部信息</h2><p><strong>UDP</strong> 的首部信息包含四个内容：<strong>源端口号（2byte）</strong>、<strong>目标端口号（2byte）</strong>、<strong>包长度（2byte）</strong> 以及 <strong>校验和（2byte）</strong>。一共 <strong>8byte</strong> 的长度。</p>
<ul>
<li>源端口号：可选项，如果客户端不需要接收返回的消息，则可以设置为 <strong>0</strong>；</li>
<li>目标端口号：一般存储服务器处理程序监听的端口号；</li>
<li>包长度：<strong>UDP头部信息</strong> 长度 和 <strong>数据部分</strong> 的长度之和；</li>
<li>校验和：该字段为了提供可靠的 <strong>UDP首部</strong> 和 <strong>数据</strong> 而设计的，协议的校验需要 <strong>源和目标的IP地址</strong>、<strong>协议号</strong>、还有 <strong>发送接收端两边的端口号</strong> 参与计算（称为 <strong>伪首部</strong>）。这个校验和是为了验证 <strong>IP</strong> <strong>端口</strong> <strong>协议</strong> 三个关键值的正确以防止数据对其他的 <strong>应用</strong> 产生干扰而设置的。</li>
</ul>
<h2 id="UDP的分包问题"><a href="#UDP的分包问题" class="headerlink" title="UDP的分包问题"></a>UDP的分包问题</h2><p>上面我们说了，<strong>UDP</strong> 可以保证接收到的信息是完整的。但是这里有个前提条件，就是不需要被 <strong>IP协议</strong> 进行分包的信息。比方说，我发送了 <strong>ABCD</strong>，接收端要么没收到，要么就收到 <strong>ABCD</strong>，毕竟这四个字符如果用 <strong>UTF-8</strong> 进行编码的话，也只是需要 <strong>4byte</strong>。</p>
<p>而如果我们分包大于系统设置的默认 <strong>MTU</strong> 从导致一个消息被分成多个 <strong>分片</strong> 的情况下，要么所有 <strong>分片</strong> 都接受到了，系统重组成功返回给 <strong>应用程序</strong>，要么 <strong>分片</strong> 不完整或者受损导致无法重组从而系统将整个 <strong>UDP</strong> 消息丢弃。</p>
<p>那我们来推断一下，数据应该在多少字节的情况下能够安全的发送消息，首先我们知道一个 <strong>以太网帧</strong> 是 <strong>1500byte</strong>，而 <strong>IP协议首部信息</strong> 占用了 <strong>20byte</strong>（没有可选参数的情况下），说明 <strong>IP数据包</strong> 的 <strong>数据部分</strong> 只有 <strong>1480byte</strong>，而 <strong>UDP首部信息</strong> 的长度是 <strong>8byte</strong>，所以一个 <strong>MTU</strong> 中我们可以存放的空间是 <strong>1472byte</strong>。</p>
<p>但是但是，我们之前已经说了，如果传播图中有个设备小于 <strong>MTU</strong>，则使用的是最小的 <strong>MTU</strong> 进行数据传输（木桶定理）所以即使是 <strong>MTU=1500</strong> 的情况下，如果需要转发的 <strong>设备</strong> 过多的话，这个值 <strong>1472byte</strong> 也不是一个稳定的值，所以我们只能在我们知道设备信息的情况下（比如办公室局域网），<strong>应用程序</strong> 以 <strong>1472byte</strong> 进行分包发送数据。那如果需要发送到公网的数据咋办，我们就只能使用 <strong>Internet上的标准MTU值 576byte（其实也就是目前互联网上可能存在的旧设备链路处理的 MTU 值）</strong> 的内容进行数据传输，才不容易出现奇怪的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Network             MTU (bytes)</span><br><span class="line">-------------------------------</span><br><span class="line">16 Mbps Token Ring        17914</span><br><span class="line">4 Mbps Token Ring          4464</span><br><span class="line">FDDI                       4352</span><br><span class="line">Ethernet                   1500</span><br><span class="line">IEEE 802.3/802.2           1492</span><br><span class="line">PPPoE (WAN Miniport)       1480</span><br><span class="line">X.25                        576</span><br><span class="line"></span><br><span class="line">via https://support.microsoft.com/en-hk/help/314496/the-default-mtu-sizes-for-different-network-topologies</span><br></pre></td></tr></table></figure>
<h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p><strong>UDP</strong> 只是一个简单的过度 <strong>传输层</strong> 的协议，但 <strong>TCP</strong> 就不一样了，<strong>TCP</strong> 会给予承诺说所有的数据使用 <strong>TCP</strong> 协议的话基本上是不会丢失的。即使 <strong>IP数据包</strong> 经过很多跳 <strong>路由器</strong> 被丢弃了，但是 <strong>TCP</strong> 的发送端会接听接收端的接收情况，如果一直在一定的时长内没有收到接收端的接收确认，他将会继续将这一部分数据进行 <strong>重发</strong>，直到所有数据发送完毕为止。</p>
<p>我们可以假想使用 <strong>TCP协议</strong> 连接的两个应用程序中连接了一条 <strong>管道</strong>（但其实 <strong>IP层</strong> 并没有任何的管道，都是靠一问一答的方式来实现这个虚拟的假想的），就类似于 <strong>水管</strong> 一样，水就是 <strong>数据</strong>，但是水是会连连不断的 <strong>传输</strong> 过来的，所以我们的 <strong>应用程序</strong> 就需要使用自己的一些规范，比如 <strong>分隔符</strong> 或者 <strong>换行符</strong> 来切割每次发送端发送的不在同一个业务内的 <strong>数据</strong>。</p>
<h2 id="TCP首部信息"><a href="#TCP首部信息" class="headerlink" title="TCP首部信息"></a>TCP首部信息</h2><p><strong>TCP首部信息</strong> 相比 <strong>UDP首部信息</strong> 就要复杂很多，毕竟有来来回回的应答在。</p>
<p><img src="/images/4-TCP-UDP.md/0.png" alt="TCP首部信息"></p>
<p>简单的喵几个比较有意思的字段吧：</p>
<ul>
<li>序列号Seq：这个序列号表示传输到数据的哪个位置，但并不是从 <strong>0</strong> 开始的，而是一个随机数，再加上位置的长度，可以理解为一个相对位置吧；</li>
<li>确认应答号ACK：应答的位置标示这个位置之前的数据已经被接收完整，发送端需要发送后面的数据；</li>
<li>数据偏移：表示数据部分应该从 <strong>TCP包</strong> 的哪个位置开始算起，也可以当成 <strong>首部信息</strong> 的长度；</li>
<li>保留位：拓展使用一般设置为 <strong>0</strong>；</li>
<li>控制位：这个值一共有 <strong>8</strong> 位，如果某一位上的值为 <strong>1</strong> 时，表示这个包属于哪种类型的，分别是：<ul>
<li>CWR：这个字段和下面的 <strong>ECE</strong> 字段均用于 <strong>IP包</strong> 的 <strong>ECN</strong> 字段；</li>
<li>ECE：<strong>1</strong> 表示出现网络拥堵，通知对方将 <strong>拥塞窗口</strong> 缩小；</li>
<li>URG：表示当前包中有紧急数据需要处理；</li>
<li>ACK：<strong>1</strong> 表示 <strong>ACK</strong> 字段有效，除了最初的建立连接以外，其他的包都需要把这个值设置为 <strong>1</strong>；</li>
<li>PSH：<strong>1</strong> 表示需要把接收到的数据立刻传给上层应用协议，否则则先进行缓存；</li>
<li>RST：<strong>TCP</strong> 出现异常需要强制中断</li>
<li>SYN：用于建立连接，<strong>1</strong> 表示希望建立连接；</li>
<li>FIN：用于请求断开连接。</li>
</ul>
</li>
<li>窗口大小：<strong>8位</strong>，通知从应答号开始的位置可以接受的数据大小，<strong>TCP</strong> 不允许发送超过这个值的数据；</li>
<li>校验和：跟 <strong>UDP</strong> 类似，主要用于鉴别程序漏洞造成的首部破坏；</li>
<li>紧急指针：在控制位 <strong>URG</strong> 为 <strong>1</strong> 时有效，一般我们浏览器在加载页面的时候，如果加载不出来我们手动点击了停止加载按钮的话，就会发送一个 <strong>URG=1</strong> 的包；</li>
<li>可选选项：可以在此字段设置最大段的长度、窗口扩大值（用于拓展窗口大小字段）、时间戳（用于32位的序列号不够用的时候加以判断包的先后顺序）等等。</li>
</ul>
<h2 id="TCP连接的开始与结束"><a href="#TCP连接的开始与结束" class="headerlink" title="TCP连接的开始与结束"></a>TCP连接的开始与结束</h2><p>这也就是我们最熟悉的 <strong>三次握手，四次挥手</strong> 了，由于 <strong>HTTP</strong> 的传输层用的是 <strong>TCP</strong>，又由于他是短连接的协议，所以如果我们没有设置 <strong>Connection: Keep-alive</strong> 和 <strong>Keep-Alive: timeout=20</strong> 这两个 <strong>HTTP Header</strong> 的话，那么一个页面的每一次连接（<strong>CSS</strong>、<strong>JS</strong> 以及 <strong>异步调用</strong>），都需要经历 <strong>三次握手，四次挥手</strong>。</p>
<p>那现在我们用一个图来描述这两个过程：</p>
<p><img src="/images/4-TCP-UDP.md/1.png" alt="三次握手和四次挥手"></p>
<p>那四次挥手的起因是因为，即使发送端发送了断开的请求，但是此时彼此都还需要处理剩下的数据包。只有当所有数据包已经处理完成了，才是真正断开的时机。</p>
<h2 id="TCP数据传输的方式"><a href="#TCP数据传输的方式" class="headerlink" title="TCP数据传输的方式"></a>TCP数据传输的方式</h2><p><strong>TCP</strong> 是以 <strong>段</strong> 为单位进行数据传输的，在建立连接的 <strong>SYN</strong> 请求中，可以设置消息的最大长度 <strong>MSS（Maximum Segment Size）</strong>，理想的长度是在传输链路中不需要被分包的长度，所以一般在第二次握手，服务端返回的 <strong>ACK+SYN消息</strong> 中，就会包含这个值。</p>
<h2 id="TCP滑动窗口加快传输"><a href="#TCP滑动窗口加快传输" class="headerlink" title="TCP滑动窗口加快传输"></a>TCP滑动窗口加快传输</h2><p><strong>滑动窗口</strong> 这个词可是听了很多遍，听起来就很牛逼的样子。</p>
<p><strong>滑动窗口</strong> 之前，<strong>发送端</strong> 和 <strong>服务端</strong> 需要一来一回的确认数据是否接收完整，比如：<strong>发送端</strong> 发送 <strong>1-1000</strong> 字节的数据，然后阻塞等待，<strong>服务端</strong> 返回说 “ <strong>1-1000</strong> 字节我接受完整了，你下一个发 <strong>1001-2000</strong> 字节的数据吧”，这时候 <strong>发送端</strong> 才着手把 <strong>服务端</strong> 要求的数据发送出去。</p>
<p>而 <strong>滑动窗口</strong> 就不是这样了，而是先把 <strong>几个段</strong> 的数据发送出去，等 <strong>第一段</strong> 的数据接收到来自 <strong>服务端</strong> 的 <strong>ACK</strong> 的时候，就发送下一个段的数据，有一个固定的窗口表示当前正在处理的数据的范围。这里有个网站很不错，<a href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html">滑动窗口演示</a> 我截个图来看看。</p>
<p><img src="/images/4-TCP-UDP.md/3.gif" alt="Window"></p>
<p><strong>上方发送端</strong> 的 <strong>灰色方框</strong> 就是表示一个 <strong>滑动窗口</strong> 的大小，这个 <strong>窗口</strong> 的第一个数据 <strong>接收到ACK</strong> 以后，窗口将会往下移动（而无需等待后面的段接收到 <strong>ACK</strong>），继续发送数据。</p>
<p>一旦出现丢失的问题，接收端则会一直发送应答确认，比如说 <strong>1-1000</strong> 丢失了，<strong>2001-3000</strong> 没有丢失，则 <strong>接收端</strong> 每接收一次 <strong>滑动窗口</strong> 后面的数据，就会应答一次 <strong>下一个是1-1000</strong> 的 <strong>ACK</strong>，<strong>发送端</strong> 在接收了 <strong>3次</strong> 这一个应答就会认为数据已经丢失，即会重新发送 <strong>1-1000</strong> 的数据，然后 <strong>服务端</strong> 因为已经接受了 <strong>2001-3000</strong> 的数据，所以就会跳跃回答 <strong>下一个是3001-4000</strong> 的 <strong>ACK</strong>。</p>
<p>至于 <strong>滑动窗口</strong> 的大小，在发送数据的过程中，<strong>发送端</strong> 会时不时的发送一个 <strong>窗口探测</strong> 的请求，来彼此调整 <strong>滑动窗口</strong> 的大小。</p>
<p>而为了防止 <strong>网络瘫痪</strong> 的局势出现，<strong>TCP</strong> 还有一个概念称为 <strong>慢启动</strong>，并且有另外的一个值 <strong>拥塞窗口</strong>。为了调节 <strong>滑动窗口</strong> 的容量值，在刚启动传输的时候，将 <strong>拥塞窗口</strong> 的容量值设置为 <strong>1</strong>，之后每收到一个 <strong>ACK</strong> 应答的时候，这个 <strong>拥塞窗口</strong> 的容量值就会按照 *<em>1个数据段字节数 / 拥塞窗口字节数 * 1个数据段字节数*</em> 的比例增大，增大到 <strong>ACK</strong> 返回超时情况时（并非上面说的收到三次 <strong>ACK</strong> 的情况，这个只是单纯的返回超时了），<strong>拥塞窗口</strong> 又会缩小为 <strong>当前滑动窗口容量</strong> 的 <strong>1/2</strong>。</p>
<p><img src="/images/4-TCP-UDP.md/4.png" alt="拥塞窗口的值变化 via《图解TCP/IP》"></p>
<h2 id="提高网络利用率"><a href="#提高网络利用率" class="headerlink" title="提高网络利用率"></a>提高网络利用率</h2><h3 id="发送端的Nagle算法"><a href="#发送端的Nagle算法" class="headerlink" title="发送端的Nagle算法"></a>发送端的Nagle算法</h3><p><strong>Nagle算法</strong> 由 <strong>Nagle</strong> 发明，他的目的是减少网络中传输的小段的 <strong>TCP包</strong>，执行的方式也很简单，条件是 <strong>已发送的数据都已经收到ACK || 可以发送最大段长度数据的时候</strong>。如果此时需要发送的数据太小，则会先在 <strong>发送端</strong> 待一会再发送出去。这种方式虽然可以不用随时发送数据导致网络拥堵，但是有时候在需要比较快速传输数据的系统中却是一种障碍。</p>
<h3 id="接收端的延迟确认应答"><a href="#接收端的延迟确认应答" class="headerlink" title="接收端的延迟确认应答"></a>接收端的延迟确认应答</h3><p>这个就是上图的 <strong>滑动窗口</strong> 的加强补充，<strong>接收端</strong> 没有必要为每一段数据进行应答，可以等待再接收多一点的数据再一起应答，只要应答的序列是递增的 <strong>发送端</strong> 就会认为已经收到数据了。最大延迟 <strong>0.5秒</strong> 再发送 <strong>ACK应答</strong>。</p>
<p>但是但是，上面的两个算法放在一起，可能就是灾难了。比方说我 <strong>发送端</strong> 发送了一个 <strong>8字节</strong> 的数据以后还需要发送一个 <strong>6字节</strong> 的数据，但是 <strong>接收端</strong> 却认为在 <strong>0.5秒内</strong> 不需要立即应答，然后这个时间里就会导致 <strong>发送端</strong> 和 <strong>接收端</strong> 相互等待的局面。所以日常开发中，我们可以关闭我们服务端的 <strong>tcpNoDelay</strong> 来提高接口响应的速度（<code>-Dsun.net.httpserver.nodelay=true</code>，如果使用的是 <strong>Tomcat</strong>，默认就是 <strong>true</strong> 的值）。</p>
<h3 id="捎带应答"><a href="#捎带应答" class="headerlink" title="捎带应答"></a>捎带应答</h3><p>这个应用在上面 <strong>三次握手</strong> 的时候就可以看到了，<strong>接收端</strong> 在 <strong>ACK</strong> 的时候顺带还加上了 <strong>SYN</strong> 的请求，合并成一个数据包进行发送。</p>
<h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1>]]></content>
      <categories>
        <category>技能</category>
        <category>基础</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 集群部署方式</title>
    <url>//redis/redis-deploy/index.html</url>
    <content><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>使用的 <code>Redis</code> 版本：<code>4</code> 通常来说，一个小型的项目一台 <code>redis</code> 服务实例即可满足需求，但是当系统很大的时候，客户端读写频繁，一台机器很容易就成为性能和内存的瓶颈，这时候就需要使用<strong>集群</strong>来拓展性能了。 <code>redis</code> 集群有两种方式：</p>
<ol>
<li> 复制</li>
<li> 哨兵</li>
<li> 集群<h2 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h2></li>
</ol>
<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p><code>redis</code> 在复制模式下被分为两类数据库：主数据库和从数据库。一个主数据库可以拥有多个从数据库，但是一个从数据库则只能拥有一个主数据库。当主库数据发送变化时，<code>redis</code> 会将数据自动同步到多个从数据库中去。 在 <code>redis</code> 数据库中使用复制功能很简单，只需要在从数据库的配置文件中加入以下配置即可实现：</p>
<blockquote>
<p>ps：以下配置是 Redis4 的配置，在以前版本需要查看配置文件的配置方式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replicaof 192.168.1.129 6379 # 配置主数据库链接信息</span><br><span class="line">masterauth 123456 # 配置主数据库的密码</span><br><span class="line">bind 192.168.1.130 # 配置主数据库的IP地址表示可以让这个IP访问数据</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>主数据库无需任何配置。 查看 <code>redis</code> 服务的 <code>Replication</code> 节点相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">INFO replication</span><br></pre></td></tr></table></figure>
<p>默认情况下，从数据库是只读的，如果向从数据库设置值，将会得到一个错误（<code>(error) READONLY You can&#39;t write against a read only replica.</code>）。如果想要让从数据库可写，那么需要在配置加上以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slave-read-only no</span><br></pre></td></tr></table></figure>
<p>但是即使从数据库可写，写入的数据也会被主数据库同样的键给代替了，所以一般来说，从数据库应该只是只读的模式。 这种方式主数据库只能有一个，而从数据库可以有很多个。 然而，从数据库也可以有自己的从数据库（这里应该说这个从数据库是另外一个从数据库的主数据库。</p>
<h3 id="无硬盘复制"><a href="#无硬盘复制" class="headerlink" title="无硬盘复制"></a>无硬盘复制</h3><p>当 <code>Redis</code> 被配置不使用 <code>RDB</code> 备份的时候（删除所有的 <code>SAVE</code> 配置），<code>Redis</code> 还是会在硬盘生成 <code>RDB</code> 文件，这是为了在 <code>Redis</code> 被关闭的时候，重启 <code>Redis</code> 可以恢复内存中的数据。 在执行复制的时候，每次复制 <code>Redis</code> 都需要执行一次 <code>RDB</code> 文件的导出工作，这时候需要读取硬盘 <code>IO</code> ，必定造成复制效率的下降，在 <code>Redis 2.8.18</code> 开始，<code>Redis</code> 支持无硬盘复制操作，即在内存中生成 <code>RDB</code> 数据，然后通过网络传递给从服务器，避免造成硬盘性能瓶颈。 可以通过在配置文件中修改以下配置开启该功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-diskless-sync yes</span><br></pre></td></tr></table></figure>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>在 <code>Redis 2.8</code> 之前，从数据库同步主数据的都需要使用全量复制的模式，即从数据库一旦启动就会发送 <code>SYNC</code> 命令给主数据库，要求读取所有数据然后再写入从数据库。在 <code>2.8</code> 以后咧，新增了增量复制。 增量复制过程：</p>
<ol>
<li> 从数据库会存储主数据库的运行 <code>id</code> ，每个实例都会有一个，每当实例重启，就会自动生成一个新的 <code>id</code> 。</li>
<li> 复制过程中，主数据库一旦接收到操作命令，就会传送给从数据库，并且存入到一个挤压队列中（backlog，在我看来有点像 <code>MySQL</code> 的 <code>binlog</code> 文档），并记录当前挤压队列中的命令的偏移量范围。</li>
<li> 同时从数据库接收到主数据库的命令的时候，也会记录下数据的偏移量。</li>
</ol>
<p>从数据库一旦断开，重新连接上主数据库的时候，不再发送 <code>SYNC</code> 命令，而是 <code>PSYNC</code> 。格式为 <code>PSYNC 断开连接前的命令偏移量</code> 。主数据库收到请求将会查看是否可以发送偏移量后面的内容给从数据库。</p>
<ol>
<li> 首先主数据库拿到了运行ID和偏移量，会判断运行ID是否和自己目前的相同，如果不同即进行全量复制。</li>
<li> 判断命令偏移量是否存储在当前的积压队列里边，如果存在，进行增量复制，如果不存在，即进行全量复制。</li>
</ol>
<p>主数据的挤压队列默认是 <code>1m</code>，可以通过配置修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repl-backlog-size 10m # 积压队列长度</span><br><span class="line">repl-backlog-ttl 3600 # 积压队列过多久释放 默认1小时</span><br></pre></td></tr></table></figure>
<p>积压队列长度应按照网络情况，机器情况设定，积压队列越大，可容忍的断连时间就越长。</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h3 id="准备复制主从数据库"><a href="#准备复制主从数据库" class="headerlink" title="准备复制主从数据库"></a>准备复制主从数据库</h3><p>在复制模式下，我们项目可以通过读写分离来提高系统并发量。但是当主数据宕机的时候，需要人工手动切换主从数据库，比较繁琐。如果引入哨兵模式，哨兵就会自动的帮我们完成上面的动作。 在系统中，我们只需要运行一个哨兵，通过配置主数据库的连接信息。哨兵即会向主数据库发送一条 <code>INFO replication</code> 命令，了解当前系统中有多少个从数据库。从而各自读取从数据库的信息，并且建立与从数据沟通的链接。 OK，我现在准备了三个虚拟机：<code>192.168.1.129(Master)</code> <code>192.168.1.134(Slave1)</code> <code>192.168.1.139(Slave2)</code> 关闭防火墙，配置 <code>129</code> 机器为主 <code>Redis</code> 数据库。 先测试正常的复制用法。</p>
<h3 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h3><p>哨兵完全配置在 <code>redis路径/sentinel.conf</code>。 当前我们需要配置他监控主数据库，并且配置主数据库的密码（这不要忘记了，我忘记了所以总是认为掉线了）。修改连接的主数据库地址和连接密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#                主库名字  主库IP     端口 多少票通过认为数据库掉线，用于多个哨兵的时候配置</span><br><span class="line">sentinel monitor mymaster 192.168.1.129 6379 1</span><br><span class="line"># 配置密码</span><br><span class="line">sentinel auth-pass mymaster 123456</span><br><span class="line"># 配置 1500 毫秒数据库没有返回 ping 结果则认为已经掉线</span><br><span class="line">sentinel down-after-milliseconds mymaster 1500</span><br></pre></td></tr></table></figure>
<p>然后运行启动哨兵：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure>
<p>运行启动配置文件会被覆写新增从库的监控地址。 来到这里表示哨兵已经就位，开始看看哪个屌毛偷懒了。</p>
<h3 id="划重点的配置"><a href="#划重点的配置" class="headerlink" title="划重点的配置"></a>划重点的配置</h3><p>哨兵和 <code>Redis</code> 中的通讯会受到 <code>bind</code> 配置和 <code>protect-mode</code> 的影响。如果配置这两个的话，哨兵的配置也需要加上相关的配置，如果没有配置的话，那么需要关闭哨兵的 <code>bind</code> 和 <code>protect-mode</code> 配置！我在测试的时候卡在这里很久。 OK，因为是自己使用的，先关闭掉这两个配置先。</p>
<h3 id="测试哨兵"><a href="#测试哨兵" class="headerlink" title="测试哨兵"></a>测试哨兵</h3><p>分别把服务都启动起来，包括哨兵。即可看见，上面的 <code>Redis 132库</code> 是 <code>Master</code> 角色，下面两个 <code>133</code> 和 <code>134</code> 是从库。 <img src="/images/redis-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F.md/0.png" alt="image-20190309154733954"></p>
<p> 现在我进入主库服务器，把主库 <code>kill</code> 掉： </p>
<p><img src="/images/switch-master-2268365.gif"> </p>
<p>可见干掉主库进程的时候，哨兵开始进行投票选举，然后选出来了 <code>127.0.0.1</code> 作为主库（因为哨兵就运行在这台机器上面）然后，哨兵开始切换所有数据库的状态的时候，也会把当前宕机的加入，但是是以从数据库的身份加入的，所以可以看到有 <code>+sdown</code> 输出</p>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p>即使我们使用了哨兵模式保证了 <code>Redis</code> 多实例的运行，但是因为是使用复制原理来做的，所以我们的 <code>Redis</code> 存储量极可能会受到最小机器的存储量的影响，形成木桶效应（也就是整个集群能存储多少数据取决于最小配置的实例） 在我们应用还不会很大，数据量不会很多的时候，哨兵模式完全够用（据我所知我们现在商城存储量才 <code>200m</code> 多点） 虽然我在项目中可能完全不需要 <code>Redis</code> 的集群配置，但是为了丰富文档，我还是决定写一写。 早期 <code>Redis</code> 不支持集群的时候，我们一般的做法是使用客户端来做的集群。比如 <code>Java</code> 客户端的 <code>Shardis</code> 。通过一定的规则计算出 <code>Key</code> 应该存储在哪个节点，从而写入数据库，读取也一样。但是这种做法有个弊端，就是后期的拓展性很差，当需要新增数据库的时候，我们所有的数据都会从新被计算，从而导致新增节点需要重置所有数据的尴尬局面。 当然现在 <code>Redis</code> 的集群也有一定的缺陷，当想读取多个键的时候，如果多个键均分布在同一个节点的时候可以正常读取，但是当键落在不同节点的时，此时 <code>Redis</code> 将会报错。</p>
<h3 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h3><p>配置集群必要点：</p>
<ol>
<li> 每个实例配置中的 <code>cluster-enabled</code> 均需要为 <code>yes</code> ，也就是每个实例都要打开集群模式；</li>
<li> 集群中必须存在 <strong>3</strong> 个主数据库，集群才能正常启动。</li>
</ol>
<p>OK，为了更好玩一点我就不使用单机形式启动，而是启动 6 台虚拟机进行模拟。 第一步 修改配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启集群模式</span><br><span class="line">cluster-enabled yes</span><br></pre></td></tr></table></figure>
<p>第二步 启动所有 <code>Redis</code> 实例，每台实例都会打印以下日志表明身份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11837:M 14 Mar 2019 03:06:48.465 * Node configuration loaded, I&#x27;m 15876fe78b4d5bd61f8df8bdc748d5358a761ef0</span><br></pre></td></tr></table></figure>
<p>第三步 使用 <code>redis-cli</code> 连接所有的实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.1.143:6379 192.168.1.144:6379 192.168.1.145:6379 192.168.1.150:6379 192.168.1.151:6379 192.168.1.153:6379 --cluster-replicas 1</span><br></pre></td></tr></table></figure>
<p>就可以看到输出了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11956:M 14 Mar 2019 07:03:17.632 * Replica 192.168.1.150:6379 asks for synchronization</span><br></pre></td></tr></table></figure>
<p>这个表示 <code>150</code> 服务器是主服务器，当前服务器是从服务器。 测试数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 需要使用 -c 参数表示读写集群中的 redis </span><br><span class="line">redis-cli -c</span><br><span class="line">127.0.0.1:6379&gt; set hello World</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;World&quot;</span><br><span class="line"># 如果在其他机器上读取，会出现重定向到指定机器上去读取</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">-&gt; Redirected to slot [866] located at 192.168.1.143:6379</span><br><span class="line">&quot;World&quot;</span><br></pre></td></tr></table></figure>
<h3 id="集群常用命令"><a href="#集群常用命令" class="headerlink" title="集群常用命令"></a>集群常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CLUSTER NODES</span><br><span class="line">15876fe78b4d5bd61f8df8bdc748d5358a761ef0 192.168.1.144:6379@16379 master - 0 1552564297487 2 connected 5461-10922</span><br><span class="line">f5a0ac798882cdeb6c543729a501a16220156f0a 192.168.1.143:6379@16379 myself,master - 0 1552564280000 1 connected 0-5460</span><br><span class="line">4acf665a179c8959c3287c05a515fce4648a550e 192.168.1.150:6379@16379 slave f5a0ac798882cdeb6c543729a501a16220156f0a 0 1552564299501 1 connected</span><br><span class="line">39ffad57d67b7b456f6e3373eb15f1f3f90f4242 192.168.1.153:6379@16379 slave 47ff715c566f6e373c0b3c020f34e9b910b7aa0b 0 1552564300509 6 connected</span><br><span class="line">4c825414ed6c09b375abb9917be3300e29970a07 192.168.1.151:6379@16379 slave 15876fe78b4d5bd61f8df8bdc748d5358a761ef0 0 1552564301519 5 connected</span><br><span class="line">47ff715c566f6e373c0b3c020f34e9b910b7aa0b 192.168.1.145:6379@16379 master - 0 1552564298493 3 connected 10923-16383</span><br></pre></td></tr></table></figure>
<p><code>CLUSTER NODES</code> 可以查看当前集群中插槽的情况以及主从的情况。</p>
<h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>一个 <code>redis</code> 共拥有 <code>16384</code> 个插槽，将会平均分配给每个主数据库，像上面的命令后面的 <code>connected 5461-10922</code> 即表示这个主数据库处理哪部分的插槽。 每个键将会落在哪个插槽，<code>redis</code> 会通过建的有效部分（如果存在 <code>&#123;&#125;</code> 则取 <code>&#123;&#125;</code> 中间的至少一个字符，如果不存在，整个键都是有效部分）进行 <code>CRC16</code> 算法计算出来散列值，然后与 <code>16384</code> 进行取余，然后得出来落在哪个节点的哪个插槽上去。 使用 <code>&#123;&#125;</code> 指定有效部分可以使相似业务的键值落在同一个节点，比如 <code>&#123;order&#125;:details</code> <code>&#123;order&#125;:info</code> 这样既可使这两个订单业务的数据落在同一个节点上去，从而支持一些集群不支持的命令。</p>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><ol>
<li> 集群中每个节点都会定时向其他节点发送 <code>ping</code> 命令，并且判断哪个节点没有回复</li>
<li> 将没有回复的节点通知其他节点试试看能不能 <code>ping</code> 通</li>
<li> 如果半数以上的节点认为已经下线，则集群系统会标记这个节点已经掉线了</li>
<li> 如果挂掉的节点是个 <code>master</code> 并且拥有 <code>slave</code> 节点那么他的 <code>slave</code> 会通过选举自己，然后由集群进行投票，从而竞选升级为 <code>master</code> （这里可能会因为总是没有合适的 <code>slave</code> 而出现集群短时间不提供服务）</li>
<li> 如果有半数以上的 <code>master</code> 挂掉了，那么集群将不会再对外提供服务</li>
<li> <code>master</code> 挂掉以后可以重新加入集群，但是 <code>slave</code> 挂掉以后如果 <code>master</code> 不同了，需要通过修改配置文件来加入集群。</li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 持久化机制</title>
    <url>//redis/redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/index.html</url>
    <content><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><code>redis</code> 数据库，可以直接用来当数据库使用，也可以当系统的缓存使用。但是 <code>redis</code> 大部分数据是存储在内存中的，当服务掉线重启，会造成数据的丢失。当然，<code>redis</code> 是有持久化线程的，我们可以利用这个持久化服务来做数据的持久化，这样当 <code>redis</code> 重启的时候，即可从硬盘重新读取数据，然后进行数据的恢复。 <code>redis</code> 的持久化方式有两种：</p>
<ol>
<li> RDB 方式</li>
<li> AOP方式<h2 id="RDB-方式"><a href="#RDB-方式" class="headerlink" title="RDB 方式"></a>RDB 方式</h2></li>
</ol>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p><code>redis</code> 的 <code>RDB</code> 持久化是通过快照完成的。当符合一定条件的时候，<code>redis</code> 可以将目前的数据生成一份副本存储在硬盘。 <code>redis</code> 执行快照的一句有下面几种：</p>
<ol>
<li> 根据配置的规则</li>
<li> 用户执行 <code>SAVE</code> 或 <code>BGSAVE</code> 命令</li>
<li> 执行 <code>FLUSHALL</code> 命令</li>
<li> 执行复制时</li>
</ol>
<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p><code>redis</code> 可以根据用户在配置文件中配置的规则进行定时，定量的持久化。在 <code>redis</code> 的 <code>conf</code> 文件夹中配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1 # 表示900秒以内有一个或以上的简直更改时进行快照</span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="执行-SAVE-或-BGSAVE-命令"><a href="#执行-SAVE-或-BGSAVE-命令" class="headerlink" title="执行 SAVE 或 BGSAVE 命令"></a>执行 SAVE 或 BGSAVE 命令</h3><p>执行 <code>SAVE</code> 时，<code>redis</code> 会阻塞所有客户端的请求，然后进行备份。这一过程可能造成 <code>redis</code> 长时间无响应，所以应该尽量避免。 执行 <code>BGSAVE</code> 时，<code>redis</code> 则异步的进行快照，客户端的请求依然可以进行处理。 执行 <code>BGSAVE</code> 时，<code>redis</code> 做了以下的操作：</p>
<ol>
<li> 当执行 <code>BGSAVE</code> 的时候，<code>redis</code> 会使用 <code>Fork</code> 函数复制一份当前进程（父）的副本（子）</li>
<li> 父进程继续接收客户端的请求，而子进程会将 <code>Fork</code> 的副本写入硬盘的临时文件</li>
<li> 当子进程将所有数据写入临时文件时，开始替换旧的 <code>RDB</code> 文件</li>
</ol>
<blockquote>
<p>在进行 Fork 操作的时候，父子进程共享一份内存数据，当父进程需要修改某一片的数据的时候，操作系统会将这一份数据进行复制，保证子进程的读取。所以，Fork 函数执行的时候，RDB文件存储的是这一时刻的数据。 执行这一操作需要确保开启 Linux 系统允许应用程序申请超过可用内存的空间（物理空间和交换空间）。方法是在 .etc/sysctl.conf 加入 vm.overcommit_memory = 1 然后重启系统或执行 sysctl vm.overcommit_memory = 1使配置生效即可。</p>
</blockquote>
<h3 id="执行-FLUSHALL-命令"><a href="#执行-FLUSHALL-命令" class="headerlink" title="执行 FLUSHALL 命令"></a>执行 FLUSHALL 命令</h3><p>执行该命令时，数据库中的所有数据将会被清空，不论配置文件怎么配置，只要执行该命令，<code>redis</code> 就会执行一次快照操作。</p>
<h3 id="执行复制时"><a href="#执行复制时" class="headerlink" title="执行复制时"></a>执行复制时</h3><p>只要配置主从复制时，无论有没有配置规则，都会生成 <code>RDB</code> 文件的快照。用于多个实例之间进行数据的同步。</p>
<h2 id="AOF-方式"><a href="#AOF-方式" class="headerlink" title="AOF 方式"></a>AOF 方式</h2><p>当使用 <code>redis</code> 存储非临时数据时，一般需要开启 <code>AOF</code> 模式来减少每次 <code>redis</code> 的宕机造成的数据损失。<code>AOF</code> 会将 <code>redis</code> 执行的每一条命令都写入硬盘。当然这一过程肯定对性能造成一定影响，不过可以接受。</p>
<h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>默认 <code>redis</code> 是没有开启 <code>AOF</code> 模式的。可以通过配置文件来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>开启 <code>AOF</code> 持久化后将会保存每一条命令，可以通过下面配置来指定持久化文件的名字。 <code>appendfilename append.aof</code></p>
<h3 id="AOF-的实现"><a href="#AOF-的实现" class="headerlink" title="AOF 的实现"></a>AOF 的实现</h3><p><code>AOF</code> 会通过保存客户端发送的通讯协议进行保存，所以会导致 <code>AOF</code> 文件越来越大的问题，因为可能出现的情况是，一个键被设置了，后面又被删除了，这时候完全可以不进行记录这一个过程。那么可以通过配置文件来设置 <code>redis</code> 当 <code>AOF</code> 文件达到一定容量的时候进行 <code>AOF</code> 的优化重写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100 # 当前 AOF 文件超过上一次的 AOF 文件的百分之多少时进行重写，如果无重写过则以启动时的文件大小为准</span><br><span class="line">auto-aof-min-size 64mb # 当 AOF 达到这个设置容量时触发重写</span><br></pre></td></tr></table></figure>
<p>除了可以让 <code>redis</code> 自动重写以外，还可以通过传输命令 <code>BGREWRITEAOF</code> 来触发 <code>redis</code> 的重写。</p>
<h3 id="同步硬盘数据"><a href="#同步硬盘数据" class="headerlink" title="同步硬盘数据"></a>同步硬盘数据</h3><p>虽然每次都会重写 <code>AOF</code> 文件，但是此时这个文件并没有真正的写入硬盘中，而是进入硬盘缓存，如果此时系统出现异常宕机，则会导致数据的丢失。系统默认情况下，30秒执行一次同步硬盘操作，但是一般开启 <code>AOF</code> 的应用都不能允许这个情况的出现，这就需要 <code>redis</code> 在写入 <code>AOF</code> 文件的时候，主动触发同步硬盘。我们可以通过以下设置来实现这个目的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aapendfsync everysec # 每秒执行一次同步操作，也是默认设置</span><br></pre></td></tr></table></figure>
<p>可选值：<code>always</code> <code>no</code> 前者是每次写入 <code>AOF</code> 都进行同步，后者则完全交由系统决定。</p>
<h2 id="持久化使用"><a href="#持久化使用" class="headerlink" title="持久化使用"></a>持久化使用</h2><p><code>redis</code> 允许同时开启两种模式，既保证数据安全又使得备份十分容易。重启 <code>redis</code> 后 <code>redis</code> 会使用 <code>AOF</code> 方式来回复数据，因为 <code>AOF</code> 可能丢失的数据更少。 </p>
]]></content>
      <categories>
        <category>技能</category>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>redis</tag>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tomcat】一.初识Tomcat以及调试Tomcat</title>
    <url>//tomcat/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat/index.html</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="一-Tomcat服务器"><a href="#一-Tomcat服务器" class="headerlink" title="一.Tomcat服务器"></a>一.Tomcat服务器</h2><p>相信一直默默耕耘在 <code>JavaWEB</code> 的同学，肯定不会不认识 <code>Tomcat</code>。这可是世界一个著名的 <code>Web服务器</code> 之一，在之前动态 <code>Web服务</code> 还没有那么盛行的时候，<code>Tomcat</code> 依靠对 <code>Servlet</code> 的实现，让 <code>Web开发</code> 变得简单，<code>JSP诞生</code> 也是目前 <code>动态页面</code> 的始祖。 我不知道现在的同学还记不记得 <code>servlet</code> 的开发方法：</p>
<ol>
<li> 创建自己的处理类，继承 <code>HttpServlet</code>，覆写 <code>doGet</code> <code>doPost</code> <code>doPut</code> 等不同 <code>HTTP Method</code> 的方法实现；</li>
<li> 在 <code>WEB项目</code> 的 <code>web.xml</code> 文件中配置 <code>servlet</code> 的请求路径信息；</li>
<li> 打包成 <code>war</code> 包，丢进 <code>Tomcat/webapp</code>；</li>
<li> 启动 <code>Tomcat</code> 服务器，<code>Tomcat</code> 端口映射成功以后请求相对应的路径，即可访问到我们刚刚写的 <code>servlet</code> 中。<a id="more"></a>
而当我们需要配置 <code>Tomcat服务器</code> 的端口呀，以及一些其他信息的时候，这时候就需要到 <code>&#123;TomcatHome&#125;/conf/server.xml</code> 中去配置，不过搁以前，我都是找到我要改掉的参数，比如说我要把 <code>8080</code> 改成 <code>12345</code>，那就是先找到 <code>8080</code> 的字符，然后改成 <code>12345</code> ，赶紧保存，关掉编辑窗口，防止配置被我弄了其他的，导致整个服务器起不来。起不来就只好重新解压了hhh</li>
</ol>
<h2 id="二-Tomcat架构"><a href="#二-Tomcat架构" class="headerlink" title="二.Tomcat架构"></a>二.Tomcat架构</h2><p><img src="/images/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat.md/0.jpeg"></p>
<p>这个配置文件，用过 <code>Tomcat</code> 的应该都不会不认识，其实这里就已经能够很好的反应了 <code>Tomcat</code> 的架构了： <img src="/images/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat.md/1.jpeg"> 所以，<code>Tomcat</code> 就有几个这样的元素：</p>
<ol>
<li> <code>Server</code>：表示整个 <code>Tomcat容器</code>，这个容器可以配置多个 <code>Service</code> 呀，运行多个程序等等；</li>
<li> <code>Service</code>：表示一个服务容器，可配置这个服务容器的 <code>Engine</code>、<code>Connector</code> 、<code>Host</code> 等等，在一个 <code>Server</code> 中允许配置多个 <code>Service</code>。</li>
<li> <code>Connector</code>：负责解析数据，然后将数据交给 <code>Engine</code> 去处理，处理完成拿到 <code>响应数据</code> 再包装成对应的格式输出到客户端；</li>
<li> <code>Engine</code>：处理引擎，代表一系列的数据转换链表，从多个 <code>Connector</code> 接收数据，处理数据输出出去；</li>
<li> <code>Host</code>：代表一个域名，这个域名下可以存放多个 <code>Context</code>，也就是我们的 <code>war项目</code>，一个 <code>Service</code> 同样可以拥有多个 <code>Host</code>；</li>
<li> <code>Context</code>：我们的 <code>Web上下文</code>，生命周期就跟 <code>Servlet</code> 项目一样了，存在于 <code>Host</code> 下，我们写的代码主要负责将接收的数据处理，处理完成返回 <code>响应数据</code> 出去即可。</li>
</ol>
<h2 id="三-导入IDEA"><a href="#三-导入IDEA" class="headerlink" title="三.导入IDEA"></a>三.导入IDEA</h2><p>不得不说，这玩意儿导入 <code>idea</code> 是真的麻烦，没有之一…. 首先，打开 <code>https://tomcat.apache.org/download-80.cgi</code> 下载源码，<code>Source Code</code> 那部分就是了：<br> <img src="/images/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat.md/2.jpeg"><br> 然后，别急着打开，创建一个 <code>pom.xml</code> 在项目根目录（对，就是用 <code>maven</code> 插件来编译 <code>ant</code> 项目，比较猥琐，但是能用啊~）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apache-tomcat-8.5.51&lt;/artifactId&gt;</span><br><span class="line">    &lt;name&gt;apache-tomcat-8.5.51&lt;/name&gt;</span><br><span class="line">    &lt;version&gt;8.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.7&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-apache-log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-commons-logging&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml.rpc&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.xml.rpc-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;apache-tomcat-8.5.51&lt;/finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;/sourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;/directory&gt;</span><br><span class="line">            &lt;/resource&gt;</span><br><span class="line">        &lt;/resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.5&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">                    &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;</span><br><span class="line">                    &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>这时候可以通过 <code>idea</code> 打开 <code>pom.xml</code> 文件来加载项目了。 依赖下载完成以后，别急，先到我们平常使用的 <code>tomcat</code> 中把 <code>conf</code> <code>lib</code> <code>logs</code> <code>webapps</code> <code>work</code> 这几个文件夹拷贝出来，在项目根目录创建一个名为 <code>catalina-home</code> 的文件夹，把上面拷贝的文件夹粘贴进去。 </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat.md/3.jpeg"> </p>
<p>然后，我们先找到 <code>Boostrap</code> 类，他是 <code>Tomcat服务器</code> 启动的主程序类，<code>main</code> 方法就在里边，启动他，反正起不来，也可以在启动过程中直接终止。 </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat.md/4.jpeg"> 然后我们在第一处点击启动类的配置，将以下的代码拷贝到 <code>2</code> 处，再启动就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dcatalina.home=catalina-home</span><br><span class="line">-Dcatalina.base=catalina-home</span><br><span class="line">-Djava.endorsed.dirs=catalina-home/endorsed</span><br><span class="line">-Djava.io.tmpdir=catalina-home/temp</span><br><span class="line">-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file=catalina-home/conf/logging.properties</span><br></pre></td></tr></table></figure>
<p>然后重新启动，访问 <code>http://localhost:8080</code> 就可以了： </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat.md/5.jpeg"></p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>tomcat源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tomcat】三.Tomcat启动（上）</title>
    <url>//tomcat/%E3%80%90tomcat%E3%80%91%E4%B8%89-tomcat%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89/index.html</url>
    <content><![CDATA[<p>上一篇的时序图： <img src="/images/%E3%80%90tomcat%E3%80%91%E4%B8%89-tomcat%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89.md/0.jpeg"></p>
<a id="more"></a>
<h2 id="一-StandardRoot启动"><a href="#一-StandardRoot启动" class="headerlink" title="一. StandardRoot启动"></a>一. StandardRoot启动</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardRoot</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title class_">WebResourceRoot</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">    mainResources.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型，创建对应的资源包实例</span></span><br><span class="line">    main = createMainResourceSet();</span><br><span class="line"></span><br><span class="line">    mainResources.add(main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次启动此类指定的资源</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;WebResourceSet&gt; list : allResources) &#123;</span><br><span class="line">      <span class="comment">// Skip class resources since they are started below</span></span><br><span class="line">      <span class="keyword">if</span> (list != classResources) &#123;</span><br><span class="line">        <span class="keyword">for</span> (WebResourceSet webResourceSet : list) &#123;</span><br><span class="line">          webResourceSet.start();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描lib下的所有jar包</span></span><br><span class="line">    processWebInfLib();</span><br><span class="line">    <span class="comment">// Need to start the newly found resources</span></span><br><span class="line">    <span class="keyword">for</span> (WebResourceSet classResource : classResources) &#123;</span><br><span class="line">      classResource.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.enforceObjectMaxSizeLimit();</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们知道，一个 <code>webapp</code> 入口是 <code>WEB-INF</code> ，因为里边包含了 <code>web.xml</code> 以及 <code>lib包</code>，所以此时就是扫描 <code>lib</code> 下所有的 <code>jar</code> 包，然后加载到 <code>webapp</code> 的 <code>ClassLoader</code> 中去。所以这个时候 <code>StandardRoot</code> 做的事情就是加载所有的 <code>jar</code> 包。</p>
<h2 id="二-发送事件通知加载web应用"><a href="#二-发送事件通知加载web应用" class="headerlink" title="二. 发送事件通知加载web应用"></a>二. 发送事件通知加载web应用</h2><p>上面图我们可以看到，<code>fireLifecycleEvent</code> 通知了 <code>ContextConfig</code> 加载 <code>webapp</code> 的配置、加载所有 <code>Pipeline</code>。 先看第一个：</p>
<h3 id="2-1-加载配置"><a href="#2-1-加载配置" class="headerlink" title="2.1 加载配置"></a>2.1 加载配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextConfig</span> <span class="keyword">implements</span> <span class="title class_">LifecycleListener</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">configureStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Called from StandardContext.start()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.start&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.xmlSettings&quot;</span>,</span><br><span class="line">                             context.getName(),</span><br><span class="line">                             Boolean.valueOf(context.getXmlValidation()),</span><br><span class="line">                             Boolean.valueOf(context.getXmlNamespaceAware())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置webConfig，会将项目中的web.xml跟tomcat目录下的web.xml合并</span></span><br><span class="line">    <span class="comment">// 并且加载所有必要的jar包</span></span><br><span class="line">    webConfig();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!context.getIgnoreAnnotations()) &#123;</span><br><span class="line">      applicationAnnotationsConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// 一堆配置鉴权的东西，tomcat-users.xml配置的东西</span></span><br><span class="line">      validateSecurityRoles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      authenticatorConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Pipeline Configuration:&quot;</span>);</span><br><span class="line">      <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> context.getPipeline();</span><br><span class="line">      Valve valves[] = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (pipeline != <span class="literal">null</span>) &#123;</span><br><span class="line">        valves = pipeline.getValves();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (valves != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valves.length; i++) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;  &quot;</span> + valves[i].getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.debug(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make our application available if no problems were encountered</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      context.setConfigured(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;contextConfig.unavailable&quot;</span>));</span><br><span class="line">      context.setConfigured(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">webConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WebXmlParser</span> <span class="variable">webXmlParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebXmlParser</span>(context.getXmlNamespaceAware(),</span><br><span class="line">                                                 context.getXmlValidation(), context.getXmlBlockExternal());</span><br><span class="line">    <span class="comment">// 加载全局的web.xml</span></span><br><span class="line">    Set&lt;WebXml&gt; defaults = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    defaults.add(getDefaultWebXmlFragment(webXmlParser));</span><br><span class="line"></span><br><span class="line">    <span class="type">WebXml</span> <span class="variable">webXml</span> <span class="operator">=</span> createWebXml();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始解析webapp的web.xml</span></span><br><span class="line">    <span class="type">InputSource</span> <span class="variable">contextWebXml</span> <span class="operator">=</span> getContextWebXmlSource();</span><br><span class="line">    <span class="keyword">if</span> (!webXmlParser.parseWebXml(contextWebXml, webXml, <span class="literal">false</span>)) &#123;</span><br><span class="line">      ok = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">sContext</span> <span class="operator">=</span> context.getServletContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ordering is important here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1. 加载所有jar包的web-fragment.xml</span></span><br><span class="line">    Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2. 排序上面加载的web-fragment.xml.</span></span><br><span class="line">    Set&lt;WebXml&gt; orderedFragments = <span class="literal">null</span>;</span><br><span class="line">    orderedFragments =</span><br><span class="line">      WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3. 查找ServletContainerInitializer接口实现类</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      processServletContainerInitializers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  (!webXml.isMetadataComplete()  typeInitializerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理web-fragment.xml</span></span><br><span class="line">      processClasses(webXml, orderedFragments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!webXml.isMetadataComplete()) &#123;</span><br><span class="line">      <span class="comment">// Step 6. 合并所有的web-fragment.xml</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        ok = webXml.merge(orderedFragments);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 7. 合并默认配置</span></span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 8. JSP转Servlet</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        convertJsps(webXml);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 9. 应用合并以后的web.xml对象</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        configureContext(webXml);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line">      convertJsps(webXml);</span><br><span class="line">      configureContext(webXml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getLogEffectiveWebXml()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;web.xml:\n&quot;</span> + webXml.toXml());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 10. 查找静态资源</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// Spec does not define an order.</span></span><br><span class="line">      <span class="comment">// Use ordered JARs followed by remaining JARs</span></span><br><span class="line">      Set&lt;WebXml&gt; resourceJars = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : orderedFragments) &#123;</span><br><span class="line">        resourceJars.add(fragment);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : fragments.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resourceJars.contains(fragment)) &#123;</span><br><span class="line">          resourceJars.add(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      processResourceJARs(resourceJars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 11. 应用ServletContainerInitializer配置</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">           initializerClassMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue().isEmpty()) &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-StandardPipeline初始化"><a href="#2-2-StandardPipeline初始化" class="headerlink" title="2.2 StandardPipeline初始化"></a>2.2 StandardPipeline初始化</h3><p><code>BasicAuthenticator</code> 和 <code>StandardContextValue</code> 分别初始化，<code>Pipeline</code> 的内容打算后面请求的时候再看…</p>
<h2 id="三-StandardManager启动"><a href="#三-StandardManager启动" class="headerlink" title="三. StandardManager启动"></a>三. StandardManager启动</h2><p><code>StandardManager</code> 就负责了 <code>Session</code> 的事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardManager</span> <span class="keyword">extends</span> <span class="title class_">ManagerBase</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">        <span class="comment">// 在父级抽象，准备Session的一些工具容器</span></span><br><span class="line">    <span class="built_in">super</span>.startInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取被序列化到硬盘的session</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      load();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ExceptionUtils.handleThrowable(t);</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;standardManager.managerLoad&quot;</span>), t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里为止，所以异步启动容器的任务就都完成了，接下来就看看怎么处理请求。</p>
<h2 id="四-管理连接的类NioEndpoint"><a href="#四-管理连接的类NioEndpoint" class="headerlink" title="四. 管理连接的类NioEndpoint"></a>四. 管理连接的类NioEndpoint</h2><p>之前说过，在启动 <code>StandardService</code> 的时候，会初始化 <code>connectors</code>，这时候 <code>Connector[HTTP/1.1-8080]</code> 也会被初始化，这是一个处理 <code>HTTP请求</code> 的关键连接器。而这个连接器有一个 <code>protocolHandler</code>，也就是 <code>协议处理器</code>，现在 <code>8.5</code> 使用的是 <code>Http11NioProtocol</code> 这个处理类来处理。 <code>Connector[HTTP/1.1-8080]</code> 在初始化的时候，就会初始化 <code>Http11NioProtocol</code>，<code>Http11NioProtocol</code> 就包含了 <code>Endpoint</code>，理解为 <code>终端口</code> 吧，也就是请求进来的地方，在 <code>NioEndpoint</code> 初始化的时候，就会绑定到系统的端口里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      <span class="comment">// 打开ServerSocketChannel</span></span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> (getAddress()!=<span class="literal">null</span>?<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getAddress(),getPort()):<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getPort()));</span><br><span class="line">      <span class="comment">// 绑定端口</span></span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">      <span class="type">Channel</span> <span class="variable">ic</span> <span class="operator">=</span> System.inheritedChannel();</span><br><span class="line">      <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">        serverSock = (ServerSocketChannel) ic;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (serverSock == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(sm.getString(<span class="string">&quot;endpoint.init.bind.inherited&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="literal">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化acceptor、poller的线程数</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化完成以后，<code>StandardService</code> 会经过 <code>startInternal</code> 函数，即开启容器内部所有的组件，那么 <code>NioEndpoint</code> 相对应的组件 <code>Acceptor</code> <code>Poller</code> 即会被开启线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 启动Connector的时候顺带启动NioEndpoint</span></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">      running = <span class="literal">true</span>;</span><br><span class="line">      paused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      processorCache = <span class="keyword">new</span> <span class="title class_">SynchronizedStack</span>&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                               socketProperties.getProcessorCache());</span><br><span class="line">      eventCache = <span class="keyword">new</span> <span class="title class_">SynchronizedStack</span>&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                           socketProperties.getEventCache());</span><br><span class="line">      nioChannels = <span class="keyword">new</span> <span class="title class_">SynchronizedStack</span>&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                            socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建任务队列</span></span><br><span class="line">      <span class="keyword">if</span> ( getExecutor() == <span class="literal">null</span> ) &#123;</span><br><span class="line">        createExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化最大连接数，默认是10000</span></span><br><span class="line">      initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开启 poller 所有的线程</span></span><br><span class="line">      pollers = <span class="keyword">new</span> <span class="title class_">Poller</span>[getPollerThreadCount()];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">        pollers[i] = <span class="keyword">new</span> <span class="title class_">Poller</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">pollerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">        pollerThread.setPriority(threadPriority);</span><br><span class="line">        pollerThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        pollerThread.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开启Acceptor所有的线程</span></span><br><span class="line">      startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">startAcceptorThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> <span class="title class_">Acceptor</span>[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      acceptors[i] = createAcceptor();</span><br><span class="line">      <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> getName() + <span class="string">&quot;-Acceptor-&quot;</span> + i;</span><br><span class="line">      acceptors[i].setThreadName(threadName);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(acceptors[i], threadName);</span><br><span class="line">      t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">      t.setDaemon(getDaemon());</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建Worker线程，用来处理请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    internalExecutor = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">TaskQueue</span> <span class="variable">taskqueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">    <span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">    taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化连接限流器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> LimitLatch <span class="title function_">initializeConnectionLatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxConnections==-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (connectionLimitLatch==<span class="literal">null</span>) &#123;</span><br><span class="line">      connectionLimitLatch = <span class="keyword">new</span> <span class="title class_">LimitLatch</span>(getMaxConnections());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connectionLimitLatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在这个开启中，启动了 <code>acceptors</code> <code>pollers</code> 以及 <code>workers</code> ，这些线程也是构成 <code>Tomcat</code> 处理请求返回响应的关键。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>tomcat源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tomcat】三.Tomcat启动（下）</title>
    <url>//tomcat/%E3%80%90tomcat%E3%80%91%E4%B8%89-tomcat%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/index.html</url>
    <content><![CDATA[<p>上一篇的时序图： </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E4%B8%89-tomcat%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89.md/0.jpeg"></p>
<h2 id="一-StandardRoot启动"><a href="#一-StandardRoot启动" class="headerlink" title="一. StandardRoot启动"></a>一. StandardRoot启动</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardRoot</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title class_">WebResourceRoot</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">    mainResources.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型，创建对应的资源包实例</span></span><br><span class="line">    main = createMainResourceSet();</span><br><span class="line"></span><br><span class="line">    mainResources.add(main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次启动此类指定的资源</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;WebResourceSet&gt; list : allResources) &#123;</span><br><span class="line">      <span class="comment">// Skip class resources since they are started below</span></span><br><span class="line">      <span class="keyword">if</span> (list != classResources) &#123;</span><br><span class="line">        <span class="keyword">for</span> (WebResourceSet webResourceSet : list) &#123;</span><br><span class="line">          webResourceSet.start();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描lib下的所有jar包</span></span><br><span class="line">    processWebInfLib();</span><br><span class="line">    <span class="comment">// Need to start the newly found resources</span></span><br><span class="line">    <span class="keyword">for</span> (WebResourceSet classResource : classResources) &#123;</span><br><span class="line">      classResource.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.enforceObjectMaxSizeLimit();</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>那我们知道，一个 <code>webapp</code> 入口是 <code>WEB-INF</code> ，因为里边包含了 <code>web.xml</code> 以及 <code>lib包</code>，所以此时就是扫描 <code>lib</code> 下所有的 <code>jar</code> 包，然后加载到 <code>webapp</code> 的 <code>ClassLoader</code> 中去。所以这个时候 <code>StandardRoot</code> 做的事情就是加载所有的 <code>jar</code> 包。</p>
<h2 id="二-发送事件通知加载web应用"><a href="#二-发送事件通知加载web应用" class="headerlink" title="二. 发送事件通知加载web应用"></a>二. 发送事件通知加载web应用</h2><p>上面图我们可以看到，<code>fireLifecycleEvent</code> 通知了 <code>ContextConfig</code> 加载 <code>webapp</code> 的配置、加载所有 <code>Pipeline</code>。 先看第一个：</p>
<h3 id="2-1-加载配置"><a href="#2-1-加载配置" class="headerlink" title="2.1 加载配置"></a>2.1 加载配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextConfig</span> <span class="keyword">implements</span> <span class="title class_">LifecycleListener</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">configureStart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Called from StandardContext.start()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.start&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.xmlSettings&quot;</span>,</span><br><span class="line">                             context.getName(),</span><br><span class="line">                             Boolean.valueOf(context.getXmlValidation()),</span><br><span class="line">                             Boolean.valueOf(context.getXmlNamespaceAware())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置webConfig，会将项目中的web.xml跟tomcat目录下的web.xml合并</span></span><br><span class="line">    <span class="comment">// 并且加载所有必要的jar包</span></span><br><span class="line">    webConfig();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!context.getIgnoreAnnotations()) &#123;</span><br><span class="line">      applicationAnnotationsConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// 一堆配置鉴权的东西，tomcat-users.xml配置的东西</span></span><br><span class="line">      validateSecurityRoles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      authenticatorConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Pipeline Configuration:&quot;</span>);</span><br><span class="line">      <span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> context.getPipeline();</span><br><span class="line">      Valve valves[] = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (pipeline != <span class="literal">null</span>) &#123;</span><br><span class="line">        valves = pipeline.getValves();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (valves != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; valves.length; i++) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;  &quot;</span> + valves[i].getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.debug(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make our application available if no problems were encountered</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      context.setConfigured(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;contextConfig.unavailable&quot;</span>));</span><br><span class="line">      context.setConfigured(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">webConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WebXmlParser</span> <span class="variable">webXmlParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebXmlParser</span>(context.getXmlNamespaceAware(),</span><br><span class="line">                                                 context.getXmlValidation(), context.getXmlBlockExternal());</span><br><span class="line">    <span class="comment">// 加载全局的web.xml</span></span><br><span class="line">    Set&lt;WebXml&gt; defaults = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    defaults.add(getDefaultWebXmlFragment(webXmlParser));</span><br><span class="line"></span><br><span class="line">    <span class="type">WebXml</span> <span class="variable">webXml</span> <span class="operator">=</span> createWebXml();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始解析webapp的web.xml</span></span><br><span class="line">    <span class="type">InputSource</span> <span class="variable">contextWebXml</span> <span class="operator">=</span> getContextWebXmlSource();</span><br><span class="line">    <span class="keyword">if</span> (!webXmlParser.parseWebXml(contextWebXml, webXml, <span class="literal">false</span>)) &#123;</span><br><span class="line">      ok = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">sContext</span> <span class="operator">=</span> context.getServletContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ordering is important here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1. 加载所有jar包的web-fragment.xml</span></span><br><span class="line">    Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2. 排序上面加载的web-fragment.xml.</span></span><br><span class="line">    Set&lt;WebXml&gt; orderedFragments = <span class="literal">null</span>;</span><br><span class="line">    orderedFragments =</span><br><span class="line">      WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3. 查找ServletContainerInitializer接口实现类</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      processServletContainerInitializers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  (!webXml.isMetadataComplete()  typeInitializerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理web-fragment.xml</span></span><br><span class="line">      processClasses(webXml, orderedFragments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!webXml.isMetadataComplete()) &#123;</span><br><span class="line">      <span class="comment">// Step 6. 合并所有的web-fragment.xml</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        ok = webXml.merge(orderedFragments);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 7. 合并默认配置</span></span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 8. JSP转Servlet</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        convertJsps(webXml);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 9. 应用合并以后的web.xml对象</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        configureContext(webXml);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line">      convertJsps(webXml);</span><br><span class="line">      configureContext(webXml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getLogEffectiveWebXml()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;web.xml:\n&quot;</span> + webXml.toXml());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 10. 查找静态资源</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// Spec does not define an order.</span></span><br><span class="line">      <span class="comment">// Use ordered JARs followed by remaining JARs</span></span><br><span class="line">      Set&lt;WebXml&gt; resourceJars = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : orderedFragments) &#123;</span><br><span class="line">        resourceJars.add(fragment);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : fragments.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resourceJars.contains(fragment)) &#123;</span><br><span class="line">          resourceJars.add(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      processResourceJARs(resourceJars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 11. 应用ServletContainerInitializer配置</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">           initializerClassMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue().isEmpty()) &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-StandardPipeline初始化"><a href="#2-2-StandardPipeline初始化" class="headerlink" title="2.2 StandardPipeline初始化"></a>2.2 StandardPipeline初始化</h3><p><code>BasicAuthenticator</code> 和 <code>StandardContextValue</code> 分别初始化，<code>Pipeline</code> 的内容打算后面请求的时候再看…</p>
<h2 id="三-StandardManager启动"><a href="#三-StandardManager启动" class="headerlink" title="三. StandardManager启动"></a>三. StandardManager启动</h2><p><code>StandardManager</code> 就负责了 <code>Session</code> 的事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardManager</span> <span class="keyword">extends</span> <span class="title class_">ManagerBase</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">        <span class="comment">// 在父级抽象，准备Session的一些工具容器</span></span><br><span class="line">    <span class="built_in">super</span>.startInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取被序列化到硬盘的session</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      load();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ExceptionUtils.handleThrowable(t);</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;standardManager.managerLoad&quot;</span>), t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里为止，所以异步启动容器的任务就都完成了，接下来就看看怎么处理请求。</p>
<h2 id="四-管理连接的类NioEndpoint"><a href="#四-管理连接的类NioEndpoint" class="headerlink" title="四. 管理连接的类NioEndpoint"></a>四. 管理连接的类NioEndpoint</h2><p>之前说过，在启动 <code>StandardService</code> 的时候，会初始化 <code>connectors</code>，这时候 <code>Connector[HTTP/1.1-8080]</code> 也会被初始化，这是一个处理 <code>HTTP请求</code> 的关键连接器。而这个连接器有一个 <code>protocolHandler</code>，也就是 <code>协议处理器</code>，现在 <code>8.5</code> 使用的是 <code>Http11NioProtocol</code> 这个处理类来处理。 <code>Connector[HTTP/1.1-8080]</code> 在初始化的时候，就会初始化 <code>Http11NioProtocol</code>，<code>Http11NioProtocol</code> 就包含了 <code>Endpoint</code>，理解为 <code>终端口</code> 吧，也就是请求进来的地方，在 <code>NioEndpoint</code> 初始化的时候，就会绑定到系统的端口里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      <span class="comment">// 打开ServerSocketChannel</span></span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> (getAddress()!=<span class="literal">null</span>?<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getAddress(),getPort()):<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getPort()));</span><br><span class="line">      <span class="comment">// 绑定端口</span></span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">      <span class="type">Channel</span> <span class="variable">ic</span> <span class="operator">=</span> System.inheritedChannel();</span><br><span class="line">      <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">        serverSock = (ServerSocketChannel) ic;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (serverSock == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(sm.getString(<span class="string">&quot;endpoint.init.bind.inherited&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="literal">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化acceptor、poller的线程数</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化完成以后，<code>StandardService</code> 会经过 <code>startInternal</code> 函数，即开启容器内部所有的组件，那么 <code>NioEndpoint</code> 相对应的组件 <code>Acceptor</code> <code>Poller</code> 即会被开启线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 启动Connector的时候顺带启动NioEndpoint</span></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">      running = <span class="literal">true</span>;</span><br><span class="line">      paused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      processorCache = <span class="keyword">new</span> <span class="title class_">SynchronizedStack</span>&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                               socketProperties.getProcessorCache());</span><br><span class="line">      eventCache = <span class="keyword">new</span> <span class="title class_">SynchronizedStack</span>&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                           socketProperties.getEventCache());</span><br><span class="line">      nioChannels = <span class="keyword">new</span> <span class="title class_">SynchronizedStack</span>&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                            socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建任务队列</span></span><br><span class="line">      <span class="keyword">if</span> ( getExecutor() == <span class="literal">null</span> ) &#123;</span><br><span class="line">        createExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化最大连接数，默认是10000</span></span><br><span class="line">      initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开启 poller 所有的线程</span></span><br><span class="line">      pollers = <span class="keyword">new</span> <span class="title class_">Poller</span>[getPollerThreadCount()];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">        pollers[i] = <span class="keyword">new</span> <span class="title class_">Poller</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">pollerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">        pollerThread.setPriority(threadPriority);</span><br><span class="line">        pollerThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        pollerThread.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开启Acceptor所有的线程</span></span><br><span class="line">      startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">startAcceptorThreads</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> <span class="title class_">Acceptor</span>[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      acceptors[i] = createAcceptor();</span><br><span class="line">      <span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> getName() + <span class="string">&quot;-Acceptor-&quot;</span> + i;</span><br><span class="line">      acceptors[i].setThreadName(threadName);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(acceptors[i], threadName);</span><br><span class="line">      t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">      t.setDaemon(getDaemon());</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建Worker线程，用来处理请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    internalExecutor = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">TaskQueue</span> <span class="variable">taskqueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">    <span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">    taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化连接限流器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> LimitLatch <span class="title function_">initializeConnectionLatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxConnections==-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (connectionLimitLatch==<span class="literal">null</span>) &#123;</span><br><span class="line">      connectionLimitLatch = <span class="keyword">new</span> <span class="title class_">LimitLatch</span>(getMaxConnections());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connectionLimitLatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在这个开启中，启动了 <code>acceptors</code> <code>pollers</code> 以及 <code>workers</code> ，这些线程也是构成 <code>Tomcat</code> 处理请求返回响应的关键。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>tomcat源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tomcat】四.Tomcat处理请求（上）</title>
    <url>//tomcat/%E3%80%90tomcat%E3%80%91%E5%9B%9B-tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%EF%BC%88%E4%B8%8A%EF%BC%89/index.html</url>
    <content><![CDATA[<h2 id="一-处理流程"><a href="#一-处理流程" class="headerlink" title="一.处理流程"></a>一.处理流程</h2><h3 id="1-1-系统IO多路复用"><a href="#1-1-系统IO多路复用" class="headerlink" title="1.1 系统IO多路复用"></a>1.1 系统IO多路复用</h3><p>OK，要知道 <code>Tomcat</code> 请求的流程，首先我们得先知道 <code>I/O复用模型</code>，同等级的模型还有 <code>阻塞式I/O</code>、<code>非阻塞式I/O</code>、<code>I/O复用(select/poll/epoll)</code>、<code>信号驱动式I/O</code> 和 <code>异步I/O</code>，目前的 <code>Tomcat</code> 是 <code>8.5</code> 版本，使用的就是 <code>I/O复用模型</code>，也叫 <code>多路复用</code> 模型。 <code>I/O复用模型</code>： </p>
<a id="more"></a>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E5%9B%9B-tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%EF%BC%88%E4%B8%8A%EF%BC%89.md/0.jpeg"> </p>
<p>从左往右走，首先用户程序会被 <code>select函数</code> 阻塞，当系统有数据可读的时候，就会直接返回表示 <code>我有数据啦</code>，然后程序再手动调用 <code>recvfrom</code> 来获取缓冲区的数据，<code>内核</code> 则会将数据拷贝到 <code>缓冲区</code> 以供 <code>用户态</code> 的程序处理，拷贝整个过程需要等待完成。每个链接进来都会现在内核转换成一个 <code>channel通道</code>，这里的 <code>多路</code> 指的就是 <code>多个channel</code>，而 <code>复用</code> 则指的是系统只需要几个线程来处理这些连接就可以了。 相对于一个连接就是创建一个线程来处理，这个模型的好处就是只需要很少量的线程即可完成 <code>channel</code> 的处理。</p>
<h3 id="1-2-Tomcat再多路复用"><a href="#1-2-Tomcat再多路复用" class="headerlink" title="1.2 Tomcat再多路复用"></a>1.2 Tomcat再多路复用</h3><p>这就有点意思了，接收请求是异步的，处理请求也是异步的。 前面我们说了，<code>NioEndpoint</code> 有 <code>acceptors</code> <code>pollers</code> 以及 <code>workers</code> 这些线程：</p>
<ol>
<li><p><code>acceptor</code> 负责监听 <code>select函数</code>，将 <code>socket</code> 均衡注册到某个 <code>Poller</code> 线程中；</p>
</li>
<li><p><code>Poller</code> 负责捞出 <code>socket</code>，并且交给线程池进行 <code>ProtocolHandler进行处理</code>；</p>
</li>
<li><p><code>NioSocketWrapper</code> 负责写出去响应消息。</p>
</li>
</ol>
<h3 id="1-3-NioEndpoint-Acceptor接收请求"><a href="#1-3-NioEndpoint-Acceptor接收请求" class="headerlink" title="1.3 NioEndpoint#Acceptor接收请求"></a>1.3 NioEndpoint#Acceptor接收请求</h3><p>OK先来看看 <code>Acceptor</code> 怎么接收请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">Acceptor</span> <span class="keyword">extends</span> <span class="title class_">AbstractEndpoint</span>.Acceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">errorDelay</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 无限循环！接收一条请求通道后进行注册</span></span><br><span class="line">      <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="comment">// 判断NioEndpoint的状态 也就是暂停状态了</span></span><br><span class="line">        <span class="keyword">while</span> (paused &amp;&amp; running) &#123;</span><br><span class="line">          state = AcceptorState.PAUSED;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state = AcceptorState.RUNNING;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 先自增1个通道，限流，超出限量10000个链接的时候，被阻塞在这里</span></span><br><span class="line">          countUpOrAwaitConnection();</span><br><span class="line"></span><br><span class="line">          <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 常年阻塞在这里</span></span><br><span class="line">            socket = serverSock.accept();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="comment">// 发生错误的时候，要把刚刚新增的限流数减下来</span></span><br><span class="line">            countDownConnection();</span><br><span class="line">            <span class="keyword">if</span> (running) &#123;</span><br><span class="line">              errorDelay = handleExceptionWithDelay(errorDelay);</span><br><span class="line">              <span class="keyword">throw</span> ioe;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 错误置零</span></span><br><span class="line">          errorDelay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">            <span class="comment">// 这句话是重点，将Socket注册到事件通道中，然后由Poller取出来处理</span></span><br><span class="line">            <span class="comment">// 来到这里的时候，整个接受请求流程也就结束了</span></span><br><span class="line">            <span class="keyword">if</span> (!setSocketOptions(socket)) &#123;</span><br><span class="line">              closeSocket(socket);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeSocket(socket);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          ExceptionUtils.handleThrowable(t);</span><br><span class="line">          log.error(sm.getString(<span class="string">&quot;endpoint.accept.fail&quot;</span>), t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state = AcceptorState.ENDED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">setSocketOptions</span><span class="params">(SocketChannel socket)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 关闭同步呀，设置一些属性</span></span><br><span class="line">      socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">      <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> socket.socket();</span><br><span class="line">      socketProperties.setProperties(sock);</span><br><span class="line"></span><br><span class="line">      <span class="type">NioChannel</span> <span class="variable">channel</span> <span class="operator">=</span> nioChannels.pop();</span><br><span class="line">      <span class="keyword">if</span> (channel == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将请求置入缓存</span></span><br><span class="line">        <span class="type">SocketBufferHandler</span> <span class="variable">bufhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SocketBufferHandler</span>(</span><br><span class="line">          socketProperties.getAppReadBufSize(),</span><br><span class="line">          socketProperties.getAppWriteBufSize(),</span><br><span class="line">          socketProperties.getDirectBuffer());</span><br><span class="line">        <span class="keyword">if</span> (isSSLEnabled()) &#123;</span><br><span class="line">          channel = <span class="keyword">new</span> <span class="title class_">SecureNioChannel</span>(socket, bufhandler, selectorPool, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          channel = <span class="keyword">new</span> <span class="title class_">NioChannel</span>(socket, bufhandler);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        channel.setIOChannel(socket);</span><br><span class="line">        channel.reset();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 均衡的取出Poller线程（之前说过是跟CPU一样的长度，最小是2），然后把这个通道注入进去！</span></span><br><span class="line">      <span class="comment">// 由对应的 Poller 线程处理请求。</span></span><br><span class="line">      getPoller0().register(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ExceptionUtils.handleThrowable(t);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&quot;</span>,t);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(tt);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Tell to close the socket</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-NioEndpoint-Poller接收请求"><a href="#1-4-NioEndpoint-Poller接收请求" class="headerlink" title="1.4 NioEndpoint#Poller接收请求"></a>1.4 NioEndpoint#Poller接收请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// Poller循环获取事件</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasEvents</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!close) &#123;</span><br><span class="line">            hasEvents = events();</span><br><span class="line">            <span class="keyword">if</span> (wakeupCounter.getAndSet(-<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 如果队列中存在任务，则立马返回已经准备完成的channel</span></span><br><span class="line">              keyCount = selector.selectNow();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 有个超时时间来返回准备完成的channel</span></span><br><span class="line">              keyCount = selector.select(selectorTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">            wakeupCounter.set(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            events();</span><br><span class="line">            timeout(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              selector.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">              log.error(sm.getString(<span class="string">&quot;endpoint.nio.selectorCloseFail&quot;</span>), ioe);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">          ExceptionUtils.handleThrowable(x);</span><br><span class="line">          log.error(<span class="string">&quot;&quot;</span>,x);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//either we timed out or we woke up, process events first</span></span><br><span class="line">        <span class="keyword">if</span> ( keyCount == <span class="number">0</span> ) hasEvents = (hasEvents  <span class="title function_">events</span><span class="params">()</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到已经准备就绪的channel的Key值</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">          keyCount &gt; <span class="number">0</span> ? selector.selectedKeys().iterator() : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 遍历所有已经准备就绪的Channel，对请求数据进行处理</span></span><br><span class="line">        <span class="keyword">while</span> (iterator != <span class="literal">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">          <span class="type">SelectionKey</span> <span class="variable">sk</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">          <span class="type">NioSocketWrapper</span> <span class="variable">attachment</span> <span class="operator">=</span> (NioSocketWrapper)sk.attachment();</span><br><span class="line">          <span class="comment">// Attachment may be null if another thread has called</span></span><br><span class="line">          <span class="comment">// cancelledKey()</span></span><br><span class="line">          <span class="keyword">if</span> (attachment == <span class="literal">null</span>) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="comment">// 在这里进入，交给ProtocolHandler来处理请求</span></span><br><span class="line">            processKey(sk, attachment);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理超时的key</span></span><br><span class="line">        timeout(keyCount,hasEvents);</span><br><span class="line">      &#125;<span class="comment">//while</span></span><br><span class="line"></span><br><span class="line">      getStopLatch().countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processKey</span><span class="params">(SelectionKey sk, NioSocketWrapper attachment)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( close ) &#123;</span><br><span class="line">          cancelledKey(sk);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( sk.isValid() &amp;&amp; attachment != <span class="literal">null</span> ) &#123;</span><br><span class="line">          <span class="comment">// 可读或者可写，即进入处理</span></span><br><span class="line">          <span class="keyword">if</span> (sk.isReadable()  sk.isWritable() ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( attachment.getSendfileData() != <span class="literal">null</span> ) &#123;</span><br><span class="line">              <span class="comment">// 处理上传文件的请求</span></span><br><span class="line">              processSendfile(sk,attachment, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              unreg(sk, attachment, sk.readyOps());</span><br><span class="line">              <span class="type">boolean</span> <span class="variable">closeSocket</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">              <span class="comment">// 先处理可读</span></span><br><span class="line">              <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                <span class="comment">// 调用外部类的方法来读取请求</span></span><br><span class="line">                <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_READ, <span class="literal">true</span>)) &#123;</span><br><span class="line">                  closeSocket = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 再处理可写</span></span><br><span class="line">              <span class="keyword">if</span> (!closeSocket &amp;&amp; sk.isWritable()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processSocket(attachment, SocketEvent.OPEN_WRITE, <span class="literal">true</span>)) &#123;</span><br><span class="line">                  closeSocket = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (closeSocket) &#123;</span><br><span class="line">                cancelledKey(sk);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//invalid key</span></span><br><span class="line">          cancelledKey(sk);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> ( CancelledKeyException ckx ) &#123;</span><br><span class="line">        cancelledKey(sk);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        log.error(<span class="string">&quot;&quot;</span>,t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个方法放置于AbstractEndpoint中，为了方便阅读就丢这个类里面了</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">processSocket</span><span class="params">(SocketWrapperBase&lt;S&gt; socketWrapper,</span></span><br><span class="line"><span class="params">                               SocketEvent event, <span class="type">boolean</span> dispatch)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (socketWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从缓存队列中取出NioEndpoint$NioSocketWrapper缓存，复用这些Socket处理器</span></span><br><span class="line">      SocketProcessorBase&lt;S&gt; sc = processorCache.pop();</span><br><span class="line">      <span class="keyword">if</span> (sc == <span class="literal">null</span>) &#123;</span><br><span class="line">        sc = createSocketProcessor(socketWrapper, event);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sc.reset(socketWrapper, event);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getExecutor();</span><br><span class="line">      <span class="comment">// 这时候请求就交给线程池异步去解析+调用我们的servlet，并且将数据写出去</span></span><br><span class="line">      <span class="keyword">if</span> (dispatch &amp;&amp; executor != <span class="literal">null</span>) &#123;</span><br><span class="line">        executor.execute(sc);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sc.run();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ree) &#123;</span><br><span class="line">      getLog().warn(sm.getString(<span class="string">&quot;endpoint.executor.fail&quot;</span>, socketWrapper) , ree);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ExceptionUtils.handleThrowable(t);</span><br><span class="line">      <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></span><br><span class="line">      <span class="comment">// the pool and its queue are full</span></span><br><span class="line">      getLog().error(sm.getString(<span class="string">&quot;endpoint.process.fail&quot;</span>), t);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来完善一下那张图： </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E5%9B%9B-tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%EF%BC%88%E4%B8%8A%EF%BC%89.md/1.jpeg"></p>
<h2 id="二-处理Request"><a href="#二-处理Request" class="headerlink" title="二. 处理Request"></a>二. 处理Request</h2><p>上面接收的请求的看的我难受，接下来就是处理请求了。涉及到怎么解析 <code>Socket</code> 数据，以及写出去，先看看调用之前 <code>Tomcat</code> 做了什么，才能让我们的 <code>servlet</code> 顺利完成请求。 由于我们上面已经将请求转移给 <code>executor</code> 执行了，而这个线程类则是 <code>NioEndpoint$SocketProcessor</code>，他的 <code>run</code> 方法在 <code>SocketProcessorBase</code> 里面，其实这个是一个模板模式，因为 <code>run</code> 又调用了子类需要实现的 <code>doRun</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SocketProcessorBase</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 一个Socket包装类.</span></span><br><span class="line">  <span class="keyword">protected</span> SocketWrapperBase&lt;S&gt; socketWrapper;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 读写可能都进来这里所以需要包装只有一个线程可以进来</span></span><br><span class="line">        <span class="comment">// 什么时候发生的后面看看能不能看到</span></span><br><span class="line">        <span class="keyword">synchronized</span> (socketWrapper) &#123;</span><br><span class="line">            <span class="comment">// 需要关心Socket是否已经被关闭了，被关闭了就不做任何事情</span></span><br><span class="line">            <span class="keyword">if</span> (socketWrapper.isClosed()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            doRun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟进子类的 <code>doRun()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">SocketProcessor</span> <span class="keyword">extends</span> <span class="title class_">SocketProcessorBase</span>&lt;NioChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketProcessor</span><span class="params">(SocketWrapperBase&lt;NioChannel&gt; socketWrapper, SocketEvent event)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(socketWrapper, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRun</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">NioChannel</span> <span class="variable">socket</span> <span class="operator">=</span> socketWrapper.getSocket();</span><br><span class="line">      <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// HTTPS握手需要用到的变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">handshake</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket.isHandshakeComplete()) &#123;</span><br><span class="line">              <span class="comment">// 没有握手</span></span><br><span class="line">              handshake = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> ...</span><br><span class="line">              <span class="comment">// 删除部分代码</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handshake == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="type">SocketState</span> <span class="variable">state</span> <span class="operator">=</span> SocketState.OPEN;</span><br><span class="line">          <span class="comment">// 开始处理request的请求byte数组</span></span><br><span class="line">          <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">            state = getHandler().process(socketWrapper, SocketEvent.OPEN_READ);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 目前状态是读取数据：SocketEvent.OPEN_READ，先获取ConnectionHandler然后处理，返回SocketState.OPEN状态</span></span><br><span class="line">            <span class="comment">// 返回了ConnectionHandler，接下来进去处理方法</span></span><br><span class="line">            state = getHandler().process(socketWrapper, event);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (state == SocketState.CLOSED) &#123;</span><br><span class="line">            close(socket, key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == -<span class="number">1</span> ) &#123;</span><br><span class="line">                    <span class="comment">// ....</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == SelectionKey.OP_READ)&#123;</span><br><span class="line">                    <span class="comment">// ....</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handshake == SelectionKey.OP_WRITE)&#123;</span><br><span class="line">                    <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CancelledKeyException cx) &#123;</span><br><span class="line">        socket.getPoller().cancelledKey(key);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (VirtualMachineError vme) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(vme);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&quot;</span>, t);</span><br><span class="line">        socket.getPoller().cancelledKey(key);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        socketWrapper = <span class="literal">null</span>;</span><br><span class="line">        event = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 缓存Processor，以便下一个请求可以直接使用</span></span><br><span class="line">        <span class="keyword">if</span> (running &amp;&amp; !paused) &#123;</span><br><span class="line">          processorCache.push(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ConnectionHandler</code> 的 <code>process</code> 方法会根据当前 <code>Socket</code> 的状态进行不同的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProtocol</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">ProtocolHandler</span>, MBeanRegistration &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConnectionHandler</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">AbstractEndpoint</span>.Handler&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> SocketState <span class="title function_">process</span><span class="params">(SocketWrapperBase&lt;S&gt; wrapper, SocketEvent status)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">        getLog().debug(sm.getString(<span class="string">&quot;abstractConnectionHandler.process&quot;</span>,</span><br><span class="line">                                    wrapper.getSocket(), status));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (wrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">S</span> <span class="variable">socket</span> <span class="operator">=</span> wrapper.getSocket();</span><br><span class="line"></span><br><span class="line">      <span class="type">Processor</span> <span class="variable">processor</span> <span class="operator">=</span> connections.get(socket);</span><br><span class="line">      <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">        getLog().debug(sm.getString(<span class="string">&quot;abstractConnectionHandler.connectionsGet&quot;</span>,</span><br><span class="line">                                    processor, socket));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 确认TIMEOUT时间</span></span><br><span class="line">      <span class="keyword">if</span> (SocketEvent.TIMEOUT == status &amp;&amp;</span><br><span class="line">          (processor == <span class="literal">null</span> </span><br><span class="line">           !processor.isAsync() &amp;&amp; !processor.isUpgrade() </span><br><span class="line">           processor.isAsync() &amp;&amp; !processor.checkAsyncTimeoutGeneration())) &#123;</span><br><span class="line">        <span class="comment">// This is effectively a NO-OP</span></span><br><span class="line">        <span class="keyword">return</span> SocketState.OPEN;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (processor != <span class="literal">null</span>) &#123;</span><br><span class="line">        getProtocol().removeWaitingProcessor(processor);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.DISCONNECT  status == SocketEvent.ERROR) &#123;</span><br><span class="line">        <span class="comment">// Nothing to do. Endpoint requested a close and there is no</span></span><br><span class="line">        <span class="comment">// longer a processor associated with this socket.</span></span><br><span class="line">        <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ContainerThreadMarker.set();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (processor == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">negotiatedProtocol</span> <span class="operator">=</span> wrapper.getNegotiatedProtocol();</span><br><span class="line">          <span class="comment">// 处理SSL</span></span><br><span class="line">          <span class="keyword">if</span> (negotiatedProtocol != <span class="literal">null</span> &amp;&amp; negotiatedProtocol.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (processor == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 从processors队列尝试取出一个processor来进行处理</span></span><br><span class="line">          processor = recycledProcessors.pop();</span><br><span class="line">          <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">            getLog().debug(sm.getString(<span class="string">&quot;abstractConnectionHandler.processorPop&quot;</span>, processor));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (processor == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 创建并丢进去缓存中以便使用</span></span><br><span class="line">          processor = getProtocol().createProcessor();</span><br><span class="line">          register(processor);</span><br><span class="line">          <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">            getLog().debug(sm.getString(<span class="string">&quot;abstractConnectionHandler.processorCreate&quot;</span>, processor));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SSL，先不看</span></span><br><span class="line">        processor.setSslSupport(</span><br><span class="line">          wrapper.getSslSupport(getProtocol().getClientCertProvider()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将连接的Socket和Processor关联起来</span></span><br><span class="line">        connections.put(socket, processor);</span><br><span class="line"></span><br><span class="line">        <span class="type">SocketState</span> <span class="variable">state</span> <span class="operator">=</span> SocketState.CLOSED;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// 关键代码！！！！！！！！！！！！！！：交给Processor进行处理</span></span><br><span class="line">          state = processor.process(wrapper, status);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理连接升级的业务</span></span><br><span class="line">          <span class="keyword">if</span> (state == SocketState.UPGRADING) &#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( state == SocketState.UPGRADING);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理连接状态</span></span><br><span class="line">        <span class="keyword">if</span> (state == SocketState.LONG) &#123;</span><br><span class="line">          longPoll(wrapper, processor);</span><br><span class="line">          <span class="keyword">if</span> (processor.isAsync()) &#123;</span><br><span class="line">            getProtocol().addWaitingProcessor(processor);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.OPEN) &#123;</span><br><span class="line">          connections.remove(socket);</span><br><span class="line">          release(processor);</span><br><span class="line">          wrapper.registerReadInterest();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.SENDFILE) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.UPGRADED) &#123;</span><br><span class="line">          <span class="keyword">if</span> (status != SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">            longPoll(wrapper, processor);</span><br><span class="line">            getProtocol().addWaitingProcessor(processor);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.SUSPENDED) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 开始回收Processor数据，以便后续使用</span></span><br><span class="line">          connections.remove(socket);</span><br><span class="line">          <span class="keyword">if</span> (processor.isUpgrade()) &#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">          &#125;</span><br><span class="line">          release(processor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(java.net.SocketException e) &#123;</span><br><span class="line">        <span class="comment">// 删除大部分异常的处理流程代码</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ContainerThreadMarker.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 释放 socket/processor 的连接</span></span><br><span class="line">      connections.remove(socket);</span><br><span class="line">      release(processor);</span><br><span class="line">      <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交给 <code>Processor</code> 的 <code>process</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProcessorLight</span> <span class="keyword">implements</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">  <span class="comment">// ConnectionHandler</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SocketState <span class="title function_">process</span><span class="params">(SocketWrapperBase&lt;?&gt; socketWrapper, SocketEvent status)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// this: Http11Processor</span></span><br><span class="line">    <span class="type">SocketState</span> <span class="variable">state</span> <span class="operator">=</span> SocketState.CLOSED;</span><br><span class="line">    Iterator&lt;DispatchType&gt; dispatches = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (dispatches != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">DispatchType</span> <span class="variable">nextDispatch</span> <span class="operator">=</span> dispatches.next();</span><br><span class="line">        <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">          getLog().debug(<span class="string">&quot;Processing dispatch type: [&quot;</span> + nextDispatch + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        state = dispatch(nextDispatch.getSocketStatus());</span><br><span class="line">        <span class="keyword">if</span> (!dispatches.hasNext()) &#123;</span><br><span class="line">          state = checkForPipelinedData(state, socketWrapper);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.DISCONNECT) &#123;</span><br><span class="line">        <span class="comment">// Do nothing here, just wait for it to get recycled</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync()  isUpgrade()  state == SocketState.ASYNC_END) &#123;</span><br><span class="line">        state = dispatch(status);</span><br><span class="line">        state = checkForPipelinedData(state, socketWrapper);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_WRITE) &#123;</span><br><span class="line">        <span class="comment">// Extra write event likely after async, ignore</span></span><br><span class="line">        state = SocketState.LONG;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.OPEN_READ) &#123;</span><br><span class="line">        <span class="comment">// 目前是OPEN_READ状态，处理请求的关键部位，这个方法由子类去实现</span></span><br><span class="line">        state = service(socketWrapper);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == SocketEvent.CONNECT_FAIL) &#123;</span><br><span class="line">        logAccess(socketWrapper);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Default to closing the socket if the SocketEvent passed in</span></span><br><span class="line">        <span class="comment">// is not consistent with the current state of the Processor</span></span><br><span class="line">        state = SocketState.CLOSED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 删除日志记录代码</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (state != SocketState.CLOSED &amp;&amp; isAsync()) &#123;</span><br><span class="line">        state = asyncPostProcess();</span><br><span class="line">        <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</span><br><span class="line">          getLog().debug(<span class="string">&quot;Socket: [&quot;</span> + socketWrapper +</span><br><span class="line">                         <span class="string">&quot;], State after async post processing: [&quot;</span> + state + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (dispatches == <span class="literal">null</span>  !dispatches.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// Only returns non-null iterator if there are</span></span><br><span class="line">        <span class="comment">// dispatches to process.</span></span><br><span class="line">        dispatches = getIteratorAndClearDispatches();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (state == SocketState.ASYNC_END </span><br><span class="line">             dispatches != <span class="literal">null</span> &amp;&amp; state != SocketState.CLOSED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Http11Processor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> SocketState <span class="title function_">service</span><span class="params">(SocketWrapperBase&lt;?&gt; socketWrapper)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 开始处理请求</span></span><br><span class="line">    <span class="type">RequestInfo</span> <span class="variable">rp</span> <span class="operator">=</span> request.getRequestProcessor();</span><br><span class="line">    rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setting up the I/O</span></span><br><span class="line">    setSocketWrapper(socketWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flags</span></span><br><span class="line">    keepAlive = <span class="literal">true</span>;</span><br><span class="line">    openSocket = <span class="literal">false</span>;</span><br><span class="line">    readComplete = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">keptAlive</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">SendfileState</span> <span class="variable">sendfileState</span> <span class="operator">=</span> SendfileState.DONE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!getErrorState().isError() &amp;&amp; keepAlive &amp;&amp; !isAsync() &amp;&amp; upgradeToken == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">           sendfileState == SendfileState.DONE &amp;&amp; !endpoint.isPaused()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 解析HttpHeader</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!inputBuffer.parseRequestLine(keptAlive)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (inputBuffer.getParsingRequestLinePhase() == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> SocketState.UPGRADING;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handleIncompleteRequestLineRead()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (endpoint.isPaused()) &#123;</span><br><span class="line">          <span class="comment">// 如果endpoint暂停了，返回请求错误503</span></span><br><span class="line">          response.setStatus(<span class="number">503</span>);</span><br><span class="line">          setErrorState(ErrorState.CLOSE_CLEAN, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          keptAlive = <span class="literal">true</span>;</span><br><span class="line">          request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());</span><br><span class="line">          <span class="comment">// 解析HTTP-Header获取我们访问的访问协议内容，包括Content-Type, Method等等</span></span><br><span class="line">          <span class="keyword">if</span> (!inputBuffer.parseHeaders()) &#123;</span><br><span class="line">            openSocket = <span class="literal">true</span>;</span><br><span class="line">            readComplete = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (!disableUploadTimeout) &#123;</span><br><span class="line">            socketWrapper.setReadTimeout(connectionUploadTimeout);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(sm.getString(<span class="string">&quot;http11processor.header.parse&quot;</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">        setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        UserDataHelper.<span class="type">Mode</span> <span class="variable">logMode</span> <span class="operator">=</span> userDataHelper.getNextMode();</span><br><span class="line">        <span class="keyword">if</span> (logMode != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sm.getString(<span class="string">&quot;http11processor.header.parse&quot;</span>);</span><br><span class="line">          <span class="keyword">switch</span> (logMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> INFO_THEN_DEBUG:</span><br><span class="line">              message += sm.getString(<span class="string">&quot;http11processor.fallToDebug&quot;</span>);</span><br><span class="line">              <span class="comment">//$FALL-THROUGH$</span></span><br><span class="line">            <span class="keyword">case</span> INFO:</span><br><span class="line">              log.info(message, t);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DEBUG:</span><br><span class="line">              log.debug(message, t);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 400 - Bad Request</span></span><br><span class="line">        response.setStatus(<span class="number">400</span>);</span><br><span class="line">        setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Has an upgrade been requested?</span></span><br><span class="line">      <span class="keyword">if</span> (isConnectionToken(request.getMimeHeaders(), <span class="string">&quot;upgrade&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 协议升级的一些处理</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestedProtocol</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Upgrade&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UpgradeProtocol</span> <span class="variable">upgradeProtocol</span> <span class="operator">=</span> protocol.getUpgradeProtocol(requestedProtocol);</span><br><span class="line">        <span class="keyword">if</span> (upgradeProtocol != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 省略升级请求的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;</span><br><span class="line">        <span class="comment">// Setting up filters, and parse some request headers</span></span><br><span class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 在这里将字符串的byte数组进行翻译，依据反编译byte到字符串然后比对的形式进行设置</span></span><br><span class="line">          prepareRequest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          ExceptionUtils.handleThrowable(t);</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;http11processor.request.prepare&quot;</span>), t);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 500 - Internal Server Error</span></span><br><span class="line">          response.setStatus(<span class="number">500</span>);</span><br><span class="line">          setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (maxKeepAliveRequests == <span class="number">1</span>) &#123;</span><br><span class="line">        keepAlive = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxKeepAliveRequests &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 socketWrapper.decrementKeepAlive() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        keepAlive = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Process the request in the adapter</span></span><br><span class="line">      <span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);</span><br><span class="line">          <span class="comment">// 关键代码！！！！！！！！！：进入下一个环节，找到对应的处理器来处理请求和响应结果</span></span><br><span class="line">          <span class="comment">// response在构造当前Http11Processor的时候就被创建了</span></span><br><span class="line">          getAdapter().service(request, response);</span><br><span class="line">          <span class="keyword">if</span>(keepAlive &amp;&amp; !getErrorState().isError() &amp;&amp; !isAsync() &amp;&amp;</span><br><span class="line">             statusDropsConnection(response.getStatus())) &#123;</span><br><span class="line">            setErrorState(ErrorState.CLOSE_CLEAN, <span class="literal">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedIOException e) &#123;</span><br><span class="line">          setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HeadersTooLargeException e) &#123;</span><br><span class="line">          <span class="comment">// 抛出异常都设置status=500；</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          ExceptionUtils.handleThrowable(t);</span><br><span class="line">          log.error(sm.getString(<span class="string">&quot;http11processor.request.process&quot;</span>), t);</span><br><span class="line">          <span class="comment">// 500 - Internal Server Error</span></span><br><span class="line">          response.setStatus(<span class="number">500</span>);</span><br><span class="line">          setErrorState(ErrorState.CLOSE_CLEAN, t);</span><br><span class="line">          getAdapter().log(request, response, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 回收Request、Response资源，以便后续可以继续使用当前Processor对象.</span></span><br><span class="line">      rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);</span><br><span class="line">      <span class="keyword">if</span> (!isAsync()) &#123;</span><br><span class="line">        endRequest();</span><br><span class="line">      &#125;</span><br><span class="line">      rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果有错误，返回500</span></span><br><span class="line">      <span class="keyword">if</span> (getErrorState().isError()) &#123;</span><br><span class="line">        response.setStatus(<span class="number">500</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isAsync()  getErrorState().isError()) &#123;</span><br><span class="line">        request.updateCounters();</span><br><span class="line">        <span class="keyword">if</span> (getErrorState().isIoAllowed()) &#123;</span><br><span class="line">          inputBuffer.nextRequest();</span><br><span class="line">          outputBuffer.nextRequest();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!disableUploadTimeout) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">soTimeout</span> <span class="operator">=</span> endpoint.getConnectionTimeout();</span><br><span class="line">        <span class="keyword">if</span>(soTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          socketWrapper.setReadTimeout(soTimeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          socketWrapper.setReadTimeout(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);</span><br><span class="line"></span><br><span class="line">      sendfileState = processSendfile(socketWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getErrorState().isError()  endpoint.isPaused()) &#123;</span><br><span class="line">      <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync()) &#123;</span><br><span class="line">      <span class="keyword">return</span> SocketState.LONG;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUpgrade()) &#123;</span><br><span class="line">      <span class="keyword">return</span> SocketState.UPGRADING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sendfileState == SendfileState.PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> SocketState.SENDFILE;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (openSocket) &#123;</span><br><span class="line">          <span class="keyword">if</span> (readComplete) &#123;</span><br><span class="line">            <span class="comment">// 返回OPEN状态</span></span><br><span class="line">            <span class="keyword">return</span> SocketState.OPEN;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> SocketState.LONG;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> SocketState.CLOSED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>tomcat源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tomcat】二.Tomcat启动初始化Boostrap</title>
    <url>//tomcat/%E3%80%90tomcat%E3%80%91%E4%BA%8C-tomcat%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96boostrap/index.html</url>
    <content><![CDATA[<h2 id="零-Bootstrap初始化"><a href="#零-Bootstrap初始化" class="headerlink" title="零.Bootstrap初始化"></a>零.Bootstrap初始化</h2><p><code>Bootstrap</code> 可以看成是一个 <code>TomcatServer</code> 运行时需要的环境的准备，这里通过加载配置文件，设置全局数据以便让后面的 <code>组件</code> 初始化的时候可以使用到。</p>
<a id="more"></a>
<h2 id="一-获取Tomcat运行的配置目录"><a href="#一-获取Tomcat运行的配置目录" class="headerlink" title="一.获取Tomcat运行的配置目录"></a>一.获取Tomcat运行的配置目录</h2><p>那么首先是在 <code>static代码块</code> 中获取到运行环境的目录基础：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Bootstrap</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Bootstrap.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Daemon object used by main.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">daemonLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 声明一个Bootstrap静默线程的对象引用，main方法将会用到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Bootstrap</span> <span class="variable">daemon</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaBaseFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaHomeFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">PATH_PATTERN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\&quot;.*?\&quot;)(([^,])*)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前运行的绝对路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取catalina.home的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">home</span> <span class="operator">=</span> System.getProperty(Globals.CATALINA_HOME_PROP);</span><br><span class="line">        <span class="type">File</span> <span class="variable">homeFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (home != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(home);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两次尝试获取homeFile的值，不过刚开始我们就配置了，所以这两个判断直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">bootstrapJar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(userDir, <span class="string">&quot;bootstrap.jar&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (bootstrapJar.exists()) &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(userDir, <span class="string">&quot;..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    homeFile = f.getCanonicalFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    homeFile = f.getAbsoluteFile();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Second fall-back. Use current directory</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(userDir);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储到Boostrap的静态变量中.</span></span><br><span class="line">        catalinaHomeFile = homeFile;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_HOME_PROP, catalinaHomeFile.getPath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后获取catalina.base的值，也同样存储到System属性中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">base</span> <span class="operator">=</span> System.getProperty(Globals.CATALINA_BASE_PROP);</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="literal">null</span>) &#123;</span><br><span class="line">            catalinaBaseFile = catalinaHomeFile;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">baseFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baseFile = baseFile.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                baseFile = baseFile.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">            catalinaBaseFile = baseFile;</span><br><span class="line">        &#125;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_BASE_PROP, catalinaBaseFile.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// .......省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二-读取运行参数"><a href="#二-读取运行参数" class="headerlink" title="二.读取运行参数"></a>二.读取运行参数</h2><p>既然第一步已经初始化好了运行时所需要使用的 <code>文件路径</code>，那么接下来肯定就是读取配置并且根据配置来初始化项目了。这一步就直接在 <code>main</code> 方法中进行调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Bootstrap</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="comment">// 加锁初始化 Boostrap 的静默引用</span></span><br><span class="line">        <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t set daemon until init() has completed</span></span><br><span class="line">                <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bootstrap.init();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    handleThrowable(t);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 持有引用</span></span><br><span class="line">                daemon = bootstrap;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据运行的命令做相对应的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">&quot;startd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stopd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">                daemon.setAwait(<span class="literal">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;configtest&quot;</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Bootstrap: command \&quot;&quot;</span> + command + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                    t.getCause() != <span class="literal">null</span>) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-Bootstrap初始化"><a href="#2-1-Bootstrap初始化" class="headerlink" title="2.1 Bootstrap初始化"></a>2.1 Bootstrap初始化</h3><p>包括初始化自定义的 <code>ClassLoader</code> 以及 <code>Catalina</code> 的准备工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// 初始化三个ClassLoader</span></span><br><span class="line">  initClassLoaders();</span><br><span class="line">  <span class="comment">// 将当前线程的ClassLoader设置成Catalina的Loader</span></span><br><span class="line">  Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过反射，做 Catalina 的准备工作</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Loading startup class&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">&quot;org.apache.catalina.startup.Catalina&quot;</span>);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">startupInstance</span> <span class="operator">=</span> startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 sharedLoader 设置成 Catalina 的父级 ClassLoader</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Setting startup class properties&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;setParentClassLoader&quot;</span>;</span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">&quot;java.lang.ClassLoader&quot;</span>);</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">  <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span></span><br><span class="line">    startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">  method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">  catalinaDaemon = startupInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要初始化三个 <code>ClassLoader</code>（但其实到最后三个都指向 <code>commonLoader</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initClassLoaders</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    commonLoader = createClassLoader(<span class="string">&quot;common&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (commonLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// no config file, default to this loader - we might be in a &#x27;single&#x27; env.</span></span><br><span class="line">      commonLoader = <span class="built_in">this</span>.getClass().getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    catalinaLoader = createClassLoader(<span class="string">&quot;server&quot;</span>, commonLoader);</span><br><span class="line">    sharedLoader = createClassLoader(<span class="string">&quot;shared&quot;</span>, commonLoader);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    handleThrowable(t);</span><br><span class="line">    log.error(<span class="string">&quot;Class loader creation threw exception&quot;</span>, t);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们现在就有这些 <code>ClassLoader</code>： </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E4%BA%8C-tomcat%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96boostrap.md/0.jpeg"> </p>
<p>每一层加载 <code>Class</code> 的时候， <code>Loader</code> 就都会说：<code>你去找你爷去</code>，找到最后没有找到，才退下来一层，如果找到了就返回，到最后都没有找到就会抛出 <code>ClassNotFoundException</code>。 所以这种方式可以很好的防止我们使用一个同样的类，对 <code>Tomcat</code> 造成破坏。 根据 <code>catalina-home/conf/catalina.properties</code> 的配置创建初始化 <code>ClassLoader</code>。我们使用的是默认配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">common.loader</span>=<span class="string">&quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span></span><br><span class="line"><span class="attr">server.loader</span>=<span class="string"></span></span><br><span class="line"><span class="attr">shared.loader</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>
<p>由于只有 <code>common.loader</code> 配置了规则，所以下面两个在创建的时候由于没有配置，直接将 <code>commonClassLoader</code> 返回了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ClassLoader <span class="title function_">createClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// 通过读取 catalina-home/conf/catalina.properties 的配置，</span></span><br><span class="line">  <span class="comment">// 如果没有配置，则返回直接返回父级的ClassLoader</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> CatalinaProperties.getProperty(name + <span class="string">&quot;.loader&quot;</span>);</span><br><span class="line">  <span class="comment">// 默认情况下，shared和Catalina的ClassLoader都没有配置，直接返回了CommonLoader实例</span></span><br><span class="line">  <span class="keyword">if</span> ((value == <span class="literal">null</span>)  (value.equals(<span class="string">&quot;&quot;</span>)))</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line"></span><br><span class="line">  value = replace(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在加载CommonLoader的时候加载了 lib 文件夹下的所有jar包.</span></span><br><span class="line">  List&lt;Repository&gt; repositories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  String[] repositoryPaths = getPaths(value);</span><br><span class="line">  <span class="comment">// 循环 catalina-home/catalina.properties 配置的规则的路径，</span></span><br><span class="line">  <span class="comment">// 使用 URL 加载 jar 包</span></span><br><span class="line">  <span class="keyword">for</span> (String repository : repositoryPaths) &#123;</span><br><span class="line">    <span class="comment">// Check for a JAR URL repository</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">      <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(repository);</span><br><span class="line">      repositories.add(<span class="keyword">new</span> <span class="title class_">Repository</span>(repository, RepositoryType.URL));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local repository</span></span><br><span class="line">    <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;*.jar&quot;</span>)) &#123;</span><br><span class="line">      repository = repository.substring</span><br><span class="line">        (<span class="number">0</span>, repository.length() - <span class="string">&quot;*.jar&quot;</span>.length());</span><br><span class="line">      repositories.add(<span class="keyword">new</span> <span class="title class_">Repository</span>(repository, RepositoryType.GLOB));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> <span class="title class_">Repository</span>(repository, RepositoryType.JAR));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> <span class="title class_">Repository</span>(repository, RepositoryType.DIR));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ClassLoaderFactory.createClassLoader(repositories, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步的就不打算走下去了，只要知道目前 <code>commonClassLoader</code> 加载了 <code>lib</code> 下的所有包就可以了。</p>
<h3 id="2-2-Bootstrap启动"><a href="#2-2-Bootstrap启动" class="headerlink" title="2.2 Bootstrap启动"></a>2.2 Bootstrap启动</h3><p>加载完 <code>jar</code> 包目录，接下来就是启动了，在 <code>main</code> 方法里面我们可以直接看这几句话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">  daemon.setAwait(<span class="literal">true</span>);</span><br><span class="line">  daemon.load(args);</span><br><span class="line">  daemon.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == daemon.getServer()) &#123;</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，设置 <code>Catalina</code> 进行等候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAwait</span><span class="params">(<span class="type">boolean</span> await)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Boolean.TYPE;</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = Boolean.valueOf(await);</span><br><span class="line">  <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span></span><br><span class="line">    catalinaDaemon.getClass().getMethod(<span class="string">&quot;setAwait&quot;</span>, paramTypes);</span><br><span class="line">  method.invoke(catalinaDaemon, paramValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>Bootstrap</code> 设置 <code>Catalina</code> 的时候，一直都是通过反射的形式调用，这是因为 <code>Boostrap</code> 要保证 <code>Catalina</code> 类和 <code>XML读取的相关工具</code> 在不同的 <code>ClassLoader</code> 中，从而可以保证 <code>Catalina</code> 加载的我们 <code>war</code> 项目不可以访问到 <code>Tomcat的关键类</code>。</p>
<blockquote>
<p>Catalina：蛮好听的名字，查了一下百度资料，Catalina 是美国西海岸靠近洛杉矶22英里的一个小岛，因为其风景秀丽而著名。 Servlet 运行模块的最早开发者 Craig McClanahan 因为喜欢 Catalina岛 故以 Catalina 命名他所开这个模块，尽管他从来也没有去过那里。 另外在开发的早期阶段，Tomcat是被搭建在一个叫 Avalon 的服务器框架上，而 Avalon 则是 Catalina 岛上的一个小镇的名字，于是想一个与小镇名字相关联的单词也是自然而然。还有一个原因来自于 Craig McClanahan 养的猫，他养的猫在他写程序的时候喜欢在电脑周围闲逛。</p>
</blockquote>
<p>那就想象成 <code>Bootstrap</code> 把这个岛建立起来了！。 那第二句 <code>daemon.load(args);</code> 也是通过反射调用，代码就不贴了，直接进入 <code>Catalina.class#load()</code>。</p>
<h2 id="三-Catalina加载配置"><a href="#三-Catalina加载配置" class="headerlink" title="三.Catalina加载配置"></a>三.Catalina加载配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Catalina</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 装配 server.xml 的配置</span></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    initDirs();</span><br><span class="line">    initNaming();</span><br><span class="line">    <span class="type">Digester</span> <span class="variable">digester</span> <span class="operator">=</span> createStartDigester();</span><br><span class="line">    <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        file = configFile();</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        inputSource = <span class="keyword">new</span> <span class="title class_">InputSource</span>(file.toURI().toURL().toString());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>, file), e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(getConfigFile());</span><br><span class="line">          inputSource = <span class="keyword">new</span> <span class="title class_">InputSource</span></span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(getConfigFile()).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   getConfigFile()), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This should be included in catalina.jar</span></span><br><span class="line">      <span class="comment">// Alternative: don&#x27;t bother with xml, just create it manually.</span></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(<span class="string">&quot;server-embed.xml&quot;</span>);</span><br><span class="line">          inputSource = <span class="keyword">new</span> <span class="title class_">InputSource</span></span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(<span class="string">&quot;server-embed.xml&quot;</span>).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   <span class="string">&quot;server-embed.xml&quot;</span>), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="literal">null</span>  inputSource == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (file == <span class="literal">null</span>) &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                getConfigFile() + <span class="string">&quot;] or [server-embed.xml]&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                file.getAbsolutePath()));</span><br><span class="line">          <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Permissions incorrect, read permission is not allowed on the file.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="built_in">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">                 spe.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> , e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存Server的一些信息：</span></span><br><span class="line">    getServer().setCatalina(<span class="built_in">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将日志输出流从默认的 System.out 替换成 Tomcat 自己的实现.</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始初始化 Server，也就是最大的一层。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.lang.Error(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Catalina.start&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;Initialization processed in &quot;</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看人家配置解析，Emm还是蛮无聊的，直接跳过去了。只要知道是根据 <code>server.xml</code> 解析创建对象就可以了，在这个过程中，实例化了 <code>server</code> 对象。 那么接下来就需要初始化里面的内容了，我们大概还记得这个图： </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E4%BA%8C-tomcat%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96boostrap.md/1.jpeg"><br><code>getServer().init();</code> 相当于初始化 <code>TomcatServer</code>。 我们知道一个 <code>Service</code> 包含了 <code>Connector</code> 和 <code>Engine</code>，所以初始化肯定涉及这两个鬼：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardService</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="literal">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-StandardServer初始化"><a href="#四-StandardServer初始化" class="headerlink" title="四.StandardServer初始化"></a>四.StandardServer初始化</h2><h3 id="4-1-lifecycle生命周期转换"><a href="#4-1-lifecycle生命周期转换" class="headerlink" title="4.1 lifecycle生命周期转换"></a>4.1 lifecycle生命周期转换</h3><p><code>StandardServer</code> 就需要先看看 <code>Lifecycle</code> 接口了： </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E4%BA%8C-tomcat%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96boostrap.md/2.jpeg"> </p>
<p>这个接口规范了在 <code>Tomcat</code> 运行期间的 <code>生命周期函数</code>。只要跟 <code>Tomcat</code> 一起运行的，就会有这些 <code>生命周期</code>。 与此同时还有个 <code>LifecycleBase</code> 实现了基本的生命周期转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LifecycleBase</span> <span class="keyword">implements</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">      invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZING, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">      initInternal();</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZED, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      handleSubClassException(t, <span class="string">&quot;lifecycleBase.initFail&quot;</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类实现这个即可实现转换</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-StandardServer初始化"><a href="#4-2-StandardServer初始化" class="headerlink" title="4.2 StandardServer初始化"></a>4.2 StandardServer初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StandardServer</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String注册</span></span><br><span class="line">    onameStringCache = register(<span class="keyword">new</span> <span class="title class_">StringCache</span>(), <span class="string">&quot;type=StringCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册MBeanFactory，用来创建</span></span><br><span class="line">    <span class="type">MBeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MBeanFactory</span>();</span><br><span class="line">    factory.setContainer(<span class="built_in">this</span>);</span><br><span class="line">    onameMBeanFactory = register(factory, <span class="string">&quot;type=MBeanFactory&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局组件名字的组件</span></span><br><span class="line">    globalNamingResources.init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getCatalina() != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> getCatalina().getParentClassLoader();</span><br><span class="line">      <span class="comment">// 加载 shared 和 common ClassLoader 的Jar包，一直到 SystemClassLoader</span></span><br><span class="line">      <span class="keyword">while</span> (cl != <span class="literal">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">          URL[] urls = ((URLClassLoader) cl).getURLs();</span><br><span class="line">          <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span> (url.toURI());</span><br><span class="line">                <span class="keyword">if</span> (f.isFile() &amp;&amp;</span><br><span class="line">                    f.getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                  ExtensionValidator.addSystemResource(f);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化Service</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">      services[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载了一些 <code>Jar</code> 包，然后就初始化我们最熟悉的 <code>Service</code>。</p>
<h2 id="五-StandardService初始化"><a href="#五-StandardService初始化" class="headerlink" title="五.StandardService初始化"></a>五.StandardService初始化</h2><p>同样的实现了 <code>Lifecycle</code> 接口，所以我们只需要关注 <code>initInternal</code> 即可。那我们知道 <code>Service</code> 是包含一个 <code>Engine</code> 和 <code>接收数据的 Connector</code> 的。所以他的初始化主要是关注这两者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardService</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="literal">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-Engine初始化"><a href="#六-Engine初始化" class="headerlink" title="六.Engine初始化"></a>六.Engine初始化</h2><p><code>Engine</code> 默认实现是 <code>StandardEngine</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StandardEngine</span> <span class="keyword">extends</span> <span class="title class_">ContainerBase</span> <span class="keyword">implements</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">    <span class="comment">// Realm，一个认证的东西，这里保证加载成功</span></span><br><span class="line">    getRealm();</span><br><span class="line">    <span class="built_in">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来瞄一下配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Server&gt;  </span><br><span class="line">  &lt;!-- 省略 --&gt;</span><br><span class="line">    &lt;Service name=&quot;Catalina&quot;&gt;</span><br><span class="line">    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; secretRequired=&quot;&quot;/&gt;</span><br><span class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</span><br><span class="line">        &lt;!-- 这是一个混合的Realm认证，可以包含其他的 Realm --&gt;</span><br><span class="line">      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</span><br><span class="line">        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span><br><span class="line">               resourceName=&quot;UserDatabase&quot;/&gt;</span><br><span class="line">      &lt;/Realm&gt;</span><br><span class="line">      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;</span><br><span class="line">            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</span><br><span class="line">        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</span><br><span class="line">               prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;</span><br><span class="line">               pattern=&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; /&gt;</span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">    &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure>
<p><code>LockOutRealm</code> 是一个可以组合子 <code>Realm</code> 的类，规定了在一定时间内 <code>用户鉴权出错次数</code>，超出次数则会返回错误。不过项目中一般不用这个。 接下来 <code>super.initInternal()</code> ，父类不是 <code>LifecycleBase</code> 了，而是另外一个类：<code>ContainerBase</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ContainerBase</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; startStopQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">    startStopExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">      getStartStopThreadsInternal(),</span><br><span class="line">      getStartStopThreadsInternal(), <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">      startStopQueue,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">StartStopThreadFactory</span>(getName() + <span class="string">&quot;-startStop-&quot;</span>));</span><br><span class="line">    startStopExecutor.allowCoreThreadTimeOut(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是初始化线程池实例以便后续可以让项目可以并行执行部署。</p>
<h2 id="七-MapperListener初始化"><a href="#七-MapperListener初始化" class="headerlink" title="七.MapperListener初始化"></a>七.MapperListener初始化</h2><p>这个容器主要处理 <code>HOST</code> 以及 <code>URI</code> 映射的 <code>Servlet</code>。初始化没做什么事情，只是注册了个名字，先跳过不看。</p>
<h2 id="八-Connector初始化"><a href="#八-Connector初始化" class="headerlink" title="八.Connector初始化"></a>八.Connector初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Connector</span> <span class="keyword">extends</span> <span class="title class_">LifecycleMBeanBase</span>  &#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize adapter</span></span><br><span class="line">    adapter = <span class="keyword">new</span> <span class="title class_">CoyoteAdapter</span>(<span class="built_in">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">      <span class="comment">// 设置需要解析消息体的HTTPMethod</span></span><br><span class="line">      setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isInstanceCreated()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprListener&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprLibrary&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">        protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">      AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">        (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">      <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">          jsseProtocolHandler.getSslImplementationName() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">        jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化协议处理器：Http11NIOProtocol</span></span><br><span class="line">      protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LifecycleException</span>(</span><br><span class="line">        sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParseBodyMethods</span><span class="params">(String methods)</span> &#123;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; methodSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != methods) &#123;</span><br><span class="line">      methodSet.addAll(Arrays.asList(methods.split(<span class="string">&quot;\\s*,\\s*&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (methodSet.contains(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(sm.getString(<span class="string">&quot;coyoteConnector.parseBodyMethodNoTrace&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.parseBodyMethods = methods;</span><br><span class="line">    <span class="built_in">this</span>.parseBodyMethodsSet = methodSet;</span><br><span class="line">    setProperty(<span class="string">&quot;parseBodyMethods&quot;</span>, methods);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="九-Http11NIOProtocol初始化"><a href="#九-Http11NIOProtocol初始化" class="headerlink" title="九.Http11NIOProtocol初始化"></a>九.Http11NIOProtocol初始化</h2><p><code>Http11NIOProtocol</code> 是一个 <code>HTTP 1.1</code> 的解析器，所以他需要负责 <code>Request</code> 和 <code>Response</code> 的解析，所以，这里又通过一个 <code>Endpoint</code> 组件来做，所以需要初始化 <code>Endpont</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProtocol</span>&lt;S&gt; <span class="keyword">implements</span> <span class="title class_">ProtocolHandler</span>, MBeanRegistration &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">      getLog().info(sm.getString(<span class="string">&quot;abstractProtocolHandler.init&quot;</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="literal">null</span>) &#123;</span><br><span class="line">      oname = createObjectName();</span><br><span class="line">      <span class="keyword">if</span> (oname != <span class="literal">null</span>) &#123;</span><br><span class="line">        Registry.getRegistry(<span class="literal">null</span>, <span class="literal">null</span>).registerComponent(<span class="built_in">this</span>, oname, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.domain != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 与域名绑定解析器</span></span><br><span class="line">      rgOname = <span class="keyword">new</span> <span class="title class_">ObjectName</span>(domain + <span class="string">&quot;:type=GlobalRequestProcessor,name=&quot;</span> + getName());</span><br><span class="line">      Registry.getRegistry(<span class="literal">null</span>, <span class="literal">null</span>).registerComponent(</span><br><span class="line">        getHandler().getGlobal(), rgOname, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取接口名字并初始化，接口在这里的意思是管理Socket数据进出的意思</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">endpointName</span> <span class="operator">=</span> getName();</span><br><span class="line">    <span class="comment">// Endpoint在解析server.xml被初始化，现在是设置一些数据</span></span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line"></span><br><span class="line">    endpoint.init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;S&gt; <span class="keyword">extends</span> <span class="title class_">AbstractEndpoint</span>&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    testServerCipherSuitesOrderSupport();</span><br><span class="line">    <span class="built_in">super</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testServerCipherSuitesOrderSupport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// JDK8下不支持使用SSLImplementation实现类，估计是修复Bug时需要hhh</span></span><br><span class="line">    <span class="keyword">if</span>(!JreCompat.isJre8Available() &amp;&amp;</span><br><span class="line">       !OpenSSLImplementation.class.getName().equals(getSslImplementationName())) &#123;</span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : sslHostConfigs.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sslHostConfig.getHonorCipherOrder() != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(</span><br><span class="line">            sm.getString(<span class="string">&quot;endpoint.jsse.cannotHonorServerCipherOrder&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractEndpoint</span>&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">      bind();</span><br><span class="line">      bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.domain != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Register endpoint (as ThreadPool - historical name)</span></span><br><span class="line">      oname = <span class="keyword">new</span> <span class="title class_">ObjectName</span>(domain + <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      Registry.getRegistry(<span class="literal">null</span>, <span class="literal">null</span>).registerComponent(<span class="built_in">this</span>, oname, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">ObjectName</span> <span class="variable">socketPropertiesOname</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectName</span>(domain +</span><br><span class="line">                                                        <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;,subType=SocketProperties&quot;</span>);</span><br><span class="line">      socketProperties.setObjectName(socketPropertiesOname);</span><br><span class="line">      Registry.getRegistry(<span class="literal">null</span>, <span class="literal">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) &#123;</span><br><span class="line">        registerJmx(sslHostConfig);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NioEndpoint</span> <span class="keyword">extends</span> <span class="title class_">AbstractJsseEndpoint</span>&lt;NioChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the endpoint.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用NIO的类库打开绑定端口</span></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      <span class="type">InetSocketAddress</span> <span class="variable">addr</span> <span class="operator">=</span> (getAddress()!=<span class="literal">null</span>?<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getAddress(),getPort()):<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(getPort()));</span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="literal">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于 <code>NIO内核</code> 后面再详细了解了。 一路跳出来，<code>Catalina</code> 的 <code>load()</code> 方法就走完了，至于 <code>start()</code> 丢下一篇。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>tomcat源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tomcat】四.Tomcat处理请求（下）</title>
    <url>//tomcat/%E3%80%90tomcat%E3%80%91%E5%9B%9B-tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%EF%BC%88%E4%B8%8B%EF%BC%89/index.html</url>
    <content><![CDATA[<h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><p>上一节我们来到了 <code>getAdapter().service(request, response);</code> 这里，接下来需要看一个 <code>连接器 -- Coyote框架</code> <code>Coyote</code> 的中文意思是 <code>山狗</code> ，北美的一种狼，我想用这个名字应该是指他非常的迅猛。 它实现了自己的 <code>Request</code> 和 <code>Response</code>（不是 <code>servlet</code> 标准），主要用于将 <code>byte数组</code> 翻译成必要的 <code>HTTP信息</code>。</p>
<a id="more"></a>
<h2 id="一-CoyoteAdapter处理请求"><a href="#一-CoyoteAdapter处理请求" class="headerlink" title="一. CoyoteAdapter处理请求"></a>一. CoyoteAdapter处理请求</h2><p><code>CoyoteAdapter</code> 会将 <code>Socket</code> 接收的 <code>byte数组</code> 包装成 <code>Request</code> 和 <code>Response</code>，这是一个 <code>Facade模式</code>，意将解析过程封装起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoyoteAdapter</span> <span class="keyword">implements</span> <span class="title class_">Adapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建 Request对象 和 Response对象</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Create objects</span></span><br><span class="line">      request = connector.createRequest();</span><br><span class="line">      request.setCoyoteRequest(req);</span><br><span class="line">      response = connector.createResponse();</span><br><span class="line">      response.setCoyoteResponse(res);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Link objects</span></span><br><span class="line">      request.setResponse(response);</span><br><span class="line">      response.setRequest(request);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set as notes</span></span><br><span class="line">      req.setNote(ADAPTER_NOTES, request);</span><br><span class="line">      res.setNote(ADAPTER_NOTES, response);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set query string encoding</span></span><br><span class="line">      req.getParameters().setQueryStringCharset(connector.getURICharset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connector.getXpoweredBy()) &#123;</span><br><span class="line">      response.addHeader(<span class="string">&quot;X-Powered-By&quot;</span>, POWERED_BY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 Request对象 和 Response对象END</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">async</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">postParseSuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    req.getRequestProcessor().setWorkerThreadName(THREAD_NAME.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 解析Request参数，主要为了寻找对应的容器进行处理</span></span><br><span class="line">      postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">      <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">        <span class="comment">//check valves if we support async</span></span><br><span class="line">        request.setAsyncSupported(</span><br><span class="line">          connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">        <span class="comment">// 关键代码！！！！！！：拿到容器直行链的第一个处理器开始处理</span></span><br><span class="line">        <span class="comment">// 后续将是一个责任链一直连续下去</span></span><br><span class="line">        connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">          request, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 异步的请求处理</span></span><br><span class="line">      <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">        async = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ReadListener</span> <span class="variable">readListener</span> <span class="operator">=</span> req.getReadListener();</span><br><span class="line">        <span class="keyword">if</span> (readListener != <span class="literal">null</span> &amp;&amp; request.isFinished()) &#123;</span><br><span class="line">          <span class="comment">// Possible the all data may have been read during service()</span></span><br><span class="line">          <span class="comment">// method so this needs to be checked here</span></span><br><span class="line">          <span class="type">ClassLoader</span> <span class="variable">oldCL</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            oldCL = request.getContext().bind(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (req.sendAllDataReadEvent()) &#123;</span><br><span class="line">              req.getReadListener().onAllDataRead();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            request.getContext().unbind(<span class="literal">false</span>, oldCL);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span></span><br><span class="line">          (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!request.isAsyncCompleting() &amp;&amp; throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">          request.getAsyncContextInternal().setErrorState(throwable, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理完成数据以后，将响应数据刷新出去</span></span><br><span class="line">        request.finishRequest();</span><br><span class="line">        response.finishResponse();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="type">AtomicBoolean</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">      res.action(ActionCode.IS_ERROR, error);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.isAsyncCompleting() &amp;&amp; error.get()) &#123;</span><br><span class="line">        <span class="comment">// Connection will be forcibly closed which will prevent</span></span><br><span class="line">        <span class="comment">// completion happening at the usual point. Need to trigger</span></span><br><span class="line">        <span class="comment">// call to onComplete() here.</span></span><br><span class="line">        res.action(ActionCode.ASYNC_POST_PROCESS,  <span class="literal">null</span>);</span><br><span class="line">        async = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 记录请求日志</span></span><br><span class="line">      <span class="keyword">if</span> (!async &amp;&amp; postParseSuccess) &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> request.getContext();</span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> request.getHost();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis() - req.getStartTime();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">          context.logAccess(request, response, time, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.isError()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (host != <span class="literal">null</span>) &#123;</span><br><span class="line">            host.logAccess(request, response, time, <span class="literal">false</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connector.getService().getContainer().logAccess(</span><br><span class="line">              request, response, time, <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      req.getRequestProcessor().setWorkerThreadName(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 回收资源</span></span><br><span class="line">      <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">        updateWrapperErrorCount(request, response);</span><br><span class="line">        request.recycle();</span><br><span class="line">        response.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有必要祭出之前那副请求处理图了： </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E5%9B%9B-tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%EF%BC%88%E4%B8%8B%EF%BC%89.md/0.png"><br>我们现在来到了 <code>Connector</code> 这一步，他会将 <code>Request</code> 和 <code>Response</code> 开始传递给 <code>Engine</code> 的 <code>Pipeline</code> 进行处理，<code>Pipeline</code> 又会继续调用容器里面的子容器的 <code>Pipeline</code> 逐一处理完成以后，最后来到了我们 <code>webapp</code> 的 <code>service</code> 方法。当 <code>webapp</code> 都执行完成了以后，就会调用到 <code>request.finishRequest()</code> 和 <code>response.finishResponse();</code> 写出去。</p>
<h2 id="二-CoyoteAdapter写出响应"><a href="#二-CoyoteAdapter写出响应" class="headerlink" title="二. CoyoteAdapter写出响应"></a>二. CoyoteAdapter写出响应</h2><p>因为在这里完全可以拿到已经处理完成的 <code>Response</code> 数据，所以也是在这里写出数据的，我打算先看完 <code>请求</code> 和 <code>响应</code>，所以直接先看写出数据。 那么我们上面是 <code>response.finishResponse();</code> 这个方法来完成响应的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Response</span> <span class="keyword">implements</span> <span class="title class_">HttpServletResponse</span> &#123;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    outputBuffer.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在上面 CoyoteAdapter#service 创建响应的时候，就会创建一个 outputBuffer</span></span><br><span class="line">  <span class="comment">// 然后再把这个 outputBuffer 跟 Connector 连起来，就可以将数据通过通道写出去了</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnector</span><span class="params">(Connector connector)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;AJP/1.3&quot;</span>.equals(connector.getProtocol())) &#123;</span><br><span class="line">      <span class="comment">// default size to size of one ajp-packet</span></span><br><span class="line">      outputBuffer = <span class="keyword">new</span> <span class="title class_">OutputBuffer</span>(<span class="number">8184</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      outputBuffer = <span class="keyword">new</span> <span class="title class_">OutputBuffer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    outputStream = <span class="keyword">new</span> <span class="title class_">CoyoteOutputStream</span>(outputBuffer);</span><br><span class="line">    writer = <span class="keyword">new</span> <span class="title class_">CoyoteWriter</span>(outputBuffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>OutputBuffer</code> 是由 <code>Tomcat</code> 提供的，接下来看看 <code>close</code> 做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputBuffer</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (suspended) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cb.remaining() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      flushCharBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试计算ContentLength</span></span><br><span class="line">    <span class="keyword">if</span> ((!coyoteResponse.isCommitted()) &amp;&amp; (coyoteResponse.getContentLengthLong() == -<span class="number">1</span>)</span><br><span class="line">        &amp;&amp; !coyoteResponse.getRequest().method().equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!coyoteResponse.isCommitted()) &#123;</span><br><span class="line">        coyoteResponse.setContentLength(bb.remaining());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要是需要升级请求的话，flush出去</span></span><br><span class="line">    <span class="keyword">if</span> (coyoteResponse.getStatus() == HttpServletResponse.SC_SWITCHING_PROTOCOLS) &#123;</span><br><span class="line">      doFlush(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      doFlush(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应都要关闭了，请求肯定没东西了，所以这时候请求关闭请求的通道</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">req</span> <span class="operator">=</span> (Request) coyoteResponse.getRequest().getNote(CoyoteAdapter.ADAPTER_NOTES);</span><br><span class="line">    req.inputBuffer.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 又要回到了上面Response对象里边操作</span></span><br><span class="line">    coyoteResponse.action(ActionCode.CLOSE, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Response</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(ActionCode actionCode, Object param)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hook != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (param == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// ActionCode.CLOSE，hook是之前的 Http11Processor</span></span><br><span class="line">        hook.action(actionCode, <span class="built_in">this</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hook.action(actionCode, param);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractProcessor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessorLight</span> <span class="keyword">implements</span> <span class="title class_">ActionHook</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(ActionCode actionCode, Object param)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (actionCode) &#123;</span><br><span class="line">        <span class="comment">// &#x27;Normal&#x27; servlet support</span></span><br><span class="line">      <span class="keyword">case</span> COMMIT: &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response.isCommitted()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 准备响应头</span></span><br><span class="line">            prepareResponse();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> CLOSE: &#123;</span><br><span class="line">        action(ActionCode.COMMIT, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          finishResponse();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloseNowException cne) &#123;</span><br><span class="line">          setErrorState(ErrorState.CLOSE_NOW, cne);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          setErrorState(ErrorState.CLOSE_CONNECTION_NOW, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> ACK: &#123;&#125;</span><br><span class="line">      <span class="comment">// 省略其他Action动作处理...        </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>case CLOSE</code> 会先递归调用 <code>Commit</code>，然后再调用完成响应的函数。 <code>prepareResponse</code> 包含了验证是否需要写 <code>body</code>，<code>Content-Type</code>，计算 <code>Content-Length</code> 等等一些必要的 <code>响应头</code>，然后一起写到客户端，代码过长就不放了。 <code>finishResponse</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Http11Processor</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessor</span> &#123;   </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finishResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    outputBuffer.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Http11OutputBuffer</span> <span class="keyword">implements</span> <span class="title class_">HttpOutputBuffer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (responseFinished) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastActiveFilter == -<span class="number">1</span>) &#123;</span><br><span class="line">      outputStreamOutputBuffer.end();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// lastActiveFilter参数在上面的 prepareResponse 会根据响应头</span></span><br><span class="line">      <span class="comment">// 来调整，现在被创建了一个 IdentityOutputFilter 也就是将数据写出去</span></span><br><span class="line">      <span class="comment">// 其他类型的还有ChunkedOutputFilter、GzipOutputFilter、VoidOutputFilter</span></span><br><span class="line">      <span class="comment">// 分别处理 分批、压缩、以及没有响应体的。</span></span><br><span class="line">      activeFilters[lastActiveFilter].end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responseFinished = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那现在就需要来观察 <code>IdentityOutputFilter</code> 的 <code>end</code> 函数，然而这个 <code>end</code> 函数会一步一步通过 <code>代理</code> 传递到对应的 <code>Socket</code> 的 <code>end</code> 函数来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentityOutputFilter</span> <span class="keyword">implements</span> <span class="title class_">OutputFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    buffer.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">SocketOutputBuffer</span> <span class="keyword">implements</span> <span class="title class_">HttpOutputBuffer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    socketWrapper.flush(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NioSocketWrapper</span> <span class="keyword">extends</span> <span class="title class_">SocketWrapperBase</span>&lt;NioChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">flush</span><span class="params">(<span class="type">boolean</span> block)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">      <span class="comment">// A blocking flush will always empty the buffer.</span></span><br><span class="line">      flushBlocking();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = flushNonBlocking();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">flushBlocking</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    doWrite(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nonBlockingWriteBuffer.isEmpty()) &#123;</span><br><span class="line">      nonBlockingWriteBuffer.write(<span class="built_in">this</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!socketBufferHandler.isWriteBufferEmpty()) &#123;</span><br><span class="line">        doWrite(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doWrite</span><span class="params">(<span class="type">boolean</span> block)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    socketBufferHandler.configureWriteBufferForRead();</span><br><span class="line">    doWrite(block, socketBufferHandler.getWriteBuffer());</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 上面三个方法在SocketWrapperBase中 为了阅读方便就放一起了</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doWrite</span><span class="params">(<span class="type">boolean</span> block, ByteBuffer from)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">writeTimeout</span> <span class="operator">=</span> getWriteTimeout();</span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      selector = pool.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 通过Socket定位到对应的通道，然后将数据写到通道里面</span></span><br><span class="line">      pool.write(from, getSocket(), selector, writeTimeout, block);</span><br><span class="line">      <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        <span class="comment">// Make sure we are flushed</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// 刷新出去，刷新成功返回true就停止循环</span></span><br><span class="line">          <span class="keyword">if</span> (getSocket().flush(<span class="literal">true</span>, selector, writeTimeout)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      updateLastWrite();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (selector != <span class="literal">null</span>) &#123;</span><br><span class="line">        pool.put(selector);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-业务数据处理链"><a href="#三-业务数据处理链" class="headerlink" title="三.业务数据处理链"></a>三.业务数据处理链</h2><p>业务数据的处理主要发生在上面提到过的 <code>CoyoteAdapter</code> 中，我重新贴一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoyoteAdapter</span> <span class="keyword">implements</span> <span class="title class_">Adapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(org.apache.coyote.Request req, org.apache.coyote.Response res)</span></span><br><span class="line">    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建 Request对象 和 Response对象</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> (Request) req.getNote(ADAPTER_NOTES);</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> (Response) res.getNote(ADAPTER_NOTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Create objects</span></span><br><span class="line">      request = connector.createRequest();</span><br><span class="line">      request.setCoyoteRequest(req);</span><br><span class="line">      response = connector.createResponse();</span><br><span class="line">      response.setCoyoteResponse(res);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Link objects</span></span><br><span class="line">      request.setResponse(response);</span><br><span class="line">      response.setRequest(request);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set as notes</span></span><br><span class="line">      req.setNote(ADAPTER_NOTES, request);</span><br><span class="line">      res.setNote(ADAPTER_NOTES, response);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set query string encoding</span></span><br><span class="line">      req.getParameters().setQueryStringCharset(connector.getURICharset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connector.getXpoweredBy()) &#123;</span><br><span class="line">      response.addHeader(<span class="string">&quot;X-Powered-By&quot;</span>, POWERED_BY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 Request对象 和 Response对象END</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">async</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">postParseSuccess</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    req.getRequestProcessor().setWorkerThreadName(THREAD_NAME.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 解析Request参数，主要为了寻找对应的容器进行处理</span></span><br><span class="line">      postParseSuccess = postParseRequest(req, request, res, response);</span><br><span class="line">      <span class="keyword">if</span> (postParseSuccess) &#123;</span><br><span class="line">        <span class="comment">//check valves if we support async</span></span><br><span class="line">        request.setAsyncSupported(</span><br><span class="line">          connector.getService().getContainer().getPipeline().isAsyncSupported());</span><br><span class="line">        <span class="comment">// 关键代码！！！！！！：拿到容器直行链的第一个处理器开始处理</span></span><br><span class="line">        <span class="comment">// 后续将是一个责任链一直连续下去</span></span><br><span class="line">        connector.getService().getContainer().getPipeline().getFirst().invoke(</span><br><span class="line">          request, response);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 异步的请求处理</span></span><br><span class="line">      <span class="keyword">if</span> (request.isAsync()) &#123;</span><br><span class="line">        async = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ReadListener</span> <span class="variable">readListener</span> <span class="operator">=</span> req.getReadListener();</span><br><span class="line">        <span class="keyword">if</span> (readListener != <span class="literal">null</span> &amp;&amp; request.isFinished()) &#123;</span><br><span class="line">          <span class="comment">// Possible the all data may have been read during service()</span></span><br><span class="line">          <span class="comment">// method so this needs to be checked here</span></span><br><span class="line">          <span class="type">ClassLoader</span> <span class="variable">oldCL</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            oldCL = request.getContext().bind(<span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (req.sendAllDataReadEvent()) &#123;</span><br><span class="line">              req.getReadListener().onAllDataRead();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            request.getContext().unbind(<span class="literal">false</span>, oldCL);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span></span><br><span class="line">          (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!request.isAsyncCompleting() &amp;&amp; throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">          request.getAsyncContextInternal().setErrorState(throwable, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理完成数据以后，将响应数据刷新出去</span></span><br><span class="line">        request.finishRequest();</span><br><span class="line">        response.finishResponse();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="type">AtomicBoolean</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">      res.action(ActionCode.IS_ERROR, error);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.isAsyncCompleting() &amp;&amp; error.get()) &#123;</span><br><span class="line">        <span class="comment">// Connection will be forcibly closed which will prevent</span></span><br><span class="line">        <span class="comment">// completion happening at the usual point. Need to trigger</span></span><br><span class="line">        <span class="comment">// call to onComplete() here.</span></span><br><span class="line">        res.action(ActionCode.ASYNC_POST_PROCESS,  <span class="literal">null</span>);</span><br><span class="line">        async = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 记录请求日志</span></span><br><span class="line">      <span class="keyword">if</span> (!async &amp;&amp; postParseSuccess) &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> request.getContext();</span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> request.getHost();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis() - req.getStartTime();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">          context.logAccess(request, response, time, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.isError()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (host != <span class="literal">null</span>) &#123;</span><br><span class="line">            host.logAccess(request, response, time, <span class="literal">false</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connector.getService().getContainer().logAccess(</span><br><span class="line">              request, response, time, <span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      req.getRequestProcessor().setWorkerThreadName(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 回收资源</span></span><br><span class="line">      <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">        updateWrapperErrorCount(request, response);</span><br><span class="line">        request.recycle();</span><br><span class="line">        response.recycle();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</code> 就是调用处理链来处理请求和写响应数据的关键： </p>
<p><img src="/images/%E3%80%90tomcat%E3%80%91%E5%9B%9B-tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%EF%BC%88%E4%B8%8B%EF%BC%89.md/1.png"><br>那 <code>connector.getService().getContainer()</code> 就是拿到了 <code>Engine</code> 对象，再通过 <code>getPipeline().getFirst()</code> 拿到第一个 <code>Pipeline</code> 处理器，开始进行调用，也就是图中的 <code>StandardEngineValve</code>，图中还有 <code>ValveA</code> 和 <code>ValveB</code> 表示我们可以根据自己的需求进行 <code>Pipeline</code> 的组装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StandardEngineValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到当前请求需要使用到的 Host 对象，如果没有找到，则表示请求不到</span></span><br><span class="line">    <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> request.getHost();</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;</span><br><span class="line">      response.sendError</span><br><span class="line">        (HttpServletResponse.SC_BAD_REQUEST,</span><br><span class="line">         sm.getString(<span class="string">&quot;standardEngine.noHost&quot;</span>,</span><br><span class="line">                      request.getServerName()));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">      request.setAsyncSupported(host.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将请求交给 Host 进行处理</span></span><br><span class="line">    host.getPipeline().getFirst().invoke(request, response);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我使用的是默认的配置，<code>Host</code> 的 <code>Pipeline</code> 第一个即是 <code>AccessLogValve</code> 来处理请求的记录信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAccessLogValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> <span class="keyword">implements</span> <span class="title class_">AccessLog</span> &#123;</span><br><span class="line">  <span class="comment">// 当前this=`AccessLogValue`，集成这个抽象类</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">  ServletException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tlsAttributeRequired) &#123;</span><br><span class="line">      <span class="comment">// 如果开启了TLS，则需要先把属性缓存起来</span></span><br><span class="line">      request.getAttribute(Globals.CERTIFICATES_ATTR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理读取Request中，Socket包含的远程客户端的地址，目前是HostCache进行处理</span></span><br><span class="line">    <span class="keyword">for</span> (CachedElement element : cachedElements) &#123;</span><br><span class="line">      element.cache(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Next是ErrorReportValve进行处理</span></span><br><span class="line">    getNext().invoke(request, response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后交给 <code>ErrorReportValve</code> 处理，他是先将 <code>Request</code> 继续传递下去，如果 <code>Response</code> 响应的是错误的，那么会根据需求渲染错误的页面，也就是我们经常看到的 <code>Tomcat</code> 的错误页面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorReportValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform the request</span></span><br><span class="line">    getNext().invoke(request, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是处理相应错误的时候，需要做的事情</span></span><br><span class="line">    <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.setErrorReported()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          response.flushBuffer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          ExceptionUtils.handleThrowable(t);</span><br><span class="line">        &#125;</span><br><span class="line">        response.getCoyoteResponse().action(ActionCode.CLOSE_NOW,</span><br><span class="line">                                            request.getAttribute(RequestDispatcher.ERROR_EXCEPTION));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span> (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line">        <span class="keyword">if</span> (request.isAsync() &amp;&amp; !request.isAsyncCompleting()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (throwable != <span class="literal">null</span> &amp;&amp; !response.isError()) &#123;</span><br><span class="line">      response.reset();</span><br><span class="line">      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setSuspended(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      report(request, response, throwable);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable tt) &#123;</span><br><span class="line">      ExceptionUtils.handleThrowable(tt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ErrorReportValve</code> 的接下来一个是 <code>StandardHostValve</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StandardHostValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Select the Context to be used for this Request</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> request.getContext();</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">      request.setAsyncSupported(context.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">asyncAtStart</span> <span class="operator">=</span> request.isAsync();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      context.bind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!asyncAtStart &amp;&amp; !context.fireRequestInitEvent(request.getRequest())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 查找对应的Context进行处理</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response.isErrorReportRequired()) &#123;</span><br><span class="line">          context.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        container.getLogger().error(<span class="string">&quot;Exception Processing &quot;</span> + request.getRequestURI(), t);</span><br><span class="line">        <span class="comment">// 处理失败，指的是查找我们容器的过程中的失败，则会抛出异常，渲染页面</span></span><br><span class="line">        <span class="comment">// 而如果我们的webapp处理失败了，没有做统一的监听返回响应处理的话，也算在这里</span></span><br><span class="line">        <span class="comment">// 一般建议我们的项目可以监听错误从而表示项目是正常运行的只不过是业务错误，返回业务错误信息即可</span></span><br><span class="line">        <span class="keyword">if</span> (!response.isErrorReportRequired()) &#123;</span><br><span class="line">          request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);</span><br><span class="line">          throwable(request, response, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理已经请求完成了，现在可以处理Response了，例如要刷出数据等工作</span></span><br><span class="line">      response.setSuspended(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果相应出现了错误，根据需要，要渲染页面或者是要返回错误编码</span></span><br><span class="line">      <span class="keyword">if</span> (response.isErrorReportRequired()) &#123;</span><br><span class="line">        <span class="comment">// 判断Channel通道是否正常，如果非正常的，则不会继续收集错误</span></span><br><span class="line">        <span class="type">AtomicBoolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">        response.getCoyoteResponse().action(ActionCode.IS_IO_ALLOWED, result);</span><br><span class="line">        <span class="keyword">if</span> (result.get()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            throwable(request, response, t);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status(request, response);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Request已经完成他的使命，触发Request的销毁事件</span></span><br><span class="line">      <span class="keyword">if</span> (!request.isAsync() &amp;&amp; !asyncAtStart) &#123;</span><br><span class="line">        context.fireRequestDestroyEvent(request.getRequest());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Access a session (if present) to update last accessed time, based</span></span><br><span class="line">      <span class="comment">// on a strict interpretation of the specification</span></span><br><span class="line">      <span class="keyword">if</span> (ACCESS_SESSION) &#123;</span><br><span class="line">        request.getSession(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      context.unbind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Host</code> 有了，接下来就是 <code>Context</code> 的 <code>Pipeline</code> 了吧，不过默认第一个是 <code>AuthenticatorValve</code> 但是我们没有配置什么鉴权的请求，所以我打算跳过他，接下来就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StandardContextValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保护敏感目录不被请求</span></span><br><span class="line">    <span class="type">MessageBytes</span> <span class="variable">requestPathMB</span> <span class="operator">=</span> request.getRequestPathMB();</span><br><span class="line">    <span class="keyword">if</span> ((requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/META-INF/&quot;</span>, <span class="number">0</span>))</span><br><span class="line">         (requestPathMB.equalsIgnoreCase(<span class="string">&quot;/META-INF&quot;</span>))</span><br><span class="line">         (requestPathMB.startsWithIgnoreCase(<span class="string">&quot;/WEB-INF/&quot;</span>, <span class="number">0</span>))</span><br><span class="line">         (requestPathMB.equalsIgnoreCase(<span class="string">&quot;/WEB-INF&quot;</span>))) &#123;</span><br><span class="line">      response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到Servlet</span></span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> request.getWrapper();</span><br><span class="line">    <span class="keyword">if</span> (wrapper == <span class="literal">null</span>  wrapper.isUnavailable()) &#123;</span><br><span class="line">      response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应100-continue，告诉客户端你可以继续发送消息了</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response.sendAcknowledgement();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">      container.getLogger().error(sm.getString(</span><br><span class="line">        <span class="string">&quot;standardContextValve.acknowledgeException&quot;</span>), ioe);</span><br><span class="line">      request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, ioe);</span><br><span class="line">      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.isAsyncSupported()) &#123;</span><br><span class="line">      request.setAsyncSupported(wrapper.getPipeline().isAsyncSupported());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到Servlet，开始进行调用，不过在这之前，还有个Filter要用到</span></span><br><span class="line">    wrapper.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>StandardWrapperValve</code> 基本可以当成表示我们的 <code>webapp</code> 了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StandardWrapperValve</span> <span class="keyword">extends</span> <span class="title class_">ValveBase</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize local variables we may need</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">unavailable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">throwable</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// This should be a Request attribute...</span></span><br><span class="line">    <span class="type">long</span> t1=System.currentTimeMillis();</span><br><span class="line">    requestCount.incrementAndGet();</span><br><span class="line">    <span class="type">StandardWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> (StandardWrapper) getContainer();</span><br><span class="line">    <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> (Context) wrapper.getParent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证当前应用是否被停止，在manage页面上管理</span></span><br><span class="line">    <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;</span><br><span class="line">      response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                         sm.getString(<span class="string">&quot;standardContext.isUnavailable&quot;</span>));</span><br><span class="line">      unavailable = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证servlet可用</span></span><br><span class="line">    <span class="keyword">if</span> (!unavailable &amp;&amp; wrapper.isUnavailable()) &#123;</span><br><span class="line">      container.getLogger().info(sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                                              wrapper.getName()));</span><br><span class="line">      <span class="type">long</span> <span class="variable">available</span> <span class="operator">=</span> wrapper.getAvailable();</span><br><span class="line">      <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">        response.setDateHeader(<span class="string">&quot;Retry-After&quot;</span>, available);</span><br><span class="line">        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                           sm.getString(<span class="string">&quot;standardWrapper.isUnavailable&quot;</span>,</span><br><span class="line">                                        wrapper.getName()));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                           sm.getString(<span class="string">&quot;standardWrapper.notFound&quot;</span>,</span><br><span class="line">                                        wrapper.getName()));</span><br><span class="line">      &#125;</span><br><span class="line">      unavailable = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请需要用到的servlet</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!unavailable) &#123;</span><br><span class="line">        servlet = wrapper.allocate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">      <span class="comment">// 省略异常处理代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">MessageBytes</span> <span class="variable">requestPathMB</span> <span class="operator">=</span> request.getRequestPathMB();</span><br><span class="line">    <span class="type">DispatcherType</span> <span class="variable">dispatcherType</span> <span class="operator">=</span> DispatcherType.REQUEST;</span><br><span class="line">    <span class="keyword">if</span> (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</span><br><span class="line">                         requestPathMB);</span><br><span class="line">    <span class="comment">// 创建webapp处理链，包含过滤器filter、servlet等</span></span><br><span class="line">    <span class="type">ApplicationFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span></span><br><span class="line">      ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((servlet != <span class="literal">null</span>) &amp;&amp; (filterChain != <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// Swallow output if needed</span></span><br><span class="line">        <span class="keyword">if</span> (context.getSwallowOutput()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            SystemLogHandler.startCapture();</span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">              request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              filterChain.doFilter(request.getRequest(),</span><br><span class="line">                                   response.getResponse());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">log</span> <span class="operator">=</span> SystemLogHandler.stopCapture();</span><br><span class="line">            <span class="keyword">if</span> (log != <span class="literal">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              context.getLogger().info(log);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">            request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重点进入的代码，调用处理链进行请求响应的处理</span></span><br><span class="line">            <span class="comment">// 并且在此时，Connector的Request和Response被转换为符合Servlet规范的对象</span></span><br><span class="line">            <span class="comment">// 在Tomcat里被包装成RequestFacade和ResponseFacade</span></span><br><span class="line">            filterChain.doFilter</span><br><span class="line">              (request.getRequest(), response.getResponse());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientAbortException  CloseNowException e) &#123;</span><br><span class="line">      <span class="comment">// 省略调用webapp可能发生的错误异常处理代码......</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 释放资源</span></span><br><span class="line">      <span class="keyword">if</span> (filterChain != <span class="literal">null</span>) &#123;</span><br><span class="line">        filterChain.release();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 释放servlet对象代码</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (servlet != <span class="literal">null</span>) &#123;</span><br><span class="line">          wrapper.deallocate(servlet);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.deallocateException&quot;</span>,</span><br><span class="line">                                                 wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">if</span> (throwable == <span class="literal">null</span>) &#123;</span><br><span class="line">          throwable = e;</span><br><span class="line">          exception(request, response, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this servlet has been marked permanently unavailable,</span></span><br><span class="line">      <span class="comment">// unload it and release this instance</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">            (wrapper.getAvailable() == Long.MAX_VALUE)) &#123;</span><br><span class="line">          wrapper.unload();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">&quot;standardWrapper.unloadException&quot;</span>,</span><br><span class="line">                                                 wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">if</span> (throwable == <span class="literal">null</span>) &#123;</span><br><span class="line">          exception(request, response, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">long</span> t2=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">      <span class="type">long</span> time=t2-t1;</span><br><span class="line">      processingTime += time;</span><br><span class="line">      <span class="keyword">if</span>( time &gt; maxTime) maxTime=time;</span><br><span class="line">      <span class="keyword">if</span>( time &lt; minTime) minTime=time;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，通过了一个 <code>Filter</code> 之后，就可以进入我们 <code>webapp</code> 的 <code>Servlet</code> 进行处理了，反正我们通常是使用 <code>SpringMVC</code>，<code>Servlet</code> 通常都是 <code>DispatchServlet</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">// 没有开启安全策略</span></span><br><span class="line">    <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        java.security.AccessController.doPrivileged(</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">java</span>.security.PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">              <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">              internalDoFilter(req,res);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">catch</span>( PrivilegedActionException pe) &#123;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> pe.getException();</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ServletException)</span><br><span class="line">          <span class="keyword">throw</span> (ServletException) e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IOException)</span><br><span class="line">          <span class="keyword">throw</span> (IOException) e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">          <span class="keyword">throw</span> (RuntimeException) e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 直接调用</span></span><br><span class="line">      internalDoFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">internalDoFilter</span><span class="params">(ServletRequest request,</span></span><br><span class="line"><span class="params">                                ServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在过滤器，默认是有一个WsServerContainer，则调用过滤器的方法</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">      <span class="comment">// 在下一个filter又会调用回来，但是此时 pos = n 了，所以不会再走一次</span></span><br><span class="line">      <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// WsServerContainer是当前的Filter</span></span><br><span class="line">        <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; <span class="string">&quot;false&quot;</span>.equalsIgnoreCase(</span><br><span class="line">          filterConfig.getFilterDef().getAsyncSupported())) &#123;</span><br><span class="line">          request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">          <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span></span><br><span class="line">            ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line"></span><br><span class="line">          Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;req, res, <span class="built_in">this</span>&#125;;</span><br><span class="line">          SecurityUtil.doAsPrivilege (<span class="string">&quot;doFilter&quot;</span>, filter, classType, args, principal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException  ServletException  RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(sm.getString(<span class="string">&quot;filterChain.filter&quot;</span>), e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤器链处理完成，接下来交给servlet的service方法处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">        lastServicedRequest.set(request);</span><br><span class="line">        lastServicedResponse.set(response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;</span><br><span class="line">        request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,</span><br><span class="line">                             Boolean.FALSE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Use potentially wrapped request from this point</span></span><br><span class="line">      <span class="keyword">if</span> ((request <span class="keyword">instanceof</span> HttpServletRequest) &amp;&amp;</span><br><span class="line">          (response <span class="keyword">instanceof</span> HttpServletResponse) &amp;&amp;</span><br><span class="line">          Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> request;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">res</span> <span class="operator">=</span> response;</span><br><span class="line">        <span class="type">Principal</span> <span class="variable">principal</span> <span class="operator">=</span></span><br><span class="line">          ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line">        Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;req, res&#125;;</span><br><span class="line">        SecurityUtil.doAsPrivilege(<span class="string">&quot;service&quot;</span>,</span><br><span class="line">                                   servlet,</span><br><span class="line">                                   classTypeUsedInService,</span><br><span class="line">                                   args,</span><br><span class="line">                                   principal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// MyServlet#service，此时是MyServlet，我在里面写了数据到Response，然后交给Connector写出去</span></span><br><span class="line">        <span class="comment">// 由于类加载器的隔离，在这里并不知道MyServlet的内容，只管调用即可</span></span><br><span class="line">        servlet.service(request, response);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException  ServletException  RuntimeException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">      ExceptionUtils.handleThrowable(e);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(sm.getString(<span class="string">&quot;filterChain.servlet&quot;</span>), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">        lastServicedRequest.set(<span class="literal">null</span>);</span><br><span class="line">        lastServicedResponse.set(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那最后完善下那幅请求图： <img src="/images/%E3%80%90tomcat%E3%80%91%E5%9B%9B-tomcat%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%EF%BC%88%E4%B8%8B%EF%BC%89.md/2.jpeg"></p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>tomcat源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【工作台】黑苹果 osx_catalina_10.15 安装教程</title>
    <url>//work-tool/black-macos-install/index.html</url>
    <content><![CDATA[<blockquote>
<p>从大学就开始折腾黑苹果，迟迟没有做些记录，总觉得差点什么，所以这次趁我需要重装系统的机会，拍了些照片，结合一些文字来做一个教程吧。 阅读按照文章顺序来，不要跳着来，除非我注明让你可以跳过。</p>
</blockquote>
<h2 id="OSX系统"><a href="#OSX系统" class="headerlink" title="OSX系统"></a>OSX系统</h2><p>不做评价谁好谁差，但是作为 <code>Web工程师</code> 的话，在 <code>osx</code> 系统下的编程体验确实要比 <code>Windows</code> 下好很多，软件也特别干净，从来没有在你工作的时候，突然右下角来个弹窗给你看广告，或者直接把广告就弹在最顶层来影响你的工作。 <code>jdk</code> <code>npm</code> <code>git</code> <code>Dart</code> <code>Flutter</code> 这些程序，在 <code>unix</code> 系的 <code>osx</code> 下也从来没有报错。所以还是推荐使用的。</p>
<a id="more"></a>
<h2 id="安装须知"><a href="#安装须知" class="headerlink" title="安装须知"></a>安装须知</h2><h3 id="台式机"><a href="#台式机" class="headerlink" title="台式机"></a>台式机</h3><p>在我看来台式机安装黑果是比较完美的，能够屏蔽独立显卡，没有 <code>WiFi</code> 的顾虑。而且较高的性能使得能够更加完美的体验 <code>osx</code> 系统。 但是还是有些限制你需要知道：</p>
<ol>
<li> <code>Intel</code> 芯支持比较完美，如果是 <code>AMD</code> 芯的话，虽然说现在有破解，但是我还是觉得不如自然免驱的好（无测试过，没什么发言权）；</li>
<li> 一般比较热门的独立显卡，在国内远景论坛都有驱动的教程，涉及一些代码的注入，我比较懒，所以公司的电脑就拆掉了独显，使用集显来驱动，集显也是免驱的；</li>
</ol>
<h3 id="笔记本"><a href="#笔记本" class="headerlink" title="笔记本"></a>笔记本</h3><ol>
<li> 笔记本受限比较大，现在笔记本一般都是 集显+独显 来自动切换达到省电的功能的，但是白苹果的笔记本，不是一个独显就是一个集显。所以，两者混合的情况下一般只能驱动集显（除非部分笔记本可以屏蔽集显），显卡问题就是独显基本就废了；</li>
<li><code>WiFi</code> 常年无解，两个方法解决：<ol>
<li> 淘宝购买 <code>usb</code> 接口的免驱网卡，卖家通常会提供使用所需要的驱动和软件；</li>
<li> 更换笔记本内部的网卡，这一步比较专业，加上联想笔记本更换配件是需要刷白名单的，所以通常来说，都会选择第一种方式解决。</li>
</ol>
</li>
</ol>
<h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><h3 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h3><p>因为在这篇文章产生的时候最新的 <code>osx</code> 系统是 <code>10.15 catalina</code>。所以我就是用这个系统来做教程吧。 <code>osx_10.15_catalina</code> 下载地址：<a href="/images/black-macos-install.md/0.html">下载地址</a></p>
<blockquote>
<p>感谢远景论坛大佬的封装，我没有直接放大佬的最终下载地址，因为我还是希望各位能够给去下载，大佬有硬币赚。</p>
</blockquote>
<p>镜像已经下好了，大佬也提供了常用的机型配置：<br><img src="/images/black-macos-install.md/1.png"><br>这一步只是先让你们看，先放一边，我们通常安装的时候不会直接选择合适的驱动，而是先使用通用驱动来安装，他是以最小的通用兼容配置来做的，通常都能够进入安装并且顺利通过。</p>
<h3 id="写入优盘"><a href="#写入优盘" class="headerlink" title="写入优盘"></a>写入优盘</h3><p>此时，你需要拥有一个 <code>16G</code> 的优盘！记住记住，一定是 <code>16G</code> 不然他镜像可以刻录但是不会帮你刻录完整，不完整的镜像就是一个无法安装的镜像。（我用了一个 <code>8G</code> 的在这一步卡了好几个小时，最后把公司的师弟杀了祭天了，他出现了警告也不看直接点击 <code>OK</code> 就给我刻录了一个废盘） 首先你需要一个软件：<a href="https://transmac.en.softonic.com/">TransMac</a> 当然因为我的习惯，所以我都是在 <code>Windows</code> 系统下写优盘的。 安装，然后右键 -&gt; 以管理员身份运行<br><img src="/images/black-macos-install.md/3.png"> </p>
<p>会有提示需要购买正版什么的，不过点击 <code>run</code> 可以直接运行试用版，试用版就够用了。 然后找到你的优盘，右键选择 <code>Format Disk</code> –&gt; <code>Format with Disk Image</code> 即可。 </p>
<p><img src="/images/black-macos-install.md/4.png"> </p>
<p>漫长的等待，结束了就可以使用这个优盘来安装系统了。</p>
<h3 id="修改BIOS引导"><a href="#修改BIOS引导" class="headerlink" title="修改BIOS引导"></a>修改BIOS引导</h3><p><code>msr</code> 和 <code>uefi</code>，只能选择后者。一般新买的电脑或者近几年的电脑都是这个。 简单的识别方法：开机的时候，如果是品牌 <code>Logo</code> 然后就开始转圈圈进入 <code>Windows</code> 系统的话，就是 <code>uefi</code>。 第二就是修改 <code>bios</code> 的 <code>security boot</code>，直接关闭就完事了。如果同等级的还有说什么引导什么系统的话，记得把它修改成 <code>other</code>。</p>
<h3 id="如果需要双系统"><a href="#如果需要双系统" class="headerlink" title="如果需要双系统"></a>如果需要双系统</h3><blockquote>
<p>如果不需要双系统安装，直接跳过这一段</p>
</blockquote>
<p>双系统指的是 <code>Windows</code> + <code>osx</code>，好像一般初学者都需要这个东西（包括之前的我自己）？ 首先首先，<code>Windows</code> 默认的引导分区太小了，如果你不重新安装 <code>Windows</code> 的话，直接安装 <code>osx</code> 后面都会导致任何软件都无法安装。 <a href="https://www.cnblogs.com/zhenfei/p/4279386.html">教程</a> 类似于上面地址里面的教程，但是在创建 <code>efi</code> 的时候，大小给大点，我一般给的是 <code>512m</code>，因为后面我们可能还需要根据不同的机型，在这个分区里面放入驱动。 分好区，先把 <code>Windows</code> 装上，记得留一些硬盘给 <code>osx</code>，我建议是 <code>100G</code>。</p>
<blockquote>
<p>装好系统后，在硬盘管理那里给 <code>efi</code> 分区随便给个盘符，然后把里面的东西备份一份出来，因为待会需要对他开刀，备份完整不至于你总是需要重新安装系统。</p>
</blockquote>
<h3 id="优盘引导开机"><a href="#优盘引导开机" class="headerlink" title="优盘引导开机"></a>优盘引导开机</h3><p>为了安装方便我建议将 <code>first boot</code> 设置为上面的优盘。当然使用 <code>F12</code> 来选择也行不过中途需要重启的时候就要留意重新选择了。 选择优盘中的带有 <code>UEFI</code> 选项的，这时候电脑将会读取优盘的引导，进入引导界面。<br><img src="/images/black-macos-install.md/6.jpg"><br>进入优盘是这个样子的：<br><img src="/images/black-macos-install.md/7.jpg"><br>一般是在第一项，下面会提示 <code>Boot macOS Install from xxx</code> 后面一般是优盘它默认给的名字。此时，我们 <strong>需要按一次 <code>空格键</code></strong> ，来到下一个页面：<br><img src="/images/black-macos-install.md/8.jpg"><br>下面是启动选项，一般按下空格需要设定的，大佬已经帮我们写好了，这个时候直接 <strong>按下回车键</strong> 进入安装软件就可以了。 一串命令后，我们会进来到这个页面：<br><img src="/images/black-macos-install.md/9.jpg"> </p>
<p>能够来到这里，说明安装过程十分顺利，接下来进入下一个环节。</p>
<h3 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h3><p>就跟上面一样，我们选择磁盘工具，然后点击 <code>继续</code>，就会进入到磁盘工具的页面，那我们先选择显示所有设备，这时候磁盘都会显示出来。<br><img src="/images/black-macos-install.md/10.jpg"><br>然后我们选择整个硬盘（如果是单系统的话，<strong>双系统的话，你需要选择你要格式化的那个分区</strong>）点击上面的抹掉（看我鼠标那个位置）：<br><img src="/images/black-macos-install.md/11.jpg"> </p>
<p>点击之后会出来这个硬盘设定界面： </p>
<p><img src="/images/black-macos-install.md/12.jpg"></p>
<ol>
<li><p>名称，可以自定义；</p>
</li>
<li><p>格式，新出来的文件系统是 <code>APFS</code> 听说是提速以及增加安全性的，那我就用这个好了，也建议使用这个。强烈不要使用区分大小写的分区格式（敲黑板），因为我使用了大小写区分的硬盘导致有些软件它不支持！！我目前就是因为这个原因重新安装系统的；</p>
</li>
<li><p>方案选择 <code>GUID 分区图</code>；</p>
</li>
</ol>
<p>稍稍等待一番，成功以后，直接左上角关闭磁盘管理工具。我们就可以安装系统了。</p>
<h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><p>回到这个界面，选择 <code>安装 macOS</code> ：<br><img src="/images/black-macos-install.md/13.jpg"><br><img src="/images/black-macos-install.md/14.jpg"><br>然后就同意协议了，这个不用图都知道要选择什么吧… 同意协议之后就是选择硬盘了，在这个界面，没有意外的话应该可以看到我们刚刚分出来的硬盘分区：<br><img src="/images/black-macos-install.md/15.jpg"><br>选好硬盘点击安装，接下来进入漫长的等待：<br><img src="/images/black-macos-install.md/16.jpg"><br><strong>！！！请注意！！！几分钟动一次鼠标，不要让电脑进入睡眠，因为可能因为驱动原因会睡死。</strong> 然后系统在安装过程需要一次重启，别担心，如果你在之前已经设置好优盘第一启动了的话，就不用管它，没有的话，需要手动选择优盘引导，进入优盘不用做什么，会继续安装：<br><img src="/images/black-macos-install.md/17.jpg"><br>跑完基本就可以进入系统的基础设置页面了：<br><img src="/images/black-macos-install.md/18.jpg"><br>选择什么不用说了吧，选择其他国家也可以，只要看得懂就好…</p>
<h3 id="完成安装"><a href="#完成安装" class="headerlink" title="完成安装"></a>完成安装</h3><p>完成安装可以进入桌面了，左上角有个 <code></code> -&gt; <code>关于本机</code>： </p>
<p><img src="/images/black-macos-install.md/19.png"> </p>
<p>哎哟卧槽，这个显存不对劲啊….. 那现在我们暂时忍一下，使用憋屈的动画效果使用一下 <code>Safari</code>，去下载一个软件：<a href="https://mackie100projects.altervista.org/download-clover-configurator/">Clover Configurator</a> 安装软件 </p>
<p><img src="/images/black-macos-install.md/21.png"> </p>
<p>在 <code>LaunchPad</code> 打开运行，不出意外的话： </p>
<p><img src="/images/black-macos-install.md/22.png"> </p>
<p>在 <code>LaunchPad/其他/终端</code> 运行以下命令，输入设置的用户密码就可以了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>
<p><img src="/images/black-macos-install.md/23.png"> </p>
<p>重新打开 <code>Clover Configurator</code> 来到这个菜单： </p>
<p><img src="/images/black-macos-install.md/24.png"> </p>
<p>我们现在的引导还是优盘，所以先在优盘那一项点击后面的挂载，这时候应该需要输入用户的密码，挂载成功完以后，就可以在 <code>访达</code> 看到 <code>EFI</code> 分区了。</p>
<p><img src="/images/black-macos-install.md/25.png"> </p>
<p>还记得这张图吗： </p>
<p><img src="/images/black-macos-install.md/26.png"> 将原来的 </p>
<p><code>config.plist</code> 备份一份，把这里面的适合自己机型的配置，改名为 <code>config.plist</code> 放在上一层文件夹： </p>
<p><img src="/images/black-macos-install.md/27.png"> </p>
<p>然后重启电脑，进入优盘引导，根据下面字样提示，选择 <code>Boot macOS from 你设置的分区名</code> 即可进入安装好的系统。如果配置兼容的话，重新查看关于本机： </p>
<p><img src="/images/black-macos-install.md/28.png"> </p>
<p>显存正常了。 再尝试音乐，如果声卡也正常，那就完成安装了。</p>
<h3 id="迁入硬盘引导"><a href="#迁入硬盘引导" class="headerlink" title="迁入硬盘引导"></a>迁入硬盘引导</h3><p>一切好了，总不能总是插着硬盘来开机吧，我们需要把硬盘的文件替换到磁盘里面去，还是使用 <code>Clover Configurator</code>： </p>
<p><img src="/images/black-macos-install.md/29.png"></p>
<p> 一个是硬盘的，一个是优盘的，同时挂载出来。 然后使用 <code>访达</code> 进行操作： </p>
<p><img src="/images/black-macos-install.md/30.png"> OK，<code>bios</code> 重新设置第一启动是硬盘，然后，如果需要进入 <code>osx</code> 则选择 <code>osx</code> 硬盘回车，需要 <code>Windows</code> 的话就选择 <code>Windows</code> 所在的分区即可。</p>
<h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p>这是我自己觉得比较好的设置，每个人可以按照自己的习惯来。 当然关于原来在 <code>Windows</code> 习惯的 <code>Ctrl + c</code> 这些都需要换成 <code>Command + C</code> 了，<code>Command</code> 在原来的 <code>Win键</code> 上面，我是不建议在系统设置里面替换这两者的按键位置的，毕竟用起来还蛮舒服的。 然后所有软件需要进入设置界面，都已经统一是 <code>Command + ,</code> 这个快捷键了。</p>
<h3 id="访达小设置"><a href="#访达小设置" class="headerlink" title="访达小设置"></a>访达小设置</h3><p>访达默认设置我感觉是不太好用的，比如点击访达，显示的不是我的电脑的内容，而是最近使用的内容，我特么写代码最近使用的内容都是代码文件，而我们通常不需要在这里去访问这些文件的（都是通过 <code>IDE</code> 工具），所以我希望点击访达进来的时候就是 <code>我的个人文件夹</code>： 打开 <code>访达</code>， <code>Command + ,</code> </p>
<p><img src="/images/black-macos-install.md/31.png"></p>
<p> 第二个不好的点是，我去到那个文件夹，要搜索某个文件，默认给我跑整个电脑去搜索，速度慢又没必要，所以： </p>
<p><img src="/images/black-macos-install.md/32.png"></p>
<p> 第三个不好的点是，文件默认居然不排序，还要像垃圾堆一样堆在一起！！改掉设置！： 这个不在 <code>Command + ,</code> 里边了，在这里：</p>
<p> <img src="/images/black-macos-install.md/33.png"></p>
<p> <img src="/images/black-macos-install.md/34.png"></p>
<h3 id="开启Retina渲染"><a href="#开启Retina渲染" class="headerlink" title="开启Retina渲染"></a>开启Retina渲染</h3><p>参考资料： <a href="https://imoe.me/os/hackintosh-fonts-blurry-fix.html">黑苹果开启缩放分辨率HiDPi以及字体模糊的调整方法总结</a> <a href="https://imoe.me/os/hackintosh-hidpi.html">黑苹果开启HiDPI“解决”字体模糊的问题</a> 直接在 <code>其他软件/终端</code> 粘贴下面的命令运行，提示输入用户密码，输入完以后根据提示来走就可以了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi.sh)&quot;</span><br></pre></td></tr></table></figure>
<p>重启电脑后安装 <a href="http://avi.alkalay.net/software/RDM/">RDM</a> 工具来配置分辨率（下载 <code>RDM-2.2.dmg</code> 就可以了 ） 运行，右上角： </p>
<p><img src="/images/black-macos-install.md/38.png"> </p>
<p>选择带有小闪电的就是 <code>HiDPI</code> 的设置（也就是 <code>Retina</code> 效果）</p>
<blockquote>
<p>一般根据屏幕原始分辨率来定，有 4K 显示器开 2K 分辨率的话，效果就跟白苹果一样了，2倍的差距，我目前原始分辨率是 1920 * 1080，开图中的分辨率也就凑合凑合过吧</p>
</blockquote>
<p>然后在 <code>系统偏好设置</code> –&gt; <code>通用</code> 里面开启字体平滑（在最下面，默认也是开启的） </p>
<p><img src="/images/black-macos-install.md/39.png"></p>
<p> 我对默认的平滑程度还是不太喜欢，要开最高的，终端运行以下命令，提示输入用户密码，输入完以后重启即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">defaults -currentHost write -globalDomain AppleFontSmoothing -int 3</span><br></pre></td></tr></table></figure>
<p>来看看效果图： 开启前：<br><img src="/images/black-macos-install.md/40.png"><br>开启后：<br><img src="/images/black-macos-install.md/41.png"></p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>后面有空再更更常用软件了。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>工作台</category>
      </categories>
      <tags>
        <tag>osx</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot 使用 aop</title>
    <url>//spring/spring-boot-%E4%BD%BF%E7%94%A8-aop/index.html</url>
    <content><![CDATA[<h1 id="spring-boot-使用-aop"><a href="#spring-boot-使用-aop" class="headerlink" title="spring-boot 使用 aop"></a>spring-boot 使用 aop</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p><code>AOP</code> 是一种热门的编程模式，用途十分广泛，可以作为日志的记录、事件订阅。 主要的方式是通过 <code>Aspect</code> 框架，将与项目无太大关联的但是每个方法又都需要做的事情给抽取到一个类里面。然后使用 <code>IOC</code> 容器调用方法之前之后或者抛异常以后，跳入指定的方法执行 <code>Aspect</code> 框架定义了很多种切入模式，基本涵盖编程需求，有跳入方法之前之后执行的，环绕方法执行的，抛异常执行的等。<br>GitHub地址：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> <strong>项目示例：<code>spring-boot-aop</code></strong></p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-引入-aop-依赖"><a href="#1-引入-aop-依赖" class="headerlink" title="1. 引入 aop 依赖"></a>1. 引入 aop 依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;        </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-使用注解切入"><a href="#2-使用注解切入" class="headerlink" title="2. 使用注解切入"></a>2. 使用注解切入</h3><ul>
<li>  <code>@Pointcut</code>： 切入点</li>
<li>  <code>@Around(&quot;aopPoint()&quot;)</code>：环绕切入，可以在方法执行之前之后切入，用于记录请求</li>
<li>  <code>@AfterThrowing(throwing = &quot;ex&quot;, value = &quot;aopPoint()&quot;)</code>：抛出异常之后切入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 当 Spring 检测到这个类带有 @Aspect 注解时将会把这个类设置成 AOP 的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* cn.liweidan.web.service.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aopPoint</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;aopPoint()&quot;)</span> <span class="comment">// 环绕方法执行注解</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getSignature().getDeclaringTypeName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">&quot;-----&quot;</span> + className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;----&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        logger.info(<span class="string">&quot;-----&quot;</span> + className + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot;End, doing in &quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;ms----&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(throwing = &quot;ex&quot;, value = &quot;aopPoint()&quot;)</span> <span class="comment">// 方法出现异常时执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">errorAop</span><span class="params">(JoinPoint joinPoint, Throwable ex)</span> &#123;</span><br><span class="line">        logger.error(ex.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-开发一个用户控制器以及用户传输类"><a href="#3-开发一个用户控制器以及用户传输类" class="headerlink" title="3. 开发一个用户控制器以及用户传输类"></a>3. 开发一个用户控制器以及用户传输类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserEndpoint</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter &amp; setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-开发一个用户业务层"><a href="#4-开发一个用户业务层" class="headerlink" title="4. 开发一个用户业务层"></a>4. 开发一个用户业务层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">findById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id.equals(<span class="number">1L</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ItemNotFoundException</span>(<span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="string">&quot;Jane&quot;</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-请求访问"><a href="#5-请求访问" class="headerlink" title="5. 请求访问"></a>5. 请求访问</h3><p>根据上面 <code>AOP</code> 配置可知，如果请求 <code>id</code> 为 <code>1</code> 的用户那么将会报错，两个 <code>AOP</code> 方法都会被调用到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8080/user/1</span><br><span class="line"></span><br><span class="line">HTTP/1.1 404 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, 13 Dec 2018 12:59:21 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: &quot;404&quot;,</span><br><span class="line">  &quot;data&quot;: null,</span><br><span class="line">  &quot;errMsg&quot;: &quot;未找到id为id=1未找到的资源&quot;,</span><br><span class="line">  &quot;success&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印了需要的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-12-13 20:49:50.041  INFO 1523 --- [nio-8080-exec-1] cn.liweidan.web.common.aop.MethodAop     : -----cn.liweidan.web.service.UserService.findById----</span><br><span class="line">2018-12-13 20:49:50.044 ERROR 1523 --- [nio-8080-exec-1] cn.liweidan.web.common.aop.MethodAop     : cn.liweidan.web.common.ex.ItemNotFoundException: 未找到id为id=1未找到的资源</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot 的 web 开发项目</title>
    <url>//spring/spring-boot-%E7%9A%84-web-%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE/index.html</url>
    <content><![CDATA[<h1 id="spring-boot-的-web-开发项目"><a href="#spring-boot-的-web-开发项目" class="headerlink" title="spring-boot 的 web 开发项目"></a><code>spring-boot</code> 的 <code>web</code> 开发项目</h1><p>[toc]</p>
<h2 id="一-导入-spring-boot-父类依赖"><a href="#一-导入-spring-boot-父类依赖" class="headerlink" title="一. 导入 spring-boot 父类依赖"></a>一. 导入 <code>spring-boot</code> 父类依赖</h2><p>通常来说，使用 <a href="https://start.spring.io/">官方脚手架</a> 生成的 <code>spring-boot</code> 的父类依赖都是 <code>spring</code> 官方提供的 <code>parent</code> 然而，在实际生产中，这种方法，很少使用。我们更多的时候依赖自己项目中的父类进行生成。所以我们需要在自己的 <code>pom.xml</code> 中导入 <code>spring</code> 官方提供的 <code>parent</code> 即使现在 <code>2.0.0</code> 版本已经出来了，新增了 <code>reactor</code> 功能，但是如果不使用这套功能的话，我依然推荐 <code>1.5.10.RELEASE</code> 版。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;!-- Import dependency management from Spring Boot --&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.5.10.RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="二-引入-spring-boot-web-依赖"><a href="#二-引入-spring-boot-web-依赖" class="headerlink" title="二. 引入 spring-boot-web 依赖"></a>二. 引入 <code>spring-boot-web</code> 依赖</h2><p>在我们的子项目中引入 <code>web-starter</code> 模块即可进行 <code>rest-service</code> 开发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h2 id="三-编写启动器"><a href="#三-编写启动器" class="headerlink" title="三. 编写启动器"></a>三. 编写启动器</h2><p>一般来说，项目都是作为微服务来做的，所以包名应该是 <code>公司域名.业务名</code> ，我在这里就简单的命名为 <code>cn.liweidan.web</code> 在该包下，除了有一个启动器的主类，其他类应该放置于包内。这里有个重点：<strong>启动器只扫描他所在的包以及下级里的类（配置类或业务类）</strong>。如果启动器 在外部，会出现以来报错问题。 启动类命名：我喜欢采用该项目的 业务+<code>Application</code> 的方式进行命名，比如该项目则为 <code>WebApplication</code>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Web项目启动器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/22 上午9:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// #1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(WebApplication.class, args); <span class="comment">// #2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意代码中的两个点： 1. 注解注释该类是个 <code>spring-boot</code> 项目的启动类 2. 通过调用 <code>SpringApplication</code> 的静态方法，传递该类的 <code>class</code> 实例进行启动。 可以直接通过 <code>ide</code> 启动该类，日志输出以下即表示启动成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-08-22 10:14:51.515  INFO 1789 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)</span><br><span class="line">2018-08-22 10:14:51.520  INFO 1789 --- [           main] cn.liweidan.web.WebApplication           : Started WebApplication in 2.492 seconds (JVM running for 3.673)</span><br></pre></td></tr></table></figure>
<h2 id="四-编写控制器"><a href="#四-编写控制器" class="headerlink" title="四. 编写控制器"></a>四. 编写控制器</h2><p>如果只是单纯提供 <code>JSON</code> 数据，那么就是一个 <code>Endpoint</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.web.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个控制器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/22 下午2:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// #1 使用 RestController 注解暴露返回类型是 application/json</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello-springboot&quot;)</span> <span class="comment">// #2 资源路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloSpringBootEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span> <span class="comment">// #3 rest 风格中的 get 操作</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">helloSpringBoot</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; resp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        resp.put(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;SpringBoot&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请求测试： </p>
<p><img src="/images/spring-boot-%E7%9A%84-web-%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE.md/2.png"></p>
<h2 id="五-添加拦截器"><a href="#五-添加拦截器" class="headerlink" title="五. 添加拦截器"></a>五. 添加拦截器</h2><h3 id="1-开发拦截器"><a href="#1-开发拦截器" class="headerlink" title="1. 开发拦截器"></a>1. 开发拦截器</h3><p>实现 <code>HandlerInterceptor</code> 接口，重写三个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆拦截</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/22 下午2:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&gt; 进入控制器之前&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&gt; 返回数据，渲染视图之前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&gt; 渲染视图之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-注册拦截器"><a href="#2-注册拦截器" class="headerlink" title="2. 注册拦截器"></a>2. 注册拦截器</h3><p>在启动器之下的任意包中（我习惯放在 <code>config</code> 包中），添加配置类，注册拦截器，并添加拦截路径和排除的路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册拦截器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/22 下午3:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanderInterceptorConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//注册自定义拦截器，添加拦截路径和排除拦截路径</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/hello-springboot&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我增加一个 <code>resource</code> 的资源控制器，可以参照对比拦截器行为。</p>
<h2 id="六-新增全局控制器通知"><a href="#六-新增全局控制器通知" class="headerlink" title="六. 新增全局控制器通知"></a>六. 新增全局控制器通知</h2><p>全局控制器通知实则是为了在请求出现业务异常（比如：未找到、参数错误、不能为空等等异常）的时候，返回所规定的格式以及状态码（如：rest 风格中，id 不存在的情况下返回404） 通常项目中总是会有类似的返回值统一的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultDto</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isSuccess;</span><br><span class="line">    <span class="keyword">private</span> String errMsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultDto</span><span class="params">(String code, T data, <span class="type">boolean</span> isSuccess, String errMsg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.isSuccess = isSuccess;</span><br><span class="line">        <span class="built_in">this</span>.errMsg = errMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也会出现类似于参数错误，未找到的自定义异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ItemNotFoundException</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;未找到id为&quot;</span> + id + <span class="string">&quot;的资源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有了控制器通知类，我们便可以在控制器层捕捉到这类业务性异常，返回我们所规定的数据以及格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionControllerHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理业务出现的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ItemNotFoundException.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span></span><br><span class="line">    <span class="keyword">public</span> ResultDto&lt;Void&gt; <span class="title function_">itemNotFoundException</span><span class="params">(ItemNotFoundException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultDto</span>&lt;&gt;(<span class="string">&quot;404&quot;</span>, <span class="literal">null</span>, <span class="literal">false</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理业务出现的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span></span><br><span class="line">    <span class="keyword">public</span> ResultDto&lt;Void&gt; <span class="title function_">serverException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultDto</span>&lt;&gt;(<span class="string">&quot;500&quot;</span>, <span class="literal">null</span>, <span class="literal">false</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我请求 <code>resource</code>，假定 id 为 100 的资源不存在，抛出元素不存在异常，便可以接收到以下格式的返回值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;404&quot;</span><span class="punctuation">,</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;errMsg&quot;</span><span class="punctuation">:</span><span class="string">&quot;未找到id为100的资源&quot;</span><span class="punctuation">,</span><span class="attr">&quot;success&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">false</span></span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="七-多配置"><a href="#七-多配置" class="headerlink" title="七. 多配置"></a>七. 多配置</h2><p>开发了这么久，还没配置过一个配置文件，这是因为 <code>spring-boot</code> 提供了一系列的默认配置，在不需要修改的情况下，便不需要去配置这些参数。 那么在 <code>resources</code> 文件夹中，我们可以设置共同配置，以及不同环境的配置： 1. 共同配置可以配置诸如应用名称等通用的配置 2. 不同的环境配置可以配置中间件的连接参数 <code>application.yml</code> 配置了项目名称以及默认激活的环境为开发环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: basic-web</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure>
<p><code>application-dev.yml</code> 只配置了端口信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br></pre></td></tr></table></figure>
<p>当把该项目打包成 <code>jar</code> 包的时候，运行时配置 <code>java -jar xxx.jar -Dspring.profiles.active=prod</code>即可切换成生产环境的配置 </p>
<p><img src="/images/spring-boot-%E7%9A%84-web-%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE.md/6.png"></p>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p>我从官方附录上拷贝一些比较常用的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 日志配置相关</span><br><span class="line">logging.config= # 日志配置文件的路径. For instance, `classpath:logback.xml` for Logback.</span><br><span class="line">logging.file= # Log file name (for instance, `myapp.log`). Names can be an exact location or relative to the current directory.</span><br><span class="line">logging.file.max-history=0 # 日志保留最大的数量，只支持logback</span><br><span class="line">logging.file.max-size=10MB # 日志最大容量</span><br><span class="line">logging.level.*= # 指定文件的日志等级. For instance, `logging.level.org.springframework=DEBUG`.</span><br><span class="line">logging.path= # 日志存放的文件夹路径. For instance, `/var/log`.</span><br><span class="line">logging.pattern.console= # Appender pattern for output to the console. Supported only with the default Logback setup.</span><br><span class="line">logging.pattern.dateformat=yyyy-MM-dd HH:mm:ss.SSS # Appender pattern for log date format. Supported only with the default Logback setup.</span><br><span class="line">logging.pattern.file= # Appender pattern for output to a file. Supported only with the default Logback setup.</span><br><span class="line">logging.pattern.level=%5p # Appender pattern for log level. Supported only with the default Logback setup.</span><br><span class="line">logging.register-shutdown-hook=false # Register a shutdown hook for the logging system when it is initialized.</span><br><span class="line"></span><br><span class="line"># Email (MailProperties)</span><br><span class="line">spring.mail.default-encoding=UTF-8 # Default MimeMessage encoding.</span><br><span class="line">spring.mail.host= # SMTP server host. For instance, `smtp.example.com`.</span><br><span class="line">spring.mail.password= # Login password of the SMTP server.</span><br><span class="line">spring.mail.port= # SMTP server port.</span><br><span class="line">spring.mail.properties.*= # Additional JavaMail Session properties.</span><br><span class="line">spring.mail.protocol=smtp # Protocol used by the SMTP server.</span><br><span class="line">spring.mail.test-connection=false # Whether to test that the mail server is available on startup.</span><br><span class="line">spring.mail.username= # Login user of the SMTP server.</span><br><span class="line"></span><br><span class="line"># 线程池配置  (TaskExecutionProperties)</span><br><span class="line">spring.task.execution.pool.allow-core-thread-timeout=true # Whether core threads are allowed to time out. This enables dynamic growing and shrinking of the pool.</span><br><span class="line">spring.task.execution.pool.core-size=8 # Core number of threads.</span><br><span class="line">spring.task.execution.pool.keep-alive=60s # Time limit for which threads may remain idle before being terminated.</span><br><span class="line">spring.task.execution.pool.max-size= # Maximum allowed number of threads. If tasks are filling up the queue, the pool can expand up to that size to accommodate the load. Ignored if the queue is unbounded.</span><br><span class="line">spring.task.execution.pool.queue-capacity= # Queue capacity. An unbounded capacity does not increase the pool and therefore ignores the &quot;max-size&quot; property.</span><br><span class="line">spring.task.execution.thread-name-prefix=task- # Prefix to use for the names of newly created threads.</span><br><span class="line"></span><br><span class="line"># WEB CONFIG</span><br><span class="line">server.port=8080 # 端口</span><br><span class="line"></span><br><span class="line"># DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</span><br><span class="line">spring.datasource.continue-on-error=false # 初始化数据库连接池的时候，出现异常是否继续初始化</span><br><span class="line">spring.datasource.data= # Data (DML) script resource references. 数据库数据初识文件</span><br><span class="line">spring.datasource.driver-class-name= # 驱动名称</span><br><span class="line">spring.datasource.generate-unique-name=false # 是否随机生成一个数据库名称</span><br><span class="line">spring.datasource.hikari.*= # Hikari specific settings</span><br><span class="line">spring.datasource.initialization-mode=embedded # Initialize the datasource with available DDL and DML scripts.</span><br><span class="line">spring.datasource.name= # Name of the datasource. Default to &quot;testdb&quot; when using an embedded database.</span><br><span class="line">spring.datasource.password= # 登陆数据库密码</span><br><span class="line">spring.datasource.schema= # 表结构文件</span><br><span class="line">spring.datasource.type= # 修改连接池驱动</span><br><span class="line">spring.datasource.username= # 登陆数据库用户名</span><br><span class="line"></span><br><span class="line"># JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)</span><br><span class="line">spring.jpa.generate-ddl=false # 初始化的时候是否创建数据表</span><br><span class="line">spring.jpa.hibernate.ddl-auto= # DDL 模式，跟hibernate的一致. This is actually a shortcut for the &quot;hibernate.hbm2ddl.auto&quot; property. Defaults to &quot;create-drop&quot; when using an embedded database and no schema manager was detected. Otherwise, defaults to &quot;none&quot;.</span><br><span class="line">spring.jpa.show-sql=false # 是否在日志打印sql语句</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot 使用 jpa 进行数据库访问</title>
    <url>//spring/spring-boot-%E4%BD%BF%E7%94%A8-jpa-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE/index.html</url>
    <content><![CDATA[<p>因为已经编写了 <code>web</code> 项目，此项目直接在 <code>web</code> 项目上新增数据库访问。此处使用的访问 <code>orm</code> 层是 <code>spring</code> 官方提供的 <code>spring-data-jpa</code>。 <code>spring-data-jpa</code> 是官方通过使用 <code>java</code> 规范中的 <code>jpa</code> 标准，使用 <code>hibernate</code> 框架作为 <code>orm</code> 层进行的数据库层面的请求访问。众所周知， <code>hibernate</code> 框架是针对数据库层面的面向对象框架，编写一次兼容所有数据库，不过前提是都使用他提供的 <code>hql</code> 或者接口进行编写。 <code>spring</code> 还对其新增了对领域驱动设计的友好支持。</p>
<h2 id="一-在项目中引入依赖"><a href="#一-在项目中引入依赖" class="headerlink" title="一. 在项目中引入依赖"></a>一. 在项目中引入依赖</h2><ol>
<li> 引入 <code>spring-boot-starter-data-jpa</code> 框架，便已经让项目支持了数据库连接</li>
<li> 数据库驱动</li>
<li> 如若需要测试环境，再引入内存数据库以及测试驱动</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 测试支持，可以使用内存数据库 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.h2database&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;h2&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="二-yml-文件新增数据库配置"><a href="#二-yml-文件新增数据库配置" class="headerlink" title="二. yml 文件新增数据库配置"></a>二. <code>yml</code> 文件新增数据库配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/spring-data</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">generate-ddl:</span> <span class="literal">true</span> <span class="comment"># 自动生成数据库表</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span> <span class="comment"># 启动时进行验证，可以设置成create-drop用于开发使用</span></span><br></pre></td></tr></table></figure>
<h2 id="三-编写-dbo-类"><a href="#三-编写-dbo-类" class="headerlink" title="三. 编写 dbo 类"></a>三. 编写 <code>dbo</code> 类</h2><p>需要使用 <code>jpa</code> 规范注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user_info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy= GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;, length = 50)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_age&quot;, length = 50)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDo</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四-编写对应的-repository-类进行数据库访问"><a href="#四-编写对应的-repository-类进行数据库访问" class="headerlink" title="四. 编写对应的 repository 类进行数据库访问"></a>四. 编写对应的 <code>repository</code> 类进行数据库访问</h2><p>继承自 <code>JpaRepository</code>，第一个参数是 <code>dbo</code> 类，第二个参数是 <code>@Id</code> 的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;UserDo, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承以后将自动拥有以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">List&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort var1)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Iterable&lt;ID&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">save</span><span class="params">(Iterable&lt;S&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">saveAndFlush</span><span class="params">(S var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">deleteAllInBatch</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(ID var1)</span>;</span><br><span class="line"></span><br><span class="line">&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">&lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; var1, Sort var2)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="五-启动类新增初始化代码"><a href="#五-启动类新增初始化代码" class="headerlink" title="五. 启动类新增初始化代码"></a>五. 启动类新增初始化代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">demo</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (args) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 启动时进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (userRepository.findAll().size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            userRepository.save(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="string">&quot;Jane&quot;</span>, <span class="number">18</span>));</span><br><span class="line">            userRepository.save(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="string">&quot;Tony&quot;</span>, <span class="number">22</span>));</span><br><span class="line">            userRepository.save(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="string">&quot;Jenny&quot;</span>, <span class="number">31</span>));</span><br><span class="line">            userRepository.save(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="string">&quot;Gogo&quot;</span>, <span class="number">54</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-编写一个基本的-rest-资源控制器"><a href="#六-编写一个基本的-rest-资源控制器" class="headerlink" title="六. 编写一个基本的 rest 资源控制器"></a>六. 编写一个基本的 <code>rest</code> 资源控制器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserEndpoint</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserDo&gt; <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">idOf</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findOne(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.saveAndFlush(userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.saveAndFlush(userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.ACCEPTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        userRepository.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请求对应的接口，基本算是完成一个资源服务。</p>
<h2 id="七-测试用例"><a href="#七-测试用例" class="headerlink" title="七. 测试用例"></a>七. 测试用例</h2><p>测试用例用的是 <code>spring-boot-test</code>，用于初始化 <code>spring</code> 容器以及对接口进行测试等。我只做一个 <code>getById</code> 使用 <code>h2</code> 内存数据库作为测试库。</p>
<h3 id="7-1-新增测试环境配置"><a href="#7-1-新增测试环境配置" class="headerlink" title="7.1 新增测试环境配置"></a>7.1 新增测试环境配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">h2</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">generate-ddl:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-编写测试类"><a href="#7-2-编写测试类" class="headerlink" title="7.2 编写测试类"></a>7.2 编写测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepositoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="string">&quot;Jane&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        id = userRepository.save(userDo).getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFindById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">aUser</span> <span class="operator">=</span> userRepository.findOne(id);</span><br><span class="line">        assertEquals(<span class="string">&quot;Jane&quot;</span>, aUser.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然如果不想使用内存数据库，也可以使用MySQL，在测试类上方加上 <code>@Transactional</code> 注解即可实现测试完成数据回滚。 </p>
<p><img src="/images/spring-boot-%E4%BD%BF%E7%94%A8-jpa-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE.md/0.png">  </p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>springboot整合druid</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 与 freemark 模板</title>
    <url>//spring/springboot-%E4%B8%8E-freemark-%E6%A8%A1%E6%9D%BF/index.html</url>
    <content><![CDATA[<h1 id="springboot-与-freemark-模板"><a href="#springboot-与-freemark-模板" class="headerlink" title="springboot 与 freemark 模板"></a>springboot 与 freemark 模板</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p><code>Freemarker</code> 是一个热门的 <code>MVC</code> 模板引擎，拥有跟 <code>jsp</code> 一样的一些指令标签，广受大众的热爱。 我没真正使用过 <code>Freemarker</code> ，在即将投入使用的项目中，因为一个偶然的想法（动静分离）而彻底放弃了 <code>MVC</code> 思想，改用了前端的 <code>MVVM</code> 框架，配合 <code>JSON</code> 数据格式。</p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-MVN-的依赖"><a href="#1-MVN-的依赖" class="headerlink" title="1. MVN 的依赖"></a>1. <code>MVN</code> 的依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>其实我感觉这是我写过的最简单的 <code>Spring-Boot</code> 教程了，全程不需要任何的自定义配置，只要引入依赖的包即可投入使用。</p>
<a id="more"></a>
<h3 id="2-控制器"><a href="#2-控制器" class="headerlink" title="2. 控制器"></a>2. 控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">helloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld!&quot;</span> + <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;hello&quot;</span>).addObject(<span class="string">&quot;message&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-编写-ftl-和-静态文件"><a href="#3-编写-ftl-和-静态文件" class="headerlink" title="3. 编写 ftl 和 静态文件"></a>3. 编写 <code>ftl</code> 和 静态文件</h3><p>需要注意两个路径，都在 <code>resources</code> 文件夹下：</p>
<ol>
<li> <code>templates</code> 用于存放模板文件</li>
<li> <code>static</code> 用于存放静态资源，如：<code>js</code> <code>css</code> <code>html</code></li>
</ol>
<p><code>templates</code> 下的 <code>ftl</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">Message: $&#123;message&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><code>static</code> 下的 <code>js</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HelloWorld&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-请求-http-localhost-8080-hello-以及-http-localhost-8080-hello-js"><a href="#4-请求-http-localhost-8080-hello-以及-http-localhost-8080-hello-js" class="headerlink" title="4. 请求 http://localhost:8080/hello 以及 http://localhost:8080/hello.js"></a>4. 请求 <code>http://localhost:8080/hello</code> 以及 <code>http://localhost:8080/hello.js</code></h3><p><img src="/images/springboot-%E4%B8%8E-freemark-%E6%A8%A1%E6%9D%BF.md/0.png"> </p>
<p><img src="/images/springboot-%E4%B8%8E-freemark-%E6%A8%A1%E6%9D%BF.md/1.png"></p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 与 jpa 的简单使用</title>
    <url>//spring/springboot-%E4%B8%8E-jpa-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/index.html</url>
    <content><![CDATA[<h1 id="SpringBoot-与-jpa-的简单使用"><a href="#SpringBoot-与-jpa-的简单使用" class="headerlink" title="SpringBoot 与 jpa 的简单使用"></a>SpringBoot 与 jpa 的简单使用</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p><code>jpa</code> 全称 <code>javax.persistence.annotation</code> ，刚开始是由 <code>hibernate</code> 作者开发，后面被 <code>java</code> 公司收入到规范之中。<code>spring-boot-data-jpa</code> 就是在这套规范上面建立起来的。所以开发的时候默认的 <code>orm</code> 框架就是 <code>hibernate</code> 。 在刚开始接触编程的时候，万事以快为主，但其实现在我感觉开发体验更加重要。<code>mybatis</code> 是个封装比较少的框架，速度会略胜一筹，但 <code>hibernate</code> 开发数据库的时候会显得更加面向对象。当然两者都可以在不同的业务需求中体现其重要性。 简单的开发区别就是，把 <code>hibernate</code> 框架的 <code>repository</code> 当成一个集合来使用，使用起来就更加的得心应手。<code>mybatis</code> 则更加的面向过程，自主控制 <code>SQL</code> 的运行。<br>GitHub地址：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> 演示项目：spring-boot-data-jpa</p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><p>我们就通过一个简单用户系统来开发</p>
<a id="more"></a>
<h3 id="1-mvn-依赖"><a href="#1-mvn-依赖" class="headerlink" title="1. mvn 依赖"></a>1. mvn 依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入 jpa 注解 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- mysql依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 为了方便测试加入端口检测包 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- SpringBoot 测试 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 为了测试的时候使用内存数据库 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.h2database&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;h2&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-开发用户接口"><a href="#2-开发用户接口" class="headerlink" title="2. 开发用户接口"></a>2. 开发用户接口</h3><p>此处通常需要返回 <code>DTO</code> 类，但是为了方便就不去做转换了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserEndpoint</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> &#123;</span><br><span class="line">        userService.add(userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NO_CONTENT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> &#123;</span><br><span class="line">        userService.update(userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NO_CONTENT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span> &#123;</span><br><span class="line">        userService.delete(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-用户业务层"><a href="#3-用户业务层" class="headerlink" title="3. 用户业务层"></a>3. 用户业务层</h3><p>关于为什么使用业务层做示例呢，因为直接接口请求仓库没有事务边界，在使用 <code>update</code> 相关方法的时候，并不能帮我自动刷新到数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserDo userDo)</span> &#123;</span><br><span class="line">        userRepository.save(userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(UserDo userDo)</span> &#123;</span><br><span class="line">        Optional&lt;UserDo&gt; origin = userRepository.findById(userDo.getId());</span><br><span class="line">        origin.ifPresent(originUserDo -&gt; originUserDo.setName(userDo.getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        userRepository.deleteById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">getById</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(userId)</span><br><span class="line">                .orElse(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-用户DBO类"><a href="#4-用户DBO类" class="headerlink" title="4. 用户DBO类"></a>4. 用户DBO类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">// 指定这是一个数据库映射类</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user_db&quot;)</span> <span class="comment">// 表的基本信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">// 规定这是一个主键</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_id&quot;)</span> <span class="comment">// column 的定义</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy= GenerationType.IDENTITY)</span> <span class="comment">// 使用数据库 id 自增的功能</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;, length = 50)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserDo&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-用户仓库类"><a href="#5-用户仓库类" class="headerlink" title="5. 用户仓库类"></a>5. 用户仓库类</h3><p>只需要通过继承接口的方式去获取他应有的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;UserDo, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JpaRepository</code> 接口的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">JpaRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">PagingAndSortingRepository</span>&lt;T, ID&gt;, QueryByExampleExecutor&lt;T&gt; &#123;</span><br><span class="line">    List&lt;T&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Sort var1)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; <span class="title function_">findAllById</span><span class="params">(Iterable&lt;ID&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">saveAll</span><span class="params">(Iterable&lt;S&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; S <span class="title function_">saveAndFlush</span><span class="params">(S var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteAllInBatch</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">getOne</span><span class="params">(ID var1)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; var1)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;S <span class="keyword">extends</span> <span class="title class_">T</span>&gt; List&lt;S&gt; <span class="title function_">findAll</span><span class="params">(Example&lt;S&gt; var1, Sort var2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-配置文件"><a href="#6-配置文件" class="headerlink" title="6. 配置文件"></a>6. 配置文件</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-data-jpa</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">create-drop</span> <span class="comment"># 定义数据库生成策略</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">org.hibernate.dialect.MySQL5InnoDBDialect</span> <span class="comment"># 设置 innoDB 引擎</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/jpa_data?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true</span></span><br></pre></td></tr></table></figure>
<h3 id="7-请求接口"><a href="#7-请求接口" class="headerlink" title="7. 请求接口"></a>7. 请求接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/user</span><br><span class="line"></span><br><span class="line">HTTP/1.1 201 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Wed, 19 Dec 2018 02:42:16 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 201; Time: 70ms; Content length: 0 bytes</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">GET http://127.0.0.1:8080/user/1</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Wed, 19 Dec 2018 02:42:41 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;name&quot;: &quot;狗娃&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 31ms; Content length: 20 bytes</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">PUT http://127.0.0.1:8080/user</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;name&quot;: &quot;狗娃&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HTTP/1.1 204 </span><br><span class="line">Date: Wed, 19 Dec 2018 02:43:06 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 204; Time: 21ms; Content length: 0 bytes</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">GET http://127.0.0.1:8080/user/1</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Wed, 19 Dec 2018 02:43:24 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;name&quot;: &quot;狗娃&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 39ms; Content length: 20 bytes</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">DELETE http://127.0.0.1:8080/user/1</span><br><span class="line"></span><br><span class="line">HTTP/1.1 204 </span><br><span class="line">Date: Wed, 19 Dec 2018 02:49:49 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 204; Time: 128ms; Content length: 0 bytes</span><br></pre></td></tr></table></figure>
<h3 id="8-测试业务层"><a href="#8-测试业务层" class="headerlink" title="8. 测试业务层"></a>8. 测试业务层</h3><p>通常来说，按照 <code>TDD</code> 的开发模式，都需要有测试用例，在日常开发中我习惯测试业务层（没那么多时间覆盖所有测试）。所以现在按照测试业务层做示例。 测试用例可以使用 <code>MySQL</code> 来做也可以用内存数据库来做，我演示是使用内存数据库来做的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 可以在测试完成的时候回滚数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>();</span><br><span class="line">        userDo.setName(<span class="string">&quot;狗蛋&quot;</span>);</span><br><span class="line">        userService.add(userDo);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userRepository.findAll().stream()</span><br><span class="line">                .filter(userDo1 -&gt; userDo1.getName().equals(userDo.getName()))</span><br><span class="line">                .count();</span><br><span class="line">        assertTrue(<span class="string">&quot;should have a user who name is &quot;</span> + userDo.getName(), count &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>();</span><br><span class="line">        userDo.setName(<span class="string">&quot;狗剩&quot;</span>);</span><br><span class="line">        userService.add(userDo);</span><br><span class="line"></span><br><span class="line">        Optional&lt;UserDo&gt; optionalUserDo = userRepository.findAll()</span><br><span class="line">                .stream().findAny();</span><br><span class="line">        optionalUserDo.ifPresent(userDo1 -&gt; &#123;</span><br><span class="line">            <span class="type">UserDo</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>();</span><br><span class="line">            update.setId(userDo1.getId());</span><br><span class="line">            update.setName(<span class="string">&quot;狗仔&quot;</span>);</span><br><span class="line">            userService.update(update);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Optional&lt;UserDo&gt; aDo = userRepository.findAll()</span><br><span class="line">                .stream().filter(query -&gt; query.getName().equals(<span class="string">&quot;狗仔&quot;</span>)).findAny();</span><br><span class="line">        assertTrue(<span class="string">&quot;should have a user who name is 狗仔&quot;</span>, aDo.isPresent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>();</span><br><span class="line">        userDo.setName(<span class="string">&quot;狗剩&quot;</span>);</span><br><span class="line">        userService.add(userDo);</span><br><span class="line"></span><br><span class="line">        Optional&lt;UserDo&gt; optionalUserDo = userRepository.findAll()</span><br><span class="line">                .stream().findAny();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> optionalUserDo.get().getId();</span><br><span class="line">        userService.delete(id);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userRepository.findAll()</span><br><span class="line">                .stream().filter(userDo1 -&gt; userDo1.getId().equals(id))</span><br><span class="line">                .count();</span><br><span class="line">        assertTrue(<span class="string">&quot;should not have a user who id is &quot;</span> + id, count &lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>();</span><br><span class="line">        userDo.setName(<span class="string">&quot;狗剩&quot;</span>);</span><br><span class="line">        userService.add(userDo);</span><br><span class="line"></span><br><span class="line">        Optional&lt;UserDo&gt; optionalUserDo = userRepository.findAll()</span><br><span class="line">                .stream().findAny();</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">byId</span> <span class="operator">=</span> userService.getById(optionalUserDo.get().getId());</span><br><span class="line">        assertNotNull(<span class="string">&quot;result should not be null&quot;</span>, byId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>test/resources</code> 放置 <code>Spring-Boot</code> 的配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-data-jpa</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">create-drop</span> <span class="comment"># 定义数据库生成策略，启动就创建 关闭就删除</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">org.hibernate.dialect.MySQL5InnoDBDialect</span> <span class="comment"># 设置 innoDB 引擎</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:h2:mem:scope_test_db;MODE=MYSQL;DB_CLOSE_DELAY=-1</span></span><br></pre></td></tr></table></figure>
<p>OK，运行完整测试即可。</p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>使用 <code>spring-boot-data-jpa</code> 应该尽量避免使用 <code>SQL</code> 来编写，会出现一些不可控的问题。尽量使用 <code>jpa</code> 提供的接口来做增删查改操作，后期迁移数据库的时候也不会显得无力（当然这种事情很少发生）。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 与 MongoDB 数据处理</title>
    <url>//spring/springboot-%E4%B8%8E-mongodb-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/index.html</url>
    <content><![CDATA[<h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p><code>MongoDB</code> 是一款新兴的 <code>NO-SQL</code> 数据库，使用的是类 <code>JSON</code> 的数据格式 <code>BSON</code> 进行数据存储。<code>MongoDB</code> 将索引放在内存中，因此查询的时候会大幅度提高速度。在数据库领域中，<code>MongoDB</code> 适合单表的或者说 <code>Column</code> 不需要高度统一的业务处理中，比如：用户娱乐信息表（在商城的用户信息中存储的用户兴趣、用户QQ等等）。<code>MongoDB</code> 对事务支持度不算太高，日常需求需要连表操作的就不要放在 <code>MongoDB</code> 了。 <code>SpringBoot</code> 对 <code>MongoDB</code> 提供了 <code>starter</code> 让 <code>Javaer</code> 能够更加简单的操作 <code>MongoDB</code> 数据库的信息。 项目地址：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> 项目演示：<code>spring-boot-data-mongo</code></p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="（一）MongoDB-环境的准备"><a href="#（一）MongoDB-环境的准备" class="headerlink" title="（一）MongoDB 环境的准备"></a>（一）MongoDB 环境的准备</h3><h5 id="1-使用-Docker-启动-MongoDB-环境"><a href="#1-使用-Docker-启动-MongoDB-环境" class="headerlink" title="1. 使用 Docker 启动 MongoDB 环境"></a>1. 使用 Docker 启动 MongoDB 环境</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="comment"># 启动MongoDB</span></span><br><span class="line">  <span class="attr">mongo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br><span class="line"><span class="comment"># 启动MongoDB管理后台</span></span><br><span class="line">  <span class="attr">mongo-express:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo-express</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8081</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker-compose</span> <span class="string">-f</span> <span class="string">mongodb.yml</span> <span class="string">up</span></span><br></pre></td></tr></table></figure>
<p>访问 <code>http://localhost:8081</code> 如果可以看到管理页面即为成功</p>
<h3 id="（二）项目开发"><a href="#（二）项目开发" class="headerlink" title="（二）项目开发"></a>（二）项目开发</h3><h4 id="1-mvn-依赖"><a href="#1-mvn-依赖" class="headerlink" title="1. mvn 依赖"></a>1. mvn 依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- MongoDB starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-编写-UserDo-实体类"><a href="#2-编写-UserDo-实体类" class="headerlink" title="2. 编写 UserDo 实体类"></a>2. 编写 UserDo 实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Document(collection = &quot;user_info&quot;)</span> <span class="comment">// 指定这个类是一个Document，类似于@Entity，可以在注解中指定 collection (MySQL 中的 Table)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String fristName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 setter 和 getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-编写-MongoDB-的数据仓库"><a href="#3-编写-MongoDB-的数据仓库" class="headerlink" title="3. 编写 MongoDB 的数据仓库"></a>3. 编写 MongoDB 的数据仓库</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">MongoRepository</span>&lt;UserDo, String&gt; &#123; <span class="comment">// 继承 跟 JpaRepository 一样的用法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-调用"><a href="#4-调用" class="headerlink" title="4. 调用"></a>4. 调用</h4><p>为了方便我省略了业务层直接在接口层进行调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserEndpoint</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserDo&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> &#123;</span><br><span class="line">        userDo.setUuid(UUID.randomUUID().toString());</span><br><span class="line">        userRepository.save(userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">findByUID</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(uid).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-测试调用"><a href="#5-测试调用" class="headerlink" title="5. 测试调用"></a>5. 测试调用</h4><h5 id="1-先新增两条记录"><a href="#1-先新增两条记录" class="headerlink" title="1. 先新增两条记录"></a>1. 先新增两条记录</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/user</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;fristName&quot;: &quot;MING&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;LI&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Fri, 28 Dec 2018 03:05:59 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 259ms; Content length: 0 bytes</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">POST http://127.0.0.1:8080/user</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;fristName&quot;: &quot;WEIDAN&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;LI&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Fri, 28 Dec 2018 03:05:59 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 259ms; Content length: 0 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="2-查询所有用户信息"><a href="#2-查询所有用户信息" class="headerlink" title="2. 查询所有用户信息"></a>2. 查询所有用户信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/user</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 28 Dec 2018 03:11:16 GMT</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;uuid&quot;: &quot;5354b97f-bc1f-4198-97f1-d10ee624493e&quot;,</span><br><span class="line">    &quot;fristName&quot;: &quot;MING&quot;,</span><br><span class="line">    &quot;lastName&quot;: &quot;LI&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;uuid&quot;: &quot;23916e7c-cfa2-4ca8-9c8a-826c7abd6c9d&quot;,</span><br><span class="line">    &quot;fristName&quot;: &quot;WEIDAN&quot;,</span><br><span class="line">    &quot;lastName&quot;: &quot;LI&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 26ms; Content length: 169 bytes</span><br></pre></td></tr></table></figure>
<h5 id="3-查询单条记录"><a href="#3-查询单条记录" class="headerlink" title="3. 查询单条记录"></a>3. 查询单条记录</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/user/5354b97f-bc1f-4198-97f1-d10ee624493e</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 28 Dec 2018 03:11:50 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;uuid&quot;: &quot;5354b97f-bc1f-4198-97f1-d10ee624493e&quot;,</span><br><span class="line">  &quot;fristName&quot;: &quot;MING&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;LI&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 171ms; Content length: 82 bytes</span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>本文演示了如何使用 <code>spring-boot</code> 操作 <code>MongoDB</code> 数据库，刚开始因为设置了用户名和密码，需要授权访问不上（原谅我第一次使用，不知道怎么授权= =）查询官方文档说是鼓励在内网完全开放，让任何项目可以随时连接上去（比如用 <code>Docker</code> 进行容器连接访问），不过不设置密码估计都过不了自己心里那一关，所以还是设置用户名密码，根据要求在 <code>MongoDB</code> 中进行授权。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 与 security 保护 web 安全</title>
    <url>//spring/springboot-%E4%B8%8E-security-%E4%BF%9D%E6%8A%A4-web-%E5%AE%89%E5%85%A8/index.html</url>
    <content><![CDATA[<h1 id="springboot-与-security-保护-web-安全"><a href="#springboot-与-security-保护-web-安全" class="headerlink" title="springboot 与 security 保护 web 安全"></a>springboot 与 security 保护 web 安全</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>做 <code>web</code> 项目，权限的事情就常常伴随着左右，比如某个用户有没有资格访问这个资源，常用的权限框架一般有 <code>shrio</code> 和 <code>spring-security</code> 。一般来说，很多公司会选择前者，因为会稍微轻量级（其实我为了写这篇文章稍微学习一下 <code>spring-security</code> 也有这种感觉，<code>spring</code> 公司把用户权限等等都已经提供了接口，不利于我们自己定制化，有好有坏吧，熟悉的话快速开发是个不错的选择）。当然现在我有种比较喜欢 <code>spring</code> 的全家桶的感觉，毕竟开发起来很面向对象。而且自家的产品，跟自己搭配起来，都会很简单的就起来了。<br>OK，简单的搭建没什么意义，所以这里我提前用了下 <code>jpa</code> ，简单的示例。 业务情景是这样子的：我数据库里面有一堆资源，但是有规定，不同角色只能请求不同的资源，当你的角色不匹配，请求的时候会被拒绝。用户和角色我就没分出来表了，放在同一张表，目的是快速的进行演示。 <strong>示例代码：<code>web-security</code></strong></p>
<a id="more"></a>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-mvn-依赖"><a href="#1-mvn-依赖" class="headerlink" title="1. mvn 依赖"></a>1. <code>mvn</code> 依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- web-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- security-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- jpa-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- mysql 依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-定义资源"><a href="#2-定义资源" class="headerlink" title="2. 定义资源"></a>2. 定义资源</h3><p>OK，因为需要类似于实战的东西，在资源定义这里我使用了 <code>Spring</code> 的钩子 + <code>Spring-data-jpa</code> 来辅助实战。</p>
<h4 id="2-1-两个资源（均省略了-getter-和-setter）"><a href="#2-1-两个资源（均省略了-getter-和-setter）" class="headerlink" title="2.1 两个资源（均省略了 getter 和 setter）"></a>2.1 两个资源（均省略了 <code>getter</code> 和 <code>setter</code>）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 登陆的用户 */</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;security_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;, length = 13)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_role&quot;, length = 20)</span></span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String role)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.role = role;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 请求的资源 */</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;security_resource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;res_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;res_role&quot;, length = 20)</span></span><br><span class="line">    <span class="keyword">private</span> String requireRole;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;res_content&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Resource</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Resource</span><span class="params">(String requireRole, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.requireRole = requireRole;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-两个资源对应的仓库"><a href="#2-2-两个资源对应的仓库" class="headerlink" title="2.2 两个资源对应的仓库"></a>2.2 两个资源对应的仓库</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">findByName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Resource, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Resource&gt; <span class="title function_">findByRequireRole</span><span class="params">(String requireRols)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-项目启动初始化"><a href="#2-3-项目启动初始化" class="headerlink" title="2.3 项目启动初始化"></a>2.3 项目启动初始化</h4><p>这个数据库包含三个用户以及对应角色可以访问到的一共十个资源，全部在启动的时候写入数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitDbConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">private</span> ResourceRepository resourceRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InitDbConfig</span><span class="params">(UserRepository userRepository, ResourceRepository resourceRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">        <span class="built_in">this</span>.resourceRepository = resourceRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;WEIDAN&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;XIAOMING&quot;</span>, <span class="string">&quot;vip&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;XIAOHONG&quot;</span>, <span class="string">&quot;customer&quot;</span>);</span><br><span class="line">        List&lt;User&gt; addUser = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        addUser.add(user1);</span><br><span class="line">        addUser.add(user2);</span><br><span class="line">        addUser.add(user3);</span><br><span class="line">        userRepository.saveAll(addUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;admin&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;admin&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;vip&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;admin&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;vip&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;admin&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;vip&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;admin&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource9</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;admin&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Resource</span>(<span class="string">&quot;customer&quot;</span>, UUID.randomUUID().toString());</span><br><span class="line">        List&lt;Resource&gt; resourceList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        resourceList.add(resource1);</span><br><span class="line">        resourceList.add(resource2);</span><br><span class="line">        resourceList.add(resource3);</span><br><span class="line">        resourceList.add(resource4);</span><br><span class="line">        resourceList.add(resource5);</span><br><span class="line">        resourceList.add(resource6);</span><br><span class="line">        resourceList.add(resource7);</span><br><span class="line">        resourceList.add(resource8);</span><br><span class="line">        resourceList.add(resource9);</span><br><span class="line">        resourceList.add(resource10);</span><br><span class="line">        resourceRepository.saveAll(resourceList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-项目配置"><a href="#2-4-项目配置" class="headerlink" title="2.4 项目配置"></a>2.4 项目配置</h4><p>既然使用到了数据库，那么项目配置就必不可少了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">create-drop</span> <span class="comment"># 项目启动时生成，关闭时删掉</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">org.hibernate.dialect.MySQL5InnoDBDialect</span> <span class="comment"># 设置 innoDB 引擎</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/security_db</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<h3 id="3-配合-spring-security-开发业务层"><a href="#3-配合-spring-security-开发业务层" class="headerlink" title="3. 配合 spring-security 开发业务层"></a>3. 配合 <code>spring-security</code> 开发业务层</h3><h4 id="3-1-用户业务层"><a href="#3-1-用户业务层" class="headerlink" title="3.1 用户业务层"></a>3.1 用户业务层</h4><p>这个业务层不需要我们定义接口，用于实现 <code>Spring</code> 提供的 <code>UserDetailsService</code> 接口即可。当然一般来说我们的用户层业务不会只有他那么一个方法，所以如若需要还是要定义我们自己的用户业务层接口的。 <code>UserDetailsService</code> 这个类，只有一个方法 <code>loadUserByUsername</code>，我们需要实现它，读取我们数据库用户的数据然后返回 <code>Spring</code> 定义的 <code>UserDetails</code>，当然了，也可以使用我们自己的类来集成这个 <code>UserDetails</code>。我想这一步可能就是大家所说的 <code>spring-security</code> 不轻量级的地方吧。因为权限模型都定义了，我们还需要根据他的需要来将我们的数据转换到他的类去。 <strong>在这里为了方便我把所有的用户的密码都设置成 <code>123</code> 了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.security.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.liweidan.springboot.security.dbo.User;</span><br><span class="line"><span class="keyword">import</span> cn.liweidan.springboot.security.repository.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/29 10:20 AM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123; <span class="comment">// 实现 spring 提供的 UserDetailsService 类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一个 spring 提供的简单的密码编译器，用于密码的加密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDetailServiceImpl</span><span class="params">(UserRepository userRepository, BCryptPasswordEncoder bCryptPasswordEncoder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">        <span class="built_in">this</span>.bCryptPasswordEncoder = bCryptPasswordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 loadUserByUsername</span></span><br><span class="line"><span class="comment">     * 这个方法会根据用户名取出相对应的用户数据，然后相当于转换成 spring 定义的用户类</span></span><br><span class="line"><span class="comment">     * spring 会在拦截登陆，登录验证，权限验证等使用到这个用户对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> spring 定义的用户类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException 没有找到用户异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String name)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userRepository.findByName(name);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(name + <span class="string">&quot; is not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;GrantedAuthority&gt; grantedAuthorityList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        grantedAuthorityList.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(user.getRole()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">org</span>.springframework.security.core.userdetails.User(user.getName(), bCryptPasswordEncoder.encode(<span class="string">&quot;123&quot;</span>), grantedAuthorityList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-资源业务层"><a href="#3-2-资源业务层" class="headerlink" title="3.2 资源业务层"></a>3.2 资源业务层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceRepository resourceRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResourceService</span><span class="params">(ResourceRepository resourceRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceRepository = resourceRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有 vip 的角色才可以访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 资源集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;vip&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Resource&gt; <span class="title function_">getVipResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resourceRepository.findByRequireRole(<span class="string">&quot;vip&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-资源控制器"><a href="#3-3-资源控制器" class="headerlink" title="3.3 资源控制器"></a>3.3 资源控制器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;resource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceService resourceService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;vip&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Resource&gt; <span class="title function_">getVipResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resourceService.getVipResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h3><p>启动项目，请求 <code>http://localhost:8080/resource/vip</code> 会发现请求被重定向到一个内置的登陆页面（可定制的）： </p>
<p><img src="/images/springboot-%E4%B8%8E-security-%E4%BF%9D%E6%8A%A4-web-%E5%AE%89%E5%85%A8.md/0.png"> </p>
<p>我使用 <code>WEIDAN</code> <code>123</code> 来登录（并不具备 vip 的角色）然后请求 vip 的资源。发现被拒绝访问了（这个页面可以通过之前所说的 <code>ControllerAdvise</code> 来定制）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Whitelabel Error Page</span><br><span class="line">This application has no explicit mapping for /error, so you are seeing this as a fallback.</span><br><span class="line"></span><br><span class="line">Sat Dec 01 09:11:58 CST 2018</span><br><span class="line">There was an unexpected error (type=Forbidden, status=403).</span><br><span class="line">Forbidden</span><br></pre></td></tr></table></figure>
<p>OK，接下来使用一个 <code>XIAOMING</code> <code>123</code> 来登录（具备 vip 角色），然后请求 vip 资源：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;requireRole&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vip&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;963d08cd-4ddb-4601-865a-9d91470bad28&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;requireRole&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vip&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;574353a7-5ec8-4383-b5b2-2b4435220069&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;requireRole&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vip&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d019d923-e267-4a18-a632-5cbecc04c012&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p><code>Spring-security</code> 提供了整套权限模型，如若真的计划使用来架构权限的话，需要了解有哪些类。<code>Spring</code> 依然提供了一些可以控制权限的注解类，这些类需要加在方法上面，初步感觉，可能有点不太灵活。在未来的微服务架构中我更希望是通过路由来控制接口的访问权限，而项目服务中开发就不再关注，降低耦合性，也能尽量防止在项目服务中开发错误的局面。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 与 redis 处理缓存</title>
    <url>//spring/springboot-%E4%B8%8E-redis-%E5%A4%84%E7%90%86%E7%BC%93%E5%AD%98/index.html</url>
    <content><![CDATA[<h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p><code>Redis</code> 是现在大部分项目中使用最多的 <code>NOSQL</code> 型数据库，其单线程的模型以及内存级别的读取可以给项目适当加加速。<code>Redis</code> 不仅会被当成缓存数据库使用，还会被作为分布式锁（因为是单线程模型）的工具来使用。 <code>Spring-Boot</code> 项目有两种方式使用 <code>Redis</code> ，接下来就是两种方式的使用方式了。<br>项目：<code>spring-boot-data-redis</code> 地址：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a></p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="（一）连接-redis-数据库"><a href="#（一）连接-redis-数据库" class="headerlink" title="（一）连接 redis 数据库"></a>（一）连接 redis 数据库</h3><h4 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h4><p>使用 <code>Docker</code> 启动 <code>redis</code> 内存数据库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -d -p 6379:6379 --name imopei-redis redis redis-server</span><br></pre></td></tr></table></figure>
<h4 id="2-mvn-依赖"><a href="#2-mvn-依赖" class="headerlink" title="2. mvn 依赖"></a>2. mvn 依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="3-配置-redis-信息"><a href="#3-配置-redis-信息" class="headerlink" title="3. 配置 redis 信息"></a>3. 配置 redis 信息</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># 连接地址</span></span><br><span class="line">    <span class="attr">password:</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">16</span>   <span class="comment"># 最大多少个可用</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>      <span class="comment"># 最大存活数量</span></span><br></pre></td></tr></table></figure>
<h4 id="4-开发接口以及实体类"><a href="#4-开发接口以及实体类" class="headerlink" title="4. 开发接口以及实体类"></a>4. 开发接口以及实体类</h4><p>为了简单，我就只使用接口和自带的 <code>redisTemplate</code> 来做数据存储。（当然有些数据真的可以直接存放于 <code>redis</code> 数据库）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .........</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">uuidOf</span><span class="params">(<span class="meta">@PathVariable</span> String uid)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> redisTemplate.opsForValue().get(uid);</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().readValue(json, UserDo.class);</span><br><span class="line">        <span class="keyword">return</span> userDo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(userDo.getUuid(), <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(userDo));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-请求测试"><a href="#5-请求测试" class="headerlink" title="5. 请求测试"></a>5. 请求测试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/user</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;uuid&quot;: &quot;1238910&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;Weidan&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Fri, 04 Jan 2019 08:24:30 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 202ms; Content length: 0 bytes</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">GET http://127.0.0.1:8080/user/1238910</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 04 Jan 2019 08:25:01 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;uuid&quot;: &quot;1238910&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;Weidan&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 89ms; Content length: 34 bytes</span><br></pre></td></tr></table></figure>
<h3 id="（二）使用-spring-的缓存注解"><a href="#（二）使用-spring-的缓存注解" class="headerlink" title="（二）使用 spring 的缓存注解"></a>（二）使用 spring 的缓存注解</h3><p>第（一）种方式自由度比较高，可以决定是否要缓存部分数据。 使用了 <code>spring</code> 的缓存注解的时候，因为缓存注解是使用 <code>AOP</code> 方式切入业务层的，所以可定制度相对就比较低了，一般是直接将整个方法的返回值根据注解定制的 <code>Key</code> 进行存储。 不过项目中可以采用两种方式缓和的方式进行开发？可能维护缓存是否有效就比较麻烦了。 我在项目中是采用第一种方式进行存储的。</p>
<h4 id="1-mvn-依赖"><a href="#1-mvn-依赖" class="headerlink" title="1. mvn 依赖"></a>1. mvn 依赖</h4><p>需要新增一个包：<code>spring-boot-starter-cache</code> 项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-启动类配置启动缓存"><a href="#2-启动类配置启动缓存" class="headerlink" title="2. 启动类配置启动缓存"></a>2. 启动类配置启动缓存</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RedisApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-新增一个缓存注解的控制器和业务层"><a href="#3-新增一个缓存注解的控制器和业务层" class="headerlink" title="3. 新增一个缓存注解的控制器和业务层"></a>3. 新增一个缓存注解的控制器和业务层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;usercache&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCacheEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserCacheEndpoint</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">uuidOf</span><span class="params">(<span class="meta">@PathVariable</span> String uid)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.uuidOf(uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        userService.add(userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="meta">@PathVariable</span> String uid)</span> &#123;</span><br><span class="line">        userService.deyByUuid(uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_VALUE</span> <span class="operator">=</span> <span class="string">&quot;user-details&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果可缓存</span></span><br><span class="line">    <span class="meta">@Cacheable(value = REDIS_VALUE, key = &quot;getArgs()[0]&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">uuidOf</span><span class="params">(String uuid)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------&quot;</span>);</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>();</span><br><span class="line">        userDo.setUuid(uuid);</span><br><span class="line">        userDo.setName(<span class="string">&quot;USER&quot;</span> + uuid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userDo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删掉缓存</span></span><br><span class="line">    <span class="meta">@CacheEvict(value = REDIS_VALUE, key = &quot;getArgs()[0]&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deyByUuid</span><span class="params">(String uuid)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将返回值放入缓存系统中</span></span><br><span class="line">    <span class="meta">@CachePut(value = REDIS_VALUE, key = &quot;getArgs()[0].uuid&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">add</span><span class="params">(UserDo userDo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要实现序列化接口和toString！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserDo&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;uuid=&#x27;&quot;</span> + uuid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-测试调用"><a href="#4-测试调用" class="headerlink" title="4. 测试调用"></a>4. 测试调用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/usercache</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;uuid&quot;: &quot;1238910&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;Weidan&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Mon, 07 Jan 2019 09:36:29 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 127ms; Content length: 0 bytes</span><br></pre></td></tr></table></figure>
<p>接下来我需要请求我新增的这个对象，要知道我上面如果没有缓存的话，<code>get</code> 出来的 <code>user</code> 的名字和这里的名字是不同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET http:<span class="comment">//127.0.0.1:8080/usercache/1238910</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> </span><br><span class="line">Content-Type: application/json;charset=UTF-<span class="number">8</span></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Mon, <span class="number">07</span> Jan <span class="number">2019</span> 09:<span class="number">37</span>:<span class="number">25</span> GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uuid&quot;</span>: <span class="string">&quot;1238910&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Weidan&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: <span class="number">200</span>; Time: 34ms; Content length: <span class="number">34</span> bytes</span><br></pre></td></tr></table></figure>
<p>OK，已经成功了，实现了我们新增用户的时候就把新增结果存入缓存系统。 接下来我要把它删掉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DELETE http:<span class="comment">//127.0.0.1:8080/usercache/1238910</span></span><br><span class="line"></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> </span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Date: Mon, <span class="number">07</span> Jan <span class="number">2019</span> 09:<span class="number">38</span>:<span class="number">05</span> GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: <span class="number">200</span>; Time: 25ms; Content length: <span class="number">0</span> bytes</span><br></pre></td></tr></table></figure>
<p>再重新获取这个 <code>uid</code> 的用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/usercache/1238910</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Mon, 07 Jan 2019 09:38:28 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;uuid&quot;: &quot;1238910&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;USER1238910&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 30ms; Content length: 39 bytes</span><br></pre></td></tr></table></figure>
<p>可以发现，获取的用户信息已经变成我自定义的用户信息了。 到这里缓存系统就已经集成成功了。 接下来，有个需求：</p>
<ol>
<li> 缓存系统缓存的信息在 <code>redis</code> 是以二进制的形式存在，不利于查看维护，所以我们需要修改序列化的方式</li>
</ol>
<h4 id="5-修改缓存序列化的形式"><a href="#5-修改缓存序列化的形式" class="headerlink" title="5. 修改缓存序列化的形式"></a>5. 修改缓存序列化的形式</h4><p>一般来说，缓存的形式以 <code>JSON</code> 的形式存在，当需要手动干预系统的运行（比如某个地方出现 <code>bug</code> 暂时不能运行但是又需要删除这个缓存的时候，可以快速定位）可以快速的进行相关的操作。</p>
<blockquote>
<p>参考资料：<a href="https://www.cnblogs.com/cjsblog/p/9150482.html">Spring Boot Cache配置 序列化成JSON字符串</a></p>
</blockquote>
<p>相当于只需要在系统中重新定义 <code>RedisTemplate</code> 的序列化方式即可，为了方便我没有多余创建配置类，直接写在了启动类里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheWriter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：启动器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/4 4:14 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RedisApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;Object&gt;(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        serializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setValueSerializer(serializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        redisTemplate.setHashValueSerializer(serializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisCacheManager <span class="title function_">redisCacheManager</span><span class="params">(RedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="type">RedisCacheWriter</span> <span class="variable">redisCacheWriter</span> <span class="operator">=</span> RedisCacheWriter.nonLockingRedisCacheWriter(redisTemplate.getConnectionFactory());</span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">redisCacheConfiguration</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getValueSerializer()));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>(redisCacheWriter, redisCacheConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，重新获取上面接口的内容，可以在 <code>redis</code> 的桌面端查看数据： <code>[&quot;cn.liweidan.springboot.redis.dbo.UserDo&quot;,&#123;&quot;uuid&quot;:&quot;1238910&quot;,&quot;name&quot;:&quot;USER1238910&quot;&#125;]</code></p>
<h4 id="6-Cache-的注解"><a href="#6-Cache-的注解" class="headerlink" title="6. Cache 的注解"></a>6. Cache 的注解</h4><h5 id="0）常用的属性"><a href="#0）常用的属性" class="headerlink" title="0）常用的属性"></a>0）常用的属性</h5><p>缓存的方式相当于我们自己手动设置的 <code>redisKey</code> : user-details: ${id} 在 <code>Redis</code> 桌面工具查看是会把前缀 user-details 当成一个文件夹来看的，相当于分组 Value: <code>Redis</code> 的 <code>key</code> 前缀，相当于分组 key: 可变后缀，可以使用常用的函数进行读取，函数调用的方法都存在于 <code>CacheExpressionRootObject</code> 类中</p>
<h5 id="1）查询缓存"><a href="#1）查询缓存" class="headerlink" title="1）查询缓存"></a>1）查询缓存</h5><p><code>@Cacheable(value = REDIS_VALUE, key = &quot;getArgs()[0]&quot;)</code> 这个注解常用于查询，因为运行的机制是先在缓存中查询是否有对应的 <code>value</code> 和 <code>key</code> ，如果没有再调用方法进行查询。示例中的意思是使用常量 <code>REDIS_VALUE</code> 存储前缀，参数的第一个值作为可变后缀。</p>
<h5 id="2）更新缓存"><a href="#2）更新缓存" class="headerlink" title="2）更新缓存"></a>2）更新缓存</h5><p><code>@CachePut(value = REDIS_VALUE, key = &quot;getArgs()[0].uuid&quot;)</code> 这个注解常用于更新缓存，无论是新增还是更新操作，只要方法运行完成，会将方法的返回值（注意是方法的返回值，所以更新、新增操作都需要返回对象）存入 <code>Redis</code> 中。<code>value</code> <code>key</code> 用法同上。</p>
<h5 id="3）删除缓存"><a href="#3）删除缓存" class="headerlink" title="3）删除缓存"></a>3）删除缓存</h5><p><code>@CacheEvict(value = REDIS_VALUE, key = &quot;getArgs()[0]&quot;)</code> 这个注解常用于删除处理，也是方法（一般是删除方法）运行完成后运行，将会把缓存中的数据给删除了。</p>
<h5 id="4）类全局配置"><a href="#4）类全局配置" class="headerlink" title="4）类全局配置"></a>4）类全局配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheConfig(cacheNames = &#123;&quot;user-details&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以定义该类行为下所有的分组 <code>cacheName</code> ，这样就不需要在上面三个注解中定义 <code>value</code> 值。</p>
<h4 id="7-注意！！"><a href="#7-注意！！" class="headerlink" title="7. 注意！！"></a>7. 注意！！</h4><p>因为缓存注解 <code>Spring</code> 是通过 <code>AOP</code> 进行实现的，所以，只有进入 <code>AOP</code> 的时候方法才会被缓存，嵌套调用 <code>service</code> 方法的时候，缓存注解并不会起作用。 我新增一个接口来做测试，按照上面 <code>uuidOf</code> 方法打印的 <code>------</code> 做判定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;usercache&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCacheEndpoint</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;testUuidOfWithMutipleCache/&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">testUuidOfWithMutipleCache</span><span class="params">(<span class="meta">@PathVariable</span> String uid)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.testUuidOfWithMutipleCache(uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &#123;&quot;user-details&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">testUuidOfWithMutipleCache</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uuidOf(uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连续调用三次 <code>GET http://127.0.0.1:8080/usercache/testUuidOfWithMutipleCache/1238910</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">2019-01-08 09:24:58.154  INFO 8892 --- [on(4)-127.0.0.1] io.lettuce.core.EpollProvider            : Starting without optional epoll library</span><br><span class="line">2019-01-08 09:24:58.155  INFO 8892 --- [on(4)-127.0.0.1] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library</span><br><span class="line">------</span><br><span class="line">------</span><br><span class="line">------</span><br></pre></td></tr></table></figure>
<p>可以看到控制台打印了三次，说明缓存并不起作用。</p>
<h2 id="三-总结一下"><a href="#三-总结一下" class="headerlink" title="三. 总结一下"></a>三. 总结一下</h2><p>两种方式各不相同，一种是直接当成数据库调用来看待，一种是通过注解的形式。 当然各有长短板，所以可以说，两种方式可以在项目中结合使用，但是缓存的时候不要互串，比如使用第二种方式创建的缓存在第一种方式获取，后面维护起来可以说很痛苦了。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 与 web 拦截器</title>
    <url>//spring/springboot-%E4%B8%8E-web-%E6%8B%A6%E6%88%AA%E5%99%A8/index.html</url>
    <content><![CDATA[<h1 id="springboot-web-拦截器的使用"><a href="#springboot-web-拦截器的使用" class="headerlink" title="springboot-web 拦截器的使用"></a>springboot-web 拦截器的使用</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>用过 <code>SpringMVC</code> 的应该都知道拦截器，拦截器可以设置在 <code>SpringMVC</code> 接收请求之前处理（返回 <code>true</code> 继续执行或 <code>false</code> 拒绝执行），方法处理请求之后，以及处理完整个请求之后的操作。例如：单体项目的登陆拦截、在进入处理器之前先给线程栈设置一个公用的 <code>UserThreadLocal</code> 等等。<br>GitHub地址：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> <strong>项目示例：<code>web-interceptor</code></strong></p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-mvn-新增-web-starter-的依赖"><a href="#1-mvn-新增-web-starter-的依赖" class="headerlink" title="1. mvn 新增 web-starter 的依赖"></a>1. <code>mvn</code> 新增 <code>web-starter</code> 的依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- 引入 web-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>拦截器依然默认是存在 <code>web-starter</code> 里面的。</p>
<a id="more"></a>
<h3 id="2-设置一个资源控制器"><a href="#2-设置一个资源控制器" class="headerlink" title="2. 设置一个资源控制器"></a>2. 设置一个资源控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.simpleweb.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：HelloWorld 控制器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/19 12:14 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// 使用 RestController，指定该控制器输出都是 json 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span> <span class="comment">// 使用 GetMapping 代替 RequestMapping、同理还有 PostMapping PutMapping DeleteMapping</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">helloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; helloMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        helloMap.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> helloMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-开发拦截器"><a href="#3-开发拦截器" class="headerlink" title="3. 开发拦截器"></a>3. 开发拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.webinterceptor.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：权限拦截器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/22 1:30 AM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123; <span class="comment">// 1. 实现 HandlerInterceptor 接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 preHandle 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authHeader</span> <span class="operator">=</span> request.getHeader(HttpHeaders.AUTHORIZATION);</span><br><span class="line">        <span class="comment">// 假设只有 Authorization 的值是 weidan 才给继续请求</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(authHeader) &amp;&amp; !authHeader.isEmpty() &amp;&amp; authHeader.equals(<span class="string">&quot;weidan&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>Spring</code> 5.0 之前是需要重写所有方法的，现在都是默认接口方法了，要靠自己重写所需要的。 一般重写 <code>preHandle</code> 方法，但这里需要注意的是，需要设置不通过后的响应问，不然会出现状态码 <code>200</code> 但是没有响应体的情况，我这里返回 <code>401</code></p>
<h3 id="4-配置拦截器注入项目"><a href="#4-配置拦截器注入项目" class="headerlink" title="4. 配置拦截器注入项目"></a>4. 配置拦截器注入项目</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.webinterceptor.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：web 配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/22 1:35 AM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类必备</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 注入拦截器并设置拦截路径</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">AuthInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意两点：</p>
<ol>
<li><p>同样，<code>WebMvcConfigurer</code> 都是默认方法的形式，只需要重写所需要的即可。</p>
</li>
<li><p><code>@Configuration</code> 是编写配置类必备的，不要忘记。</p>
</li>
</ol>
<h3 id="5-接口测试"><a href="#5-接口测试" class="headerlink" title="5. 接口测试"></a>5. 接口测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 传递错误的 Authorization 头</span><br><span class="line">GET http://localhost:8080</span><br><span class="line">Accept: application/json</span><br><span class="line">Authorization: weidan0</span><br><span class="line"></span><br><span class="line">HTTP/1.1 401 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Wed, 21 Nov 2018 17:44:01 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 401; Time: 29ms; Content length: 0 bytes</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line">// 正确的姿势传递</span><br><span class="line">GET http://localhost:8080</span><br><span class="line">Accept: application/json</span><br><span class="line">Authorization: weidan</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Wed, 21 Nov 2018 17:50:32 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;hello&quot;: &quot;world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 189ms; Content length: 17 bytes</span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>使用拦截器来开发登陆拦截，权限是可行的，就是需要自己编写较多的逻辑如查询数据库啦，判断啦。 所以如果权限模型简单的话，是没有问题的，如果权限问题比较复杂可以结合著名框架 <code>shrio</code> <code>spring-security</code> 等协助开发，当然像我们公司，权限模型自定义程度高，框架是解决不了的，也只能手撸了。 在日常开发中，一般 <code>Authorization</code> 存放的是 <code>jwt</code> 验证字符串，具体后面再细说。在微服务架构中，拦截器可就没什么用场了，我能想到的就是在当前线程栈中设置用户信息这个需求了。一般微服务架构权限的实现会交给路由来解决。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 的多配置环境配置</title>
    <url>//spring/springboot-%E7%9A%84%E5%A4%9A%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/index.html</url>
    <content><![CDATA[<h1 id="springboot-的多配置环境配置"><a href="#springboot-的多配置环境配置" class="headerlink" title="springboot 的多配置环境配置"></a>springboot 的多配置环境配置</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>多环境配置，这个东西无论在大厂小厂都是需要的，因为往往我们开发环境、测试环境、生产环境都不一样。数据库连接不说别的，起码 <code>url</code> 是不一样的。当然做法也有很多，可以通过 <code>properties</code> ，也可以通过 <code>mvn</code> 的配置以及 <code>spring</code> 的 <code>profile</code> 方式。 Github地址：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> 演示项目：<code>globle-profiles</code></p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-mvn-依赖"><a href="#1-mvn-依赖" class="headerlink" title="1. mvn 依赖"></a>1. <code>mvn</code> 依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入 web-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>感觉这个 <code>web-starter</code> 就是万能的依赖，有了它什么东西都有了。</p>
<a id="more"></a>
<h3 id="2-编写不同-profile-的配置"><a href="#2-编写不同-profile-的配置" class="headerlink" title="2. 编写不同 profile 的配置"></a>2. 编写不同 <code>profile</code> 的配置</h3><p>共同的配置，类似于一个产量的名字啊等等均可以放在通用的配置里。 通用的配置取名是 <code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">common:</span></span><br><span class="line">  <span class="attr">profile:</span> <span class="string">common-profile</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 指定启动的环境，这里默认是开发环境</span></span><br></pre></td></tr></table></figure>
<p>现在我用一个开发，一个生产环境的常亮来演示： <code>application-dev.yml</code> 可以看到，后缀就是环境的名称：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">diff:</span></span><br><span class="line">  <span class="attr">profile:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p> <code>application-prod.yml</code> ：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">diff:</span></span><br><span class="line">  <span class="attr">profile:</span> <span class="number">789123</span></span><br></pre></td></tr></table></figure>
<h3 id="3-用于读取环境常亮的控制器"><a href="#3-用于读取环境常亮的控制器" class="headerlink" title="3. 用于读取环境常亮的控制器"></a>3. 用于读取环境常亮的控制器</h3><p>简单粗暴一点，直接使用 <code>SPel</code> 去读取到不同环境的变量然后注入到控制器中返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProfileEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;common.profile&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String common;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;diff.profile&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String diffProfile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">loadProfiles</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; profileMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        profileMap.put(<span class="string">&quot;common&quot;</span>, common);</span><br><span class="line">        profileMap.put(<span class="string">&quot;diffProfile&quot;</span>, diffProfile);</span><br><span class="line">        <span class="keyword">return</span> profileMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-测试接口"><a href="#4-测试接口" class="headerlink" title="4. 测试接口"></a>4. 测试接口</h3><p>分别以 <code>dev</code> 环境和 <code>prod</code> 环境来启动项目，分别读取不同的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8080</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sat, 01 Dec 2018 03:02:50 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;common&quot;: &quot;common-profile&quot;,</span><br><span class="line">  &quot;diffProfile&quot;: &quot;123456&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line">GET http://localhost:8080</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sat, 01 Dec 2018 03:03:45 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;common&quot;: &quot;common-profile&quot;,</span><br><span class="line">  &quot;diffProfile&quot;: &quot;789123&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-修改-profile-的方式"><a href="#5-修改-profile-的方式" class="headerlink" title="5. 修改 profile 的方式"></a>5. 修改 <code>profile</code> 的方式</h3><ol>
<li> 启动时命令行传入 <code>--spring.profiles.active=prod</code> （<code>java -jar -Dspring.profiles.active=production demo-0.0.1-SNAPSHOT.jar</code>）</li>
<li> 通过修改 <code>application.yml</code> 的 <code>spring.profiles.active</code></li>
<li> 设置系统变量 <code>spring.profiles.active</code></li>
<li> 操作系统环境变量 <code>SPRING_PROFILES_ACTIVE</code></li>
</ol>
<p>以上排序优先级从高到低，也就是说，如果在命令行输入了，那么下面的设置都会被覆盖掉。我们可以利用这个特性，去做一些定制化操作，例如默认是开发环境，只有运行在服务器的时候，通过命令修改环境（一般是通过 <code>Jenkins</code> 来启动项目）</p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p><code>profile</code> 可以让我们很快的变更环境而不需要每次部署都去关心所需要修改的配置。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 与接口文档系统 swagger</title>
    <url>//spring/springboot-%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E7%B3%BB%E7%BB%9F-swagger/index.html</url>
    <content><![CDATA[<h1 id="springboot-与接口文档系统-swagger"><a href="#springboot-与接口文档系统-swagger" class="headerlink" title="springboot 与接口文档系统 swagger"></a>springboot 与接口文档系统 swagger</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>日常开发中，常常需要接口文档的交互，跟前端也好，跟 <code>app</code> 端的也好。但是如果是手动编写的文档，常常会因为各种原因（当然，懒和忘记是主要原因），会比代码滞后。这样导致的问题就比较严重了，有时候前端写完一个功能了，对接一下，哎呀，出错了。不仅增加了麻烦，还浪费了时间。 当初选择使用 <code>swagger</code> 是因为其界面还不错，清新清新的感觉。现在官网出了很多产品，但还都是需要去利用手动的去更新文档。我最喜欢的还是这种你编码一个接口顺便把文档使用注解的方式给写在了文档上面。可以有效的避免了接口更新但是忘记更新文档的尴尬。</p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-mvn-引入所需要的依赖"><a href="#1-mvn-引入所需要的依赖" class="headerlink" title="1. mvn 引入所需要的依赖"></a>1. <code>mvn</code> 引入所需要的依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;springfox-version&gt;2.5.0&lt;/springfox-version&gt;</span><br><span class="line">    &lt;swagger-core-version&gt;1.5.10&lt;/swagger-core-version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入 web-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入 swagger 相关的依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;springfox-version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.swagger&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;swagger-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;swagger-core-version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;springfox-version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-编写启动器"><a href="#2-编写启动器" class="headerlink" title="2. 编写启动器"></a>2. 编写启动器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">// 启动 swagger 自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Swagger2Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>注意需要加入 <code>@EnableSwagger2</code> 注解，<code>swagger</code> 的 <code>starter</code> 会根据所规定的流程进行初始化操作。</p>
<h3 id="3-配置一些-swagger-的信息"><a href="#3-配置一些-swagger-的信息" class="headerlink" title="3. 配置一些 swagger 的信息"></a>3. 配置一些 <code>swagger</code> 的信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.swagger2.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Predicates;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：Swagger2 配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/22 5:50 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">swaggerSpringMvcPlugin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .useDefaultResponseMessages(<span class="literal">false</span>)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/error.*&quot;</span>)))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;WEIDAN 的 SpringBoot 示例&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;主要讲解了如何使用 Swagger2 整合 SpringBoot&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-编写控制器，并加入接口数据注解"><a href="#4-编写控制器，并加入接口数据注解" class="headerlink" title="4. 编写控制器，并加入接口数据注解"></a>4. 编写控制器，并加入接口数据注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.swagger2.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.liweidan.springboot.swagger2.dbo.UserDo;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParam;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParams;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：用户资源控制器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/22 11:00 AM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 公司关联用户ID表 */</span></span><br><span class="line">    Map&lt;Long, List&lt;Long&gt;&gt; orgRelationUser = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/** 用户表 */</span></span><br><span class="line">    List&lt;UserDo&gt; userDoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserEndpoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 假设五个用户，隶属于两个公司，我可能从公司ID查询，也根据条件查询全部</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">1L</span>, <span class="string">&quot;weidan&quot;</span>, <span class="number">6000L</span>, <span class="number">18</span>));</span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">2L</span>, <span class="string">&quot;xiaodan&quot;</span>, <span class="number">10000L</span>, <span class="number">36</span>));</span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">3L</span>, <span class="string">&quot;dadan&quot;</span>, <span class="number">9000L</span>, <span class="number">28</span>));</span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">4L</span>, <span class="string">&quot;Sally&quot;</span>, <span class="number">12000L</span>, <span class="number">24</span>));</span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">5L</span>, <span class="string">&quot;weisuodan&quot;</span>, <span class="number">20000L</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Long&gt; userIds1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        userIds1.add(<span class="number">1L</span>);</span><br><span class="line">        userIds1.add(<span class="number">3L</span>);</span><br><span class="line">        userIds1.add(<span class="number">4L</span>);</span><br><span class="line">        orgRelationUser.put(<span class="number">10L</span>, userIds1);</span><br><span class="line"></span><br><span class="line">        List&lt;Long&gt; userIds2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        userIds2.add(<span class="number">2L</span>);</span><br><span class="line">        userIds2.add(<span class="number">5L</span>);</span><br><span class="line">        orgRelationUser.put(<span class="number">7L</span>, userIds2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口的说明，可以指定接口做了什么事情</span></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;用户资源请求入口&quot;, notes = &quot;可以根据公司的id查询到隶属于该公司的员工&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParams(&#123; // 参数集合，指定传递的参数的类型，是否必须，作用，数据类型等等</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;orgId&quot;, value = &quot;需要查询的公司的ID&quot;, required = true, paramType = &quot;query&quot;, dataType = &quot;String&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@GetMapping(params = &quot;orgId&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserDo&gt; <span class="title function_">selectByOrg</span><span class="params">(<span class="meta">@RequestParam(&quot;orgId&quot;)</span> Long orgId)</span> &#123;</span><br><span class="line">        List&lt;Long&gt; userIds = orgRelationUser.get(orgId);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(userIds)  userIds.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userDoList.stream().filter(userDo -&gt; userIds.contains(userDo.getId())).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-编写-UserDto-说明"><a href="#5-编写-UserDto-说明" class="headerlink" title="5. 编写 UserDto 说明"></a>5. 编写 <code>UserDto</code> 说明</h3><p>当然啦，这一步需不需要每个人的设定是不同的，我们就不设定这个地方，只要稍微污染一下 <code>Controller</code> 就基本可以交接了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.swagger2.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiImplicitParam;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：用户DO类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/22 11:01 AM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiModel</span> <span class="comment">// 指定该 dto 类是一个数据传递的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定属性的名字和说明</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(name = &quot;id&quot;, notes = &quot;用户存储的唯一ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ApiModelProperty(name = &quot;name&quot;, notes = &quot;用户名字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(name = &quot;salary&quot;, notes = &quot;用户的薪资数字，单位：分&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long salary;</span><br><span class="line">    <span class="meta">@ApiModelProperty(name = &quot;age&quot;, notes = &quot;用户的年龄&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDto</span><span class="params">(Long id, String name, Long salary, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDto</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 setter &amp; getter</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-API-文档界面"><a href="#6-API-文档界面" class="headerlink" title="6. API 文档界面"></a>6. API 文档界面</h3><p>打开 <code>http://localhost:8080/swagger-ui.html#/</code> </p>
<p><img src="/images/springboot-%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E7%B3%BB%E7%BB%9F-swagger.md/0.png"></p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>还需要配置用户名密码，或者根据环境的不同禁用 <code>swagger</code> 。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 与数据接口</title>
    <url>//spring/springboot-%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3/index.html</url>
    <content><![CDATA[<h1 id="springboot-与数据接口"><a href="#springboot-与数据接口" class="headerlink" title="springboot 与数据接口"></a>springboot 与数据接口</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>从以往的 <code>Spring</code> 项目开发经验来看，<code>Spring</code> 对 <code>JSON</code> 情有独钟，这也得益于 <code>JSON</code> 是<code>JS</code> 发明的一种轻量级的数据交换格式，因为本身 <code>JS</code> 是弱类型的语言，所以 <code>JSON</code> 便没有什么特定类型限制，使得其他各门语言都可以对 <code>JSON</code> 进行解析，从而序列化成各自的对象。 其实前面说的已经有一点半点的，基本都是返回 <code>JSON</code> 字符串，所以这里便加深一点，涉及 <code>SpringMVC</code> 可以用于开发的注解。<br>GitHub：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> <strong>项目示例：<code>web-restful</code></strong></p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-maven-依赖"><a href="#1-maven-依赖" class="headerlink" title="1. maven 依赖"></a>1. <code>maven</code> 依赖</h3><p><code>maven</code> 依赖依然只需要 <code>spring-boot-starter-web</code> 的依赖即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- 引入 web-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-资源控制器"><a href="#2-资源控制器" class="headerlink" title="2. 资源控制器"></a>2. 资源控制器</h3><p>我这里为了能够说明明白，先假定控制器是用户资源控制器，我可以通过公司查询，也可以通过用户的某个字段查询。 一般来说，一个资源控制器，我喜欢只关注聚合类的资源，比如用户控制器，返回的一般都是用户，操作的也一般是用户。 使用 <code>RESTful</code> 风格来编排 <code>URL</code> ，以前开发的时候因为没有关注到一些注解的用法，<code>RESTful</code> 用起来总是有点吃力，因为有些时候我是从另外一个方向去查询的，并不是 <code>User</code> 的内部属性。 由于先不接触数据库，所以先用集合模拟数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.webrestful.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.liweidan.springboot.webrestful.dbo.UserDo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：用户资源控制器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/22 11:00 AM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 公司关联用户ID表 */</span></span><br><span class="line">    Map&lt;Long, List&lt;Long&gt;&gt; orgRelationUser = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/** 用户表 */</span></span><br><span class="line">    List&lt;UserDo&gt; userDoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserEndpoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 假设五个用户，隶属于两个公司，我可能从公司ID查询，也根据条件查询全部</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">1L</span>, <span class="string">&quot;weidan&quot;</span>, <span class="number">6000L</span>, <span class="number">18</span>));</span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">2L</span>, <span class="string">&quot;xiaodan&quot;</span>, <span class="number">10000L</span>, <span class="number">36</span>));</span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">3L</span>, <span class="string">&quot;dadan&quot;</span>, <span class="number">9000L</span>, <span class="number">28</span>));</span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">4L</span>, <span class="string">&quot;Sally&quot;</span>, <span class="number">12000L</span>, <span class="number">24</span>));</span><br><span class="line">        userDoList.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>(<span class="number">5L</span>, <span class="string">&quot;weisuodan&quot;</span>, <span class="number">20000L</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Long&gt; userIds1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        userIds1.add(<span class="number">1L</span>);</span><br><span class="line">        userIds1.add(<span class="number">3L</span>);</span><br><span class="line">        userIds1.add(<span class="number">4L</span>);</span><br><span class="line">        orgRelationUser.put(<span class="number">10L</span>, userIds1);</span><br><span class="line"></span><br><span class="line">        List&lt;Long&gt; userIds2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        userIds2.add(<span class="number">2L</span>);</span><br><span class="line">        userIds2.add(<span class="number">5L</span>);</span><br><span class="line">        orgRelationUser.put(<span class="number">7L</span>, userIds2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(params = &quot;orgId&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserDo&gt; <span class="title function_">selectByOrg</span><span class="params">(<span class="meta">@RequestParam(&quot;orgId&quot;)</span> Long orgId)</span> &#123;</span><br><span class="line">        List&lt;Long&gt; userIds = orgRelationUser.get(orgId);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(userIds)  userIds.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userDoList.stream().filter(userDo -&gt; userIds.contains(userDo.getId())).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(params = &#123;&quot;salaryMin&quot;, &quot;salaryMax&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserDo&gt; <span class="title function_">selectAllByCondition</span><span class="params">(<span class="meta">@RequestParam(value = &quot;salaryMin&quot;, defaultValue = &quot;0&quot;)</span> Long salaryMin,</span></span><br><span class="line"><span class="params">                                             <span class="meta">@RequestParam(value = &quot;salaryMax&quot;, defaultValue = Long.MAX_VALUE + &quot;&quot;)</span> Long salaryMax)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDoList.stream()</span><br><span class="line">                .filter(userDo -&gt; userDo.getSalary() &gt; salaryMin &amp;&amp; userDo.getSalary() &lt; salaryMax)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserDo&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo, <span class="meta">@RequestParam(&quot;orgId&quot;)</span> Long orgId)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">nextId</span> <span class="operator">=</span> (<span class="type">long</span>) (userDoList.size() + <span class="number">1</span>);</span><br><span class="line">        userDo.setId(nextId);</span><br><span class="line">        userDoList.add(userDo);</span><br><span class="line"></span><br><span class="line">        List&lt;Long&gt; userIds = orgRelationUser.get(orgId);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(userIds)) &#123;</span><br><span class="line">            userIds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        userIds.add(nextId);</span><br><span class="line">        orgRelationUser.put(orgId, userIds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NO_CONTENT)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (UserDo origin : userDoList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (origin.getId().equals(userDo.getId())) &#123;</span><br><span class="line">                origin.setName(userDo.getName());</span><br><span class="line">                origin.setSalary(userDo.getSalary());</span><br><span class="line">                origin.setAge(userDo.getAge());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;userId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span> Long userId)</span> &#123;</span><br><span class="line">        userDoList = userDoList.stream().filter(userDo -&gt; !userDo.getId().equals(userId)).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-接口测试"><a href="#3-接口测试" class="headerlink" title="3. 接口测试"></a>3. 接口测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 根据公司ID查询</span><br><span class="line">GET http://localhost:8080/user?orgId=10</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, 22 Nov 2018 08:12:46 GMT</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;name&quot;: &quot;weidan&quot;,</span><br><span class="line">    &quot;salary&quot;: 6000,</span><br><span class="line">    &quot;age&quot;: 18</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 3,</span><br><span class="line">    &quot;name&quot;: &quot;dadan&quot;,</span><br><span class="line">    &quot;salary&quot;: 9000,</span><br><span class="line">    &quot;age&quot;: 28</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 4,</span><br><span class="line">    &quot;name&quot;: &quot;Sally&quot;,</span><br><span class="line">    &quot;salary&quot;: 12000,</span><br><span class="line">    &quot;age&quot;: 24</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 469ms; Content length: 144 bytes</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"># 根据条件查询全部</span><br><span class="line">GET http://localhost:8080/user?salaryMin=9000</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, 22 Nov 2018 08:13:38 GMT</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;name&quot;: &quot;weidan&quot;,</span><br><span class="line">    &quot;salary&quot;: 6000,</span><br><span class="line">    &quot;age&quot;: 18</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 2,</span><br><span class="line">    &quot;name&quot;: &quot;xiaodan&quot;,</span><br><span class="line">    &quot;salary&quot;: 10000,</span><br><span class="line">    &quot;age&quot;: 36</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 3,</span><br><span class="line">    &quot;name&quot;: &quot;dadan&quot;,</span><br><span class="line">    &quot;salary&quot;: 9000,</span><br><span class="line">    &quot;age&quot;: 28</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 4,</span><br><span class="line">    &quot;name&quot;: &quot;Sally&quot;,</span><br><span class="line">    &quot;salary&quot;: 12000,</span><br><span class="line">    &quot;age&quot;: 24</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 5,</span><br><span class="line">    &quot;name&quot;: &quot;weisuodan&quot;,</span><br><span class="line">    &quot;salary&quot;: 20000,</span><br><span class="line">    &quot;age&quot;: 20</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 22ms; Content length: 246 bytes</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"># 查询全部用户</span><br><span class="line">GET http://localhost:8080/user</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, 22 Nov 2018 08:14:11 GMT</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;name&quot;: &quot;weidan&quot;,</span><br><span class="line">    &quot;salary&quot;: 6000,</span><br><span class="line">    &quot;age&quot;: 18</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 2,</span><br><span class="line">    &quot;name&quot;: &quot;xiaodan&quot;,</span><br><span class="line">    &quot;salary&quot;: 10000,</span><br><span class="line">    &quot;age&quot;: 36</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 3,</span><br><span class="line">    &quot;name&quot;: &quot;dadan&quot;,</span><br><span class="line">    &quot;salary&quot;: 9000,</span><br><span class="line">    &quot;age&quot;: 28</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 4,</span><br><span class="line">    &quot;name&quot;: &quot;Sally&quot;,</span><br><span class="line">    &quot;salary&quot;: 12000,</span><br><span class="line">    &quot;age&quot;: 24</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 5,</span><br><span class="line">    &quot;name&quot;: &quot;weisuodan&quot;,</span><br><span class="line">    &quot;salary&quot;: 20000,</span><br><span class="line">    &quot;age&quot;: 20</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 29ms; Content length: 246 bytes</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"># 新增用户接口 返回 201</span><br><span class="line">POST http://localhost:8080/user?orgId=10</span><br><span class="line"></span><br><span class="line">HTTP/1.1 201 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Thu, 22 Nov 2018 08:16:23 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 201; Time: 232ms; Content length: 0 bytes</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"># 更新用户接口 返回 204</span><br><span class="line">PUT http://localhost:8080/user</span><br><span class="line"></span><br><span class="line">HTTP/1.1 204 </span><br><span class="line">Date: Thu, 22 Nov 2018 08:16:56 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 204; Time: 79ms; Content length: 0 bytes</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"># 删除用户接口</span><br><span class="line">DELETE http://localhost:8080/user/2</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Thu, 22 Nov 2018 08:17:20 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 46ms; Content length: 0 bytes</span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p><code>JSON</code> 已经成为各大语言的青睐，<code>SpringMVC</code> 还可以提供其他的数据格式交互，例如 <code>Hession</code> 。这些后面跟 <code>SpringCloud</code> 放在一起，跟 <code>Feign</code> 一起搭配使用，提升数据交互的效率。 其实做 <code>RESTful</code> 的时候，最纠结的就是资源的设计了，有的需要用这个条件获取，有的需要那个条件去获取，以前写的乱七八糟，自从知道了 <code>params</code> 以后，设计就变得简单易懂了。不仅仅 <code>GetMapping</code> 所有的请求方式都有这个参数。 以及还有 <code>@SessionAttribute</code> <code>@CookieValue</code> <code>@RequestHeader</code> 可以获取相对应区域的信息。交替使用则可以让开发更加流畅。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 与数据验证</title>
    <url>//spring/springboot-%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/index.html</url>
    <content><![CDATA[<h1 id="springboot-与数据验证"><a href="#springboot-与数据验证" class="headerlink" title="springboot 与数据验证"></a>springboot 与数据验证</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>在项目开发中，验证参数也是最经常使用的业务需求了。通常在开发的时候都需要根据业务需求，对参数进行必要验证。 当然一堆的 <code>if-else</code> 的验证在日常开发中时常可见。这种方式非常不友好： 1. 代码太长导致阅读不友好，更改需求可能只是简单的修改但是却需要阅读几十到几百行的代码 2. 有时候业务只是一两句但是验证代码却占用了很长时间 <code>JSR-303</code> 是 <code>Java</code> 的验证规范，早期是在 <code>Hibernate</code> 框架中实现的，后面被抽取到 <code>Java</code> 体系。<code>Spring-Boot</code> 使用了 <code>hibernate-validator</code> 验证器，所以也包含了 <code>JSR-303</code> 在里面。当需要进行参数验证的时候，只需要几个注解即可实现复杂的验证。<br>GitHub：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> 项目示例：<code>web-validate</code></p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 引入 web-starter, 已经包含 hibernate-validator 验证器 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-使用注解开发控制器"><a href="#2-使用注解开发控制器" class="headerlink" title="2. 使用注解开发控制器"></a>2. 使用注解开发控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span> <span class="comment">// 类上添加该注解，能够验证直接使用参数形式的借口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果需要验证Dto类，只需要加上<span class="doctag">@Validated</span>即可，如需分组，传入参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDto</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> UserDto userDto)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&gt; add: &quot;</span> + userDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> UserDto <span class="title function_">queryByName</span><span class="params">(<span class="meta">@Length(min = 1, max = 8)</span> <span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="type">UserDto</span> <span class="variable">userDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDto</span>();</span><br><span class="line">        userDto.setId(<span class="number">100</span>);</span><br><span class="line">        userDto.setUserName(<span class="string">&quot;狗蛋&quot;</span>);</span><br><span class="line">        userDto.setAge(<span class="number">19</span>);</span><br><span class="line">        <span class="keyword">return</span> userDto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PS: 1. 第一个接口使用 <code>DTO</code> 的形式进行验证，验证注解将会被使用在 <code>DTO</code> 上，<code>DTO</code>如下 2. 第二个接口直接在接口参数进行验证 UserDto：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户数据交换类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-请求两个接口"><a href="#3-请求两个接口" class="headerlink" title="3. 请求两个接口"></a>3. 请求两个接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://localhost:8080</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 14 Dec 2018 01:41:46 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2018-12-14T01:41:46.244+0000&quot;,</span><br><span class="line">  &quot;status&quot;: 400,</span><br><span class="line">  &quot;error&quot;: &quot;Bad Request&quot;,</span><br><span class="line">  &quot;errors&quot;: [</span><br><span class="line">  ... 这里不做详细演示因为下面要配合控制器监听把这个错误给修改掉</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">GET http://localhost:8080?name=</span><br><span class="line"></span><br><span class="line">HTTP/1.1 500 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 14 Dec 2018 01:42:55 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2018-12-14T01:42:55.654+0000&quot;,</span><br><span class="line">  &quot;status&quot;: 500,</span><br><span class="line">  &quot;error&quot;: &quot;Internal Server Error&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;queryByName.name: 长度需要在1和8之间&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;/&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 500; Time: 29ms; Content length: 141 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Spring</code> 已经对数据按照我们的需求进行了验证，但是返回的错误信息并不是很友好，我们可以使用前面提到的 <code>controller-advice</code> 进行拦截返回</p>
<h3 id="4-定制返回验证错误信息"><a href="#4-定制返回验证错误信息" class="headerlink" title="4. 定制返回验证错误信息"></a>4. 定制返回验证错误信息</h3><p>从控制台可以看到，验证不通过的时候抛出的异常是 <code>ConstraintViolationException</code> 和 <code>MethodArgumentNotValidException</code> 异常，所以在监听器里只需要对这个异常进行监听，获取 <code>message</code> 属性进行返回即可得知错误的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndpointAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span> <span class="comment">// 参数验证异常</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span> <span class="comment">// 返回 400</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">errorParam</span><span class="params">(ConstraintViolationException e)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; error = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        error.put(<span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span> <span class="comment">// DTO 验证异常</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span> <span class="comment">// 返回 400</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">errorDto</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; error = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (ObjectError allError : e.getBindingResult().getAllErrors()) &#123;</span><br><span class="line">            message.append(allError.getDefaultMessage()).append(<span class="string">&quot;; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        error.put(<span class="string">&quot;message&quot;</span>, message.toString());</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://localhost:8080</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 14 Dec 2018 01:59:57 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;message&quot;: &quot;名字不允许为空; 年龄不允许为空; &quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 400; Time: 166ms; Content length: 28 bytes</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line">GET http://localhost:8080?name=</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 14 Dec 2018 01:48:23 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;message&quot;: &quot;queryByName.name: 长度需要在1和8之间&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 400; Time: 151ms; Content length: 42 bytes</span><br></pre></td></tr></table></figure>
<h3 id="5-分组验证"><a href="#5-分组验证" class="headerlink" title="5. 分组验证"></a>5. 分组验证</h3><p><code>DTO</code> 如果验证不能自由的话，那么<code>DTO</code> 的复用性就变差了，总不能一个接口都要重新写属性相同但是验证不相同的 <code>DTO</code> 吧 所以，<code>JSR-303</code> 的每个验证注解上都有一个 <code>groups</code> 属性，传入 <code>Class</code> 数组（多组验证），用于定义分组验证的接口（但是这个接口没有实际实现，只是以 <code>Java</code> 类来做分组罢了）。 <code>DTO</code> 修改为更新的时候要求 <code>id</code> 不能为空，新增时名字和年龄不能为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(groups = Update.class)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;名字不允许为空&quot;, groups = Add.class)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;年龄不允许为空&quot;, groups = Add.class)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口修改，验证器传入分组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span> <span class="comment">// 类上添加该注解，能够验证直接使用参数形式的借口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增的时候验证 ADD 分组下需要验证的属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDto</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(<span class="meta">@Validated(&#123;Add.class&#125;)</span> <span class="meta">@RequestBody</span> UserDto userDto)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&gt; add: &quot;</span> + userDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新的时候验证 UPDATE 分组下需要验证的属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userDto</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(&#123;Update.class&#125;)</span> <span class="meta">@RequestBody</span> UserDto userDto)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----&gt; update: &quot;</span> + userDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新请求接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://localhost:8080</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 14 Dec 2018 02:11:14 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;message&quot;: &quot;年龄不允许为空; 名字不允许为空; &quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 400; Time: 11ms; Content length: 32 bytes</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">PUT http://localhost:8080</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Fri, 14 Dec 2018 02:12:06 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;message&quot;: &quot;不能为null; &quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 400; Time: 194ms; Content length: 23 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-注解使用说明"><a href="#6-注解使用说明" class="headerlink" title="6. 注解使用说明"></a>6. 注解使用说明</h3><p>每个注解都拥有两个属性： </p>
<ol>
<li>groups 用于定义这个注解要应用于哪些分组的 </li>
<li>message 用于定义不符合要求时要输出的内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注解</span><br><span class="line"></span><br><span class="line">说明</span><br><span class="line"></span><br><span class="line">@Null</span><br><span class="line"></span><br><span class="line">被注释的元素必须为</span><br><span class="line"></span><br><span class="line">@NotNull</span><br><span class="line"></span><br><span class="line">被注释的元素必须不为null</span><br><span class="line"></span><br><span class="line">@AssertTrue</span><br><span class="line"></span><br><span class="line">被注释的元素必须为true</span><br><span class="line"></span><br><span class="line">@AssertFalse</span><br><span class="line"></span><br><span class="line">被注释的元素必须为false</span><br><span class="line"></span><br><span class="line">@Min(value)</span><br><span class="line"></span><br><span class="line">被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><br><span class="line"></span><br><span class="line">@Max(value)</span><br><span class="line"></span><br><span class="line">被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line"></span><br><span class="line">@DecimalMin(value)</span><br><span class="line"></span><br><span class="line">被注释的元素必须是一个数字，其值必须大于等于指定的最小值</span><br><span class="line"></span><br><span class="line">@DecimalMax(value)</span><br><span class="line"></span><br><span class="line">被注释的元素必须是一个数字，其值必须小于等于指定的最大值</span><br><span class="line"></span><br><span class="line">@Size(max=,min=)</span><br><span class="line"></span><br><span class="line">被注释的元素的大小必须在指定的范围内</span><br><span class="line"></span><br><span class="line">@Digits</span><br><span class="line"></span><br><span class="line">被注释的元素必须是一个数字，其值必须在可接受的范围内</span><br><span class="line"></span><br><span class="line">@Past</span><br><span class="line"></span><br><span class="line">被注释的元素必须是一个过去的日期</span><br><span class="line"></span><br><span class="line">@Future</span><br><span class="line"></span><br><span class="line">被注释的元素必须是一个将来的日期</span><br><span class="line"></span><br><span class="line">@Pattern(regex=,flag=)</span><br><span class="line"></span><br><span class="line">被注释的元素必须符合指定的正则表达式</span><br><span class="line"></span><br><span class="line">Hibernate</span><br><span class="line"></span><br><span class="line">Validator</span><br><span class="line"></span><br><span class="line">@NotBlank</span><br><span class="line"></span><br><span class="line">验证字符串非null，且长度必须大于0</span><br><span class="line"></span><br><span class="line">@Email</span><br><span class="line"></span><br><span class="line">被注释的元素必须是电子邮箱地址</span><br><span class="line"></span><br><span class="line">@Length(min=,max=)</span><br><span class="line"></span><br><span class="line">被注释的字符串的大小必须在指定的范围内</span><br><span class="line"></span><br><span class="line">@NotEmpty</span><br><span class="line"></span><br><span class="line">被注释的字符串的必须非空</span><br><span class="line"></span><br><span class="line">@Range(min=,max=,message=)</span><br><span class="line"></span><br><span class="line">被注释的元素必须在合适的范围内</span><br></pre></td></tr></table></figure>
<h3 id="7-开发自定义校验器"><a href="#7-开发自定义校验器" class="headerlink" title="7. 开发自定义校验器"></a>7. 开发自定义校验器</h3><p>很多时候，框架自带的功能并不能或者说不方便实现我们想要的功能的时候，我们就可以开始考虑自己造轮子，开发属于我们所在领域的校验器。 简单来说，开发流程就是以下两个步骤：</p>
<ol>
<li> 编写约束注解，填充需要的属性以及官方必须要求的属性；</li>
<li> 编写校验器，对目标值配合注解上的属性进行验证。</li>
</ol>
<h4 id="7-1-定义校验注解"><a href="#7-1-定义校验注解" class="headerlink" title="7.1 定义校验注解"></a>7.1 定义校验注解</h4><p>为了示范，我定义一个验证目标字符串需要纯中文字符的校验注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证纯中文的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123; ChsValidator.class &#125;)</span> <span class="comment">// 定义注解的校验器</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span> <span class="comment">// 定义该注解使用在类属性上</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span> <span class="comment">// 运行时有效</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Chs &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 可以自定义属性，这个属性暂时没什么用 */</span></span><br><span class="line">    String <span class="title function_">chineseName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 以下是注解必须的三个属性，分别是定义组别、错误等级以及提示信息 */</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;该字段需要纯中文&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7-2-定义校验器"><a href="#7-2-定义校验器" class="headerlink" title="7.2 定义校验器"></a>7.2 定义校验器</h4><p>校验器需要去实现 <code>ConstraintValidator</code> 接口，传入两个泛型，第一个泛型是注解类型，第二个是目标值的类型。实现两个方法，校验器调用的校验在 <code>isValid</code> 中进行，如果校验通过返回 <code>True</code> 不同过则返回 <code>False</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChsValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;Chs, String&gt; &#123; <span class="comment">// 实现ConstraintValidator接口，第一个泛型是注解类型，第二个是目标值的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">reg</span> <span class="operator">=</span> <span class="string">&quot;^[\\u0391-\\uFFE5]+[\\w*[\\u0391-\\uFFE5]*]*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(Chs constraintAnnotation)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value.matches(reg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-测试自定义校验器"><a href="#7-3-测试自定义校验器" class="headerlink" title="7.3 测试自定义校验器"></a>7.3 测试自定义校验器</h4><p>现在需要一个控制器接口来测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;testChsValidator&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testChsValidator</span><span class="params">(<span class="meta">@Chs</span> <span class="meta">@RequestParam</span> String chsName)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求访问测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://localhost:8080/testChsValidator?chsName=888</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Tue, 18 Dec 2018 01:39:40 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;message&quot;: &quot;testChsValidator.chsName: 该字段需要纯中文&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 400; Time: 239ms; Content length: 48 bytes</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------</span><br><span class="line"></span><br><span class="line">POST http://localhost:8080/testChsValidator?chsName=你好</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Tue, 18 Dec 2018 01:40:11 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 44ms; Content length: 0 bytes</span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>OK，验证器的使用到这里基本完结，一般来说基础的可以适用大部分需求，但是我建议如果某个校验规则用的不多的话，就不大需要定义自定义校验器，如果用的比较多而且是通用的话，那么自定义的注解校验无疑会带来很多便捷。校验器适用的实现是 <code>Hibernate Validate</code> 所以如若需要查询资料可直接查询<code>Hibernate Validate</code> 相关的即可。 <a href="http://docs.jboss.org/hibernate/validator/4.2/reference/zh-CN/html_single/#validator-customconstraints-constraintannotation">Hibernate-Validate</a></p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 常用异常信息返回</title>
    <url>//spring/springboot-%E5%B8%B8%E7%94%A8%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF%E8%BF%94%E5%9B%9E/index.html</url>
    <content><![CDATA[<h1 id="springboot-web-常用异常信息返回"><a href="#springboot-web-常用异常信息返回" class="headerlink" title="springboot-web 常用异常信息返回"></a>springboot-web 常用异常信息返回</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>在日常的开发中，都会有多多少少的异常发生，如：不存在异常、参数异常等等。那这时候怎么向前端展示也是一个问题，通常的做法就是建立一个通用的数据返回类注入 <code>ResultDto</code> 然后存储是否顺利调用，数据，错误信息等信息。结合 <code>spring-boot-web</code> 的监听器，可以让我们尽量少的关注这些错误异常的发生，只要一句话或者一个注解【需要自己封装，使用 <code>aop</code> 】，就可以实现程序给我们的自动验证。 GitHub: <a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> <strong>示例代码：<code>web-exception-resp</code></strong></p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-mvn-新增-web-starter-的依赖"><a href="#1-mvn-新增-web-starter-的依赖" class="headerlink" title="1. mvn 新增 web-starter 的依赖"></a>1. <code>mvn</code> 新增 <code>web-starter</code> 的依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- 引入 web-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-准备一个标准输出类和一些异常"><a href="#2-准备一个标准输出类和一些异常" class="headerlink" title="2. 准备一个标准输出类和一些异常"></a>2. 准备一个标准输出类和一些异常</h3><p>标准数据响应类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultDto</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> success;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultDto</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.success = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultDto</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.success = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备了一些异常，一个基类，两个子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbsException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbsException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElementNotFoundException</span> <span class="keyword">extends</span> <span class="title class_">AbsException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ElementNotFoundException</span><span class="params">(String elementName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(elementName + <span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamInvalidException</span> <span class="keyword">extends</span> <span class="title class_">AbsException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParamInvalidException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;参数错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-资源和资源控制器"><a href="#3-资源和资源控制器" class="headerlink" title="3. 资源和资源控制器"></a>3. 资源和资源控制器</h3><p>我假设，<code>id</code> 超过 <code>100</code> 的就是参数错误了，如果 <code>id</code> 是个偶数就是资源不存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDto</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDto</span><span class="params">(Long id, String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDto</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultDto&lt;UserDto&gt; <span class="title function_">idOf</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParamInvalidException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (id % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ElementNotFoundException</span>(<span class="string">&quot;用户&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserDto</span> <span class="variable">userDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDto</span>(id, <span class="string">&quot;狗蛋&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultDto</span>&lt;&gt;(userDto);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-重点：使用-ControllerAdvice-监听控制器调用时出现的异常"><a href="#4-重点：使用-ControllerAdvice-监听控制器调用时出现的异常" class="headerlink" title="4. 重点：使用 ControllerAdvice 监听控制器调用时出现的异常"></a>4. 重点：使用 <code>ControllerAdvice</code> 监听控制器调用时出现的异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span> <span class="comment">// 指定这个类是一个监听类，用于监听不同异常输出结果</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndpointAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ElementNotFoundException.class)</span> <span class="comment">// 元素未找到异常</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_FOUND)</span> <span class="comment">// 返回 404</span></span><br><span class="line">    <span class="keyword">public</span> ResultDto&lt;Void&gt; <span class="title function_">elementNotFount</span><span class="params">(ElementNotFoundException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultDto</span>&lt;&gt;(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ParamInvalidException.class)</span> <span class="comment">// 参数错误异常</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span> <span class="comment">// 返回 400</span></span><br><span class="line">    <span class="keyword">public</span> ResultDto&lt;Void&gt; <span class="title function_">paramInvalid</span><span class="params">(ParamInvalidException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultDto</span>&lt;&gt;(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span> <span class="comment">// 未知错误</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span> <span class="comment">// 返回 500</span></span><br><span class="line">    <span class="keyword">public</span> ResultDto&lt;Void&gt; <span class="title function_">other</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultDto</span>&lt;&gt;(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-接口测试"><a href="#5-接口测试" class="headerlink" title="5. 接口测试"></a>5. 接口测试</h3><p>使用 <code>idea-2018</code> 的 <code>http</code> 测试工具请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8080/user/101</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Mon, 19 Nov 2018 16:45:16 GMT</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;success&quot;: false,</span><br><span class="line">  &quot;data&quot;: null,</span><br><span class="line">  &quot;message&quot;: &quot;参数错误&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 400; Time: 357ms; Content length: 46 bytes</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">GET http://localhost:8080/user/100</span><br><span class="line"></span><br><span class="line">HTTP/1.1 404 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Mon, 19 Nov 2018 16:46:46 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;success&quot;: false,</span><br><span class="line">  &quot;data&quot;: null,</span><br><span class="line">  &quot;message&quot;: &quot;用户不存在&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 404; Time: 41ms; Content length: 47 bytes</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">GET http://localhost:8080/user/99</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Mon, 19 Nov 2018 16:47:09 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;success&quot;: true,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: 99,</span><br><span class="line">    &quot;name&quot;: &quot;狗蛋&quot;,</span><br><span class="line">    &quot;age&quot;: 18</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;message&quot;: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 140ms; Content length: 69 bytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>其实 <code>spring-boot</code> 的构建大部分都是一致的，上面前几步基本和简单的 <code>web</code> 项目一致，最重要的一步就是监听到不同的异常，然后返回不同的状态码以及输出信息。 因为现在大部分项目都是微服务架构的，所以建议对自己公司内部整理一个基本的框架，包含有不同异常的，基本输出类的，以及这个 <code>ControllerAdvice</code> 的配置。在微服务中，只要对此框架进行依赖，即可拥有上面的功能。 常用状态码：</p>
<p>状态码</p>
<p>说明</p>
<p>200</p>
<p>请求成功（多用于 <code>get</code> 请求资源、<code>put</code> 更新资源）</p>
<p>201</p>
<p>创建成功（多用于 <code>post</code> 创建资源）</p>
<p>400</p>
<p>请求错误，参数格式不正确或者参数不符合验证要求</p>
<p>404</p>
<p>未找到，资源不存在或者</p>
<p>500</p>
<p>服务器出现问题</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 日志使用（LogBack）</title>
    <url>//spring/springboot-%E6%97%A5%E5%BF%97%E4%BD%BF%E7%94%A8%EF%BC%88logback%EF%BC%89/index.html</url>
    <content><![CDATA[<h1 id="springboot-日志使用（LogBack）"><a href="#springboot-日志使用（LogBack）" class="headerlink" title="springboot 日志使用（LogBack）"></a>springboot 日志使用（<code>LogBack</code>）</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>在 <code>web</code> 开发中，大大小小的 <code>bug</code> 是难以避免的。这时候，记录起来的日志就可以用来解决问题或者回滚。当然日志也可以用来查询用户操作的东西，以便甩锅（刚刚说完我就接到了一个产品被认为设置成 330 元的日志查询任务，他应该是 30 元以内的）。<br>Github地址：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> 项目演示：<code>globle-log-logback</code></p>
<a id="more"></a>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-mvn-依赖"><a href="#1-mvn-依赖" class="headerlink" title="1. mvn 依赖"></a>1. <code>mvn</code> 依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入 web-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>依然是引入这个万能的 <code>starter</code> 包即可（?）</p>
<h3 id="2-一个-user-实体类"><a href="#2-一个-user-实体类" class="headerlink" title="2. 一个 user 实体类"></a>2. 一个 <code>user</code> 实体类</h3><p>为了掩饰这里就简单的使用 <code>user</code> 这个业务来做吧。也不设置 <code>service</code> 和 <code>repo</code> 层了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDo</span><span class="params">(Long id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter &amp; setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-一个-user-控制器"><a href="#3-一个-user-控制器" class="headerlink" title="3. 一个 user 控制器"></a>3. 一个 <code>user</code> 控制器</h3><p>一个控制器，用于查询所有用户以及新增用户，将会在这里记录查询和新增的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;UserDo&gt; userDos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 slf4j 去获取日志操作实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(UserEndpoint.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserEndpoint</span><span class="params">()</span> &#123;</span><br><span class="line">        userDos.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>((<span class="type">long</span>) userDos.size(), <span class="string">&quot;Weidan&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserDo&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;查询了用户列表&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userDos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// info 记录操作</span></span><br><span class="line">        logger.info(<span class="string">&quot;新增一个用户，用户名称是&#123;&#125;&quot;</span>, name);</span><br><span class="line">        userDos.add(<span class="keyword">new</span> <span class="title class_">UserDo</span>((<span class="type">long</span>) userDos.size(), name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我建议使用 <code>slf4j</code> 去获取日志的实例，当然也不是建议啦，已经变成一种习惯了。</p>
<h3 id="4-请求访问"><a href="#4-请求访问" class="headerlink" title="4. 请求访问"></a>4. 请求访问</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-12-04 08:58:28.775  INFO 1068 --- [nio-8080-exec-1] c.l.s.logback.endpoint.UserEndpoint      : 查询了用户列表</span><br><span class="line">2018-12-04 08:58:30.823  INFO 1068 --- [nio-8080-exec-2] c.l.s.logback.endpoint.UserEndpoint      : 新增一个用户，用户名称是XiaoMing</span><br></pre></td></tr></table></figure>
<p>请求相对应的接口上面的日志将会被打印出来。（但还只是打印到控制台罢了）</p>
<h2 id="三-日志配置"><a href="#三-日志配置" class="headerlink" title="三. 日志配置"></a>三. 日志配置</h2><p>日志配置的名称约定为 <code>logback-spring.xml</code> 项目启动的时候 <code>spring</code> 将会去读取这个日志配置文件。</p>
<h3 id="1-指定日志存储位置"><a href="#1-指定日志存储位置" class="headerlink" title="1. 指定日志存储位置"></a>1. 指定日志存储位置</h3><p>像上面的范例，只是简单的在控制台记录日志，是不可行的，因为控制台的东西到了一定的大小会不断膨胀，也不利于日志的整理。所以我们一般使用每天生成一个文件的形式来记录日志。 示例中有完整的 <code>xml</code> 配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 文件保存日志的相关配置，同步 --&gt;</span><br><span class="line">&lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">    &lt;!-- 保存日志文件的路径 --&gt;</span><br><span class="line">    &lt;file&gt;$&#123;log.path&#125;/info.log&lt;/file&gt;</span><br><span class="line">    &lt;!-- 日志格式 --&gt;</span><br><span class="line">    &lt;encoder&gt;</span><br><span class="line">        &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/pattern&gt;</span><br><span class="line">    &lt;/encoder&gt;</span><br><span class="line">    &lt;!-- 过滤其它级别输出 --&gt;</span><br><span class="line">    &lt;!-- 循环政策：基于时间创建日志文件 --&gt;</span><br><span class="line">    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">        &lt;!-- 日志文件名格式 --&gt;</span><br><span class="line">        &lt;fileNamePattern&gt;$&#123;log.path&#125;/info-%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">    &lt;/rollingPolicy&gt;</span><br><span class="line">&lt;/appender&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-日志等级指定"><a href="#2-日志等级指定" class="headerlink" title="2. 日志等级指定"></a>2. 日志等级指定</h3><p>日志等级可以在 <code>application.yml</code> 指定：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">cn.liweidan.springboot.logback.endpoint.UserEndpoint:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
<p>比如我指定了用户控制器是 debug 等级的，然后在创建用户的时候加一个 debug 记录。那么请求用户创建就会记录下来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-12-04 09:35:11.027  INFO 1573 --- [nio-8080-exec-1] cn.liweidan.springboot.logback.endpoint.UserEndpoint : 新增一个用户，用户名称是XiaoMing</span><br><span class="line">2018-12-04 09:35:11.027 DEBUG 1573 --- [nio-8080-exec-1] cn.liweidan.springboot.logback.endpoint.UserEndpoint : 用户请求了用户创建接口</span><br></pre></td></tr></table></figure>
<h3 id="3-日志等级分组记录"><a href="#3-日志等级分组记录" class="headerlink" title="3. 日志等级分组记录"></a>3. 日志等级分组记录</h3><p>使用分组来简化 <code>log</code> 日志等级的配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span> </span><br><span class="line">  <span class="attr">group:</span> </span><br><span class="line">    <span class="attr">user:</span> <span class="string">cn.liweidan.springboot.logback.endpoint.UserEndpoint,</span> <span class="string">...其他controller</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-12-04 09:51:39.772  INFO 1709 --- [nio-8080-exec-1] cn.liweidan.springboot.logback.endpoint.UserEndpoint : 新增一个用户，用户名称是XiaoMing</span><br><span class="line">2018-12-04 09:51:39.772 DEBUG 1709 --- [nio-8080-exec-1] cn.liweidan.springboot.logback.endpoint.UserEndpoint : 用户请求了用户创建接口</span><br></pre></td></tr></table></figure>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p>日志的配置可以这样分类： 1. 输出样式定义的放在 <code>xml</code> 中 2. 输出等级的定义放在 <code>application.yml</code> 中</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 的打包与单独部署 部署到 tomcat</title>
    <url>//spring/springboot-%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E5%8D%95%E7%8B%AC%E9%83%A8%E7%BD%B2-%E9%83%A8%E7%BD%B2%E5%88%B0-tomcat/index.html</url>
    <content><![CDATA[<h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一.简述"></a>一.简述</h2><p>项目开发完成，就需要上线部署了，不然开发了那么久的代码也没什么存在的意义。 说到上线部署，那么以往的部署方式都是使用 <code>servlet</code> 项目，整合一些中间件使用，配置好配置文件。当需要上线部署的时候，就打包成 <code>war</code> 格式的压缩包，放在一个 <code>web</code> 容器中，然后启动容器，让容器去启动我们的项目。 但是在现在的 <code>springboot</code> 时代，官方已经很贴心的给我们提供一个内置的 <code>tomcat</code> 容器了，当然如果我们需要更换成其他的内置容器也完全可行。这样子能够让部署显得更加简单便捷，也不需要像以前一样，当需要多个微服务项目的时候，我们又不想一个 <code>tomcat</code> 运行多个项目让他互相影响，然而开启了很多 <code>tomcat</code> 容器，造成了资源的浪费。<code>springboot</code> 内置的容器咧，也经过官方修改让他更加吻合我们的项目了，我们完全可以在项目的配置文件中配置允许 <code>tomcat</code> 使用的资源信息。</p>
<h2 id="二-打包的两种方式"><a href="#二-打包的两种方式" class="headerlink" title="二.打包的两种方式"></a>二.打包的两种方式</h2><h3 id="（一）直接打包成jar包进行运行"><a href="#（一）直接打包成jar包进行运行" class="headerlink" title="（一）直接打包成jar包进行运行"></a>（一）直接打包成jar包进行运行</h3><p>直接打包 <code>jar</code> 包的方式就很简单了，我们可以使用命令行或者 <code>IDE</code> 去到我们项目的 <code>pom</code> 所在的目录。 运行 <code>mvn package</code>。稍等片刻，如果没有遇到错误，那么 <code>mvn</code> 会帮助我们在 <code>target</code> 文件夹生成一个 <code>.jar</code> 结尾的压缩包，这个就是我们项目的所有信息了。 我们只需要通过 <code>FTP</code> 或者其他的方式将这个项目包放在一个地方，然后使用 <code>java -jar xxx.jar</code> 的形式进行运行就可以启动项目了。过程还是十分轻量级的。 当然以上那种方式，运行完成以后，如果退出了，那么项目也就退出了，这并不是我们想看到的。所以在 <code>Linux</code> 下，我们可以使用 <code>nohup</code> 命令进行启动，将启动打印出来的日志定位到一个文件里面去，例如 <code>nohup java -jar xxx.jar &gt;xxx.out 2&gt;&amp;1 &amp;</code> 这样子，项目运行过程中的情况，会跟我们使用 <code>IDE</code> 一样把日志写到指定的文件里面去，当然如果不想要这个文件毕竟自己一般都实现了日志了的。那么可以使用这个命令，将日志导入到一个黑洞里面去：<code>nohup java -jar /xxx/xxx/xxx.jar &gt;/dev/null 2&gt;&amp;1 &amp;</code></p>
<h3 id="（二）打包成war包放入web容器运行"><a href="#（二）打包成war包放入web容器运行" class="headerlink" title="（二）打包成war包放入web容器运行"></a>（二）打包成war包放入web容器运行</h3><p>将项目打成 <code>jar</code> 包容易，毕竟是标配了，但是如果因为业务需要需要放进一个 <code>tomcat</code> 里面去运行的话，那么久需要反其道而行把一些配置给去掉。 <code>pom.xml</code> 需要加入一些配置：</p>
<a id="more"></a>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-tutorial&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;cn.liweidan.springboot&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定搜索不到 web.xml 不报错，继续构建 --&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;cn.liweidan.springboot.tomcat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;global-inner-tomcat&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定需要构建的格式 --&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 指定Tomcat只是编译时期加入，打包不加入 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>然后运行 <code>mvn package</code> 即可打包成 <code>war</code> 包了，这时将 <code>war</code> 包放入 <code>WEB</code> 容器即可运行起来。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot 监控 结合 spring-boot-admin 实现项目监控</title>
    <url>//spring/springboot-%E7%9B%91%E6%8E%A7-%E7%BB%93%E5%90%88-spring-boot-admin-%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7/index.html</url>
    <content><![CDATA[<h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>针对基于 <code>SpringBoot</code> 构建的微服务项目（当然也可以是普通项目），我们可以通过 <code>SpringBoot</code> 官方提供的 <code>spring-boot-starter-actuator</code> 套件进行监控。但是这个套件有个问题，就是只有 <code>HTTP</code> 接口可以调用，如果我们需要可视化的监控界面，则需要配置 <code>ELK</code> 或者其他的后台管理系统调用这个接口获取系统的信息。 当然，还有一种解决方案就是使用 <code>spring-boot-admin</code> 这个项目来监控我们的微服务系统，这是一个开源的项目，用起来还是蛮舒服的，所以在这里推荐大家可以用一用。 <code>spring-boot-admin</code> 有两种方式可以集成到系统中，一种是使用 <code>spring-cloud</code> 的服务发现，另外一种是直接配置监控的服务地址，这样 <code>admin</code> 服务即可接收到我们配置的系统的一些信息和快照了。 由于这里还不涉及 <code>spring-cloud</code> 所以这里先使用我们自己的服务集成 <code>admin-client</code> 的方式来集成系统监控。</p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="（一）-spring-boot-admin-服务端的搭建"><a href="#（一）-spring-boot-admin-服务端的搭建" class="headerlink" title="（一） spring-boot-admin 服务端的搭建"></a>（一） spring-boot-admin 服务端的搭建</h3><h4 id="1-mvn依赖："><a href="#1-mvn依赖：" class="headerlink" title="1.mvn依赖："></a>1.mvn依赖：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- 注意：admin-server的版本号要和spring-boot的版本号对应起来，不然会出现错误 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-启动器编写"><a href="#2-启动器编写" class="headerlink" title="2.启动器编写"></a>2.启动器编写</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminServerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(AdminServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-配置文件-application-yml"><a href="#3-配置文件-application-yml" class="headerlink" title="3.配置文件 application.yml"></a>3.配置文件 application.yml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>
<p>只配置了 <code>8081</code> 端口启动服务端，后面客户端需要用到这个端口，才能正确收集数据。</p>
<h2 id="（二）spring-boot-admin-客户端集成到-springboot-项目"><a href="#（二）spring-boot-admin-客户端集成到-springboot-项目" class="headerlink" title="（二）spring-boot-admin 客户端集成到 springboot 项目"></a>（二）spring-boot-admin 客户端集成到 springboot 项目</h2><h4 id="1-mvn依赖"><a href="#1-mvn依赖" class="headerlink" title="1.mvn依赖"></a>1.mvn依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-启动器编写-1"><a href="#2-启动器编写-1" class="headerlink" title="2.启动器编写"></a>2.启动器编写</h4><p>因为是在起步中，所以安全措施什么的，先不设置任何东西，后面需要整合的时候才做修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminClientApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SecurityPermitAllConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            http.authorizeRequests().anyRequest().permitAll()</span><br><span class="line">                    .and().csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(AdminClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-配置文件application-yml"><a href="#3-配置文件application-yml" class="headerlink" title="3.配置文件application.yml"></a>3.配置文件application.yml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">boot:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://localhost:8081/</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> [<span class="string">&#x27;*&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>同上，配置都是最简单的配置，整合起来先。暴露了所有安全相关的端口以及配置了一个 <code>admin-server</code> 的地址，让他可以发送相关信息给服务端。</p>
<h2 id="三-测试"><a href="#三-测试" class="headerlink" title="三. 测试"></a>三. 测试</h2><p>打开服务端的地址：<code>http://localhost:8081</code><br><img src="/images/springboot-%E7%9B%91%E6%8E%A7-%E7%BB%93%E5%90%88-spring-boot-admin-%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7.md/2.png"><br>可见，<code>spring-boot-admin</code> 已经显示了我们当前启动的系统的一些信息，包括 <code>jvm</code> 的信息，以及一些日志的情况，可以动态设置我们打印日志的一些等级等等。当然后面如果使用了 <code>spring-cloud</code> 的套件集成进来会更加的容易了。 </p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring-boot-admin</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud介绍</title>
    <url>//spring/springcloud%E4%BB%8B%E7%BB%8D/index.html</url>
    <content><![CDATA[<h2 id="微服务是什么"><a href="#微服务是什么" class="headerlink" title="微服务是什么"></a>微服务是什么</h2><h3 id="单体项目"><a href="#单体项目" class="headerlink" title="单体项目"></a>单体项目</h3><p>在互联网刚开始的年代，传统的单体项目，一般是一个服务器，对少量的用户足矣。这时候，开发一套系统，可以提供少量的(相比于现在)服务。并发性不大，服务器性能不需要太好都可以跑得好好的。这个时代我没有经历过。 </p>
<p><img src="/images/springcloud%E4%BB%8B%E7%BB%8D.md/0.png"></p>
<h3 id="单体项目分布式"><a href="#单体项目分布式" class="headerlink" title="单体项目分布式"></a>单体项目分布式</h3><p>互联网稍稍发展起来了，一台服务器好像支撑不大住。这时候，聪明的程序员们就说，如果一个系统撑不住，那就启动两个来为客户服务呀。所以架构就变成这样，用户，可以把请求落到两个随便一毛一样的系统上面，提供服务是一致的。这时候一般考虑 <code>sessionid</code> 的共享。<br><img src="/images/springcloud%E4%BB%8B%E7%BB%8D.md/1.png"></p>
<a id="more"></a>
<h3 id="初代前后端分离"><a href="#初代前后端分离" class="headerlink" title="初代前后端分离"></a>初代前后端分离</h3><p>下一个发展阶段，即很多企业发现，如果一台机器，需要做数据库操作，还需要做界面层的渲染，服务器的压力太大。这时候出现了初代前后端分离，后端访问数据库的速度可以使用 <code>redis</code> 加成，而前端项目，大部分是渲染成页面提供给用户。所以这时候的架构演变成下面：这种情况可以根据不同的需求进行拓展，拓展前端，拓展后端都还行。 </p>
<p><img src="/images/springcloud%E4%BB%8B%E7%BB%8D.md/2.png"></p>
<h3 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h3><p>很快，需求出现爆炸性的增长，后端服务器如果还是单体项目，无论是部署，拓展都显得特别笨重。如果后端服务需要新增一个实例，那么我们都需要手动重新配置前端服务。如果突然之间需要新增多个实例，那么程序猿将会累死累活。所以这时候，急需一个可以自治的生态系统，将拓展的事情交给程序去设定。 这时候，<code>Java</code> 界男神 <strong>Martin Fowler</strong> 提出了 <code>microservice</code> 架构(<a href="https://www.martinfowler.com/articles/microservices.html">原文链接</a>)。即我们将公司所在领域，按照一定的子域进行划分，每个子域自成一个小服务。此时，拓展就变得简单，我们可以给并发量大的服务拓展多几个服务，而并发小的，或者任务不重但是缺一不可的，单机或者少一点服务存在。而上一层路由层，通过网络与不同服务之间进行通讯，共同服务于用户。 而微服务还有另外一个元素，那就是自治能力、监控能力。打个比方，如果前端服务需要增加多台，系统可以自动发现，并将其加入”服务团队”中，快速的进入工作状态。 所以微服务架构急切需要一种，自带管理者，统一入口的软件架构。而在当今社会，常见的就有 <code>Dubbo</code> <code>SpringCloud</code> 以及 <code>SpringCloudAlibaba</code> 等一系列的生态框架出现。 那么架构现状，也发生了质的变化： </p>
<p><img src="/images/springcloud%E4%BB%8B%E7%BB%8D.md/4.png"></p>
<h3 id="最终前后端分离"><a href="#最终前后端分离" class="headerlink" title="最终前后端分离"></a>最终前后端分离</h3><p>正在此时，前端由于 <code>vue</code> <code>AngularJS</code> <code>react</code> 的兴起，也没闲住，也发生了剧烈的变化。<code>ES</code> (<code>JS</code> 的现代叫法)不再单纯的操作 <code>document</code> 而是将 <code>document</code> 交给框架，开发者只需要关注数据的变化即可，框架会自动根据数据的变化去修改 <code>document</code> 的展示。所以这时候，会出现前端直接分离出来，由前端开发者自己开发，自己编织架构，后端只提供数据服务的局面。走到这里，前端真正的独立出来，后端开发者不再需要编写 <code>MVC</code> 的页面。前端开发者后期维护也变得简单，因为一个前端项目修改不再需要前端和后端结对编程了。 </p>
<p><img src="/images/springcloud%E4%BB%8B%E7%BB%8D.md/5.png"></p>
<h3 id="微前端化"><a href="#微前端化" class="headerlink" title="微前端化"></a>微前端化</h3><p>由于业务量爆棚，前端也出现了后端的老路。然后前端也就走了后端的发展路线，一个前端再也支撑不住，所以前端也要分出来不同的业务团队，这时候，前端也就进行了微服务化。不同的业务有不同的模块，然后一个总视图进入前端，统领所有的业务服务模块。这块就不画出来了。</p>
<h2 id="SpringCloud是什么"><a href="#SpringCloud是什么" class="headerlink" title="SpringCloud是什么"></a>SpringCloud是什么</h2><p><code>SpringCloud</code> 是一系列套件的统称，不单单是一门技术框架。而这些套件，恰好是我们做微服务系统的时候，常常使用的套件，包含 <strong>注册中心</strong> <strong>配置中心</strong> <strong>路由器</strong> <strong>熔断器</strong> <strong>监控</strong> 等微服务所需要的框架。套件什么的，做好部署运维，那么就可以将精力集中在业务服务的开发。</p>
<h2 id="为什么选择SpringCloud"><a href="#为什么选择SpringCloud" class="headerlink" title="为什么选择SpringCloud"></a>为什么选择SpringCloud</h2><p>常见的面试题就是：为什么使用 <code>SpringBoot</code> ？ 标准答案：因为 <code>Spring</code> 官方提供了自动装配的规范，由第三方框架(<code>MyBatis</code> 等)去实现。然后版本号规约放置于 <code>SpringBoot</code> 的顶级父类里，这样当我们使用对应版本的 <code>SpringBoot</code> 的时候，依赖进来的需要使用的第三方框架也是框架官方提供的，兼容性不错的版本。 而恰恰好，<code>SpringCloud</code> 就是这样集成而来的，所以兼容性问题，并不需要关心太多。 当初选择这个框架，是因为我感觉上手简单，而且套件齐全。公司项目肯定想要稳定，拓展性好的框架。因为 <code>Spring</code> 框架让我放心，因为他是 <code>Spring</code> 公司的。其二，官方提供套件的合成，也不会出现有些不兼容的现象。因为 <code>SpringBoot</code> 的加成，统一的父类，放心的整合。 在快速做一个小服务也是十分的方便，只要把统一的配置放置于 <code>config-server</code> 我在开发新的业务服务的时候，不需要过多的关注他的配置的东西 (比起 <code>Spring</code> 时代的 <code>xml</code> 地狱简直不要太方便)</p>
<h2 id="SpringCloud常用组件"><a href="#SpringCloud常用组件" class="headerlink" title="SpringCloud常用组件"></a>SpringCloud常用组件</h2><p>微服务套件</p>
<p>推荐框架</p>
<p>作用</p>
<p>可替换框架</p>
<p>注册中心</p>
<p><code>Eureka</code></p>
<p>微服务系统的中心，可用于服务的注册以及服务之间的发现</p>
<p><code>ZooKeeper</code> <code>Consul</code></p>
<p>配置中心</p>
<p><code>ConfigService</code></p>
<p>业务服务的配置中心，将业务服务通用、系统配置放置于此，服务启动即可发现并应用配置</p>
<p><code>Apollo</code></p>
<p>路由器</p>
<p><code>Gateway</code></p>
<p>微服务生态总入口，需要请求服务只能通过于此。相对的，权限控制、登陆拦截都落在此处。</p>
<p><code>Nginx</code> <code>Nodejs自开发</code></p>
<p>熔断器</p>
<p><code>Hystrix</code></p>
<p>熔断器，用于熔断服务的连接。如果服务负载量过大、频繁报错，将会像保险丝一样断开服务，让他休息一会儿再起来</p>
<p>-</p>
<p>熔断监控</p>
<p><code>Turbine</code></p>
<p>熔断器的监控视图，用于监控熔断器的情况，以便人为干涉</p>
<p>-</p>
<p>消息通知</p>
<p><code>Stream</code></p>
<p>用于服务之间的消息通知，进行封装后可以不需要关注分布式锁(谁来处理的问题)</p>
<p>-</p>
<p>契约开发</p>
<p><code>Contract</code></p>
<p>微服务中，进行 <code>TDD</code> 开发的模拟第三方服务返回数据的套件</p>
<p>-</p>
<p>老夫认为，项目刚刚初始，<code>Eureka</code> <code>Config</code> <code>Gateway</code> <code>Stream</code> 都是初始就要考虑的必备品。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud服务使用ProtolBuffer编码进行传值</title>
    <url>//spring/springcloud%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8protolbuffer%E7%BC%96%E7%A0%81%E8%BF%9B%E8%A1%8C%E4%BC%A0%E5%80%BC/index.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道，使用 <code>SpringCloud</code> 技术栈，上下游传值的方式一般使用 <code>form</code> 表单或者使用 <code>JSON</code> 格式进行传值。但是我感觉，我们内部服务进行传值的时候，还使用这两种类型的方式，显得有点重。所以在查询了 <code>Java</code> 界以及其他语言序列化对象的时候，查询到了几个常用的序列化工具：<code>kryo</code> <code>Hession</code> <code>JSON</code> <code>XML</code> <code>Protocol Buffers</code> <code>JSON</code> <code>XML</code> 就不必多言，使用 <code>Java</code> 语言开发的基本都知道。 <code>kryo</code> 效率高，使用二进制文件进行传递，但是有个缺点就是不能跨语言。 <code>Hession</code> 效率稍稍差一点。 那么剩下的 <code>Protocol Buffers</code> 就是能够弥补上面的缺点，并且带来一个新的缺点：需要编写静态的 <code>.proto</code> 文件使其项目启动的时候，静态编译映射规格。不过速度高，跨语言，这点缺陷我还是可以接受的。 基本确定方向以后，那么本文就从怎么使用 <code>.proto</code> 将其整合到我们常用的 <code>SpringMVC</code> 中去，使其序列化和反序列化的过程对我们业务开发不可见。</p>
<h2 id="ProtocolBuffers入门"><a href="#ProtocolBuffers入门" class="headerlink" title="ProtocolBuffers入门"></a>ProtocolBuffers入门</h2><p><code>ProtocolBuffers</code> 规则是这样的：编辑 <code>.proto</code> 文件，使用编译器编译不同语言的 <code>ClassObject</code> 。有点类似于 <code>Thift</code> 。所以一开始我们需要的是 <code>ProtocolBuffer编译器</code> 。</p>
<h3 id="下载ProtocolBuffer编译器"><a href="#下载ProtocolBuffer编译器" class="headerlink" title="下载ProtocolBuffer编译器"></a>下载ProtocolBuffer编译器</h3><p><a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.7.1">下载地址</a> 根据自己所使用的系统版本，下载对应的编译器。 下载完成以后，进入 <code>protoc-3.7.1-osx-x86_64/bin</code> 运行 <code>./protoc --version</code> 如果能够打印版本号则说明安装成功。</p>
<h3 id="编写简单的proto文件"><a href="#编写简单的proto文件" class="headerlink" title="编写简单的proto文件"></a>编写简单的proto文件</h3><p>现在开始尝试生成类似于以下 <code>Java</code> 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="comment">// 省略 getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>根据谷歌官方提供的 <a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">规范文档</a> 进行编写：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;<span class="comment">// 类似于xml声明一样放于第一行，指定编译源protobuf文件的版本号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tutorial;</span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.microorder.test.dto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// required 表示构造的时候这个值必须传递</span></span><br><span class="line">    <span class="comment">// = 后面的值需要每个属性都是唯一的</span></span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>后面的 id 号是protocolBuffer用来编码的方式，1-15是使用1个字节，16-2047是使用两个字节。 1-15常用来定义经常发生变化的元素，在使用的时候记得需要保留一下以供后面的属性加入。 19000-19999 不应该使用，因为这个是框架内部使用的。</p>
</blockquote>
<h3 id="编译生成对象"><a href="#编译生成对象" class="headerlink" title="编译生成对象"></a>编译生成对象</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./protoc -I../proto/ --java_out=./ ../proto/user.proto</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令开头    proto文件夹      生成放的文件夹       源文件</span></span><br></pre></td></tr></table></figure>
<p>生成的类就不打开了，看不懂… 生成对象先放入项目中，后面使用。</p>
<h2 id="配置SpringMVC"><a href="#配置SpringMVC" class="headerlink" title="配置SpringMVC"></a>配置SpringMVC</h2><h3 id="开发MessageConverter"><a href="#开发MessageConverter" class="headerlink" title="开发MessageConverter"></a>开发MessageConverter</h3><blockquote>
<p>SpringMVC 官方自带了 ProtocolBuffer 的消息转换器，不过我写都写了，放上来吧… 官方的名字和我取的名字是一样的，如果需要使用官方的，直接导入官方包即可。 调用头使用 x-protobuf 即可接收，不过还是需要在配置中配置，因为默认没有启用。</p>
</blockquote>
<p>我们知道开发 <code>SpringMVC</code> 的消息转换器需要继承 <code>AbstractHttpMessageConverter</code> 传递类型的泛型。 然后使用配置类将此转换器加入 <code>SpringMVC</code> 的转换器列表中即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.protobuf.GeneratedMessageV3;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpInputMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpOutputMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.AbstractHttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageNotReadableException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageNotWritableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：将SpringMVC接收和输出对象转换成protobuf格式的转换器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-04-15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtobufHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHttpMessageConverter</span>&lt;GeneratedMessageV3&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ProtobufHttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//设置该转换器支持的媒体类型</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">MediaType</span>(<span class="string">&quot;application&quot;</span>, <span class="string">&quot;protobuf&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 支持的对象类型.</span></span><br><span class="line"><span class="comment">   * 如果一个对象的父类是GeneratedMessageV3，就执行该转换器</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> assignableFrom</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; assignableFrom)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> GeneratedMessageV3.class.isAssignableFrom(assignableFrom);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> GeneratedMessageV3 <span class="title function_">readInternal</span><span class="params">(</span></span><br><span class="line"><span class="params">          Class&lt;? extends GeneratedMessageV3&gt; genMsgClazz, HttpInputMessage httpInputMessage)</span></span><br><span class="line">          <span class="keyword">throws</span> IOException, HttpMessageNotReadableException &#123;</span><br><span class="line">    Method parseMethod;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//利用反射机制获得parseFrom方法</span></span><br><span class="line">      parseMethod = genMsgClazz.getDeclaredMethod(<span class="string">&quot;parseFrom&quot;</span>, InputStream.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException  NoSuchMethodException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//调用parseFrom方法从InputStream中反序列化PB对象</span></span><br><span class="line">      <span class="keyword">return</span> (GeneratedMessageV3) parseMethod.invoke(genMsgClazz, httpInputMessage.getBody());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException  IllegalAccessException  InvocationTargetException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeInternal</span><span class="params">(</span></span><br><span class="line"><span class="params">          GeneratedMessageV3 generatedMessageV3, HttpOutputMessage httpOutputMessage)</span></span><br><span class="line">          <span class="keyword">throws</span> IOException, HttpMessageNotWritableException &#123;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> httpOutputMessage.getBody();</span><br><span class="line">    generatedMessageV3.writeTo(outputStream);</span><br><span class="line">    outputStream.flush();</span><br><span class="line">    outputStream.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码来源于 CSDN 某个博主，因为记录到笔记，原地址没了…</p>
</blockquote>
<h3 id="配置到MVC中"><a href="#配置到MVC中" class="headerlink" title="配置到MVC中"></a>配置到MVC中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    converters.add(<span class="keyword">new</span> <span class="title class_">ProtobufHttpMessageConverter</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开发接口层"><a href="#开发接口层" class="headerlink" title="开发接口层"></a>开发接口层</h3><p>接口层我放了两个接口，目的是为了测试 <code>ProtocolBuffer</code> 是否真的比 <code>JSON</code> 优秀</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 protocolBuffer 传递</span></span><br><span class="line">  <span class="meta">@GetMapping</span></span><br><span class="line">  <span class="keyword">public</span> User.Person <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    User.<span class="type">Person</span> <span class="variable">build</span> <span class="operator">=</span> User.Person.newBuilder().setId(<span class="number">222</span>).setName(<span class="string">&quot;23232&quot;</span>).build();</span><br><span class="line">    System.out.println(Arrays.toString(build.toByteArray()));</span><br><span class="line">    <span class="keyword">return</span> build;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 JSON 传递</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;json&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> PersonJson <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PersonJson</span>(<span class="string">&quot;ssss&quot;</span>, <span class="number">22</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口调用测试"><a href="#接口调用测试" class="headerlink" title="接口调用测试"></a>接口调用测试</h2><p>测试方式是粗略测试，在本机运行。 测试方式是：调用 <code>1_000_000</code> 此接口，除去前面 <code>10_000</code> 此预热的结果，使用后面 <code>990_000</code> 计算均值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JSON 方式</span></span><br><span class="line">List&lt;Long&gt; timeList = Lists.newArrayListWithCapacity(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  <span class="type">URL</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/json&quot;</span>);</span><br><span class="line">  <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) target.openConnection();</span><br><span class="line">  conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">  conn.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">  conn.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> conn.getInputStream();</span><br><span class="line">  <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  inputStream.read(b);</span><br><span class="line">  inputStream.close();</span><br><span class="line">  <span class="type">PersonJson</span> <span class="variable">personJson</span> <span class="operator">=</span> JsonMapper.defaultMapper().fromJson(<span class="keyword">new</span> <span class="title class_">String</span>(b), PersonJson.class);</span><br><span class="line">  timeList.add(System.nanoTime() - start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10000</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">aLong</span> <span class="operator">=</span> timeList.get(i);</span><br><span class="line">  sum += aLong;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;平均时间：&quot;</span> + (sum / <span class="number">990000</span>));</span><br><span class="line"><span class="comment">// 平均时间：825082 0.825082毫秒(ms)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtocolBuffer方式</span></span><br><span class="line">List&lt;Long&gt; timeList = Lists.newArrayListWithCapacity(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  <span class="type">URL</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/&quot;</span>);</span><br><span class="line">  <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) target.openConnection();</span><br><span class="line">  conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">  conn.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/protobuf&quot;</span>);</span><br><span class="line">  conn.setRequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/protobuf&quot;</span>);</span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> conn.getInputStream();</span><br><span class="line">  User.<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> User.Person.parseFrom(inputStream);</span><br><span class="line">  timeList.add(System.nanoTime() - start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10000</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">aLong</span> <span class="operator">=</span> timeList.get(i);</span><br><span class="line">  sum += aLong;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;平均时间：&quot;</span> + (sum / <span class="number">990000</span>));</span><br><span class="line"><span class="comment">// 平均时间：316688 0.316688毫秒(ms)</span></span><br></pre></td></tr></table></figure>
<p>结果很明显了，<code>ProtocolBuffer</code> 方式调用使用的时间更短。</p>
<h2 id="Feign整合ProtocolBuffer"><a href="#Feign整合ProtocolBuffer" class="headerlink" title="Feign整合ProtocolBuffer"></a>Feign整合ProtocolBuffer</h2><p>用过 <code>SpringCloud</code> 基本都知道 <code>OpenFeign</code> 这个项目，此项目是可以通过编写接口的方式，让框架封装我们需要调用的 <code>HTTP</code> 请求，然后经过一系列的序列化反序列化从而取出我们需要的结果的一个开源框架。 那么上面我们已经将 <code>SpringMVC</code> 封装 <code>ProtocolBuffer</code> 数据输出，那么 <code>Feign</code> 也需要做相对应的配置使其支持。</p>
<h3 id="配置Encoder和Decoder"><a href="#配置Encoder和Decoder" class="headerlink" title="配置Encoder和Decoder"></a>配置Encoder和Decoder</h3><p><code>OpenFeign</code> 其实底层就是 <code>HttpClient</code> 去进行封装，那么要解码和编码数据就是通过修改 <code>Feign</code> 底层的解码器和编码器即可。 那么在项目中配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果使用了RestTemplate，进行以下配置.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    List&lt;HttpMessageConverter&lt;?&gt;&gt; of = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HttpMessageConverter&lt;?&gt;&gt;();</span><br><span class="line">    of.add(<span class="keyword">new</span> <span class="title class_">ProtobufHttpMessageConverter</span>());</span><br><span class="line">    restTemplate.setMessageConverters(of);</span><br><span class="line">    <span class="keyword">return</span> restTemplate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Decoder <span class="title function_">protolDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntityDecoder</span>(<span class="keyword">new</span> <span class="title class_">SpringDecoder</span>(() -&gt; <span class="keyword">new</span> <span class="title class_">HttpMessageConverters</span>(<span class="keyword">new</span> <span class="title class_">ProtobufHttpMessageConverter</span>())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Encoder <span class="title function_">protolEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringEncoder</span>(() -&gt; <span class="keyword">new</span> <span class="title class_">HttpMessageConverters</span>(<span class="keyword">new</span> <span class="title class_">ProtobufHttpMessageConverter</span>()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UserFeign"><a href="#UserFeign" class="headerlink" title="UserFeign"></a>UserFeign</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(url = &quot;http://localhost:8080/&quot;, name = &quot;userFeign&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserFeign</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span></span><br><span class="line">  User.Person <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> User.Person param)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserFeignTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserFeign userFeign;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    User.<span class="type">Person</span> <span class="variable">test</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/&quot;</span>, User.Person.class);</span><br><span class="line">    assertNotNull(<span class="string">&quot;传递对象不能为空&quot;</span>, test);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFeign</span><span class="params">()</span> &#123;</span><br><span class="line">    User.<span class="type">Person</span> <span class="variable">test</span> <span class="operator">=</span> userFeign.test();</span><br><span class="line">    assertNotNull(<span class="string">&quot;传递对象不能为空&quot;</span>, test);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line">    User.<span class="type">Person</span> <span class="variable">weoda</span> <span class="operator">=</span> User.Person.newBuilder().setName(<span class="string">&quot;Weoda&quot;</span>).setId(<span class="number">2000</span>).build();</span><br><span class="line">    userFeign.add(weoda);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><p><a href="/images/springcloud%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8protolbuffer%E7%BC%96%E7%A0%81%E8%BF%9B%E8%A1%8C%E4%BC%A0%E5%80%BC.md/10.com/WeidanLi/spring-cloud-with-protol">示例代码</a> 项目没有特别规范，随便写写 调用测试写在了 <code>com.microorder.test.Config#main</code> <code>feign</code> 测试放在 <code>test</code> 包下，先启动项目再测试 <code>feign</code> </p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring-cloud</tag>
        <tag>feign</tag>
        <tag>protolbuffer</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBootJpa 与 DDD 开发</title>
    <url>//spring/springbootjpa-%E4%B8%8E-ddd-%E5%BC%80%E5%8F%91/index.html</url>
    <content><![CDATA[<h1 id="SpringBootJpa-与-DDD-开发"><a href="#SpringBootJpa-与-DDD-开发" class="headerlink" title="SpringBootJpa 与 DDD 开发"></a>SpringBootJpa 与 DDD 开发</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p><code>DDD</code> 开发，相信开发几年的工程师一般都会知道这个名词了。还原面向对象的本质，用代码诠释业务。由 <code>Eric Evans</code> 提出但是响应起来并不是很简单。 知道 <code>DDD</code> 的都知道，使用集合型 <code>orm</code> 框架来开发会更加觉得顺手，<code>mybatis</code> 就不大合适了。所以 <code>Spring</code> 公司对 <code>jpa</code> 加入了一些支持。 <code>DDD</code> 几句话并不能讲清楚，这里就只是提供简单 <code>Demo</code> 和思路。<br>GitHub地址：<a href="https://github.com/WeidanLi/spring-boot-tutorial">https://github.com/WeidanLi/spring-boot-tutorial</a> <strong>示例代码：spring-boot-data-jpa-with-ddd</strong></p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-设定情景"><a href="#1-设定情景" class="headerlink" title="1. 设定情景"></a>1. 设定情景</h3><p>首先假定一个订单只能下单一个产品。（如果需要多产品的，需要设计订单主体信息和订单详情信息） 首先设定要开发一个下单的接口，我们下单的时候，订单都会存储一些产品的基本信息。 那么这时候一个订单就是一个实体 <code>Entity</code> （与 <code>jpa</code> 的注解不谋而合），产品信息就是一个 <code>ValueObject</code>（<code>ValueObject</code> 一般没有无参构造器，也没有 <code>setter</code>，修改信息都需要进行整体替换） ，订单一旦生成就不能修改产品的基本信息，所以订单实体不能有产品信息的 <code>setter</code>。 OK，业务需求出来了，那么设计订单的时候一般在数据库的表现是订单和产品信息放在一起。</p>
<a id="more"></a>
<h3 id="2-mvn依赖"><a href="#2-mvn依赖" class="headerlink" title="2. mvn依赖"></a>2. mvn依赖</h3><p>跟简单实用的示例一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- 引入 jpa 注解 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- mysql依赖 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 为了方便测试加入端口检测包 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- SpringBoot 测试 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.h2database&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;h2&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-设计订单Entity"><a href="#2-设计订单Entity" class="headerlink" title="2. 设计订单Entity"></a>2. 设计订单Entity</h3><p>订单实体一般有主体信息，订单状态，购买信息以及订单状态。所以我设计了一个聚合还有三个 <code>ValueObject</code> 订单实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;order_db&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_id&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_no&quot;,length = 100)</span></span><br><span class="line">    <span class="keyword">private</span> String orderNo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_total_amount&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long totalAccount;<span class="comment">// 总价格 单位分</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span> <span class="comment">// 指定这个类是同个数据库表，但是把属性抽取到同一个对象里面去</span></span><br><span class="line">    <span class="keyword">private</span> ProductInfoVb productInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">private</span> BuyInfoVb buyInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">private</span> OrderStatus orderStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带参构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderNo 订单号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> productInfo 产品信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderEntity</span><span class="params">(String orderNo, ProductInfoVb productInfo, BuyInfoVb buyInfo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderNo = orderNo;</span><br><span class="line">        <span class="built_in">this</span>.productInfo = productInfo;</span><br><span class="line">        <span class="built_in">this</span>.totalAccount = buyInfo.getQuantity() * productInfo.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.orderStatus = <span class="keyword">new</span> <span class="title class_">OrderStatus</span>(<span class="string">&quot;WAIT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderEntity</span><span class="params">(String orderNo, ProductInfoVb productInfo, <span class="type">long</span> prodId, <span class="type">long</span> quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderNo = orderNo;</span><br><span class="line">        <span class="built_in">this</span>.productInfo = productInfo;</span><br><span class="line">        <span class="built_in">this</span>.buyInfo = <span class="keyword">new</span> <span class="title class_">BuyInfoVb</span>(prodId, quantity);</span><br><span class="line">        <span class="built_in">this</span>.totalAccount = buyInfo.getQuantity() * productInfo.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造器，以便 hibernate 可以创建实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">OrderEntity</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getTotalAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalAccount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductInfoVb <span class="title function_">getProductInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> productInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OrderStatus <span class="title function_">getOrderStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderStatus</span><span class="params">(OrderStatus orderStatus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderStatus = orderStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三个 <code>value object</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductInfoVb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_product_name&quot;, length = 150)</span></span><br><span class="line">    <span class="keyword">private</span> String prodName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_product_price&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProductInfoVb</span><span class="params">(String prodName, Long price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prodName = prodName;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ProductInfoVb</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProdName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStatus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_status&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String orderStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderStatus</span><span class="params">(String orderStatus)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderStatus = orderStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">OrderStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyInfoVb</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_product_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long prodId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;order_product_quantity&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long quantity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BuyInfoVb</span><span class="params">(Long prodId, Long quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.prodId = prodId;</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">BuyInfoVb</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getProdId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prodId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getQuantity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-订单仓库"><a href="#3-订单仓库" class="headerlink" title="3. 订单仓库"></a>3. 订单仓库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;OrderEntity, Long&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-订单业务层和产品业务层"><a href="#4-订单业务层和产品业务层" class="headerlink" title="4. 订单业务层和产品业务层"></a>4. 订单业务层和产品业务层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProductService productService;</span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(ProductService productService,</span></span><br><span class="line"><span class="params">                        OrderRepository orderRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.productService = productService;</span><br><span class="line">        <span class="built_in">this</span>.orderRepository = orderRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OrderEntity <span class="title function_">create</span><span class="params">(Long prodId, Long quantity)</span> &#123;</span><br><span class="line">        <span class="type">ProductInfoVb</span> <span class="variable">productInfoVb</span> <span class="operator">=</span> productService.idOf(prodId);</span><br><span class="line">        <span class="type">OrderEntity</span> <span class="variable">orderEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderEntity</span>(UUID.randomUUID().toString(), productInfoVb, prodId, quantity);</span><br><span class="line">        orderRepository.save(orderEntity);</span><br><span class="line">        <span class="keyword">return</span> orderEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderEntity&gt; <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrder</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">OrderEntity</span> <span class="variable">orderEntity</span> <span class="operator">=</span> orderRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">        orderEntity.setOrderStatus(<span class="keyword">new</span> <span class="title class_">OrderStatus</span>(<span class="string">&quot;PAY_SUCCESS&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其实产品业务层基本上是连接第三方服务获取信息，</span></span><br><span class="line"><span class="comment">// 封装成本服务所需要的对象</span></span><br><span class="line"><span class="comment">// 是工厂类和防污层</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ProductInfoVb <span class="title function_">idOf</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductInfoVb</span>(<span class="string">&quot;iMac&quot;</span>, <span class="number">12000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-订单接口"><a href="#5-订单接口" class="headerlink" title="5. 订单接口"></a>5. 订单接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderEndpoint</span><span class="params">(OrderService orderService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderService = orderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(<span class="meta">@RequestParam(&quot;prodId&quot;)</span> Long prodId, <span class="meta">@RequestParam(&quot;quantity&quot;)</span> Long quantity)</span> &#123;</span><br><span class="line">        orderService.create(prodId, quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderEntity&gt; <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrder</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        orderService.payOrder(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-接口测试"><a href="#6-接口测试" class="headerlink" title="6. 接口测试"></a>6. 接口测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个订单</span><br><span class="line">POST http://127.0.0.1:8080?prodId=100&amp;quantity=2</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Wed, 19 Dec 2018 06:18:49 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 238ms; Content length: 0 bytes</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"># 查询所有订单</span><br><span class="line">GET http://127.0.0.1:8080</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Wed, 19 Dec 2018 06:19:48 GMT</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;orderNo&quot;: &quot;9a96a1f9-88a7-4d64-a816-42ea57de09ab&quot;,</span><br><span class="line">    &quot;totalAccount&quot;: 24000,</span><br><span class="line">    &quot;productInfo&quot;: &#123;</span><br><span class="line">      &quot;prodName&quot;: &quot;iMac&quot;,</span><br><span class="line">      &quot;price&quot;: 12000</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;orderStatus&quot;: &#123;</span><br><span class="line">      &quot;orderStatus&quot;: &quot;WAIT&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 135ms; Content length: 165 bytes</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"># 支付订单</span><br><span class="line">POST http://127.0.0.1:8080/1/</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Wed, 19 Dec 2018 06:20:25 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 78ms; Content length: 0 bytes</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"># 重新查询所有订单</span><br><span class="line">GET http://127.0.0.1:8080</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Wed, 19 Dec 2018 06:20:48 GMT</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;orderNo&quot;: &quot;9a96a1f9-88a7-4d64-a816-42ea57de09ab&quot;,</span><br><span class="line">    &quot;totalAccount&quot;: 24000,</span><br><span class="line">    &quot;productInfo&quot;: &#123;</span><br><span class="line">      &quot;prodName&quot;: &quot;iMac&quot;,</span><br><span class="line">      &quot;price&quot;: 12000</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;orderStatus&quot;: &#123;</span><br><span class="line">      &quot;orderStatus&quot;: &quot;PAY_SUCCESS&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 50ms; Content length: 172 bytes</span><br></pre></td></tr></table></figure>
<h3 id="7-仓库事件通知"><a href="#7-仓库事件通知" class="headerlink" title="7. 仓库事件通知"></a>7. 仓库事件通知</h3><p>一般我们使用 <code>Repository</code> 都是使用在聚合上，在 <code>DDD</code> 模型中，当聚合发生变化的时候，都会发送事件。 所以我们可以在 <code>Entity</code> 类上使用 <code>@DomainEvents</code> 和 <code>@AfterDomainEventPublication</code> 来发送事件。 但是这里有个问题是，当我们更新 <code>Entity</code> 的时候，也需要去调用 <code>save()</code> 方法，不调用不会发送事件。 所以，也许某些业务自己手动发布事件会更好，简单的增删查改就可以使用这个。</p>
<h4 id="7-1-在Entity新增要发布的事件"><a href="#7-1-在Entity新增要发布的事件" class="headerlink" title="7.1 在Entity新增要发布的事件"></a>7.1 在Entity新增要发布的事件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;order_db&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DomainEvents</span> <span class="comment">// 发布事件</span></span><br><span class="line">    Collection&lt;Object&gt; <span class="title function_">domainEvents</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Object&gt; orderCreateds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (orderStatus.getOrderStatus().equals(<span class="string">&quot;WAIT&quot;</span>)) &#123;</span><br><span class="line">            orderCreateds.add(<span class="keyword">new</span> <span class="title class_">OrderCreated</span>(orderNo));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderStatus.getOrderStatus().equals(<span class="string">&quot;PAY_SUCCESS&quot;</span>)) &#123;</span><br><span class="line">            orderCreateds.add(<span class="keyword">new</span> <span class="title class_">OrderPaied</span>(orderNo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orderCreateds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterDomainEventPublication</span> <span class="comment">// 发布完事件进行清理(如果需要)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">callbackMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EventsPublished...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件对象（写的比较简单）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCreated</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderNo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCreated</span><span class="params">(String orderNo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderNo = orderNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-业务层监听事件："><a href="#7-2-业务层监听事件：" class="headerlink" title="7.2 业务层监听事件："></a>7.2 业务层监听事件：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听不同事件，Spring 会根据事件对象去调用相应的方法</span></span><br><span class="line"><span class="comment">     * 如果事件跟当前业务无太大关系(比如统计什么的） 这个方法可以设置 <span class="doctag">@Async</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> orderCreated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TransactionalEventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderCreated</span><span class="params">(OrderCreated orderCreated)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单被创建, 单号: &quot;</span> + orderCreated.getOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TransactionalEventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderPaied</span><span class="params">(OrderPaied orderPaied)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订单被支付, 单号: &quot;</span> + orderPaied.getOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-调用测试"><a href="#7-3-调用测试" class="headerlink" title="7.3 调用测试"></a>7.3 调用测试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">2018-12-19 15:12:42.835  INFO 60193 --- [on(2)-127.0.0.1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 7 ms</span><br><span class="line">Hibernate: insert into order_db (order_product_id, order_product_quantity, order_no, order_status, order_product_price, order_product_name, order_total_amount) values (?, ?, ?, ?, ?, ?, ?)</span><br><span class="line">EventsPublished...</span><br><span class="line">订单被创建, 单号: a5daff61-a270-407d-a3f3-623af061669d</span><br><span class="line">Hibernate: select orderentit0_.order_id as order_id1_0_0_, orderentit0_.order_product_id as order_pr2_0_0_, orderentit0_.order_product_quantity as order_pr3_0_0_, orderentit0_.order_no as order_no4_0_0_, orderentit0_.order_status as order_st5_0_0_, orderentit0_.order_product_price as order_pr6_0_0_, orderentit0_.order_product_name as order_pr7_0_0_, orderentit0_.order_total_amount as order_to8_0_0_ from order_db orderentit0_ where orderentit0_.order_id=?</span><br><span class="line">EventsPublished...</span><br><span class="line">Hibernate: update order_db set order_product_id=?, order_product_quantity=?, order_no=?, order_status=?, order_product_price=?, order_product_name=?, order_total_amount=? where order_id=?</span><br><span class="line">订单被支付, 单号: a5daff61-a270-407d-a3f3-623af061669d</span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><ol>
<li> 每个更新都需要手动调用 <code>save</code> 才会发布事件</li>
<li> 针对的业务实体，该事件发布显得无力</li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot与mybatis，配合 tkmybatis/PageHelper 数据读取</title>
    <url>//spring/springboot%E4%B8%8Emybatis%EF%BC%8C%E9%85%8D%E5%90%88-tkmybatis-pagehelper-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96/index.html</url>
    <content><![CDATA[<h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p><code>MyBatis</code> 是一个简单粗暴的 <code>orm</code> 框架，与 <code>hibernate</code> 相比起来，速度要快一点，封装也要少一点。如果要说封装程度的话，那就是对查询、返回结果的过程进行封装。 <code>SpringBoot</code> 只要简单的使用 <code>MyBatis</code> 官方提供的 <code>starter</code> ，稍微配置下就可以使用了。</p>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="一-集成-MyBatis"><a href="#一-集成-MyBatis" class="headerlink" title="(一) 集成 MyBatis"></a>(一) 集成 MyBatis</h3><h4 id="1-mvn依赖"><a href="#1-mvn依赖" class="headerlink" title="1. mvn依赖"></a>1. mvn依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;!-- 让 maven 把 mybatis 的 xml 拷贝到 classes --&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**.*&lt;/include&gt;</span><br><span class="line">                &lt;include&gt;**/**.*&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-用户类和仓库"><a href="#2-用户类和仓库" class="headerlink" title="2. 用户类和仓库"></a>2. 用户类和仓库</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 用户数据库映射类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span> <span class="comment">// 使用注解让 SpringBoot 读取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    UserDo <span class="title function_">selectUserById</span><span class="params">(<span class="meta">@Param(&quot;userUuid&quot;)</span> String uuid)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(UserDo userDo)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;UserDo&gt; <span class="title function_">selectAllUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-SpringBoot配置"><a href="#3-SpringBoot配置" class="headerlink" title="3. SpringBoot配置"></a>3. SpringBoot配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-boot-data-jpa</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_data?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/dbo-mapper/*.xml</span></span><br></pre></td></tr></table></figure>
<p>连接的是本地数据库，需要创建表和库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mybatis_data.user_db</span><br><span class="line">(</span><br><span class="line">    user_uuid <span class="type">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    user_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    user_id <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    user_salary <span class="type">bigint</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> user_db_user_uuid_uindex</span><br><span class="line">        <span class="keyword">unique</span> (user_uuid)</span><br><span class="line">)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mybatis_data.user_db</span><br><span class="line">    <span class="keyword">add</span> <span class="keyword">primary</span> key (user_uuid)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h4 id="3-接口层"><a href="#3-接口层" class="headerlink" title="3. 接口层"></a>3. 接口层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserEndpoint</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserDo&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectAllUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> &#123;</span><br><span class="line">        userDo.setUuid(UUID.randomUUID().toString());</span><br><span class="line">        userMapper.addUser(userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">selectByUId</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectUserById(uid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST http://127.0.0.1:8080/user</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;gousheng&quot;,</span><br><span class="line">  &quot;salary&quot;: 1000,</span><br><span class="line">  &quot;id&quot;: &quot;44672938219&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Length: 0</span><br><span class="line">Date: Thu, 27 Dec 2018 11:38:09 GMT</span><br><span class="line"></span><br><span class="line">&lt;Response body is empty&gt;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 298ms; Content length: 0 bytes</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">GET http://127.0.0.1:8080/user</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, 27 Dec 2018 11:38:42 GMT</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;uuid&quot;: &quot;d2ae789c-1e95-443c-9c5b-2501d983c538&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;gousheng&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;44672938219&quot;,</span><br><span class="line">    &quot;salary&quot;: 1000</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;uuid&quot;: &quot;f444edfb-2b4a-4ba6-b4ea-8a221087e787&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;goudan&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;44672938219&quot;,</span><br><span class="line">    &quot;salary&quot;: 1000</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 29ms; Content length: 197 bytes</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">GET http://127.0.0.1:8080/user/f444edfb-2b4a-4ba6-b4ea-8a221087e787</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, 27 Dec 2018 11:39:01 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;uuid&quot;: &quot;f444edfb-2b4a-4ba6-b4ea-8a221087e787&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;goudan&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;44672938219&quot;,</span><br><span class="line">  &quot;salary&quot;: 1000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 67ms; Content length: 96 bytes</span><br></pre></td></tr></table></figure>
<p>OK，测试通过了，如果只要单纯使用 <code>MyBatis</code> 的话，那就不需要下面的步骤了。</p>
<h3 id="二-集成-TkMybatis-和-PageHelper"><a href="#二-集成-TkMybatis-和-PageHelper" class="headerlink" title="(二) 集成 TkMybatis 和 PageHelper"></a>(二) 集成 TkMybatis 和 PageHelper</h3><h4 id="1-加入-mvn-依赖"><a href="#1-加入-mvn-依赖" class="headerlink" title="1. 加入 mvn 依赖"></a>1. 加入 mvn 依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.10&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-启动类或配置类加上-MapperScan-注解"><a href="#2-启动类或配置类加上-MapperScan-注解" class="headerlink" title="2. 启动类或配置类加上 MapperScan 注解"></a>2. 启动类或配置类加上 MapperScan 注解</h4><p>启动类上要加入 <code>tkmybatis</code> 的 <code>MapperScan</code> 注解，需要指定扫描的 <code>Mapper</code> 接口的包位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;cn.liweidan.springboot.mybatis.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyBatisApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-DBO-加上-jpa注解"><a href="#3-DBO-加上-jpa注解" class="headerlink" title="3. DBO 加上 jpa注解"></a>3. DBO 加上 jpa注解</h4><p>如果 <code>DBO</code> 类（数据库映射类）和数据库的表名不一样的话，还需要使用 <code>jpa</code> 注解，在类上指定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table(name = &quot;user_db&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_uuid&quot;)</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_salary&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long salary;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-Mapper接口修改"><a href="#4-Mapper接口修改" class="headerlink" title="4. Mapper接口修改"></a>4. Mapper接口修改</h4><p><code>Mapper</code> 接口需要继承 <code>Mapper&lt;dbo&gt;</code> 以获取通用的查询方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">tk</span>.mybatis.mapper.common.Mapper&lt;UserDo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    UserDo <span class="title function_">selectUserById</span><span class="params">(<span class="meta">@Param(&quot;userUuid&quot;)</span> String uuid)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(UserDo userDo)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;UserDo&gt; <span class="title function_">selectAllUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可使用方法： </p>
<p><img src="/images/springboot%E4%B8%8Emybatis%EF%BC%8C%E9%85%8D%E5%90%88-tkmybatis-pagehelper-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96.md/0.png"></p>
<h4 id="5-调用"><a href="#5-调用" class="headerlink" title="5. 调用"></a>5. 调用</h4><p>尝试修改 <code>GetByUID</code> 是用 <code>tkmybatis</code> 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;&#123;uid&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserDo <span class="title function_">selectByUId</span><span class="params">(<span class="meta">@PathVariable(&quot;uid&quot;)</span> String uid)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userMapper.selectByPrimaryKey(uid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看是否可以正常返回：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/user/f444edfb-2b4a-4ba6-b4ea-8a221087e787</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, 27 Dec 2018 12:35:12 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;uuid&quot;: &quot;f444edfb-2b4a-4ba6-b4ea-8a221087e787&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;goudan&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;44672938219&quot;,</span><br><span class="line">  &quot;salary&quot;: 1000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 212ms; Content length: 96 bytes</span><br></pre></td></tr></table></figure>
<h4 id="6-分页助手的使用"><a href="#6-分页助手的使用" class="headerlink" title="6. 分页助手的使用"></a>6. 分页助手的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> PageInfo&lt;UserDo&gt; <span class="title function_">selectAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在查询的上一步调用 startPage 注意页码是从 1 开始的，第二个参数是查询多少条记录</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 直接返回new一个新的pageInfo即包括分页常用所需要的信息了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(userMapper.selectAllUser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/user</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Thu, 27 Dec 2018 12:37:32 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;total&quot;: 2,</span><br><span class="line">  &quot;list&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;uuid&quot;: &quot;d2ae789c-1e95-443c-9c5b-2501d983c538&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;gousheng&quot;,</span><br><span class="line">      &quot;id&quot;: &quot;44672938219&quot;,</span><br><span class="line">      &quot;salary&quot;: 1000</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 186ms; Content length: 379 bytes</span><br></pre></td></tr></table></figure>
<p>可以看到总数是 2 条，现在是查询 1 条记录。至此整合完毕</p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>本文讲述了如何简单整合 <code>mybatis</code> 以及<code>mybatis</code> 插件进行日常开发使用，建议还是要第三方插件辅助支持，不然开发效率比较慢。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>【SpringCloud】Spring-Cloud-Common解析</title>
    <url>//spring/%E3%80%90springcloud%E3%80%91spring-cloud-common%E8%A7%A3%E6%9E%90/index.html</url>
    <content><![CDATA[<h2 id="SpringCloud开篇"><a href="#SpringCloud开篇" class="headerlink" title="SpringCloud开篇"></a>SpringCloud开篇</h2><p>那么最近是想要来阅读一下 <code>SpringCloud</code> 的文章的，于是乎逗了几个圈子，又是去 <code>GitHub</code> 下 <code>原生 Eureka</code> 的源码，又是去 <code>Spring</code> 下 <code>spring-cloud-netflix</code> 的源码，最后也是基本锁定只要从 <code>spring-cloud-netflix</code> 进去了解 <code>SpringCloud</code> 组件即可，毕竟 <code>原生Eureka</code> 我没用过…</p>
<h2 id="spring-cloud-context项目"><a href="#spring-cloud-context项目" class="headerlink" title="spring-cloud-context项目"></a>spring-cloud-context项目</h2><p>那么为啥是从 <code>SpringCloudContext</code> 开始咧，是因为这样的，如果我们某个组织想要开发 <code>SpringCloud</code> 套件的话，就需要使用到 <code>Spring</code> 官方提供的 <code>spring-cloud-commons</code> 项目，这个项目是一个 <code>套件工具包</code>，提供的是官方已经写好的一些注解和工具包，比方说 <code>@EnableDiscoveryClient</code> <code>@LoadBalanced</code> 这些我们常用的 <code>SpringCloud</code> 注解，并且提供了一些少量的支持，其中最重要的莫过于 <code>SpringCloud</code> 的上下文。 那我们之前读过 <code>Spring</code> 的源码的时候了解到，无论是 <code>context</code> 还是 <code>application</code>，都是支持父级容器的，而从容器中取出 <code>Bean实例</code> 的时候，也是 <code>双亲加载机制</code>，如果父级容器有了，那么子级容器是不会重新去加载的，这样我们在设计我们的业务项目的时候，就可以把一些基础架构的 <code>Bean实例</code> 丢到父级容器，并且子级容器只需要加载业务相关的类就可以了，当需要对第三方服务（如：<code>MySQL</code> <code>Redis</code> 都可以称为第三方服务）进行访问的时候，让我们的子级业务容器去父级容器取出来进行使用。有什么好处呢，我感觉就是专业的容器，做专业事情，我们编码弄出那么多设计，不外乎就是为了让程序的 <strong>拓展性会更好</strong>，当我们的基础服务发生改变的时候，那就可以将父级容器换一个，而不需要去动我们的业务容器。 带着这个想法来了解一下 <code>spring-cloud-context</code> 项目，<code>spring-cloud-context</code> 项目提供了一个容器，名为 <code>bootstrap</code>，那使用过的 <code>spring-cloud</code> 组件搭建过项目的同学肯定想到了我们常见的 <code>bootstrap.yml</code>，没错，这个配置文件就是配置 <code>bootstrap</code> 容器的，当我们在我们的项目中加入类似于 <code>eureka</code> <code>zuul</code> 或者 <code>eureka-client</code> 的时候，我们的项目容器就发生了翻天覆地的变化。 <code>SpringApplication</code> 会先根据 <code>SPI</code> 协议加载 <code>BootstrapApplicationListener</code> 类，并且在初始化 <code>ConfigurableApplicationContext</code> 之前，先执行这个上面的 <code>ApplicationListener</code> 的回调方法，把 <code>Bootstrap容器</code> 给初始化出来，并且设置为当前容器的 <code>parent</code> （典型的 <code>我把你当朋友你居然要做我爸爸</code>）。而如果有 <code>SpringCloud</code> 架构经验的同学肯定也明白一个事情，为啥我们在整合 <code>spring-cloud-config-client</code> 的时候，<code>spring-cloud</code> 的配置内容需要写在 <code>bootstrap.yml</code> 中，当然是因为 <code>bootstrap.yml</code> 是第一个被加载的，然后他获取到了配置以后，再初始化我们自己的容器，这时候我们自己的容器如果需要一些 <code>远程配置</code> 的时候，就可以先从 <code>爸爸</code> 那里去命中了。</p>
<a id="more"></a>
<blockquote>
<p>而为啥要这样设计呢，说好听点，叫做我们可以随时替换符合 <code>spring-cloud-context</code> 规范的套件，说难听呢，就是为了让自己的市场份额，因为如果我们想替换微服务的提供商，那么符合 <code>spring-cloud-context</code> 规范的，都可以很简便的进行替换，而如果不符合我规范的，很抱歉，你需要自己重写很多东西。</p>
</blockquote>
<h2 id="Bootstrap容器的初始化"><a href="#Bootstrap容器的初始化" class="headerlink" title="Bootstrap容器的初始化"></a>Bootstrap容器的初始化</h2><h3 id="演示栗子"><a href="#演示栗子" class="headerlink" title="演示栗子"></a>演示栗子</h3><p>首先我们需要一个例子，那就用最简单的 <code>EurekaServer</code> 的例子来搭建吧： 首先，<code>pom.xml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud.test&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;eureka-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.10.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.8.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">        &lt;!-- 因为使用的是最新版的SpringCloud，还是快照版，很多包在央仓是找不到的，所以需要Spring的快照仓库来配合构建 --&gt;</span><br><span class="line">    &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;spring&lt;/id&gt;</span><br><span class="line">            &lt;repositories&gt;</span><br><span class="line">                &lt;repository&gt;</span><br><span class="line">                    &lt;id&gt;spring-snapshots&lt;/id&gt;</span><br><span class="line">                    &lt;name&gt;Spring Snapshots&lt;/name&gt;</span><br><span class="line">                    &lt;url&gt;https://repo.spring.io/libs-snapshot-local&lt;/url&gt;</span><br><span class="line">                    &lt;snapshots&gt;</span><br><span class="line">                        &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">                    &lt;/snapshots&gt;</span><br><span class="line">                    &lt;releases&gt;</span><br><span class="line">                        &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">                    &lt;/releases&gt;</span><br><span class="line">                &lt;/repository&gt;</span><br><span class="line">                &lt;repository&gt;</span><br><span class="line">                    &lt;id&gt;spring-milestones&lt;/id&gt;</span><br><span class="line">                    &lt;name&gt;Spring Milestones&lt;/name&gt;</span><br><span class="line">                    &lt;url&gt;https://repo.spring.io/libs-milestone-local&lt;/url&gt;</span><br><span class="line">                    &lt;snapshots&gt;</span><br><span class="line">                        &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">                    &lt;/snapshots&gt;</span><br><span class="line">                &lt;/repository&gt;</span><br><span class="line">                &lt;repository&gt;</span><br><span class="line">                    &lt;id&gt;spring-releases&lt;/id&gt;</span><br><span class="line">                    &lt;name&gt;Spring Releases&lt;/name&gt;</span><br><span class="line">                    &lt;url&gt;https://repo.spring.io/release&lt;/url&gt;</span><br><span class="line">                    &lt;snapshots&gt;</span><br><span class="line">                        &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">                    &lt;/snapshots&gt;</span><br><span class="line">                &lt;/repository&gt;</span><br><span class="line">            &lt;/repositories&gt;</span><br><span class="line">            &lt;pluginRepositories&gt;</span><br><span class="line">                &lt;pluginRepository&gt;</span><br><span class="line">                    &lt;id&gt;spring-snapshots&lt;/id&gt;</span><br><span class="line">                    &lt;name&gt;Spring Snapshots&lt;/name&gt;</span><br><span class="line">                    &lt;url&gt;https://repo.spring.io/libs-snapshot-local&lt;/url&gt;</span><br><span class="line">                    &lt;snapshots&gt;</span><br><span class="line">                        &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">                    &lt;/snapshots&gt;</span><br><span class="line">                    &lt;releases&gt;</span><br><span class="line">                        &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">                    &lt;/releases&gt;</span><br><span class="line">                &lt;/pluginRepository&gt;</span><br><span class="line">                &lt;pluginRepository&gt;</span><br><span class="line">                    &lt;id&gt;spring-milestones&lt;/id&gt;</span><br><span class="line">                    &lt;name&gt;Spring Milestones&lt;/name&gt;</span><br><span class="line">                    &lt;url&gt;https://repo.spring.io/libs-milestone-local&lt;/url&gt;</span><br><span class="line">                    &lt;snapshots&gt;</span><br><span class="line">                        &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">                    &lt;/snapshots&gt;</span><br><span class="line">                &lt;/pluginRepository&gt;</span><br><span class="line">                &lt;pluginRepository&gt;</span><br><span class="line">                    &lt;id&gt;spring-releases&lt;/id&gt;</span><br><span class="line">                    &lt;name&gt;Spring Releases&lt;/name&gt;</span><br><span class="line">                    &lt;url&gt;https://repo.spring.io/libs-release-local&lt;/url&gt;</span><br><span class="line">                    &lt;snapshots&gt;</span><br><span class="line">                        &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">                    &lt;/snapshots&gt;</span><br><span class="line">                &lt;/pluginRepository&gt;</span><br><span class="line">            &lt;/pluginRepositories&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;sonar&lt;/id&gt;</span><br><span class="line">            &lt;build&gt;</span><br><span class="line">                &lt;plugins&gt;</span><br><span class="line">                    &lt;plugin&gt;</span><br><span class="line">                        &lt;groupId&gt;org.jacoco&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                        &lt;executions&gt;</span><br><span class="line">                            &lt;execution&gt;</span><br><span class="line">                                &lt;id&gt;pre-unit-test&lt;/id&gt;</span><br><span class="line">                                &lt;goals&gt;</span><br><span class="line">                                    &lt;goal&gt;prepare-agent&lt;/goal&gt;</span><br><span class="line">                                &lt;/goals&gt;</span><br><span class="line">                                &lt;configuration&gt;</span><br><span class="line">                                    &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt;</span><br><span class="line">                                    &lt;destFile&gt;$&#123;project.build.directory&#125;/jacoco.exec&lt;/destFile&gt;</span><br><span class="line">                                &lt;/configuration&gt;</span><br><span class="line">                            &lt;/execution&gt;</span><br><span class="line">                            &lt;execution&gt;</span><br><span class="line">                                &lt;id&gt;post-unit-test&lt;/id&gt;</span><br><span class="line">                                &lt;phase&gt;test&lt;/phase&gt;</span><br><span class="line">                                &lt;goals&gt;</span><br><span class="line">                                    &lt;goal&gt;report&lt;/goal&gt;</span><br><span class="line">                                &lt;/goals&gt;</span><br><span class="line">                                &lt;configuration&gt;</span><br><span class="line">                                    &lt;!-- Sets the path to the file which contains the execution data. --&gt;</span><br><span class="line">                                    &lt;dataFile&gt;$&#123;project.build.directory&#125;/jacoco.exec&lt;/dataFile&gt;</span><br><span class="line">                                &lt;/configuration&gt;</span><br><span class="line">                            &lt;/execution&gt;</span><br><span class="line">                        &lt;/executions&gt;</span><br><span class="line">                    &lt;/plugin&gt;</span><br><span class="line">                &lt;/plugins&gt;</span><br><span class="line">            &lt;/build&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p><code>EurekaApplication.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.StandardEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要给个标准的环境才能运行</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> Environment <span class="title function_">environment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回顾下老朋友"><a href="#回顾下老朋友" class="headerlink" title="回顾下老朋友"></a>回顾下老朋友</h3><p>看过我 <code>SpringBoot</code> 源码解析的小朋友们应该对下面这个代码会有点熟悉感：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="comment">// 这是用来打印加载时间的工具类，暂时可以略过.</span></span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 主要设置JVM虚拟机支持无设备情况下让awt可运行的属性</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 一. 加载所有SpringApplicationRunListeners并开始遍历所有Lintener启动监听回调函数</span></span><br><span class="line">    <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">      <span class="comment">// 二. 开始准备ConfigurableEnvironment环境</span></span><br><span class="line">      <span class="comment">// ===&gt; 那么将要看的Bootstrap容器初始化就是在这里被执行的，先拿到所有的listener，然后调用onApplicationEvent方法</span></span><br><span class="line">      <span class="comment">// 在准备 ConfigurableApplicationContext，的时候，顺便准备一下Bootstrap</span></span><br><span class="line">      <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">      configureIgnoreBeanInfo(environment);</span><br><span class="line">      <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">      <span class="comment">// 三. 创建应用上下文</span></span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                                                       <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">      <span class="comment">// 四. 做一些准备工作</span></span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">      <span class="comment">// 五. 刷新上下文</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">      <span class="comment">// 六. 刷新完成后做的一些清理、回调工作</span></span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 七. 启动完成后，调用所有SpringApplicationRunListener的完成启动的回调函数</span></span><br><span class="line">      listeners.started(context);</span><br><span class="line">      <span class="comment">// 八. 主要处理ApplicationRunner和CommandLineRunner的回调</span></span><br><span class="line">      callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 九. 运行时的SpringApplicationRunListener回调函数</span></span><br><span class="line">      listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, ex, exceptionReporters, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么为什么那么确定就是 <code>Listener</code> 被调用呢，证据确凿：<code>spring-cloud-commons/spring-cloud-context/src/main/resources/META-INF/spring.factories</code>： 整合流程详见 Spring_Boot_与容器</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AutoConfiguration</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.autoconfigure.LifecycleMvcEndpointAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.autoconfigure.RefreshAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.autoconfigure.RefreshEndpointAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.autoconfigure.WritableEnvironmentEndpointAutoConfiguration</span></span><br><span class="line"><span class="comment"># Application Listeners，在这里注册了SpringBoot的ApplicationListener</span></span><br><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.cloud.bootstrap.BootstrapApplicationListener,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.bootstrap.LoggingSystemShutdownListener,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.context.restart.RestartListener</span></span><br><span class="line"><span class="comment"># Bootstrap components</span></span><br><span class="line"><span class="attr">org.springframework.cloud.bootstrap.BootstrapConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.util.random.CachedRandomPropertySourceAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<p>当然我们需要重温一下 <code>ApplicationListener</code> 有什么生命周期函数以及观望一下 <code>BootstrapApplicationListener</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SpringApplicationRunListener</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 项目开始时调用</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 环境准备好时，初始化 ConfigurableApplicationContext 的时候会调用到这里，</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上下文准备好时</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上下文读取完成</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动完成</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 项目运行时调用</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 项目失败时</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootstrapApplicationListener</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationEnvironmentPreparedEvent&gt;, Ordered &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> event.getEnvironment();</span><br><span class="line">    <span class="comment">// spring.cloud.bootstrap.enabled配置容器的开关，默认是打开的</span></span><br><span class="line">    <span class="keyword">if</span> (!environment.getProperty(<span class="string">&quot;spring.cloud.bootstrap.enabled&quot;</span>, Boolean.class,</span><br><span class="line">                                 <span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bootstrap的初始化同样会经过这里，那我们就不能让他递归创建，遇到Bootstrap直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 默认bootstrap的配置名：bootstrap</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">configName</span> <span class="operator">=</span> environment</span><br><span class="line">      .resolvePlaceholders(<span class="string">&quot;$&#123;spring.cloud.bootstrap.name:bootstrap&#125;&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果我们初始化的时候已经存在父级容器了，则从父级容器中尝试命中BootstrapContext</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationContextInitializer&lt;?&gt; initializer : event.getSpringApplication()</span><br><span class="line">         .getInitializers()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> ParentContextApplicationContextInitializer) &#123;</span><br><span class="line">        context = findBootstrapContext(</span><br><span class="line">          (ParentContextApplicationContextInitializer) initializer,</span><br><span class="line">          configName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// ======&gt; 通过SpringApplicationBuilder来构建一个Context上下问</span></span><br><span class="line">      context = bootstrapServiceContext(environment, event.getSpringApplication(),</span><br><span class="line">                                        configName);</span><br><span class="line">      <span class="comment">// 添加一个主Context关闭的监听器，为了能够发生错误的时候同时关闭Bootstrap容器</span></span><br><span class="line">      event.getSpringApplication()</span><br><span class="line">        .addListeners(<span class="keyword">new</span> <span class="title class_">CloseContextOnFailureApplicationListener</span>(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply(context, event.getSpringApplication(), environment);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ConfigurableApplicationContext <span class="title function_">bootstrapServiceContext</span><span class="params">(</span></span><br><span class="line"><span class="params">    ConfigurableEnvironment environment, <span class="keyword">final</span> SpringApplication application,</span></span><br><span class="line"><span class="params">    String configName)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个标准环境配置，带有systemProperties和systemEnvironment的相关配置信息</span></span><br><span class="line">    <span class="type">StandardEnvironment</span> <span class="variable">bootstrapEnvironment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    <span class="type">MutablePropertySources</span> <span class="variable">bootstrapProperties</span> <span class="operator">=</span> bootstrapEnvironment</span><br><span class="line">      .getPropertySources();</span><br><span class="line">    <span class="comment">// 开始整理Bootstrap所需要的配置，移除systemProperties和systemEnvironment</span></span><br><span class="line">    <span class="keyword">for</span> (PropertySource&lt;?&gt; source : bootstrapProperties) &#123;</span><br><span class="line">      bootstrapProperties.remove(source.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> environment</span><br><span class="line">      .resolvePlaceholders(<span class="string">&quot;$&#123;spring.cloud.bootstrap.location:&#125;&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">configAdditionalLocation</span> <span class="operator">=</span> environment</span><br><span class="line">      .resolvePlaceholders(<span class="string">&quot;$&#123;spring.cloud.bootstrap.additional-location:&#125;&quot;</span>);</span><br><span class="line">    Map&lt;String, Object&gt; bootstrapMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    bootstrapMap.put(<span class="string">&quot;spring.config.name&quot;</span>, configName);</span><br><span class="line">    bootstrapMap.put(<span class="string">&quot;spring.main.web-application-type&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(configLocation)) &#123;</span><br><span class="line">      bootstrapMap.put(<span class="string">&quot;spring.config.location&quot;</span>, configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(configAdditionalLocation)) &#123;</span><br><span class="line">      bootstrapMap.put(<span class="string">&quot;spring.config.additional-location&quot;</span>,</span><br><span class="line">                       configAdditionalLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    bootstrapProperties.addFirst(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(BOOTSTRAP_PROPERTY_SOURCE_NAME, bootstrapMap));</span><br><span class="line">    <span class="keyword">for</span> (PropertySource&lt;?&gt; source : environment.getPropertySources()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (source <span class="keyword">instanceof</span> StubPropertySource) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bootstrapProperties.addLast(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过SpringApplicationBuilder构建一个船新的Context出来</span></span><br><span class="line">    <span class="type">SpringApplicationBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class="line">      .profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)</span><br><span class="line">      .environment(bootstrapEnvironment)</span><br><span class="line">      <span class="comment">// Don&#x27;t use the default properties in this builder</span></span><br><span class="line">      .registerShutdownHook(<span class="literal">false</span>).logStartupInfo(<span class="literal">false</span>)</span><br><span class="line">      .web(WebApplicationType.NONE);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SpringApplication</span> <span class="variable">builderApplication</span> <span class="operator">=</span> builder.application();</span><br><span class="line">    <span class="keyword">if</span> (builderApplication.getMainApplicationClass() == <span class="literal">null</span>) &#123;</span><br><span class="line">      builder.main(application.getMainApplicationClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (environment.getPropertySources().contains(<span class="string">&quot;refreshArgs&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// 过滤掉在刷新环境的时候，会影响到全局状态的Listener，如 LoggingApplicationListener</span></span><br><span class="line">      builderApplication</span><br><span class="line">        .setListeners(filterListeners(builderApplication.getListeners()));</span><br><span class="line">    &#125;</span><br><span class="line">    builder.sources(BootstrapImportSelectorConfiguration.class);</span><br><span class="line">    <span class="comment">// ====&gt; 构建BootstrapContext，这时候要重复我们上面说到的Context的加载过程</span></span><br><span class="line">    <span class="comment">// 我们必须清楚这一步加载了什么BeanDefinition</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> builder.run();</span><br><span class="line">    context.setId(<span class="string">&quot;bootstrap&quot;</span>);</span><br><span class="line">    <span class="comment">// 然后将BootstrapContext设置为当前context的父级容器</span></span><br><span class="line">    addAncestorInitializer(application, context);</span><br><span class="line">    <span class="comment">// 先移除掉Bootstrap的配置，后面会被加回去</span></span><br><span class="line">    bootstrapProperties.remove(BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">    mergeDefaultProperties(environment.getPropertySources(), bootstrapProperties);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们需要用一点言语来概括一下上下文初始化的过程：</p>
<ol>
<li> 我们所启动的 <code>ApplicationContext</code>，在准备加载的时候，调用了模块中定义的 <code>ApplicationListener</code>，也就是 <code>spring-cloud-context</code> 包中定义的 <code>BootstrapApplicationListener</code>；</li>
<li> <code>BootstrapApplicationListener</code> 开始根据 <code>ApplicationContext</code> 获取的一系列配置，使用 <code>SpringApplicationBuilder</code> 构建开始 <code>BootstrapContext</code>，并且通过 <code>AncestorInitializer</code> 配置好两个上下文的父子关系；</li>
<li> <code>SpringApplicationBuilder</code> 调用 <code>run()</code> 函数，刷新容器中的 <code>Bean实例</code>。</li>
<li> 那接下来我们就需要重新进入 <code>SpringBoot</code> 容器的加载流程来瞅一瞅到底加载了什么</li>
</ol>
<h3 id="Bootstrap容器的加载"><a href="#Bootstrap容器的加载" class="headerlink" title="Bootstrap容器的加载"></a>Bootstrap容器的加载</h3><p>那之前在说 <code>Spring</code> 的时候有说过，<code>Spring</code> 加载 <code>Bean</code> 的时候是会根据一些规则，比如 <code>@Configuration</code> 或者 <code>ImportSelector子类</code>，用于查询需要导入的 <code>配置Bean</code>，整合进框架的方法莫过于 <code>spring.factories</code> 文件去定义。对应的生命周期子类将会在不同的时期被执行。 那么上面使用 <code>SpringApplicationBuilder</code> 构造 <code>BootstrapContext</code> 之前呢，通过 <code>builder.sources(BootstrapImportSelectorConfiguration.class);</code> 把 <code>Bootstrap</code> 配置信息给加载进去，而这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(BootstrapImportSelector.class)</span> <span class="comment">// 导入了一个BootstrapImportSelector的 ImportSelector 处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootstrapImportSelectorConfiguration</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入Bootstrap配置类的选择器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootstrapImportSelector</span> <span class="keyword">implements</span> <span class="title class_">EnvironmentAware</span>, DeferredImportSelector &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MetadataReaderFactory</span> <span class="variable">metadataReaderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnvironment</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(SpringFactoriesLoader</span><br><span class="line">                .loadFactoryNames(BootstrapConfiguration.class, classLoader));</span><br><span class="line">        names.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">                <span class="built_in">this</span>.environment.getProperty(<span class="string">&quot;spring.cloud.bootstrap.sources&quot;</span>, <span class="string">&quot;&quot;</span>))));</span><br><span class="line"></span><br><span class="line">        List&lt;OrderedAnnotatedElement&gt; elements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                elements.add(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">OrderedAnnotatedElement</span>(<span class="built_in">this</span>.metadataReaderFactory, name));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        AnnotationAwareOrderComparator.sort(elements);</span><br><span class="line"></span><br><span class="line">        String[] classNames = elements.stream().map(e -&gt; e.name).toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> classNames;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要先来聊聊 <code>ImportSelector</code>，这个后处理器会在解析配置的时候被调用到，而调用他主要是用来加载我们整合框架的时候，需要使用到的一些特殊配置，那么看到上面的 <code>BootstrapImportSelector</code>，他支持将 <code>BootstrapConfiguration</code> 类（实际上使用了最简单的 <code>注解</code> 来表示一个类），所以 <code>spring.factories</code> 写了 <code>org.springframework.cloud.bootstrap.BootstrapConfiguration=/xxx</code> 的类即可被 <code>SpringFactoriesLoader</code> 读取到。 那这个类呢，就是将 <code>spring.factories</code> 定义的 <code>BootstrapConfiguration</code> 类加载到容器中，并且应用其中的设置。 那么目前加载的 <code>Bean</code> 就有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\</span><br><span class="line">org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\</span><br><span class="line">org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.cloud.util.random.CachedRandomPropertySourceAutoConfiguration, \</span><br><span class="line">org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfiguration</span><br></pre></td></tr></table></figure>
<p>最后一个是 <code>Eureka</code> 加载的发现服务的客户端配置类。 那为啥我依赖个 <code>@EnableEurekaServer</code> 而给我注入的是一个 <code>客户端</code> 的配置呢，那是因为，<code>Eureka</code> 的设计中，<code>Core</code> 是用来存储实例的，而服务端和客户端存储的实例设计都是一样，那在 <code>SpringCloud</code> 项目中，服务端又可以相互注册，所以 <code>EurekaServer</code> 实际也是一个 <code>EurekaClient</code>。 那么上面加载到容器中的类，那么很明显，在加载 <code>Bootstrap</code> 容器的时候，会被读取到上面那些类，上面那些类，有 <code>ApplicationContextInitializer</code> <code>@Configuration</code> 等等，应有尽有，主要都是用于在不同容器生命周期发光发亮的处理类。然后我们也说过，在 <code>SpringBoot</code> 使用的 <code>AnnotationConfigApplicationContext</code> 上下文中，所有的非惰性 <code>Bean</code> 在刷新的最后都会被进行一次 <code>加载</code>，所以上面配置中所有的 <code>Bean</code> 都会被初始化。 而这些 <code>Bean</code>，就是我们常用的 <code>配置从config-server读取</code> <code>配置解密</code> 的关键，这些放在后面再来阅读。 那么现在总结一下，<code>spring-cloud-context</code> 有什么用呢，最主要的一点就是提供了一个 <code>Bootstrap上下文</code>，<code>SpringCloud</code> 的组件们，就是在这个上下文中进行工作的，而我们的 <code>业务上下文</code>，依然存在于我们创建的上下文中，当需要用到一些比如调用第三方服务的工具类的时候，就会从 <code>spring-cloud-context</code> 中取出来使用，而 <code>套件</code> 则会利用这个上下文的工具类，来提供更加便利的使用。</p>
<h2 id="spring-cloud-commons项目"><a href="#spring-cloud-commons项目" class="headerlink" title="spring-cloud-commons项目"></a>spring-cloud-commons项目</h2><p>这个包，提供了一系列的关于微服务的 <code>类定义</code>，如果 <code>SpringCloud</code> 套件的开发者遵守这套规范的话，那我们是可以在不同的 <code>套件</code> 之间来回切换的，比方说目前市面上存在 <code>SpringCloudNetflix</code> 和 <code>SpringCloudAlibaba</code>，而我们在使用其中一套的时候，如果注解用的是 <code>spring-cloud-commons</code> 的规范注解，则切换套件的任务将会变得十分简单。 下一节聊一聊 <code>eureka-server</code> 了。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
        <tag>spring</tag>
        <tag>spring-cloud-common</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring源码】SpringBoot_MyBatis_starter源码（一）</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot-mybatis-starter%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/index.html</url>
    <content><![CDATA[<h2 id="准备一下"><a href="#准备一下" class="headerlink" title="准备一下"></a>准备一下</h2><p>由于我们使用 <code>MyBatis</code> 的时候，很少独立使用，所以我直接从 <code>SpringBoot</code> 自动装配，进入 <code>MyBatis</code> 来看看。 直接看 <code>org.mybatis.spring.boot:mybatis-spring-boot-starter</code> 源码目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── license.txt</span><br><span class="line">├── mvnw</span><br><span class="line">├── mvnw.cmd</span><br><span class="line">├── mybatis-spring-boot-autoconfigure</span><br><span class="line">│   ├── format.xml</span><br><span class="line">│   ├── license.txt</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── mybatis-spring-boot-samples</span><br><span class="line">│   ├── mybatis-spring-boot-sample-annotation</span><br><span class="line">│   ├── mybatis-spring-boot-sample-freemarker</span><br><span class="line">│   ├── mybatis-spring-boot-sample-freemarker-legacy</span><br><span class="line">│   ├── mybatis-spring-boot-sample-groovy</span><br><span class="line">│   ├── mybatis-spring-boot-sample-kotlin</span><br><span class="line">│   ├── mybatis-spring-boot-sample-thymeleaf</span><br><span class="line">│   ├── mybatis-spring-boot-sample-velocity</span><br><span class="line">│   ├── mybatis-spring-boot-sample-velocity-legacy</span><br><span class="line">│   ├── mybatis-spring-boot-sample-war</span><br><span class="line">│   ├── mybatis-spring-boot-sample-web</span><br><span class="line">│   ├── mybatis-spring-boot-sample-xml</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── mybatis-spring-boot-starter</span><br><span class="line">│   ├── license.txt</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── mybatis-spring-boot-starter-test</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── mybatis-spring-boot-test-autoconfigure</span><br><span class="line">│   ├── format.xml</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── pom.xml</span><br><span class="line">└── travis</span><br><span class="line">    ├── after_success.sh</span><br><span class="line">    └── settings.xml</span><br></pre></td></tr></table></figure>
<p>在 <code>mybatis-spring-boot-samples/mybatis-spring-boot-sample-xml</code> 中刚好有我想要的示例，刚好不用自己写了，就使用这个示例来查看吧。</p>
<a id="more"></a>
<h2 id="自动发现"><a href="#自动发现" class="headerlink" title="自动发现"></a>自动发现</h2><p>从之前的自动发现文章中，我们发现，通常自动装配的类都写在 <code>META-INF/spring.factories</code> 这里面，现在我们可以直接查看 <code>mybatis-spring-boot-autoconfigure</code> 这里面的这个文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<p>通过名字，感觉 <code>org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</code> 在装载的过程中比较重要。 这个类里面有个内部类，是 <code>MyBatis</code> 切入 <code>SpringBoot</code> 的重点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguredMapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, ImportBeanDefinitionRegistrar &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!AutoConfigurationPackages.has(<span class="built_in">this</span>.beanFactory)) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Could not determine auto-configuration package, automatic mapper scanning disabled.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.debug(<span class="string">&quot;Searching for mappers annotated with @Mapper&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; packages = AutoConfigurationPackages.get(<span class="built_in">this</span>.beanFactory);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      packages.forEach(pkg -&gt; logger.debug(<span class="string">&quot;Using auto-configuration base package &#x27;&#123;&#125;&#x27;&quot;</span>, pkg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;processPropertyPlaceHolders&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;annotationClass&quot;</span>, Mapper.class);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;basePackage&quot;</span>, StringUtils.collectionToCommaDelimitedString(packages));</span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">beanWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(MapperScannerConfigurer.class);</span><br><span class="line">    Stream.of(beanWrapper.getPropertyDescriptors())</span><br><span class="line">        <span class="comment">// Need to mybatis-spring 2.0.2+</span></span><br><span class="line">        .filter(x -&gt; x.getName().equals(<span class="string">&quot;lazyInitialization&quot;</span>)).findAny()</span><br><span class="line">        .ifPresent(x -&gt; builder.addPropertyValue(<span class="string">&quot;lazyInitialization&quot;</span>, <span class="string">&quot;$&#123;mybatis.lazy-initialization:false&#125;&quot;</span>));</span><br><span class="line">    registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="meta">@Import(AutoConfiguredMapperScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123; MapperFactoryBean.class, MapperScannerConfigurer.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">      logger.debug(</span><br><span class="line">        <span class="string">&quot;Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类实现了两个接口：</p>
<ol>
<li> <code>BeanFactoryAware</code>：这个接口，被 <code>Spring</code> 扫描到的话，是会被 <code>Spring</code> 调用的，传递了当前 <code>BeanFactory</code> 实例，有助于我们后期可以对 <code>BeanFactory</code> 的操作；</li>
<li> <code>ImportBeanDefinitionRegistrar</code>：那这个接口还真的是第一次出现，他是一个在解析 <code>Configuration</code>，可以注册业务需要的 <code>BeanDefinition</code>，简单的说，在刷新容器的时候，<code>BeanDefinitionRegistryPostProcessors</code> 会被调用到，而 <code>SpringBoot</code> 中，总是有个 <code>ConfigurationClassPostProcessor</code> 存在，他在解析配置的时候，会手动的去触发 <code>ImportBeanDefinitionRegistrar#registerBeanDefinitions</code> 函数，这时候，上面的内部类就会被读取到。</li>
</ol>
<p>那这个类他就是负责在解析配置类的时候，注册了一个 <code>MapperScannerConfigurer</code> 类，看名字不用猜就知道是扫描项目中被 <code>@Mapper</code> 注解装饰的接口类了。</p>
<h2 id="配置-SqlSession"><a href="#配置-SqlSession" class="headerlink" title="配置 SqlSession"></a>配置 SqlSession</h2><p>上面注册的 <code>MapperScannerConfigurer</code> 是一个 <code>BeanDefinitionRegistryPostProcessor</code> 处理器，他会在解析配置后面，被 <code>BeanFactory</code> 调用到。 调用就是扫描 <code>Mapper</code> 的存在了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperScannerConfigurer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span>, InitializingBean, ApplicationContextAware, BeanNameAware &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建扫描器</span></span><br><span class="line">    <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">    scanner.setAddToConfig(<span class="built_in">this</span>.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(<span class="built_in">this</span>.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(<span class="built_in">this</span>.markerInterface);</span><br><span class="line">    <span class="comment">// 目前SqlSessionFactory和SqlSessionTemplate均为Null</span></span><br><span class="line">    scanner.setSqlSessionFactory(<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(<span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(<span class="built_in">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(<span class="built_in">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(<span class="built_in">this</span>.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册扫描过滤器，目前是加上扫描 @Mapper 的接口类</span></span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    <span class="comment">// 开始扫描</span></span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">beanCountAtScanStart</span> <span class="operator">=</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line"> doScan(basePackages);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">  <span class="comment">// 一个空处理，目的是为了注册注解配置类吧？</span></span><br><span class="line">  AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (<span class="built_in">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>ClassPathMapperScanner</code> 继承了 <code>Spring</code> 提供的 <code>ClassPathBeanDefinitionScanner</code>，所以可以直接把扫描注解这件事情交给 <code>Spring</code> 来做，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">    LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">        + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processBeanDefinitions(beanDefinitions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那由于上面已经扫描了大半的 <code>BeanDefinition</code>，后面就新增了还需要扫描 <code>@Mapper</code> 的注解，这时候重新进行一遍扫描以后，新增加的 <code>BeanDefinition</code> 就是我们要的 <code>Mapper</code> 接口了。所以这时候拿到了所有的 <code>Mapper</code> 的 <code>BeanDefinition</code> 进行处理。 接下来对扫描到 <code>Mapper</code> 进行处理一波：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> &#123;</span><br><span class="line">  GenericBeanDefinition definition;</span><br><span class="line">  <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">    definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">    <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> definition.getBeanClassName();</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Creating MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + beanClassName</span><br><span class="line">        + <span class="string">&quot;&#x27; mapperInterface&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean是接口，但是其实现类是 MapperFactoryBean，所以这里设置 mapperFactoryBean 进去所有的 Mapper里面</span></span><br><span class="line">    definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);</span><br><span class="line">    definition.setBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line"></span><br><span class="line">    definition.getPropertyValues().add(<span class="string">&quot;addToConfig&quot;</span>, <span class="built_in">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">explicitFactoryUsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 这下面目前均为空，所以都没有进入if里面</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">      explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">      explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.warn(</span><br><span class="line">            () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">      explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.warn(</span><br><span class="line">            () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">      explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型注入</span></span><br><span class="line">    <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">      definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">    definition.setLazyInit(lazyInitialization);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取Mapper"><a href="#获取Mapper" class="headerlink" title="获取Mapper"></a>获取Mapper</h2><p>实例化在 <code>ApplicationContext#finishBeanFactoryInitialization</code> 中这一步实现 <code>finishBeanFactoryInitialization</code>。这时候需要先看下 <code>MyBatis</code> 自动配置配置了哪些 <code>Bean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    factory.setDataSource(dataSource);</span><br><span class="line">    factory.setVfs(SpringBootVFS.class);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.properties.getConfigLocation())) &#123;</span><br><span class="line">      factory.setConfigLocation(<span class="built_in">this</span>.resourceLoader.getResource(<span class="built_in">this</span>.properties.getConfigLocation()));</span><br><span class="line">    &#125;</span><br><span class="line">    applyConfiguration(factory);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.properties.getConfigurationProperties() != <span class="literal">null</span>) &#123;</span><br><span class="line">      factory.setConfigurationProperties(<span class="built_in">this</span>.properties.getConfigurationProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.interceptors)) &#123;</span><br><span class="line">      factory.setPlugins(<span class="built_in">this</span>.interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.databaseIdProvider != <span class="literal">null</span>) &#123;</span><br><span class="line">      factory.setDatabaseIdProvider(<span class="built_in">this</span>.databaseIdProvider);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.properties.getTypeAliasesPackage())) &#123;</span><br><span class="line">      factory.setTypeAliasesPackage(<span class="built_in">this</span>.properties.getTypeAliasesPackage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.properties.getTypeAliasesSuperType() != <span class="literal">null</span>) &#123;</span><br><span class="line">      factory.setTypeAliasesSuperType(<span class="built_in">this</span>.properties.getTypeAliasesSuperType());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.properties.getTypeHandlersPackage())) &#123;</span><br><span class="line">      factory.setTypeHandlersPackage(<span class="built_in">this</span>.properties.getTypeHandlersPackage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.typeHandlers)) &#123;</span><br><span class="line">      factory.setTypeHandlers(<span class="built_in">this</span>.typeHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.properties.resolveMapperLocations())) &#123;</span><br><span class="line">      factory.setMapperLocations(<span class="built_in">this</span>.properties.resolveMapperLocations());</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; factoryPropertyNames = Stream</span><br><span class="line">        .of(<span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)</span><br><span class="line">        .collect(Collectors.toSet());</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">LanguageDriver</span>&gt; defaultLanguageDriver = <span class="built_in">this</span>.properties.getDefaultScriptingLanguageDriver();</span><br><span class="line">    <span class="keyword">if</span> (factoryPropertyNames.contains(<span class="string">&quot;scriptingLanguageDrivers&quot;</span>) &amp;&amp; !ObjectUtils.isEmpty(<span class="built_in">this</span>.languageDrivers)) &#123;</span><br><span class="line">      <span class="comment">// Need to mybatis-spring 2.0.2+</span></span><br><span class="line">      factory.setScriptingLanguageDrivers(<span class="built_in">this</span>.languageDrivers);</span><br><span class="line">      <span class="keyword">if</span> (defaultLanguageDriver == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.languageDrivers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        defaultLanguageDriver = <span class="built_in">this</span>.languageDrivers[<span class="number">0</span>].getClass();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (factoryPropertyNames.contains(<span class="string">&quot;defaultScriptingLanguageDriver&quot;</span>)) &#123;</span><br><span class="line">      <span class="comment">// Need to mybatis-spring 2.0.2+</span></span><br><span class="line">      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory.getObject();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorType</span> <span class="variable">executorType</span> <span class="operator">=</span> <span class="built_in">this</span>.properties.getExecutorType();</span><br><span class="line">    <span class="keyword">if</span> (executorType != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory, executorType);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SqlSessionFactory</code> 和 <code>SqlSessionTemplate</code>，先来看看这两个类的作用： 这两个类主要围绕构建 <code>SqlSession</code> 来做一些配置的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface SqlSession extends Closeable &#123;</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; T selectOne(String statement);</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; T selectOne(String statement, Object parameter);</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; List&lt;E&gt; selectList(String statement);</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter);</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds);</span><br><span class="line"></span><br><span class="line">  &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey);</span><br><span class="line"></span><br><span class="line">  &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey);</span><br><span class="line"></span><br><span class="line">  &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement);</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter);</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter, RowBounds rowBounds);</span><br><span class="line"></span><br><span class="line">  void select(String statement, Object parameter, ResultHandler handler);</span><br><span class="line"></span><br><span class="line">  void select(String statement, ResultHandler handler);</span><br><span class="line"></span><br><span class="line">  void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler);</span><br><span class="line"></span><br><span class="line">  int insert(String statement);</span><br><span class="line"></span><br><span class="line">  int insert(String statement, Object parameter);</span><br><span class="line"></span><br><span class="line">  int update(String statement);</span><br><span class="line"></span><br><span class="line">  int update(String statement, Object parameter);</span><br><span class="line"></span><br><span class="line">  int delete(String statement);</span><br><span class="line"></span><br><span class="line">  int delete(String statement, Object parameter);</span><br><span class="line"></span><br><span class="line">  void commit();</span><br><span class="line"></span><br><span class="line">  void commit(boolean force);</span><br><span class="line"></span><br><span class="line">  void rollback();</span><br><span class="line"></span><br><span class="line">  void rollback(boolean force);</span><br><span class="line"></span><br><span class="line">  List&lt;BatchResult&gt; flushStatements();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  void close();</span><br><span class="line"></span><br><span class="line">  void clearCache();</span><br><span class="line"></span><br><span class="line">  Configuration getConfiguration();</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; T getMapper(Class&lt;T&gt; type);</span><br><span class="line"></span><br><span class="line">  Connection getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 <code>MyBatis</code> 执行 <code>SQL</code> 的关键接口，定义了 <code>jdbc</code> 常用的方法。而 <code>SqlSessionTemplate</code> 就是一个 <code>SqlSession</code>，专门用来整合 <code>Spring</code> 的一个 <code>SqlSession</code>，而 <code>SqlSessionFactory</code> 则是封装了连接的方法以及一些其他的配置，比如拦截器等等。 那我们看看主启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleXmlApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(SampleXmlApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CityDao cityDao;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HotelMapper hotelMapper;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SampleXmlApplication</span><span class="params">(CityDao cityDao, HotelMapper hotelMapper)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cityDao = cityDao;</span><br><span class="line">    <span class="built_in">this</span>.hotelMapper = hotelMapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;squid:S106&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span>.cityDao.selectCityById(<span class="number">1</span>));</span><br><span class="line">    System.out.println(<span class="built_in">this</span>.hotelMapper.selectByCityId(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他注入了一个 <code>CityDao</code> 以及 一个 <code>HotelMapper</code>，两种不同的查询方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CityDao</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CityDao</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> City <span class="title function_">selectCityById</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSession.selectOne(<span class="string">&quot;selectCityById&quot;</span>, id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HotelMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">  Hotel <span class="title function_">selectByCityId</span><span class="params">(<span class="type">int</span> cityId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，<code>Spring</code> 容器在初始化 <code>SampleXmlApplication</code> 的时候就会去循环递归的去找到最后所需要的依赖，那其实 <code>CityDao</code> 的初始化并不难，现在看看 <code>HotelMapper</code> 的初始化。 <code>HotelMapper</code> 在注册给 <code>Spring</code> 的时候其实已经将实际对象的 <code>FactoryBean</code> 设置成 <code>MapperFactoryBean</code>，而 <code>MapperFactoryBean</code> 实现了 <code>FactoryBean</code> ，<code>Spring</code> 将会通过调用 <code>getObject</code> 来获取工厂构造的对象，所以这时候我们看看 <code>MapperFactoryBean</code> 怎么实现这个方法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperFactoryBean</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们自己写的Mapper接口类</span></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">addToConfig</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// intentionally empty</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FactoryBean需要实现这个方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，我们可以看到他从 <code>SqlSession</code> 中来获取 <code>Mapper代理</code>，所以这个方法在这里充其量就是一个桥梁，架通了 <code>MyBatis</code> 构造的代理以及 <code>Spring</code> 的 <code>Bean</code> 的桥。 那 <code>SqlSession</code> 怎么来的，又是一个 <code>Factory</code> 构造来的，还记得上面的工厂配置类吗，就是那里构造出来的，现在我们需要回去去看看他怎么构造 <code>MyBatis</code> 上下文的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// 构造一个SqlSessionFactory</span></span><br><span class="line">  <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">  <span class="comment">// 数据源</span></span><br><span class="line">  factory.setDataSource(dataSource);</span><br><span class="line">  <span class="comment">// 提供一个访问SpringBoot资源的实现类，是个VFS，MyBatis定义访问资源的一个抽象类</span></span><br><span class="line">  factory.setVfs(SpringBootVFS.class);</span><br><span class="line">  <span class="comment">// MyBatis配置文件：mybatis.config-location=classpath:mybatis-config.xml</span></span><br><span class="line">  <span class="comment">// 在applicationContext.yml中的配置</span></span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.properties.getConfigLocation())) &#123;</span><br><span class="line">    factory.setConfigLocation(<span class="built_in">this</span>.resourceLoader.getResource(<span class="built_in">this</span>.properties.getConfigLocation()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读取MyBatisProperties配置，此时SpringBoot已经将配置文件中的信息转换为JavaBean</span></span><br><span class="line">  <span class="comment">// 不过我们没有配置什么东西</span></span><br><span class="line">  applyConfiguration(factory);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.properties.getConfigurationProperties() != <span class="literal">null</span>) &#123;</span><br><span class="line">    factory.setConfigurationProperties(<span class="built_in">this</span>.properties.getConfigurationProperties());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// MyBatis拦截器</span></span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.interceptors)) &#123;</span><br><span class="line">    factory.setPlugins(<span class="built_in">this</span>.interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 主键Id生成器</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.databaseIdProvider != <span class="literal">null</span>) &#123;</span><br><span class="line">    factory.setDatabaseIdProvider(<span class="built_in">this</span>.databaseIdProvider);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接收数据JavaBean所在的包</span></span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.properties.getTypeAliasesPackage())) &#123;</span><br><span class="line">    factory.setTypeAliasesPackage(<span class="built_in">this</span>.properties.getTypeAliasesPackage());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接收数据JavaBean父类</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.properties.getTypeAliasesSuperType() != <span class="literal">null</span>) &#123;</span><br><span class="line">    factory.setTypeAliasesSuperType(<span class="built_in">this</span>.properties.getTypeAliasesSuperType());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 类型处理器所在的包</span></span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(<span class="built_in">this</span>.properties.getTypeHandlersPackage())) &#123;</span><br><span class="line">    factory.setTypeHandlersPackage(<span class="built_in">this</span>.properties.getTypeHandlersPackage());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 手动指定的类型处理器</span></span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.typeHandlers)) &#123;</span><br><span class="line">    factory.setTypeHandlers(<span class="built_in">this</span>.typeHandlers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Mapper.xml所在的位置</span></span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="built_in">this</span>.properties.resolveMapperLocations())) &#123;</span><br><span class="line">    factory.setMapperLocations(<span class="built_in">this</span>.properties.resolveMapperLocations());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断使用的自动SQL脚本驱动，看到这里我才知道SQL模板不仅支持xml，还支持FreeMarker/thymeleaf等模板引擎</span></span><br><span class="line">  Set&lt;String&gt; factoryPropertyNames = Stream</span><br><span class="line">      .of(<span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)</span><br><span class="line">      .collect(Collectors.toSet());</span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">LanguageDriver</span>&gt; defaultLanguageDriver = <span class="built_in">this</span>.properties.getDefaultScriptingLanguageDriver();</span><br><span class="line">  <span class="keyword">if</span> (factoryPropertyNames.contains(<span class="string">&quot;scriptingLanguageDrivers&quot;</span>) &amp;&amp; !ObjectUtils.isEmpty(<span class="built_in">this</span>.languageDrivers)) &#123;</span><br><span class="line">    <span class="comment">// Need to mybatis-spring 2.0.2+</span></span><br><span class="line">    factory.setScriptingLanguageDrivers(<span class="built_in">this</span>.languageDrivers);</span><br><span class="line">    <span class="keyword">if</span> (defaultLanguageDriver == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.languageDrivers.length == <span class="number">1</span>) &#123;</span><br><span class="line">      defaultLanguageDriver = <span class="built_in">this</span>.languageDrivers[<span class="number">0</span>].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (factoryPropertyNames.contains(<span class="string">&quot;defaultScriptingLanguageDriver&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// Need to mybatis-spring 2.0.2+</span></span><br><span class="line">    factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建SqlSessionFactory，在这里做了MyBatis上下文的初始化。</span></span><br><span class="line">  <span class="keyword">return</span> factory.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来到这里，终于进来了 <code>MyBatis</code> 的内容了，就是开始读取配置，解析，然后这个 <code>Configuration</code> 类将贯穿相应使用 <code>MyBatis</code> 的整个生命周期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SqlSessionFactoryBean.Java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">    afterPropertiesSet();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// 校验连接池是否存在</span></span><br><span class="line">  notNull(dataSource, <span class="string">&quot;Property &#x27;dataSource&#x27; is required&quot;</span>);</span><br><span class="line">  notNull(sqlSessionFactoryBuilder, <span class="string">&quot;Property &#x27;sqlSessionFactoryBuilder&#x27; is required&quot;</span>);</span><br><span class="line">  <span class="comment">// &#x27;configuration&#x27; and &#x27;configLocation&#x27;不能同时声明</span></span><br><span class="line">  state((configuration == <span class="literal">null</span> &amp;&amp; configLocation == <span class="literal">null</span>)  !(configuration != <span class="literal">null</span> &amp;&amp; configLocation != <span class="literal">null</span>),</span><br><span class="line">        <span class="string">&quot;Property &#x27;configuration&#x27; and &#x27;configLocation&#x27; can not specified with together&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始构建</span></span><br><span class="line">  <span class="built_in">this</span>.sqlSessionFactory = buildSqlSessionFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前官方示例给的一个配置就是简单的扫描接收类型的包以及 <code>Mapper</code> 映射的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;package name=&quot;sample.mybatis.domain&quot;/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;sample/mybatis/mapper/CityMapper.xml&quot;/&gt;</span><br><span class="line">        &lt;mapper resource=&quot;sample/mybatis/mapper/HotelMapper.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>进入 <code>buildSqlSessionFactory</code> 我们就可以看到配置熟悉的东西都在这里被解析，这个代码没点 <code>j8</code> 基础都看不懂了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SqlSessionFactoryBean.Java</span></span><br><span class="line"><span class="keyword">protected</span> SqlSessionFactory <span class="title function_">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Configuration targetConfiguration;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Builder模式</span></span><br><span class="line">  <span class="type">XMLConfigBuilder</span> <span class="variable">xmlConfigBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 如果我们配置了 configuration 对象，这里可以减少xml的读取，有效提速吧</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.configuration != <span class="literal">null</span>) &#123;</span><br><span class="line">    targetConfiguration = <span class="built_in">this</span>.configuration;</span><br><span class="line">    <span class="keyword">if</span> (targetConfiguration.getVariables() == <span class="literal">null</span>) &#123;</span><br><span class="line">      targetConfiguration.setVariables(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.configurationProperties != <span class="literal">null</span>) &#123;</span><br><span class="line">      targetConfiguration.getVariables().putAll(<span class="built_in">this</span>.configurationProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 构建XMLConfigBuilder，与下面的SpringBoot配置一起解析</span></span><br><span class="line">    xmlConfigBuilder = <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(<span class="built_in">this</span>.configLocation.getInputStream(), <span class="literal">null</span>, <span class="built_in">this</span>.configurationProperties);</span><br><span class="line">    <span class="comment">// 还没解析，只是先把默认的 Configuration 引用拿到</span></span><br><span class="line">    targetConfiguration = xmlConfigBuilder.getConfiguration();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有配置，使用默认的配置</span></span><br><span class="line">    LOGGER.debug(</span><br><span class="line">        () -&gt; <span class="string">&quot;Property &#x27;configuration&#x27; or &#x27;configLocation&#x27; not specified, using default MyBatis Configuration&quot;</span>);</span><br><span class="line">    targetConfiguration = <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">    Optional.ofNullable(<span class="built_in">this</span>.configurationProperties).ifPresent(targetConfiguration::setVariables);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象工厂</span></span><br><span class="line">  Optional.ofNullable(<span class="built_in">this</span>.objectFactory).ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">  <span class="comment">// 对象包装工厂  </span></span><br><span class="line"> Optional.ofNullable(<span class="built_in">this</span>.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">  <span class="comment">// SpringBoot扫描的资源了</span></span><br><span class="line">  Optional.ofNullable(<span class="built_in">this</span>.vfs).ifPresent(targetConfiguration::setVfsImpl);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------------- 下面是通过SpringBoot自动配置的方式去整合xml的配置了 -------------</span></span><br><span class="line">  <span class="keyword">if</span> (hasLength(<span class="built_in">this</span>.typeAliasesPackage)) &#123;</span><br><span class="line">    scanClasses(<span class="built_in">this</span>.typeAliasesPackage, <span class="built_in">this</span>.typeAliasesSuperType).stream()</span><br><span class="line">        .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())</span><br><span class="line">        .filter(clazz -&gt; !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isEmpty(<span class="built_in">this</span>.typeAliases)) &#123;</span><br><span class="line">    Stream.of(<span class="built_in">this</span>.typeAliases).forEach(typeAlias -&gt; &#123;</span><br><span class="line">      targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Registered type alias: &#x27;&quot;</span> + typeAlias + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isEmpty(<span class="built_in">this</span>.plugins)) &#123;</span><br><span class="line">    Stream.of(<span class="built_in">this</span>.plugins).forEach(plugin -&gt; &#123;</span><br><span class="line">      targetConfiguration.addInterceptor(plugin);</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Registered plugin: &#x27;&quot;</span> + plugin + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasLength(<span class="built_in">this</span>.typeHandlersPackage)) &#123;</span><br><span class="line">    scanClasses(<span class="built_in">this</span>.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())</span><br><span class="line">        .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))</span><br><span class="line">        .forEach(targetConfiguration.getTypeHandlerRegistry()::register);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isEmpty(<span class="built_in">this</span>.typeHandlers)) &#123;</span><br><span class="line">    Stream.of(<span class="built_in">this</span>.typeHandlers).forEach(typeHandler -&gt; &#123;</span><br><span class="line">      targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Registered type handler: &#x27;&quot;</span> + typeHandler + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isEmpty(<span class="built_in">this</span>.scriptingLanguageDrivers)) &#123;</span><br><span class="line">    Stream.of(<span class="built_in">this</span>.scriptingLanguageDrivers).forEach(languageDriver -&gt; &#123;</span><br><span class="line">      targetConfiguration.getLanguageRegistry().register(languageDriver);</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Registered scripting language driver: &#x27;&quot;</span> + languageDriver + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Optional.ofNullable(<span class="built_in">this</span>.defaultScriptingLanguageDriver)</span><br><span class="line">      .ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.databaseIdProvider != <span class="literal">null</span>) &#123;<span class="comment">// fix #64 set databaseId before parse mapper xmls</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      targetConfiguration.setDatabaseId(<span class="built_in">this</span>.databaseIdProvider.getDatabaseId(<span class="built_in">this</span>.dataSource));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed getting a databaseId&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Optional.ofNullable(<span class="built_in">this</span>.cache).ifPresent(targetConfiguration::addCache);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (xmlConfigBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 解析xml，将配置应用到Configuration中</span></span><br><span class="line">      xmlConfigBuilder.parse();</span><br><span class="line">      LOGGER.debug(() -&gt; <span class="string">&quot;Parsed configuration file: &#x27;&quot;</span> + <span class="built_in">this</span>.configLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse config resource: &quot;</span> + <span class="built_in">this</span>.configLocation, ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  targetConfiguration.setEnvironment(<span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="built_in">this</span>.environment,</span><br><span class="line">      <span class="built_in">this</span>.transactionFactory == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">SpringManagedTransactionFactory</span>() : <span class="built_in">this</span>.transactionFactory,</span><br><span class="line">      <span class="built_in">this</span>.dataSource));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was specified but matching resources are not found.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (Resource mapperLocation : <span class="built_in">this</span>.mapperLocations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapperLocation == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="type">XMLMapperBuilder</span> <span class="variable">xmlMapperBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(mapperLocation.getInputStream(),</span><br><span class="line">              targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">          xmlMapperBuilder.parse();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedIOException</span>(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法就是简单的将配置放入 DefaultSqlSessionFactory 中返回出去</span></span><br><span class="line">  <span class="comment">// 用于在项目中需要开启SqlSession的时候可以用到</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  public SqlSessionFactory build(Configuration config) &#123;</span></span><br><span class="line"><span class="comment">    return new DefaultSqlSessionFactory(config);</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析Configuration-xml"><a href="#解析Configuration-xml" class="headerlink" title="解析Configuration.xml"></a>解析Configuration.xml</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XMLConfigBuilder.java</span></span><br><span class="line"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="literal">true</span>;</span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XMLConfigBuilder.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 解析属性元素</span></span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里大概就是 <code>Configuration.xml</code> 的所有内容的解析，那我们就直接看看解析 <code>SqlMapper</code> 的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;mapper resource=&quot;sample/mybatis/mapper/HotelMapper.xml&quot;/&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 resource</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 来到这里开始解析</span></span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          <span class="comment">// 解析的重点</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解析Mapper-xml"><a href="#解析Mapper-xml" class="headerlink" title="解析Mapper.xml"></a>解析Mapper.xml</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XMLMapperBuilder.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">// 解析解析所有标签</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">    <span class="comment">// 标记已经解析完成</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">// 注册接口和xml绑定的类型</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析ResultMaps</span></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  <span class="comment">// 解析缓存</span></span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  <span class="comment">// 解析SQL语句</span></span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析Statement语句"><a href="#解析Statement语句" class="headerlink" title="解析Statement语句"></a>解析Statement语句</h3><p>主要是解析标签比较重要，我们现在进入来看看 <code>configurationElement(parser.evalNode(&quot;/mapper&quot;))</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configurationElement</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;namespace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (namespace == <span class="literal">null</span>  namespace.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Mapper&#x27;s namespace cannot be empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">    cacheRefElement(context.evalNode(<span class="string">&quot;cache-ref&quot;</span>));</span><br><span class="line">    cacheElement(context.evalNode(<span class="string">&quot;cache&quot;</span>));</span><br><span class="line">    parameterMapElement(context.evalNodes(<span class="string">&quot;/mapper/parameterMap&quot;</span>));</span><br><span class="line">    resultMapElements(context.evalNodes(<span class="string">&quot;/mapper/resultMap&quot;</span>));</span><br><span class="line">    sqlElement(context.evalNodes(<span class="string">&quot;/mapper/sql&quot;</span>));</span><br><span class="line">    buildStatementFromContext(context.evalNodes(<span class="string">&quot;selectinsertupdatedelete&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing Mapper XML. The XML location is &#x27;&quot;</span> + resource + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合 <code>Mapper.xml</code> 来看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;sample.mybatis.mapper.HotelMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;selectByCityId&quot; resultType=&quot;Hotel&quot;&gt;</span><br><span class="line">        select city, name, address, zip from hotel where city = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<p>解析语句是发生在 <code>buildStatementFromContext</code> 里面的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> &#123;</span><br><span class="line">  <span class="comment">// 根据不同的数据库id来绑定语句</span></span><br><span class="line">  <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="literal">null</span>) &#123;</span><br><span class="line">    buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">  &#125;</span><br><span class="line">  buildStatementFromContext(list, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不得不说，<code>MyBatis</code> 还真的是喜欢 <code>Builder</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> &#123;</span><br><span class="line">  <span class="comment">// 循环每一个 statement 标签，开始解析</span></span><br><span class="line">  <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">XMLStatementBuilder</span> <span class="variable">statementParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLStatementBuilder</span>(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发生解析，将 mapper.xml 的信息存入 Configuration</span></span><br><span class="line">      statementParser.parseStatementNode();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">      configuration.addIncompleteStatement(statementParser);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseStatementNode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">databaseId</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="built_in">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">nodeName</span> <span class="operator">=</span> context.getNode().getNodeName();</span><br><span class="line">  <span class="type">SqlCommandType</span> <span class="variable">sqlCommandType</span> <span class="operator">=</span> SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isSelect</span> <span class="operator">=</span> sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">flushCache</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">useCache</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">resultOrdered</span> <span class="operator">=</span> context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">  <span class="type">XMLIncludeTransformer</span> <span class="variable">includeParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLIncludeTransformer</span>(configuration, builderAssistant);</span><br><span class="line">  includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">parameterType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">lang</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">  <span class="type">LanguageDriver</span> <span class="variable">langDriver</span> <span class="operator">=</span> getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">  processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">  KeyGenerator keyGenerator;</span><br><span class="line">  <span class="type">String</span> <span class="variable">keyStatementId</span> <span class="operator">=</span> id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">  keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">    keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">        configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">        ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建SQLSource对象，这个接口将动态SQL和静态的划分成两个不同的对象</span></span><br><span class="line">  <span class="type">SqlSource</span> <span class="variable">sqlSource</span> <span class="operator">=</span> langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">  <span class="comment">// 获取判断是否是预编译的SQL语句</span></span><br><span class="line">  <span class="type">StatementType</span> <span class="variable">statementType</span> <span class="operator">=</span> StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">fetchSize</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">timeout</span> <span class="operator">=</span> context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">parameterMap</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">  <span class="comment">// 获取返回的对象类型</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">resultType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">  <span class="comment">// 结合配置文件中的typeAliases来获取到Class对象</span></span><br><span class="line">  Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">  <span class="type">String</span> <span class="variable">resultMap</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">resultSetType</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">  <span class="type">ResultSetType</span> <span class="variable">resultSetTypeEnum</span> <span class="operator">=</span> resolveResultSetType(resultSetType);</span><br><span class="line">  <span class="keyword">if</span> (resultSetTypeEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">    resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">String</span> <span class="variable">keyProperty</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">keyColumn</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">resultSets</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过builderAssistant将Mapper对象塞入Configuration</span></span><br><span class="line">  builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">      fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">      resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">      keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过构建好的配置信息，将查询的配置加入 <code>Configuration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// builderAssistant.addMappedStatement</span></span><br><span class="line"><span class="keyword">public</span> MappedStatement <span class="title function_">addMappedStatement</span><span class="params">(</span></span><br><span class="line"><span class="params">    String id,</span></span><br><span class="line"><span class="params">    SqlSource sqlSource,</span></span><br><span class="line"><span class="params">    StatementType statementType,</span></span><br><span class="line"><span class="params">    SqlCommandType sqlCommandType,</span></span><br><span class="line"><span class="params">    Integer fetchSize,</span></span><br><span class="line"><span class="params">    Integer timeout,</span></span><br><span class="line"><span class="params">    String parameterMap,</span></span><br><span class="line"><span class="params">    Class&lt;?&gt; parameterType,</span></span><br><span class="line"><span class="params">    String resultMap,</span></span><br><span class="line"><span class="params">    Class&lt;?&gt; resultType,</span></span><br><span class="line"><span class="params">    ResultSetType resultSetType,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> flushCache,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> useCache,</span></span><br><span class="line"><span class="params">    <span class="type">boolean</span> resultOrdered,</span></span><br><span class="line"><span class="params">    KeyGenerator keyGenerator,</span></span><br><span class="line"><span class="params">    String keyProperty,</span></span><br><span class="line"><span class="params">    String keyColumn,</span></span><br><span class="line"><span class="params">    String databaseId,</span></span><br><span class="line"><span class="params">    LanguageDriver lang,</span></span><br><span class="line"><span class="params">    String resultSets)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unresolvedCacheRef) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IncompleteElementException</span>(<span class="string">&quot;Cache-ref not yet resolved&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取id，sample.mybatis.mapper.HotelMapper.selectByCityId</span></span><br><span class="line">  id = applyCurrentNamespace(id, <span class="literal">false</span>);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isSelect</span> <span class="operator">=</span> sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">  MappedStatement.<span class="type">Builder</span> <span class="variable">statementBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappedStatement</span>.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">      .resource(resource)</span><br><span class="line">      .fetchSize(fetchSize)</span><br><span class="line">      .timeout(timeout)</span><br><span class="line">      .statementType(statementType)</span><br><span class="line">      .keyGenerator(keyGenerator)</span><br><span class="line">      .keyProperty(keyProperty)</span><br><span class="line">      .keyColumn(keyColumn)</span><br><span class="line">      .databaseId(databaseId)</span><br><span class="line">      .lang(lang)</span><br><span class="line">      .resultOrdered(resultOrdered)</span><br><span class="line">      .resultSets(resultSets)</span><br><span class="line">      .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">      .resultSetType(resultSetType)</span><br><span class="line">      .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">      .useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">      .cache(currentCache);</span><br><span class="line"></span><br><span class="line">  <span class="type">ParameterMap</span> <span class="variable">statementParameterMap</span> <span class="operator">=</span> getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">  <span class="keyword">if</span> (statementParameterMap != <span class="literal">null</span>) &#123;</span><br><span class="line">    statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">MappedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> statementBuilder.build();</span><br><span class="line">  <span class="comment">// 存入configuration</span></span><br><span class="line">  configuration.addMappedStatement(statement);</span><br><span class="line">  <span class="keyword">return</span> statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册Mapper到MyBatis的Registry"><a href="#注册Mapper到MyBatis的Registry" class="headerlink" title="注册Mapper到MyBatis的Registry"></a>注册Mapper到MyBatis的Registry</h3><p><code>Configuration</code> 中，解析 <code>Mapper</code> 已经完成，接下来就是注册一个接口代理对象到 <code>Configuration</code> 中去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bindMapperForNamespace</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> builderAssistant.getCurrentNamespace();</span><br><span class="line">  <span class="keyword">if</span> (namespace != <span class="literal">null</span>) &#123;</span><br><span class="line">    Class&lt;?&gt; boundType = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 解析接口类型</span></span><br><span class="line">      boundType = Resources.classForName(namespace);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="comment">//ignore, bound type is not required</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (boundType != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">        <span class="comment">// Spring may not know the real resource name so we set a flag</span></span><br><span class="line">        <span class="comment">// to prevent loading again this resource from the mapper interface</span></span><br><span class="line">        <span class="comment">// look at MapperAnnotationBuilder#loadXmlResource</span></span><br><span class="line">        configuration.addLoadedResource(<span class="string">&quot;namespace:&quot;</span> + namespace);</span><br><span class="line">        <span class="comment">// 将当前接口类型添加到Configuration</span></span><br><span class="line">        configuration.addMapper(boundType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">重点就在于这个 `configuration.addMapper` 中：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    mapperRegistry.addMapper(type);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is already known to the MapperRegistry.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">loadCompleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 MapperProxyFactory 封装接口类型，加入Registery中</span></span><br><span class="line">            knownMappers.put(type, <span class="keyword">new</span> <span class="title class_">MapperProxyFactory</span>&lt;&gt;(type));</span><br><span class="line">            <span class="comment">// 加入后，继续解析这个接口，看看有没有 @Select 之类的注解存在</span></span><br><span class="line">            <span class="type">MapperAnnotationBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperAnnotationBuilder</span>(config, type);</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="literal">true</span>;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">              knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MapperFactoryBean对接Spring"><a href="#MapperFactoryBean对接Spring" class="headerlink" title="MapperFactoryBean对接Spring"></a>MapperFactoryBean对接Spring</h2><p>还记得上面对接 <code>Spring</code> 中 <code>getBean</code> 的对接桥梁吗，就是 <code>MapperFactoryBean</code> 来适配接口的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperFactoryBean</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title class_">SqlSession</span>, DisposableBean &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getConfiguration().getMapper(type, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperRegistry</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxyFactory</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>到达这里，初始化工作基本已经完成，现在我们要看看运行时怎么获取数据的</p>
<hr>
<h2 id="获取代理对象"><a href="#获取代理对象" class="headerlink" title="获取代理对象"></a>获取代理对象</h2><p>那么现在就回到主程序中，来观察 <code>MyBatis</code> 是怎么封装 <code>Mapper</code> 接口来查询数据的，这里我重新贴一下主程序中的查询入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleXmlApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(SampleXmlApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CityDao cityDao;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HotelMapper hotelMapper;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SampleXmlApplication</span><span class="params">(CityDao cityDao, HotelMapper hotelMapper)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cityDao = cityDao;</span><br><span class="line">    <span class="built_in">this</span>.hotelMapper = hotelMapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;squid:S106&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="built_in">this</span>.cityDao.selectCityById(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 常用的是这种方式，我直接看这里了</span></span><br><span class="line">    System.out.println(<span class="built_in">this</span>.hotelMapper.selectByCityId(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚刚上面提到过，<code>MyBatis</code> 在整合 <code>Spring</code> 的时候其实就将自己 <code>Registry</code> 中的 <code>MapperProxy</code> 给放入 <code>BeanDefinition</code> 中，然后交给 <code>Spring</code> 去自动注入到需要依赖的对象。那么现在拿到的对象就是一个 <code>MapperProxy</code>。 既然是 <code>MapperProxy</code>，那要看怎么封装查询数据就是看这个了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (privateLookupInMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethodJava8(proxy, method, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethodJava9(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MapperProxy</code> 是何方神圣，哦，是一个 <code>InvocationHandler</code>，这是一个我从来没见过的 <code>jdk</code> 接口。<code>J8</code> 专有的动态代理的接口，那他有什么用呢，就是将实现封装在这个实现类里边，实现类有个 <code>invoke</code> 方法需要实现，那么实现类的所有方法被调用时，都需要先走这个方法，这时候我们就可以在 <code>invoke</code> 里面做一些羞羞的事情。</p>
<h2 id="InvocationHandler代理"><a href="#InvocationHandler代理" class="headerlink" title="InvocationHandler代理"></a>InvocationHandler代理</h2><p>那就来示例一下这个东西怎么用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个普通的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeHandler</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">InvokeHandler</span><span class="params">(Class&lt;T&gt; tClass)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = tClass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将会拦截接口的方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;调用到这里来了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个代理对象，接口中方法被调用的时候，均为走上面的invoke方法</span></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">getProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(type.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;type&#125;, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvoke</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokeHandler</span>&lt;&gt;(A.class).getProxy();</span><br><span class="line">    proxy.add();<span class="comment">// 输出：调用到这里来了</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那就是说，<code>MapperProxy</code> 拦截了我们所有接口的调用，然后，从这里读取了 <code>mapper.xml</code> 中配置的 <code>SQL</code> 语句，然后调用 <code>jdbc</code> 做相对应的查询。</p>
<h2 id="获取MapperMethod"><a href="#获取MapperMethod" class="headerlink" title="获取MapperMethod"></a>获取MapperMethod</h2><p>OK，弄清楚了动态代理，现在回来看看怎么被调用的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (privateLookupInMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava8(proxy, method, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> invokeDefaultMethodJava9(proxy, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面是j8后新增的默认方法的读取，以及判断代理的方法是否是对象</span></span><br><span class="line">    <span class="comment">// 如果哪个为是，直接调用实现的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里开始就是MyBatis自己的实现</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">MapperMethod</span> <span class="variable">mapperMethod</span> <span class="operator">=</span> cachedMapperMethod(method);</span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> MapperMethod <span class="title function_">cachedMapperMethod</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">    <span class="comment">// 从缓存命中，如果没有就创建</span></span><br><span class="line">    <span class="keyword">return</span> methodCache.computeIfAbsent(method,</span><br><span class="line">    k -&gt; <span class="keyword">new</span> <span class="title class_">MapperMethod</span>(mapperInterface, method,  sqlSession.getConfiguration()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MapperMethod调用"><a href="#MapperMethod调用" class="headerlink" title="MapperMethod调用"></a>MapperMethod调用</h2><p>先来看看 <code>MapperMethod</code> 有什么属性，方法肯定就是上面的 <code>execute</code> 是重中之重：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是两个内部类对象，一个封装SQL一个封装方法的签名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.command = <span class="keyword">new</span> <span class="title class_">SqlCommand</span>(config, mapperInterface, method);</span><br><span class="line">    <span class="built_in">this</span>.method = <span class="keyword">new</span> <span class="title class_">MethodSignature</span>(config, mapperInterface, method);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="comment">// 根据不同的SQL类型去调用不同的方法</span></span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="comment">// 查询进入这里</span></span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 由于主程序只是查询一个，所以跑这里来了</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果带有@Param则要根据名字匹配，如果没有，则根据args的顺序来查找</span></span><br><span class="line">          <span class="type">Object</span> <span class="variable">param</span> <span class="operator">=</span> method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          <span class="comment">// sqlSession=SqlSessionTemplate，一个对接Spring事务管理器的对象</span></span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          <span class="comment">// 如果是j8的Optional返回的话，需要使用Optional封装结果</span></span><br><span class="line">          <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result == <span class="literal">null</span>  !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName()</span><br><span class="line">          + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SqlSession拦截器"><a href="#SqlSession拦截器" class="headerlink" title="SqlSession拦截器"></a>SqlSession拦截器</h2><p>上面的代码我们来到了 <code>sqlSession.selectOne</code> 这句话，所以进入代码看看是发生什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title class_">SqlSession</span>, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionProxy.selectOne(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Proxy needed to route MyBatis method calls to the proper SqlSession got from Spring&#x27;s Transaction Manager It also</span></span><br><span class="line"><span class="comment">   * unwraps exceptions thrown by &#123;<span class="doctag">@code</span> Method#invoke(Object, Object...)&#125; to pass a &#123;<span class="doctag">@code</span> PersistenceException&#125; to the</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> PersistenceExceptionTranslator&#125;.</span></span><br><span class="line"><span class="comment">   * 翻译：代理需要路由MyBatis去调用SpringTX产生出来的SqlSession</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="comment">// 调用下面的方法去获取兼容SpringTX的SqlSession</span></span><br><span class="line">      <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> getSqlSession(SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory,</span><br><span class="line">          SqlSessionTemplate.<span class="built_in">this</span>.executorType, SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行方法内容 真正的SqlSession的SelectOne函数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(sqlSession, args);</span><br><span class="line">        <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">          <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">          <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">          <span class="comment">// 提交事务</span></span><br><span class="line">          sqlSession.commit(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">unwrapped</span> <span class="operator">=</span> unwrapThrowable(t);</span><br><span class="line">        <span class="keyword">if</span> (SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator != <span class="literal">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">          <span class="comment">// 也是关闭回滚</span></span><br><span class="line">          closeSqlSession(sqlSession, SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">          sqlSession = <span class="literal">null</span>;</span><br><span class="line">          <span class="type">Throwable</span> <span class="variable">translated</span> <span class="operator">=</span> SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator</span><br><span class="line">              .translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">          <span class="keyword">if</span> (translated != <span class="literal">null</span>) &#123;</span><br><span class="line">            unwrapped = translated;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> unwrapped;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭SqlSession并且将连接放回连接池</span></span><br><span class="line">        <span class="keyword">if</span> (sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">          closeSqlSession(sqlSession, SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType,</span></span><br><span class="line"><span class="params">      PersistenceExceptionTranslator exceptionTranslator)</span> &#123;</span><br><span class="line"></span><br><span class="line">    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);</span><br><span class="line">    notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取SpringTX事务的适配器</span></span><br><span class="line">    <span class="type">SqlSessionHolder</span> <span class="variable">holder</span> <span class="operator">=</span> (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sessionHolder(executorType, holder);</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">&quot;Creating a new SqlSession&quot;</span>);</span><br><span class="line">    session = sessionFactory.openSession(executorType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有Spring的事务注解的话，则会将事务注册到SpringTX模块中</span></span><br><span class="line">    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h2><p>好，总体的开启 <code>SqlSession</code> 啊，对接事务的，有个了解，现在具体到怎么查询的问题，那就是 <code>SqlSession</code> 了。 算了，下集一起说……. <code>To Be Continue...</code></p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring源码】SpringBoot_MyBatis_starter源码（二）</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot-mybatis-starter%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/index.html</url>
    <content><![CDATA[<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>好了，继上一节的 <code>SqlSession</code> 继续，一气呵成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> getSqlSession(SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory,</span><br><span class="line">        SqlSessionTemplate.<span class="built_in">this</span>.executorType, SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 来到这里调用SqlSession的方法</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(sqlSession, args);</span><br><span class="line">      <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">        <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">        <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">        sqlSession.commit(<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="type">Throwable</span> <span class="variable">unwrapped</span> <span class="operator">=</span> unwrapThrowable(t);</span><br><span class="line">      <span class="keyword">if</span> (SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator != <span class="literal">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">        <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">        sqlSession = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">translated</span> <span class="operator">=</span> SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator</span><br><span class="line">            .translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">        <span class="keyword">if</span> (translated != <span class="literal">null</span>) &#123;</span><br><span class="line">          unwrapped = translated;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> unwrapped;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sqlSession != <span class="literal">null</span>) &#123;</span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>OK，来到 <code>DefaultSqlSession#selectOne</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line"><span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">  List&lt;T&gt; list = <span class="built_in">this</span>.selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooManyResultsException</span>(<span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看得到，有对象封装的情况下，无论查询一个还是多个，都是使用 <code>List</code> 来接收。</p>
<!-- more -->
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot-mybatis-starter%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89.md/0.png"></p>
<p> 应该不难理解他是干嘛的，就是存储 <code>SQL</code> 的执行情况。</p>
<h2 id="Executor执行查询"><a href="#Executor执行查询" class="headerlink" title="Executor执行查询"></a>Executor执行查询</h2><p>官网上是这么写的：</p>
<blockquote>
<p>ExecutorType.SIMPLE：这个执行器类型不做特殊的事情。它为每个语句的执行创建一个新的预处理语句。 ExecutorType.REUSE：这个执行器类型会复用预处理语句。 ExecutorType.BATCH：这个执行器会批量执行所有更新语句，如果 SELECT 在它们中间执行，必要时请把它们区分开来以保证行为的易读性。</p>
</blockquote>
<p>那现在默认是启用 <code>Cache</code> 的（装配的时候，注入了 <code>CachingExecutor</code>，他可以说是个装饰类，装饰了 <code>SimpleExecutor</code>，必要的时候缓存数据）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> ms.getBoundSql(parameterObject);</span><br><span class="line">    <span class="type">CacheKey</span> <span class="variable">key</span> <span class="operator">=</span> createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BoundSql</code> 可以说是一个执行 <code>jdbc</code> 所需要数据的最小子集，剥离了 <code>MyBatis</code> 的配置，那下一步就是一个 <code>CacheKey</code>，我们来看看怎么获取 <code>CacheKey</code> 的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CacheKey <span class="title function_">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> delegate.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// delegate=SimpleExecutor，下面这个方法是在 BaseExecutor 中的</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CacheKey <span class="title function_">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据一些必要的参数取名</span></span><br><span class="line">  <span class="type">CacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CacheKey</span>();</span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  cacheKey.update(rowBounds.getOffset());</span><br><span class="line">  cacheKey.update(rowBounds.getLimit());</span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="type">TypeHandlerRegistry</span> <span class="variable">typeHandlerRegistry</span> <span class="operator">=</span> ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// 处理参数</span></span><br><span class="line">  <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        value = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (configuration.getEnvironment() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// issue #176</span></span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看 <code>query</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Cache</span> <span class="variable">cache</span> <span class="operator">=</span> ms.getCache();</span><br><span class="line">  <span class="comment">// 没有缓存，直接调用下一个Executor查询数据</span></span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="literal">null</span>) &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BaseExecutor</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    list = resultHandler == <span class="literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有缓存，从数据库查询</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>queryFromDatabase</code> 函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 真正查询出来，然后存入缓存</span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="准备Statement"><a href="#准备Statement" class="headerlink" title="准备Statement"></a>准备Statement</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configuration</span></span><br><span class="line"><span class="keyword">public</span> StatementHandler <span class="title function_">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line">  <span class="type">StatementHandler</span> <span class="variable">statementHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoutingStatementHandler</span>(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  <span class="comment">// 使用拦截器的方式，修改StatementHandler</span></span><br><span class="line">  <span class="comment">// 目前拦截器链为空，没有配置任何东西</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那 <code>StatementHandler</code> 类型的 <code>RoutingStatementHandler</code> 是做什么用的，就是指路用什么方式来实现 <code>jdbc</code> 的调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title class_">StatementHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> <span class="title class_">SimpleStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> <span class="title class_">PreparedStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> <span class="title class_">CallableStatementHandler</span>(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那上面拿到了 <code>StatementHandler</code> 以后就是准备跟 <code>Connection</code> 连接在一起了 <code>stmt = prepareStatement(handler, ms.getStatementLog())</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Statement <span class="title function_">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  Statement stmt;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> getConnection(statementLog);</span><br><span class="line">  stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">  <span class="comment">// 然后设置预编译的查询参数</span></span><br><span class="line">  handler.parameterize(stmt);</span><br><span class="line">  <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BaseStatementHandler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Statement <span class="title function_">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化Statement</span></span><br><span class="line">    statement = instantiateStatement(connection);</span><br><span class="line">    <span class="comment">// 设置超时时间</span></span><br><span class="line">    setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">    setFetchSize(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeStatement(statement);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PreparedStatementHandler</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Statement <span class="title function_">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line">  <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">    String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">    <span class="keyword">if</span> (keyColumnNames == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;</span><br><span class="line">    <span class="comment">// 默认ResultSetType方式直接像我们用 jdbc 一样调用</span></span><br><span class="line">    <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数处理器"><a href="#参数处理器" class="headerlink" title="参数处理器"></a>参数处理器</h2><p>也是一样交给了 <code>PreparedStatementHandler</code> 来处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>ParameterHandler</code> 来处理参数，<code>ParameterHandler</code> 是在装配的时候，根据 <code>mapper.xml</code> 来注入参数处理器，像我们使用 <code>xml</code> 就是被装配了个默认的参数处理器（<code>DefaultParameterHandler</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultParameterHandler</span> <span class="keyword">implements</span> <span class="title class_">ParameterHandler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameters</span><span class="params">(PreparedStatement ps)</span> &#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    <span class="comment">// 获取需要的参数mapping</span></span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    <span class="keyword">if</span> (parameterMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">        <span class="type">ParameterMapping</span> <span class="variable">parameterMapping</span> <span class="operator">=</span> parameterMappings.get(i);</span><br><span class="line">        <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">          Object value;</span><br><span class="line">          <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> parameterMapping.getProperty();</span><br><span class="line">          <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">            value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            value = <span class="literal">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">            <span class="comment">// 在MyBatis初始化时已经注册了一系列jdk原生类型的处理器</span></span><br><span class="line">            <span class="comment">// 所以这里不用进行转换，直接注入的值就是参数值</span></span><br><span class="line">            value = parameterObject;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> configuration.newMetaObject(parameterObject);</span><br><span class="line">            value = metaObject.getValue(propertyName);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 获取类型处理器进行处理</span></span><br><span class="line">          <span class="type">TypeHandler</span> <span class="variable">typeHandler</span> <span class="operator">=</span> parameterMapping.getTypeHandler();</span><br><span class="line">          <span class="type">JdbcType</span> <span class="variable">jdbcType</span> <span class="operator">=</span> parameterMapping.getJdbcType();</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="literal">null</span> &amp;&amp; jdbcType == <span class="literal">null</span>) &#123;</span><br><span class="line">            jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (TypeException  SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型解析并处理"><a href="#类型解析并处理" class="headerlink" title="类型解析并处理"></a>类型解析并处理</h2><p>首先使用了一个 <code>UnknownTypeHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BaseTypeHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">if</span> (parameter == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (jdbcType == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;JDBC requires that the JdbcType must be specified for all nullable parameters.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ps.setNull(i, jdbcType.TYPE_CODE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Error setting null for parameter #&quot;</span> + i + <span class="string">&quot; with JdbcType &quot;</span> + jdbcType + <span class="string">&quot; . &quot;</span></span><br><span class="line">            + <span class="string">&quot;Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. &quot;</span></span><br><span class="line">            + <span class="string">&quot;Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      setNonNullParameter(ps, i, parameter, jdbcType);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Error setting non null for parameter #&quot;</span> + i + <span class="string">&quot; with JdbcType &quot;</span> + jdbcType + <span class="string">&quot; . &quot;</span></span><br><span class="line">            + <span class="string">&quot;Try setting a different JdbcType for this parameter or a different configuration property. &quot;</span></span><br><span class="line">            + <span class="string">&quot;Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，父级模板方法调用了 <code>setNonNullParameter</code> 来设置参数，那既然是 <code>UnknownTypeHandler</code> 就需要先判断类型再做事情了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UnknownTypeHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, Object parameter, JdbcType jdbcType)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 第一步：寻找对应的类型处理器</span></span><br><span class="line">  <span class="type">TypeHandler</span> <span class="variable">handler</span> <span class="operator">=</span> resolveTypeHandler(parameter, jdbcType);</span><br><span class="line">  <span class="comment">// 然后就继续调用对应处理器的方法，也就是上面那个</span></span><br><span class="line">  handler.setParameter(ps, i, parameter, jdbcType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> TypeHandler&lt;?&gt; resolveTypeHandler(Object parameter, JdbcType jdbcType) &#123;</span><br><span class="line">  TypeHandler&lt;?&gt; handler;</span><br><span class="line">  <span class="keyword">if</span> (parameter == <span class="literal">null</span>) &#123;</span><br><span class="line">    handler = OBJECT_TYPE_HANDLER;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步：从默认的注册一系列的jdk类型寻找处理器</span></span><br><span class="line">    handler = typeHandlerRegistry.getTypeHandler(parameter.getClass(), jdbcType);</span><br><span class="line">    <span class="comment">// check if handler is null (issue #270)</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>  handler <span class="keyword">instanceof</span> UnknownTypeHandler) &#123;</span><br><span class="line">      handler = OBJECT_TYPE_HANDLER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那寻找到处理器以后，就是 <code>LongTypeHandler</code> 了，继续调用模板方法，这时候就是调用到 <code>LongTypeHandler</code> 的 <code>setNonNullParameter</code> 方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LongTypeHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="type">int</span> i, Long parameter, JdbcType jdbcType)</span></span><br><span class="line">    <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// jdbc老套路</span></span><br><span class="line">  ps.setLong(i, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>回到我们上面查询数据的方法里面来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">    <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">// 接下来处理完成就是调用数据库进行查询了</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RoutingStatementHandler#query</code> 会路由到 <code>PreparedStatementHandler</code> 里面来，所以现在我们就直接进入 <code>PreparedStatementHandler</code> 看就好了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 拿到PreparedStatement</span></span><br><span class="line">  <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">// 执行</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="comment">// 开始处理结果</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理结果封装"><a href="#处理结果封装" class="headerlink" title="处理结果封装"></a>处理结果封装</h2><p><code>resultSetHandler</code> 是一个 <code>DefaultResultSetHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultResultSetHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于存储多个ResultMap处理结果</span></span><br><span class="line">  <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">resultSetCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取ResultSet封装对象数据</span></span><br><span class="line">  <span class="type">ResultSetWrapper</span> <span class="variable">rsw</span> <span class="operator">=</span> getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取配置的ResultMap</span></span><br><span class="line">  List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  private ResultSetWrapper getFirstResultSet(Statement stmt) throws SQLException &#123;</span></span><br><span class="line"><span class="comment">    // 获取jdbc的ResultSet</span></span><br><span class="line"><span class="comment">    ResultSet rs = stmt.getResultSet();</span></span><br><span class="line"><span class="comment">    while (rs == null) &#123;</span></span><br><span class="line"><span class="comment">      // move forward to get the first resultset in case the driver</span></span><br><span class="line"><span class="comment">      // doesn&#x27;t return the resultset as the first result (HSQLDB 2.1)</span></span><br><span class="line"><span class="comment">      if (stmt.getMoreResults()) &#123;</span></span><br><span class="line"><span class="comment">        rs = stmt.getResultSet();</span></span><br><span class="line"><span class="comment">      &#125; else &#123;</span></span><br><span class="line"><span class="comment">        if (stmt.getUpdateCount() == -1) &#123;</span></span><br><span class="line"><span class="comment">          // no more results. Must be no resultset</span></span><br><span class="line"><span class="comment">          break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    // 包装起来</span></span><br><span class="line"><span class="comment">    return rs != null ? new ResultSetWrapper(rs, configuration) : null;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 结果集</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">resultMapCount</span> <span class="operator">=</span> resultMaps.size();</span><br><span class="line">  <span class="comment">// 验证ResultSet是否为空</span></span><br><span class="line">  validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">  <span class="comment">// 循环resultMap列表来封装对象</span></span><br><span class="line">  <span class="keyword">while</span> (rsw != <span class="literal">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">    <span class="comment">// 取出ResultMap，根据ResultMap读取ResultSet</span></span><br><span class="line">    <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> resultMaps.get(resultSetCount);</span><br><span class="line">    <span class="comment">// 处理封装结果集的地方</span></span><br><span class="line">    handleResultSet(rsw, resultMap, multipleResults, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 通过stmt.getConnection().getMetaData().supportsMultipleResultSets()判断是否支持多ResultSet，但是MySQL不支持</span></span><br><span class="line">    rsw = getNextResultSet(stmt);</span><br><span class="line">    cleanUpAfterHandlingResultSet();</span><br><span class="line">    resultSetCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为Null</span></span><br><span class="line">  String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">  <span class="keyword">if</span> (resultSets != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (rsw != <span class="literal">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">      <span class="type">ResultMapping</span> <span class="variable">parentMapping</span> <span class="operator">=</span> nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">      <span class="keyword">if</span> (parentMapping != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">nestedResultMapId</span> <span class="operator">=</span> parentMapping.getNestedResultMapId();</span><br><span class="line">        <span class="type">ResultMap</span> <span class="variable">resultMap</span> <span class="operator">=</span> configuration.getResultMap(nestedResultMapId);</span><br><span class="line">        handleResultSet(rsw, resultMap, <span class="literal">null</span>, parentMapping);</span><br><span class="line">      &#125;</span><br><span class="line">      rsw = getNextResultSet(stmt);</span><br><span class="line">      cleanUpAfterHandlingResultSet();</span><br><span class="line">      resultSetCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收集ResultList</span></span><br><span class="line">  <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，那接下来就是怎么封装对象的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultResultSetHandler.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResultSet</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 继承ResultMapping的处理</span></span><br><span class="line">    <span class="keyword">if</span> (parentMapping != <span class="literal">null</span>) &#123;</span><br><span class="line">      handleRowValues(rsw, resultMap, <span class="literal">null</span>, RowBounds.DEFAULT, parentMapping);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (resultHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有处理器走了这里</span></span><br><span class="line">        <span class="type">DefaultResultHandler</span> <span class="variable">defaultResultHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResultHandler</span>(objectFactory);</span><br><span class="line">        <span class="comment">// 使用默认的结果处理器处理ResultSet数据</span></span><br><span class="line">        handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="literal">null</span>);</span><br><span class="line">        multipleResults.add(defaultResultHandler.getResultList());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// issue #228 (close resultsets)</span></span><br><span class="line">    closeResultSet(rsw.getResultSet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRowValues</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 判断是否有嵌套结果集</span></span><br><span class="line">  <span class="comment">// 比如我们查询的时候在xml的ResultMap中查询子集合的数据</span></span><br><span class="line">  <span class="keyword">if</span> (resultMap.hasNestedResultMaps()) &#123;</span><br><span class="line">    ensureNoRowBounds();</span><br><span class="line">    checkResultHandler();</span><br><span class="line">    handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普通的数据走这里</span></span><br><span class="line">    handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRowValuesForSimpleResultMap</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span></span><br><span class="line">  <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  DefaultResultContext&lt;Object&gt; resultContext = <span class="keyword">new</span> <span class="title class_">DefaultResultContext</span>&lt;&gt;();</span><br><span class="line">  <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> rsw.getResultSet();</span><br><span class="line">  skipRows(resultSet, rowBounds);</span><br><span class="line">  <span class="keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;</span><br><span class="line">    <span class="comment">// 判断配置需要使用到的ResultMap</span></span><br><span class="line">    <span class="type">ResultMap</span> <span class="variable">discriminatedResultMap</span> <span class="operator">=</span> resolveDiscriminatedResultMap(resultSet, resultMap, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 转换成对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rowValue</span> <span class="operator">=</span> getRowValue(rsw, discriminatedResultMap, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 存储到resultContext中</span></span><br><span class="line">    storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">getRowValue</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, String columnPrefix)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ResultLoaderMap</span> <span class="variable">lazyLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultLoaderMap</span>();</span><br><span class="line">  <span class="comment">// 使用无参构造器通过反射构造一个空值的对象</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">rowValue</span> <span class="operator">=</span> createResultObject(rsw, resultMap, lazyLoader, columnPrefix);</span><br><span class="line">  <span class="keyword">if</span> (rowValue != <span class="literal">null</span> &amp;&amp; !hasTypeHandlerForResultObject(rsw, resultMap.getType())) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MetaObject</span> <span class="variable">metaObject</span> <span class="operator">=</span> configuration.newMetaObject(rowValue);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">foundValues</span> <span class="operator">=</span> <span class="built_in">this</span>.useConstructorMappings;</span><br><span class="line">    <span class="keyword">if</span> (shouldApplyAutomaticMappings(resultMap, <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="comment">// 自动映射设置值</span></span><br><span class="line">      foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, columnPrefix)  foundValues;</span><br><span class="line">    &#125;</span><br><span class="line">    foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, columnPrefix)  foundValues;</span><br><span class="line">    foundValues = lazyLoader.size() &gt; <span class="number">0</span>  foundValues;</span><br><span class="line">    rowValue = foundValues  configuration.isReturnInstanceForEmptyRow() ? rowValue : <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rowValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过属性setter设置结果"><a href="#通过属性setter设置结果" class="headerlink" title="通过属性setter设置结果"></a>通过属性setter设置结果</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultResultSetHandler.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">applyAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 建立了自动映射对象</span></span><br><span class="line">  List&lt;UnMappedColumnAutoMapping&gt; autoMapping = createAutomaticMappings(rsw, resultMap, metaObject, columnPrefix);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">foundValues</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!autoMapping.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 开始使用自动映射对象对之前反射的空对象进行设值</span></span><br><span class="line">    <span class="keyword">for</span> (UnMappedColumnAutoMapping mapping : autoMapping) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> mapping.typeHandler.getResult(rsw.getResultSet(), mapping.column);</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        foundValues = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span>  (configuration.isCallSettersOnNulls() &amp;&amp; !mapping.primitive)) &#123;</span><br><span class="line">        <span class="comment">// gcode issue #377, call setter on nulls (value is not &#x27;found&#x27;)</span></span><br><span class="line">        metaObject.setValue(mapping.property, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> foundValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找属性自动映射器"><a href="#查找属性自动映射器" class="headerlink" title="查找属性自动映射器"></a>查找属性自动映射器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultResultSetHandler.java</span></span><br><span class="line"><span class="keyword">private</span> List&lt;UnMappedColumnAutoMapping&gt; <span class="title function_">createAutomaticMappings</span><span class="params">(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">mapKey</span> <span class="operator">=</span> resultMap.getId() + <span class="string">&quot;:&quot;</span> + columnPrefix;</span><br><span class="line">  <span class="comment">// 从缓存中命中</span></span><br><span class="line">  List&lt;UnMappedColumnAutoMapping&gt; autoMapping = autoMappingsCache.get(mapKey);</span><br><span class="line">  <span class="keyword">if</span> (autoMapping == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有命中，开始处理，后存入缓存</span></span><br><span class="line">    autoMapping = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 取出所有数据库列名</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);</span><br><span class="line">    <span class="keyword">for</span> (String columnName : unmappedColumnNames) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">propertyName</span> <span class="operator">=</span> columnName;</span><br><span class="line">      <span class="keyword">if</span> (columnPrefix != <span class="literal">null</span> &amp;&amp; !columnPrefix.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 判断前缀是否与列名匹配，不匹配则跳过处理</span></span><br><span class="line">        <span class="keyword">if</span> (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) &#123;</span><br><span class="line">          propertyName = columnName.substring(columnPrefix.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从对象名中查找属性名，isMapUnderscoreToCamelCase是转换下划线到驼峰的配置，这里是false</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());</span><br><span class="line">      <span class="comment">// 如果没有setter，跳过，继续下个列名处理</span></span><br><span class="line">      <span class="keyword">if</span> (property != <span class="literal">null</span> &amp;&amp; metaObject.hasSetter(property)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultMap.getMappedProperties().contains(property)) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 需要设置的值类型</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; propertyType = metaObject.getSetterType(property);</span><br><span class="line">        <span class="comment">// 预置的处理器进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(propertyType, rsw.getJdbcType(columnName))) &#123;</span><br><span class="line">          <span class="keyword">final</span> TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName);</span><br><span class="line">          autoMapping.add(<span class="keyword">new</span> <span class="title class_">UnMappedColumnAutoMapping</span>(columnName, property, typeHandler, propertyType.isPrimitive()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          configuration.getAutoMappingUnknownColumnBehavior()</span><br><span class="line">              .doAction(mappedStatement, columnName, property, propertyType);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        configuration.getAutoMappingUnknownColumnBehavior()</span><br><span class="line">            .doAction(mappedStatement, columnName, (property != <span class="literal">null</span>) ? property : propertyName, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存起来</span></span><br><span class="line">    autoMappingsCache.put(mapKey, autoMapping);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> autoMapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设值"><a href="#设值" class="headerlink" title="设值"></a>设值</h3><p><code>metaObject.setValue(mapping.property, value)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MetaObject.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String name, Object value)</span> &#123;</span><br><span class="line">  <span class="type">PropertyTokenizer</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyTokenizer</span>(name);</span><br><span class="line">  <span class="comment">// 下一级属性，比如配置了&lt;result property=&quot;addr.name&quot; column=&quot;addr_name&quot;/&gt;property带有小数点的属性</span></span><br><span class="line">  <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">    <span class="type">MetaObject</span> <span class="variable">metaValue</span> <span class="operator">=</span> metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">    <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t instantiate child path if value is null</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        metaValue = objectWrapper.instantiatePropertyValue(name, prop, objectFactory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    metaValue.setValue(prop.getChildren(), value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有直接设置值到对象的属性</span></span><br><span class="line">    objectWrapper.set(prop, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BeanWrapper</code>，一个包装实际对象的封装对象，封装操作这个对象的函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BeanWrapper.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prop.getIndex() != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 集合属性的封装</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">collection</span> <span class="operator">=</span> resolveCollection(prop, object);</span><br><span class="line">    setCollectionValue(prop, collection, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 单个普通属性的封装</span></span><br><span class="line">    setBeanProperty(prop, object, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过反射获取setter设置对象的数据库值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Invoker</span> <span class="variable">method</span> <span class="operator">=</span> metaClass.getSetInvoker(prop.getName());</span><br><span class="line">    Object[] params = &#123;value&#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      method.invoke(object, params);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReflectionException</span>(<span class="string">&quot;Could not set property &#x27;&quot;</span> + prop.getName() + <span class="string">&quot;&#x27; of &#x27;&quot;</span> + object.getClass() + <span class="string">&quot;&#x27; with value &#x27;&quot;</span> + value + <span class="string">&quot;&#x27; Cause: &quot;</span> + t.toString(), t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，所有属性值循环完成，开始出栈，出去到哪里，到 <code>SqlSession</code> 出去。</p>
<h2 id="返回结果对象集"><a href="#返回结果对象集" class="headerlink" title="返回结果对象集"></a>返回结果对象集</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span> &#123;</span><br><span class="line">  <span class="comment">// 都是查询集合，根据查询个数进行判断</span></span><br><span class="line">  List&lt;T&gt; list = <span class="built_in">this</span>.selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 超过一个结果就会报这个错误，应该不陌生吧</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooManyResultsException</span>(<span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring源码】SpringWeb容器_基于SpringBoot</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springweb%E5%AE%B9%E5%99%A8-%E5%9F%BA%E4%BA%8Espringboot/index.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>由于现在基本使用的都是 <code>SpringBoot</code> 项目来启动，所以我就直接建立在 <code>SpringBoot</code> 基础下看 <code>WEB</code> 容器了。 如果有一些项目开发经验就知道，<code>SpringWEB</code> 模块又名 <code>SpringMVC</code>，提供了视图数据整合以及可以直接返回 <code>JSON</code> 数据。前几年 <code>JSP</code> 当道的时候，各种 <code>ViewResolver</code> 层出不穷，据我所知的就有 <code>FreeMarker</code> <code>JSP</code> <code>Beetl</code> 等等。不过最近几年前端发生爆炸性变化，前后端能分离的都分离了，需要 <code>SEO</code> 的也很少使用 <code>Java</code> 来做了。所以现在 <code>Java</code> 后端项目的主要责职是提供业务所需要的交互数据给前端，不仅仅使用 <code>JSON</code>，还可以整合其他的传输协议，比如 <code>Hessian</code> <code>XML</code> <code>Protobuf</code> 等等，只要够折腾，什么格式都可以返回，不想折腾就使用 <code>JSON</code> 就可以了。 数据转换模块也会被 <code>Spring</code> 独立出来这个自然不需要再猜测，所以我们也可以为了减少传输使用的宽带，去定义第几个字节是什么东西。 那我们现在可以直接进入 <code>SpringMVC</code> 的源码来看看了。</p>
<a id="more"></a>
<h2 id="初始化Web环境"><a href="#初始化Web环境" class="headerlink" title="初始化Web环境"></a>初始化Web环境</h2><p>在 <code>JavaWEB</code> 中，如果需要提供网络服务，一般是实现 <code>Servlet</code> 对象，像 <code>Tomcat</code> <code>Resign</code> 等网络容器都提供了自己的实现，我们就简单的用常用的 <code>Tomcat</code> 来说，<code>Tomcat</code> 会拿到我们项目中所有的 <code>HTTPServlet</code> 然后根据不同的 <code>HTTP Method</code> <code>HTTP URL</code> 来调用不同的 <code>Servlet</code> 方法来完成请求。 那 <code>SpringMVC</code> 是在 <code>Servlet</code> 级别的，所以这个容器必定会存在，那就是 <code>DispatcherServlet</code>。简单的理解 <code>DispatcherServlet</code> 就是一个在项目启动时<strong>读取</strong>了所有请求处理器，然后有请求进来<strong>根据不同的定义来调用不同的请求处理器</strong>的一个 <code>Servlet</code> 容器。 把断点打在 <code>DispatcherServlet</code> 的无参构造器上，找到初始化入口，是在 <code>refreshContext(context)</code> 中进行的，那我们就从这里开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line"> <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line"> stopWatch.start();</span><br><span class="line"> <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> configureHeadlessProperty();</span><br><span class="line"> <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line"> listeners.starting();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">  <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">  configureIgnoreBeanInfo(environment);</span><br><span class="line">  <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">  <span class="comment">// 我们之前说过，这里会根据依赖的 jar 环境来创建不同的 Context</span></span><br><span class="line">  <span class="comment">// 所以现在创建的是 AnnotationConfigServletWebServerApplicationContext 容器</span></span><br><span class="line">  context = createApplicationContext();</span><br><span class="line">  exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">  prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">  <span class="comment">// 刷新容器</span></span><br><span class="line">  refreshContext(context);</span><br><span class="line">  afterRefresh(context, applicationArguments);</span><br><span class="line">  stopWatch.stop();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">  &#125;</span><br><span class="line">  listeners.started(context);</span><br><span class="line">  callRunners(context, applicationArguments);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  listeners.running(context);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  handleRunFailure(context, ex, exceptionReporters, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一系列之前说过的步骤以后，来到这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line"> Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line"> ((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前说过，调用 <code>refresh</code> 是个模板方法，<code>AbstractApplicationContext</code> 的 <code>refresh</code> 是个模板方法，会调用子类实现的 <code>onRefresh</code>。因为当前是个 <code>WEB</code> 项目，所以实现类 <code>AnnotationConfigServletWebServerApplicationContext</code> 的 <code>onRefresh</code> 提供了实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>.onRefresh();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  createWebServer();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start web server&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一件事请 <code>super.onRefresh()</code> 是调用父级 <code>GenericWebApplicationContext</code> 的函数，不过这段函数现在看来应该没什么多大的用处了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化界面主题容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.themeSource = UiApplicationContextUtils.initThemeSource(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是一个初始化界面主题的函数，一开始我还怀疑这个主题是不是什么主题，然而进入 <code>UiApplicationContextUtils.initThemeSource</code> 看的时候，还真的就是 <code>HTML</code> 主题，里面定义了从哪里读取 <code>CSS</code> 呀这些鬼东西，跳过不看。 重点来看看 <code>createWebServer()</code> 做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> <span class="built_in">this</span>.webServer;</span><br><span class="line"> <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"> <span class="keyword">if</span> (webServer == <span class="literal">null</span> &amp;&amp; servletContext == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 工厂模式</span></span><br><span class="line">  <span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getWebServerFactory();</span><br><span class="line">  <span class="comment">// 创建webServer</span></span><br><span class="line">  <span class="built_in">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   getSelfInitializer().onStartup(servletContext);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 初始化配置属性</span></span><br><span class="line"> initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候获取了一个 <code>ServletWebServerFactory</code> 的 <code>BeanDefinition</code>，然后使用这个 <code>Factory</code> 来创建我们目前的 <code>Web</code> 环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ServletWebServerFactory <span class="title function_">getWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// Use bean names so that we don&#x27;t consider the hierarchy</span></span><br><span class="line"> String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class="line"> <span class="keyword">if</span> (beanNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;</span></span><br><span class="line">    + <span class="string">&quot;ServletWebServerFactory bean.&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;</span></span><br><span class="line">    + <span class="string">&quot;ServletWebServerFactory beans : &quot;</span> + StringUtils.arrayToCommaDelimitedString(beanNames));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> getBeanFactory().getBean(beanNames[<span class="number">0</span>], ServletWebServerFactory.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内置Tomcat注入"><a href="#内置Tomcat注入" class="headerlink" title="内置Tomcat注入"></a>内置Tomcat注入</h2><p>然而这个<code>ServletWebServerFactory</code> 什么时候偷偷被放进去的，我们现在快速过一遍：</p>
<ol>
<li> <code>SpringBoot</code> 启动的时候，在构造器调用了元信息读取器，读取了 <code>META-INF/spring.factories</code> 中配置的工厂，后初始化的时候会用到这些配置的类；</li>
<li> <code>SpringBoot</code> 中上面的配置文件配置了这个工厂：<code>ServletWebServerFactoryAutoConfiguration</code></li>
<li> 看这个工厂有什么信息：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span></span><br><span class="line"><span class="meta">        ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span></span><br><span class="line"><span class="meta">        ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span></span><br><span class="line"><span class="meta">        ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 自定义容器的初始化：</span></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="keyword">public</span> ServletWebServerFactoryCustomizer <span class="title function_">servletWebServerFactoryCustomizer</span><span class="params">(ServerProperties serverProperties)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletWebServerFactoryCustomizer</span>(serverProperties);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="meta">@ConditionalOnClass(name = &quot;org.apache.catalina.startup.Tomcat&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> TomcatServletWebServerFactoryCustomizer <span class="title function_">tomcatServletWebServerFactoryCustomizer</span><span class="params">(</span></span><br><span class="line"><span class="params">   ServerProperties serverProperties)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactoryCustomizer</span>(serverProperties);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 其他容器初始化...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看到上面导入那里导入了内置 <code>Tomcat</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"> <span class="meta">@ConditionalOnClass(&#123; Servlet.class, Tomcat.class, UpgradeProtocol.class &#125;)</span></span><br><span class="line"> <span class="meta">@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmbeddedTomcat</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">    ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,</span></span><br><span class="line"><span class="params">    ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,</span></span><br><span class="line"><span class="params">    ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers)</span> &#123;</span><br><span class="line">   <span class="type">TomcatServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">   factory.getTomcatConnectorCustomizers()</span><br><span class="line">     .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">   factory.getTomcatContextCustomizers()</span><br><span class="line">     .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">   factory.getTomcatProtocolHandlerCustomizers()</span><br><span class="line">     .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">   <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这个 <code>ServletWebServerFactory</code> 就在读取配置的时候被自动导入到 <code>BeanDefinitionMaps</code> 中去。</p>
<h2 id="DispatcherServlet构建"><a href="#DispatcherServlet构建" class="headerlink" title="DispatcherServlet构建"></a>DispatcherServlet构建</h2><p>怎么会涉及这一块的初始化呢，是因为上面 <code>ServletWebServerFactoryConfiguration</code> 初始化完成以后，触发的 <code>ServletWebServerFactoryConfiguration</code> 初始化，先来看看 <code>ServletWebServerFactoryConfiguration</code> 的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * The bean name for a DispatcherServlet that will be mapped to the root URL &quot;/&quot;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DISPATCHER_SERVLET_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;dispatcherServlet&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * The bean name for a ServletRegistrationBean for the DispatcherServlet &quot;/&quot;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME</span> <span class="operator">=</span> <span class="string">&quot;dispatcherServletRegistration&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"> <span class="meta">@Conditional(DefaultDispatcherServletCondition.class)</span></span><br><span class="line"> <span class="meta">@ConditionalOnClass(ServletRegistration.class)</span></span><br><span class="line"> <span class="meta">@EnableConfigurationProperties(&#123; HttpProperties.class, WebMvcProperties.class &#125;)</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DispatcherServletConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line">  <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">(HttpProperties httpProperties, WebMvcProperties webMvcProperties)</span> &#123;</span><br><span class="line">   <span class="type">DispatcherServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">   dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line">   dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());</span><br><span class="line">   dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class="line">   dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());</span><br><span class="line">   dispatcherServlet.setEnableLoggingRequestDetails(httpProperties.isLogRequestDetails());</span><br><span class="line">   <span class="keyword">return</span> dispatcherServlet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnBean(MultipartResolver.class)</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span></span><br><span class="line">  <span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> &#123;</span><br><span class="line">   <span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line">   <span class="keyword">return</span> resolver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 其他暂时跳过的配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个初始化就很有灵性了，跟我们平常写的配置类大致一致。那关于 <code>DispatcherServlet</code> 的配置，我们均可以通过配置 <code>WebMvcProperties</code> 来让他注入到当前的 <code>DispatcherServlet</code>。 这就完了😱？映射呢映射呢？ 好吧，差点忘记此时 <code>HTTPServlet</code> 还没有初始化。</p>
<h2 id="DispatcherServlet初始化（一）"><a href="#DispatcherServlet初始化（一）" class="headerlink" title="DispatcherServlet初始化（一）"></a>DispatcherServlet初始化（一）</h2><p>默认的 <code>HTTPServlet</code> 在启动的时候只有装载，并没有初始化，初始化发生在第一次请求的时候。 我们来看看这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HttpServletBean</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> <span class="keyword">implements</span> <span class="title class_">EnvironmentCapable</span>, EnvironmentAware &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取配置.</span></span><br><span class="line">        <span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletConfigPropertyValues</span>(getServletConfig(), <span class="built_in">this</span>.requiredProperties);</span><br><span class="line">        <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> PropertyAccessorFactory.forBeanPropertyAccess(<span class="built_in">this</span>);</span><br><span class="line">                <span class="type">ResourceLoader</span> <span class="variable">resourceLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextResourceLoader</span>(getServletContext());</span><br><span class="line">                bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> <span class="title class_">ResourceEditor</span>(resourceLoader, getEnvironment()));</span><br><span class="line">                initBeanWrapper(bw);</span><br><span class="line">                bw.setPropertyValues(pvs, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;Failed to set bean properties on servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子类实现初始化.</span></span><br><span class="line">        initServletBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FrameworkServlet</code> 实现上面的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">  getServletContext().log(<span class="string">&quot;Initializing Spring &quot;</span> + getClass().getSimpleName() + <span class="string">&quot; &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Initializing Servlet &#x27;&quot;</span> + getServletName() + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化Web应用的上下文</span></span><br><span class="line">    <span class="built_in">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    initFrameworkServlet();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ServletException  RuntimeException ex) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.enableLoggingRequestDetails ?</span><br><span class="line">      <span class="string">&quot;shown which may lead to unsafe logging of potentially sensitive data&quot;</span> :</span><br><span class="line">    <span class="string">&quot;masked to prevent unsafe logging of potentially sensitive data&quot;</span>;</span><br><span class="line">    logger.debug(<span class="string">&quot;enableLoggingRequestDetails=&#x27;&quot;</span> + <span class="built_in">this</span>.enableLoggingRequestDetails +</span><br><span class="line">                 <span class="string">&quot;&#x27;: request parameters and headers will be &quot;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Completed initialization in &quot;</span> + (System.currentTimeMillis() - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">   WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line"> <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前rootContext已经存在了</span></span><br><span class="line">  wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">  <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">   <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) wac;</span><br><span class="line">   <span class="comment">// 已经激活，这里并不会进来</span></span><br><span class="line">   <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">    <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">    <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">    <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">     <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">     cwac.setParent(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line">    configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">  <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">  <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">  <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">  wac = findWebApplicationContext();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">  wac = createWebApplicationContext(rootContext);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshEventReceived) &#123;</span><br><span class="line">  <span class="comment">// 刷新上下文</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">   onRefresh(wac);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">  <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> getServletContextAttributeName();</span><br><span class="line">  getServletContext().setAttribute(attrName, wac);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新上下文在上面那么多个容器中已经很有感觉了，就是刷新配置的 <code>Bean</code> 调用对应的构造器 <code>AOP</code> 注入啊啊巴拉巴拉。 所以，<code>onRefresh</code> 是整个 <code>Web</code> 容器初始化的关键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DispatcherServlet.java:</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line"> initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化DispatcherServlet所有的内容</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化多媒体处理器，处理上传的请求</span></span><br><span class="line">  initMultipartResolver(context);</span><br><span class="line">  <span class="comment">// i18n初始化</span></span><br><span class="line">  initLocaleResolver(context);</span><br><span class="line">  <span class="comment">// 项目主题</span></span><br><span class="line">  initThemeResolver(context);</span><br><span class="line">  <span class="comment">// 请求处理器，如果我们写Controller应该是RequestMappingHandlerMapping处理</span></span><br><span class="line">  initHandlerMappings(context);</span><br><span class="line">  <span class="comment">// 初始化适配器，会在调用的时候寻找合适的控制器和拦截器整合一起调用</span></span><br><span class="line">  initHandlerAdapters(context);</span><br><span class="line">  <span class="comment">// 异常处理器</span></span><br><span class="line">  initHandlerExceptionResolvers(context);</span><br><span class="line">  <span class="comment">// 视图名字处理器，通过控制器返回的字符串查找到对应的视图</span></span><br><span class="line">  initRequestToViewNameTranslator(context);</span><br><span class="line">  <span class="comment">// 视图处理器，处理返回值与界面的整合</span></span><br><span class="line">  initViewResolvers(context);</span><br><span class="line">  <span class="comment">// 初始化FlashMap处理器，FlashMap是一个保存数据的地方，</span></span><br><span class="line">  <span class="comment">// 在重定向的时候会把参数临时存储在session中</span></span><br><span class="line">  <span class="comment">// 跳转完成即清理上一个url携带的数据</span></span><br><span class="line">  initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我大概只对 <code>initHandlerMappings</code> 和 <code>initHandlerAdapters</code> 感兴趣。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">  <span class="comment">// 从BF中获取所有的HandlerMapping实例进行重组排序</span></span><br><span class="line">  Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">    BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">   <span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line">   <span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">   AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">HandlerMapping</span> <span class="variable">hm</span> <span class="operator">=</span> context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">   <span class="built_in">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">   <span class="comment">// Ignore, we&#x27;ll add a default HandlerMapping later.</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   logger.trace(<span class="string">&quot;No HandlerMappings declared for servlet &#x27;&quot;</span> + getServletName() +</span><br><span class="line">     <span class="string">&quot;&#x27;: using default strategies from DispatcherServlet.properties&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这些 <code>handlerMappings</code> 是什么时候被装配的，通过 <code>WebMvcAutoConfiguration</code> 这个配置类自动装配的，并且装配发生在 <code>DispatcherServletAutoConfiguration</code> 之后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">  ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类createRequestMappingHandlerMapping，带有@Bean注解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> RequestMappingHandlerMapping <span class="title function_">createRequestMappingHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.mvcRegistrations != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.mvcRegistrations.getRequestMappingHandlerMapping() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.mvcRegistrations.getRequestMappingHandlerMapping();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.createRequestMappingHandlerMapping();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RequestMappingHandlerMapping装配"><a href="#RequestMappingHandlerMapping装配" class="headerlink" title="RequestMappingHandlerMapping装配"></a>RequestMappingHandlerMapping装配</h2><p>上面我们看到，<code>RequestMappingHandler</code> 是通过自动装配的形式放入 <code>BeanFactory</code> 的，那至于我们编写的 <code>@Controller</code> 以及 <code>@RestController</code> 是怎么被读取的，就是通过装配时，调用 <code>InitializingBean</code> 接口的 <code>afterPropertiesSet</code> 方法进行装配的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RequestMappingHandlerMapping.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.config = <span class="keyword">new</span> <span class="title class_">RequestMappingInfo</span>.BuilderConfiguration();</span><br><span class="line"> <span class="built_in">this</span>.config.setUrlPathHelper(getUrlPathHelper());</span><br><span class="line"> <span class="built_in">this</span>.config.setPathMatcher(getPathMatcher());</span><br><span class="line"> <span class="built_in">this</span>.config.setSuffixPatternMatch(<span class="built_in">this</span>.useSuffixPatternMatch);</span><br><span class="line"> <span class="built_in">this</span>.config.setTrailingSlashMatch(<span class="built_in">this</span>.useTrailingSlashMatch);</span><br><span class="line"> <span class="built_in">this</span>.config.setRegisteredSuffixPatternMatch(<span class="built_in">this</span>.useRegisteredSuffixPatternMatch);</span><br><span class="line"> <span class="built_in">this</span>.config.setContentNegotiationManager(getContentNegotiationManager());</span><br><span class="line"></span><br><span class="line"> <span class="built_in">super</span>.afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractHandlerMethodMapping.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">  initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initHandlerMethods</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">      processCandidateBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到 <code>BeanFactory</code> 中所有的 <code>Bean</code> 一顿循环😶： <img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springweb%E5%AE%B9%E5%99%A8-%E5%9F%BA%E4%BA%8Espringboot.md/2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractHandlerMethodMapping.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processCandidateBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"> Class&lt;?&gt; beanType = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="comment">// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   logger.trace(<span class="string">&quot;Could not resolve type for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 关键是 isHandler，是处理器就注册</span></span><br><span class="line"> <span class="keyword">if</span> (beanType != <span class="literal">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">  detectHandlerMethods(beanName);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>Bean</code> 有 <code>@Controller</code> 或者 <code>@RequestMapping</code> 就判定是一个控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isHandler: </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) </span><br><span class="line">   AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册处理器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractHandlerMethodMapping.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlerMethods</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line"> Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">   obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (handlerType != <span class="literal">null</span>) &#123;</span><br><span class="line">  Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">  <span class="comment">// 获取处理方法和对应映射的url</span></span><br><span class="line">  <span class="comment">// 处理映射url的时候还关系到配置的其他Path的混合等等</span></span><br><span class="line">  Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">    (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class="line">        userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   logger.trace(formatMappings(userType, methods));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环处理器和url，注册到当前容器</span></span><br><span class="line">  methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">   <span class="comment">// 获取代理方法，如果加上@Validate就会用这里，但是目前没有，先不看</span></span><br><span class="line">   <span class="type">Method</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">   registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">  &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们看注册控制器，<code>Spring</code> 又定义了一个 <code>Mapping</code> 容器，用于注册 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RequestMappingHandlerMapping.java:</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandlerMethod</span><span class="params">(Object handler, Method method, RequestMappingInfo mapping)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.registerHandlerMethod(handler, method, mapping);</span><br><span class="line">  <span class="comment">// 然后根据情况，消费者的协议如果定义就更新条件</span></span><br><span class="line">  updateConsumesCondition(mapping, method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractHandlerMethodMapping.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> &#123;</span><br><span class="line"> <span class="comment">// 向下面定义的控制器容器注册处理器.</span></span><br><span class="line"> <span class="built_in">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个持有所有控制器的容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MappingRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, HandlerMethod&gt; mappingLookup = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过url查找对应的处理器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; urlLookup = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;HandlerMethod, CorsConfiguration&gt; corsLookup = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DispatcherServlet装配（二）"><a href="#DispatcherServlet装配（二）" class="headerlink" title="DispatcherServlet装配（二）"></a>DispatcherServlet装配（二）</h2><p>好了，在上面的装配中插入了 <code>RequestMappingHandlerMapping</code> 的装配，现在回来继续看两个方法：<code>initHandlerMappings</code> 和 <code>initHandlerAdapters</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">  <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">  Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">    BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">   <span class="comment">// 把 handlerMappings 缓存在 DispatcherServlet</span></span><br><span class="line">   <span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line">   <span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">   AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">HandlerMapping</span> <span class="variable">hm</span> <span class="operator">=</span> context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">   <span class="built_in">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">   <span class="comment">// Ignore, we&#x27;ll add a default HandlerMapping later.</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line"> <span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   logger.trace(<span class="string">&quot;No HandlerMappings declared for servlet &#x27;&quot;</span> + getServletName() +</span><br><span class="line">     <span class="string">&quot;&#x27;: using default strategies from DispatcherServlet.properties&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initHandlerAdapters</code> 也差不多代码就不贴上来了。</p>
<h2 id="处理HTTP请求准备"><a href="#处理HTTP请求准备" class="headerlink" title="处理HTTP请求准备"></a>处理HTTP请求准备</h2><p>那 <code>HTTPServlet</code> 处理请求是在 <code>service</code> 方法中处理的，所以现在我们需要先进入核心的这个方法中去看： <code>FrameworkServlet</code> 即这个 <code>HTTPServlet</code> 的第一个实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate GET requests to processRequest/doService.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Will also be invoked by HttpServlet&#x27;s default implementation of &#123;<span class="doctag">@code</span> doHead&#125;,</span></span><br><span class="line"><span class="comment"> * with a &#123;<span class="doctag">@code</span> NoBodyResponse&#125; that just captures the content length.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doHead</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">  <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"> processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate POST requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">  <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"> processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate PUT requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">  <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"> processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate DELETE requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doDelete</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">  <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"> processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么其实在 <code>FrameworkServlet</code> 中，每一个 <code>doXXX</code> 都是交给 <code>processRequest(request, response);</code> 来做处理，所以现在我们主要看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">  <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"> <span class="type">Throwable</span> <span class="variable">failureCause</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line"> <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line"> <span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line"> <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 当我们控制器方法是一个DeferredResult的时候会用到异步Web管理器，不过目前我们没有先跳过这部分</span></span><br><span class="line"> <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"> asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">RequestBindingInterceptor</span>());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// RequestContextHolder初始化，将当前请求的参数设置到里面，这样我们就可以在任何地方拿到请求信息</span></span><br><span class="line"> initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 在子类实现的部分</span></span><br><span class="line">  doService(request, response);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (ServletException  IOException ex) &#123;</span><br><span class="line">  failureCause = ex;</span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  failureCause = ex;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 清理RequestContextHolder</span></span><br><span class="line">  resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">  <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">   requestAttributes.requestCompleted();</span><br><span class="line">  &#125;</span><br><span class="line">  logResult(request, response, failureCause, asyncManager);</span><br><span class="line">  <span class="comment">// 发布请求事件，这里可以用来做操作记录吧，无论成功还是失败都能够拿到</span></span><br><span class="line">  publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找控制器进行处理"><a href="#查找控制器进行处理" class="headerlink" title="查找控制器进行处理"></a>查找控制器进行处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> logRequest(request);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 保存请求快照，下面恢复可以使用</span></span><br><span class="line"> Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">  attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">  <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String) attrNames.nextElement();</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude  attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">    attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 一些框架的设置，设置到Request中以供用户控制器使用</span></span><br><span class="line"> request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line"> request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line"> request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line"> request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 保存flashMap</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.flashMapManager != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">  <span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;</span><br><span class="line">   request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">  &#125;</span><br><span class="line">  request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());</span><br><span class="line">  request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 开始查找执行的控制器</span></span><br><span class="line">  doDispatch(request, response);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">   <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">   <span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">    restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doDispatch</code> 就是查找控制器，并且整合拦截器调用的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line"> <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 判断请求是否是上传的请求</span></span><br><span class="line">   processedRequest = checkMultipart(request);</span><br><span class="line">   multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 查找当前请求的处理器</span></span><br><span class="line">   mappedHandler = getHandler(processedRequest);</span><br><span class="line">   <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">    noHandlerFound(processedRequest, response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 查找适配器，用于整合一些拦截器等等</span></span><br><span class="line">   <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理 last-modified 请求头</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">   <span class="keyword">if</span> (isGet  <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用用户的控制器以及整合的拦截器处理请求，这时候请求会被写到Response中</span></span><br><span class="line">   mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理视图，但是目前是JSON，是个空处理</span></span><br><span class="line">   applyDefaultViewName(processedRequest, mv);</span><br><span class="line">   <span class="comment">// 执行其他的拦截器周期</span></span><br><span class="line">   mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">   dispatchException = ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">   <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">   <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">   dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">  processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">  triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">  triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">   <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">   <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">   <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">    cleanupMultipart(processedRequest);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前的拦截器链有四个：</p>
<ol>
<li> <code>RequestMappingHandlerAdapter</code>；</li>
<li> <code>HandlerFunctionAdapter</code>；</li>
<li> <code>HttpRequestHandlerAdapter</code>；</li>
<li> <code>SimpleControllerHandlerAdapter</code></li>
</ol>
<p>在查找的过程中，返回第一个匹配的适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">   <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;No adapter for handler [&quot;</span> + handler +</span><br><span class="line">   <span class="string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们现在拿到的实例就是 <code>RequestMappingHandlerAdapter</code>： 然后看看调用 <code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler())</code> 做什么什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">  HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> ModelAndView mav;</span><br><span class="line"> checkRequest(request);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 并发操作，查询是否需要加锁处理</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">  <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">mutex</span> <span class="operator">=</span> WebUtils.getSessionMutex(session);</span><br><span class="line">   <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">    mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">   mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 没有Session需要同步，直接走这里</span></span><br><span class="line">  mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">   applyCacheSeconds(response, <span class="built_in">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   prepareResponse(response);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构建请求处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">  HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将request和response封装成ServletWebRequest对象</span></span><br><span class="line"> <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 获取WebDataBinderFactory工厂处理表单多选项的数据绑定问题</span></span><br><span class="line">  <span class="comment">// 如CheckBox需要绑定到对象的集合中</span></span><br><span class="line">  <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">  <span class="comment">// 处理参数为Model方法的工厂</span></span><br><span class="line">  <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置参数处理器，包括&#123;PATH&#125;、RequestParam等的处理，以及返回值转换处理器</span></span><br><span class="line">  <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">   invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">   invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">  &#125;</span><br><span class="line">  invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">  invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化执行容器 ModelAndViewContainer</span></span><br><span class="line">  <span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">  mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">  modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">  mavContainer.setIgnoreDefaultModelOnRedirect(<span class="built_in">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">  <span class="type">AsyncWebRequest</span> <span class="variable">asyncWebRequest</span> <span class="operator">=</span> WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">  asyncWebRequest.setTimeout(<span class="built_in">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">  <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">  asyncManager.setTaskExecutor(<span class="built_in">this</span>.taskExecutor);</span><br><span class="line">  asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">  asyncManager.registerCallableInterceptors(<span class="built_in">this</span>.callableInterceptors);</span><br><span class="line">  asyncManager.registerDeferredResultInterceptors(<span class="built_in">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步处理器的处理</span></span><br><span class="line">  <span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> asyncManager.getConcurrentResult();</span><br><span class="line">   mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">   asyncManager.clearConcurrentResult();</span><br><span class="line">   LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Resume with async result [&quot;</span> + formatted + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">   invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行调用处理器</span></span><br><span class="line">  invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">  <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  webRequest.requestCompleted();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springweb%E5%AE%B9%E5%99%A8-%E5%9F%BA%E4%BA%8Espringboot.md/3.png"> </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springweb%E5%AE%B9%E5%99%A8-%E5%9F%BA%E4%BA%8Espringboot.md/4.png"></p>
<h2 id="ServletInvocableHandlerMethod处理请求调用"><a href="#ServletInvocableHandlerMethod处理请求调用" class="headerlink" title="ServletInvocableHandlerMethod处理请求调用"></a>ServletInvocableHandlerMethod处理请求调用</h2><p>拿到调用的 <code>ServletWebRequest</code> 以及 <code>ModelAndViewContainer</code> 开始处理请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">  Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 转换请求参数到目标方法，调用方法并拿到返回值处理</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line"> <span class="comment">// 处理相应状态</span></span><br><span class="line"> setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (returnValue == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRequestNotModified(webRequest)  getResponseStatus() != <span class="literal">null</span>  mavContainer.isRequestHandled()) &#123;</span><br><span class="line">   disableContentCachingIfNecessary(webRequest);</span><br><span class="line">   mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">  mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> mavContainer.setRequestHandled(<span class="literal">false</span>);</span><br><span class="line"> Assert.state(<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 返回值处理器将控制器的返回值处理成客户端期待的协议，比如JSON</span></span><br><span class="line">  <span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">    returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invokeForRequest</span><span class="params">(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">  Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"> <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">  logger.trace(<span class="string">&quot;Arguments: &quot;</span> + Arrays.toString(args));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取方法的参数签名</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">                                           Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前没有请求参数，直接返回空的参数值</span></span><br><span class="line">  MethodParameter[] parameters = getMethodParameters();</span><br><span class="line">  <span class="keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line">    <span class="keyword">return</span> EMPTY_ARGS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object[] args = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">    <span class="type">MethodParameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">    parameter.initParameterNameDiscovery(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line">    args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line">    <span class="keyword">if</span> (args[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatArgumentError(parameter, <span class="string">&quot;No suitable resolver&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用处理器翻译请求参数到JavaBean</span></span><br><span class="line">      <span class="comment">// 里层就是轮询所有翻译器，返回能够执行的进行调用</span></span><br><span class="line">      args[i] = <span class="built_in">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="built_in">this</span>.dataBinderFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="comment">// Leave stack trace for later, exception may actually be resolved and handled...</span></span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exMsg</span> <span class="operator">=</span> ex.getMessage();</span><br><span class="line">        <span class="keyword">if</span> (exMsg != <span class="literal">null</span> &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;</span><br><span class="line">          logger.debug(formatArgumentError(parameter, exMsg));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过反射调用控制器方法执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 传递当前对象以及参数执行，拿到返回值进行返回</span></span><br><span class="line">  <span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">  assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">  <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> (ex.getMessage() != <span class="literal">null</span> ? ex.getMessage() : <span class="string">&quot;Illegal argument&quot;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(text, args), ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">  <span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">  <span class="type">Throwable</span> <span class="variable">targetException</span> <span class="operator">=</span> ex.getTargetException();</span><br><span class="line">  <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">   <span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">   <span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">   <span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(formatInvokeError(<span class="string">&quot;Invocation failure&quot;</span>, args), targetException);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HandlerMethodReturnValueHandlerComposite处理返回值写出"><a href="#HandlerMethodReturnValueHandlerComposite处理返回值写出" class="headerlink" title="HandlerMethodReturnValueHandlerComposite处理返回值写出"></a>HandlerMethodReturnValueHandlerComposite处理返回值写出</h2><p>循环所有消息处理器，拿到第一个支持的 <code>HandlerMethodReturnValueHandler</code> 调用处理器将结果写出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">  ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 拿到RequestResponseBodyMethodProcessor处理器进行结果处理</span></span><br><span class="line"> <span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line"> <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line"> &#125;</span><br><span class="line"> handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title function_">selectHandler</span><span class="params">(<span class="meta">@Nullable</span> Object value, MethodParameter returnType)</span> &#123;</span><br><span class="line"> <span class="type">boolean</span> <span class="variable">isAsyncValue</span> <span class="operator">=</span> isAsyncReturnValue(value, returnType);</span><br><span class="line"> <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="built_in">this</span>.returnValueHandlers) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isAsyncValue &amp;&amp; !(handler <span class="keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler)) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (handler.supportsReturnType(returnType)) &#123;</span><br><span class="line">   <span class="keyword">return</span> handler;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractMessageConverterMethodProcessor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">  ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;</span><br><span class="line"></span><br><span class="line"> mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line"> <span class="comment">// 重新封装Request和Response</span></span><br><span class="line"> <span class="type">ServletServerHttpRequest</span> <span class="variable">inputMessage</span> <span class="operator">=</span> createInputMessage(webRequest);</span><br><span class="line"> <span class="type">ServletServerHttpResponse</span> <span class="variable">outputMessage</span> <span class="operator">=</span> createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 父级方法，执行消息转换</span></span><br><span class="line"> writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取返回值，根据 <code>HTTPHeaders</code> 进行匹配转换器，转换写入 <code>Response</code> 流中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">writeWithMessageConverters</span><span class="params">(<span class="meta">@Nullable</span> T value, MethodParameter returnType,</span></span><br><span class="line"><span class="params">  ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;</span><br><span class="line"></span><br><span class="line"> Object body;</span><br><span class="line"> Class&lt;?&gt; valueType;</span><br><span class="line"> Type targetType;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断返回值</span></span><br><span class="line"> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line">  body = value.toString();</span><br><span class="line">  valueType = String.class;</span><br><span class="line">  targetType = String.class;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  body = value;</span><br><span class="line">  valueType = getReturnValueType(body, returnType);</span><br><span class="line">  targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 是不是写出流，用于文件下载</span></span><br><span class="line"> <span class="keyword">if</span> (isResourceType(value, returnType)) &#123;</span><br><span class="line">  outputMessage.getHeaders().set(HttpHeaders.ACCEPT_RANGES, <span class="string">&quot;bytes&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="literal">null</span> &amp;&amp; inputMessage.getHeaders().getFirst(HttpHeaders.RANGE) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    outputMessage.getServletResponse().getStatus() == <span class="number">200</span>) &#123;</span><br><span class="line">   <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> (Resource) value;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    List&lt;HttpRange&gt; httpRanges = inputMessage.getHeaders().getRange();</span><br><span class="line">    outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());</span><br><span class="line">    body = HttpRange.toResourceRegions(httpRanges, resource);</span><br><span class="line">    valueType = body.getClass();</span><br><span class="line">    targetType = RESOURCE_REGION_LIST_TYPE;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    outputMessage.getHeaders().set(HttpHeaders.CONTENT_RANGE, <span class="string">&quot;bytes */&quot;</span> + resource.contentLength());</span><br><span class="line">    outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 根据Content-Type或Accept进行匹配转换器</span></span><br><span class="line"> <span class="type">MediaType</span> <span class="variable">selectedMediaType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> outputMessage.getHeaders().getContentType();</span><br><span class="line"> <span class="type">boolean</span> <span class="variable">isContentTypePreset</span> <span class="operator">=</span> contentType != <span class="literal">null</span> &amp;&amp; contentType.isConcrete();</span><br><span class="line"> <span class="keyword">if</span> (isContentTypePreset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">   logger.debug(<span class="string">&quot;Found &#x27;Content-Type:&quot;</span> + contentType + <span class="string">&quot;&#x27; in response&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  selectedMediaType = contentType;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> inputMessage.getServletRequest();</span><br><span class="line">  <span class="comment">// 客户端请求的MediaType</span></span><br><span class="line">  List&lt;MediaType&gt; acceptableTypes = getAcceptableMediaTypes(request);</span><br><span class="line">  <span class="comment">// 项目允许的MediaType</span></span><br><span class="line">  List&lt;MediaType&gt; producibleTypes = getProducibleMediaTypes(request, valueType, targetType);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (body != <span class="literal">null</span> &amp;&amp; producibleTypes.isEmpty()) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpMessageNotWritableException</span>(</span><br><span class="line">     <span class="string">&quot;No converter found for return value of type: &quot;</span> + valueType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 轮询获取可以使用的MediaType</span></span><br><span class="line">  List&lt;MediaType&gt; mediaTypesToUse = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (MediaType requestedType : acceptableTypes) &#123;</span><br><span class="line">   <span class="keyword">for</span> (MediaType producibleType : producibleTypes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (requestedType.isCompatibleWith(producibleType)) &#123;</span><br><span class="line">     mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mediaTypesToUse.isEmpty()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpMediaTypeNotAcceptableException</span>(producibleTypes);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;No match for &quot;</span> + acceptableTypes + <span class="string">&quot;, supported: &quot;</span> + producibleTypes);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MediaType.sortBySpecificityAndQuality(mediaTypesToUse);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历拿到第一个可以执行的MediaType</span></span><br><span class="line">  <span class="keyword">for</span> (MediaType mediaType : mediaTypesToUse) &#123;</span><br><span class="line">   <span class="keyword">if</span> (mediaType.isConcrete()) &#123;</span><br><span class="line">    selectedMediaType = mediaType;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) &#123;</span><br><span class="line">    selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">   logger.debug(<span class="string">&quot;Using &#x27;&quot;</span> + selectedMediaType + <span class="string">&quot;&#x27;, given &quot;</span> +</span><br><span class="line">     acceptableTypes + <span class="string">&quot; and supported &quot;</span> + producibleTypes);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (selectedMediaType != <span class="literal">null</span>) &#123;</span><br><span class="line">  selectedMediaType = selectedMediaType.removeQualityValue();</span><br><span class="line">  <span class="comment">// 轮询HttpMessageConverter拿到可以应用于当前MediaType和返回值的转换器</span></span><br><span class="line">  <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="built_in">this</span>.messageConverters) &#123;</span><br><span class="line">   <span class="type">GenericHttpMessageConverter</span> <span class="variable">genericConverter</span> <span class="operator">=</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter ?</span><br><span class="line">     (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="literal">null</span>);</span><br><span class="line">   <span class="comment">// 判断是否可写，此时拿到MappingJackson2HttpMessageConverter</span></span><br><span class="line">   <span class="keyword">if</span> (genericConverter != <span class="literal">null</span> ?</span><br><span class="line">     ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :</span><br><span class="line">     converter.canWrite(valueType, selectedMediaType)) &#123;</span><br><span class="line">    body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,</span><br><span class="line">      (Class&lt;? <span class="keyword">extends</span> <span class="title class_">HttpMessageConverter</span>&lt;?&gt;&gt;) converter.getClass(),</span><br><span class="line">      inputMessage, outputMessage);</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">theBody</span> <span class="operator">=</span> body;</span><br><span class="line">     LogFormatUtils.traceDebug(logger, traceOn -&gt;</span><br><span class="line">       <span class="string">&quot;Writing [&quot;</span> + LogFormatUtils.formatValue(theBody, !traceOn) + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">     <span class="comment">// 如果是下载文件新增必要的HTTP头信息</span></span><br><span class="line">     addContentDispositionHeader(inputMessage, outputMessage);</span><br><span class="line">     <span class="keyword">if</span> (genericConverter != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 写出</span></span><br><span class="line">      genericConverter.write(body, targetType, selectedMediaType, outputMessage);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">      ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Nothing to write: null body&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isContentTypePreset) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpMessageNotWritableException</span>(</span><br><span class="line">     <span class="string">&quot;No converter for [&quot;</span> + valueType + <span class="string">&quot;] with preset Content-Type &#x27;&quot;</span> + contentType + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpMediaTypeNotAcceptableException</span>(<span class="built_in">this</span>.allSupportedMediaTypes);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="keyword">final</span> T t, <span class="meta">@Nullable</span> <span class="keyword">final</span> Type type, <span class="meta">@Nullable</span> MediaType contentType,</span></span><br><span class="line"><span class="params">  HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> outputMessage.getHeaders();</span><br><span class="line"> addDefaultHeaders(headers, t, contentType);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断是否支持流信息写出</span></span><br><span class="line"> <span class="keyword">if</span> (outputMessage <span class="keyword">instanceof</span> StreamingHttpOutputMessage) &#123;</span><br><span class="line">  <span class="type">StreamingHttpOutputMessage</span> <span class="variable">streamingOutputMessage</span> <span class="operator">=</span> (StreamingHttpOutputMessage) outputMessage;</span><br><span class="line">  streamingOutputMessage.setBody(outputStream -&gt; writeInternal(t, type, <span class="keyword">new</span> <span class="title class_">HttpOutputMessage</span>() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> OutputStream <span class="title function_">getBody</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> outputStream;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> HttpHeaders <span class="title function_">getHeaders</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> headers;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 写出并刷新  </span></span><br><span class="line">  writeInternal(t, type, outputMessage);</span><br><span class="line">  outputMessage.getBody().flush();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>JSON</code> 流的形式写出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeInternal</span><span class="params">(Object object, <span class="meta">@Nullable</span> Type type, HttpOutputMessage outputMessage)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException, HttpMessageNotWritableException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> outputMessage.getHeaders().getContentType();</span><br><span class="line"> <span class="type">JsonEncoding</span> <span class="variable">encoding</span> <span class="operator">=</span> getJsonEncoding(contentType);</span><br><span class="line"> <span class="type">JsonGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="built_in">this</span>.objectMapper.getFactory().createGenerator(outputMessage.getBody(), encoding);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  writePrefix(generator, object);</span><br><span class="line"></span><br><span class="line">  <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> object;</span><br><span class="line">  Class&lt;?&gt; serializationView = <span class="literal">null</span>;</span><br><span class="line">  <span class="type">FilterProvider</span> <span class="variable">filters</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">JavaType</span> <span class="variable">javaType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (object <span class="keyword">instanceof</span> MappingJacksonValue) &#123;</span><br><span class="line">   <span class="type">MappingJacksonValue</span> <span class="variable">container</span> <span class="operator">=</span> (MappingJacksonValue) object;</span><br><span class="line">   value = container.getValue();</span><br><span class="line">   serializationView = container.getSerializationView();</span><br><span class="line">   filters = container.getFilters();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (type != <span class="literal">null</span> &amp;&amp; TypeUtils.isAssignable(type, value.getClass())) &#123;</span><br><span class="line">   javaType = getJavaType(type, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ObjectWriter</span> <span class="variable">objectWriter</span> <span class="operator">=</span> (serializationView != <span class="literal">null</span> ?</span><br><span class="line">    <span class="built_in">this</span>.objectMapper.writerWithView(serializationView) : <span class="built_in">this</span>.objectMapper.writer());</span><br><span class="line">  <span class="keyword">if</span> (filters != <span class="literal">null</span>) &#123;</span><br><span class="line">   objectWriter = objectWriter.with(filters);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (javaType != <span class="literal">null</span> &amp;&amp; javaType.isContainerType()) &#123;</span><br><span class="line">   objectWriter = objectWriter.forType(javaType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">SerializationConfig</span> <span class="variable">config</span> <span class="operator">=</span> objectWriter.getConfig();</span><br><span class="line">  <span class="keyword">if</span> (contentType != <span class="literal">null</span> &amp;&amp; contentType.isCompatibleWith(MediaType.TEXT_EVENT_STREAM) &amp;&amp;</span><br><span class="line">    config.isEnabled(SerializationFeature.INDENT_OUTPUT)) &#123;</span><br><span class="line">   objectWriter = objectWriter.with(<span class="built_in">this</span>.ssePrettyPrinter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写入JSON值</span></span><br><span class="line">  objectWriter.writeValue(generator, value);</span><br><span class="line"></span><br><span class="line">  writeSuffix(generator, object);</span><br><span class="line">  generator.flush();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (InvalidDefinitionException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpMessageConversionException</span>(<span class="string">&quot;Type definition error: &quot;</span> + ex.getType(), ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (JsonProcessingException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">HttpMessageNotWritableException</span>(<span class="string">&quot;Could not write JSON: &quot;</span> + ex.getOriginalMessage(), ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="doDispatch直接其他善后操作"><a href="#doDispatch直接其他善后操作" class="headerlink" title="doDispatch直接其他善后操作"></a>doDispatch直接其他善后操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">  mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  applyDefaultViewName(processedRequest, mv);</span><br><span class="line">  mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面的工作就是轮询拦截器执行后处理的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Apply postHandle methods of registered interceptors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="meta">@Nullable</span> ModelAndView mv)</span></span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line"> <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">   <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">   <span class="comment">// 调用我们写的拦截器</span></span><br><span class="line">   interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>springmvc</tag>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring源码】SpringBoot扫描与解析</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot%E6%89%AB%E6%8F%8F%E4%B8%8E%E8%A7%A3%E6%9E%90/index.html</url>
    <content><![CDATA[<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>OK，现代 <code>Java</code> 开发者应该都对 <code>SpringBoot</code> 很熟悉了吧，一个很 <code>&quot;轻量级&quot;</code> 的 <code>IOC</code> 容器。 我记得 <code>SpringBoot</code> 刚出来的时候，很多博客文章都会说 <code>SpringBoot</code> 减轻了 <code>Java</code> 开发工作者的负担，是个轻量级的框架。然而后面我才发现，并不轻量级。因为，<code>SpringBoot</code> 把需要依赖的东西给封装了起来，但其实比起之前自己控制依赖项目来说，反而会更重了一些，毕竟以前还可以自由组合。现在，<code>SpringBoot</code> 以及框架作者都提供了默认的依赖以及默认的配置，所以说这个框架轻量级其实并不是，要说轻量级应该只是说开发轻量级而已，菜鸟也可以快速上手建立一个后台项目而不必去关心太多项目配置的东西。 框架肯定是一个优秀的框架，我们项目全体也都是 <code>SpringBoot</code> 架构起来的，所以还是需要看看，<code>SpringBoot</code> 偷偷帮我们做了什么事情。</p>
<a id="more"></a>
<h2 id="依赖简化"><a href="#依赖简化" class="headerlink" title="依赖简化"></a>依赖简化</h2><p>日常使用中，我们只需要引入一个 <code>starter</code>，就可以神奇把我们整合的框架整合起来。但是在以前，我们要使用 <code>MyBatis</code> 的时候，却需要引入 <code>org.mybatis:mybatis</code> 主框架，然后还因为需要整合 <code>Spring</code> 框架，所以我们还需要引入一个 <code>org.mybatis:mybatis-spring</code>。这就算了，这两个包如果版本号对不上，还要出现兼容性的问题。 然而现在我们只需要一个 <code>org.mybatis.spring.boot:mybatis-spring-boot-starter</code>，就可以同时引入这两个包，而且版本号还解决的很OK。所以现在我们可以看看他的 <code>pom.xml</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.1&lt;/version&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">  &lt;name&gt;mybatis-spring-boot-starter&lt;/name&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>所以结论是，一个 <code>starter</code>，定义了需要依赖的包的版本，然后通过依赖传递将这些包传递到我们 <code>starter</code> 所在的项目上来。 目前我建立了一个项目，这个项目很简单，只是依赖了一个 <code>spring-boot-starter-web</code>， 我们可以在 <code>idea</code> 上很方便的查看依赖的所有东西： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot%E6%89%AB%E6%8F%8F%E4%B8%8E%E8%A7%A3%E6%9E%90.md/0.png"></p>
<p> 但其实这个做法在以前 <code>Spring</code> 的时候是已经存在了，这个项目就是 <code>Spring-IO</code>，但我也不知道为什么，可能因为名字取得不够好吧？然后这个项目好像很少人用。或者以前的人觉得会被依赖很多东西进来所以不用这个项目了？</p>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>我们项目所需要的依赖都弄进来了，下一步就是配置让这些包可以相互配合，共同提供服务呀。 所以，<code>SpringBoot</code> 所提供的第二个功能就是，根据默认的配置，装配依赖进来包里面的 <code>Bean</code> 实例。依赖+装配，就是我们以前一直所需要的操作了，可以说这个框架减少了全世界程序员按 <code>CTRL+C/V</code> 的次数hhhhh。 OK，简单了解的话，我需要一个额外的 <code>starter</code>，这里就使用 <code>org.mybatis.spring.boot:mybatis-spring-boot-starter</code> 来看，<a href="https://github.com/mybatis/spring-boot-starter">仓库地址</a> 项目的目录结构为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── license.txt</span><br><span class="line">├── mvnw</span><br><span class="line">├── mvnw.cmd</span><br><span class="line">├── mybatis-spring-boot-autoconfigure</span><br><span class="line">│   ├── format.xml</span><br><span class="line">│   ├── license.txt</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── mybatis-spring-boot-samples</span><br><span class="line">│   ├── mybatis-spring-boot-sample-annotation</span><br><span class="line">│   ├── mybatis-spring-boot-sample-freemarker</span><br><span class="line">│   ├── mybatis-spring-boot-sample-freemarker-legacy</span><br><span class="line">│   ├── mybatis-spring-boot-sample-groovy</span><br><span class="line">│   ├── mybatis-spring-boot-sample-kotlin</span><br><span class="line">│   ├── mybatis-spring-boot-sample-thymeleaf</span><br><span class="line">│   ├── mybatis-spring-boot-sample-velocity</span><br><span class="line">│   ├── mybatis-spring-boot-sample-velocity-legacy</span><br><span class="line">│   ├── mybatis-spring-boot-sample-war</span><br><span class="line">│   ├── mybatis-spring-boot-sample-web</span><br><span class="line">│   ├── mybatis-spring-boot-sample-xml</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── mybatis-spring-boot-starter</span><br><span class="line">│   ├── license.txt</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── mybatis-spring-boot-starter-test</span><br><span class="line">│   └── pom.xml</span><br><span class="line">├── mybatis-spring-boot-test-autoconfigure</span><br><span class="line">│   ├── format.xml</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">├── pom.xml</span><br><span class="line">└── travis</span><br><span class="line">    ├── after_success.sh</span><br><span class="line">    └── settings.xml</span><br></pre></td></tr></table></figure>
<p>其中，<code>mybatis-spring-boot-autoconfigure</code> 比较惹人注目，所以我们现在就看看这个项目。 首先我们看看 <code>main/resources/META-INF/spring.factories</code>，因为 <code>Spring</code> 很喜欢通过这些 <code>meta</code> 文件来促使各个模块很好的解耦但又能彼此配合工作，所以这个文件是定义 <code>自动装配</code> 开始的工厂类：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<p>那么通过看初步的源码，这两个类都是熟悉的 <code>Java</code> 装配类，那么将会被加入到前面提到的 <code>BeanFactory</code> 容器中，后面解析将会调用里面的配置方法。 第二个优秀的地方就是，定义配置类，就可以在 <code>yaml</code> 文件中提示的出现，可以利用 <code>IDE</code> 工具很好的防止配置名写错。这个类就是 <code>MybatisProperties.java</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MYBATIS_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;mybatis&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ResourcePatternResolver</span> <span class="variable">resourceResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Location of MyBatis xml config file.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String configLocation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Locations of MyBatis mapper files.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String[] mapperLocations;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，我们可以看到，定义了前缀就是 <code>mybatis</code>，而这个类是个贫血型的 <code>Bean</code>，只有属性。这些属性将会贯穿 <code>MyBatis</code> 在项目中整个生命周期。 接下来一个问题，我并不需要每个属性都在 <code>yaml</code> 文件中去定义啊，有些直接使用官方提供的默认值就可以了。 所以官方又贴心的提供了 <code>additional-spring-configuration-metadata.json</code> 这个 <code>JSON</code> 文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.ibatis.session.Configuration&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.ibatis.scripting.xmltags.XMLLanguageDriver&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mybatis.configuration.default-scripting-language&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A default LanguageDriver class.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.Class&lt;? extends org.apache.ibatis.scripting.LanguageDriver&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;deprecation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Because when this configuration property is used, there is case that custom language driver cannot be registered correctly.&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;replacement&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mybatis.default-scripting-language-driver&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.ibatis.session.Configuration&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.apache.ibatis.type.EnumTypeHandler&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mybatis.configuration.default-enum-type-handler&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A default TypeHandler class for Enum.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.Class&lt;? extends org.apache.ibatis.type.TypeHandler&gt;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mybatis.lazy-initialization&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Set whether enable lazy initialization for mapper bean.&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.Boolean&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mybatis.scripting-language-driver.velocity.userdirective&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;deprecation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="string">&quot;error&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The &#x27;userdirective&#x27; is deprecated since Velocity 2.x. This property defined for keeping backward compatibility with older velocity version.&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;replacement&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mybatis.scripting-language-driver.velocity.velocity-settings.runtime.custom_directives&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>不好理解的话，我们直接看第三个默认配置就好了：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mybatis.lazy-initialization&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Set whether enable lazy initialization for mapper bean.&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.Boolean&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>看了下图应该明白了吧，上面那个文件就是定义配置的一些说明、默认值的。 </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot%E6%89%AB%E6%8F%8F%E4%B8%8E%E8%A7%A3%E6%9E%90.md/2.png"></p>
<p> 所以当我们要造一个框架，又因为很多约定的东西，靠人脑来记已经靠不住的情况下，就可以编写类似于 <code>additional-spring-configuration-metadata.json</code> 这种文件来做约定以及说明了。</p>
<hr>
<p>OK，上面说完了 <code>SpringBoot</code> 的两个最主要的优点以后，现在就来看看源码。但是源码这块，因为 <code>传递依赖</code> 利用的是 <code>mvn/gradle</code> 的特性，所以 <code>依赖传递</code> 并不需要再说。 那么最主要的就是来解析，怎么自动装配的问题。</p>
<h2 id="简单的SpringBoot项目"><a href="#简单的SpringBoot项目" class="headerlink" title="简单的SpringBoot项目"></a>简单的SpringBoot项目</h2><p><code>pom.xml</code> 依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.0.BUILD-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;cn.liweidan.web&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;web-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;web-test&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>一个主启动器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebTestApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(WebTestApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping(&quot;users&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; <span class="title function_">users</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Map&lt;String, String&gt;&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      Map&lt;String, String&gt; u = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      u.put(<span class="string">&quot;id&quot;</span>, String.valueOf(i));</span><br><span class="line">      u.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;name&quot;</span> + i);</span><br><span class="line">      users.add(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SpringApplication元信息准备"><a href="#SpringApplication元信息准备" class="headerlink" title="SpringApplication元信息准备"></a>SpringApplication元信息准备</h2><p>写过 <code>SpringBoot</code> 项目的同学应该对这个很熟悉了，通过传递一个上下文的根类，<code>SpringBoot</code> 将会自动装载在此类所在的包下面的所有类，并且 <code>args</code> 很明显就是我们在控制台传递的参数，也一并传递给 <code>SpringApplication.run</code> 这个方法，<code>SpringBoot</code> 即可将命令行的参数配置覆盖配置文件指定的配置。 接下来看看这个类做了什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过静态方法，传递一个 <code>Class</code> 类作为主资源，然后再传递给主资源数组的 <code>run</code> 方法。那么这个数组其实我们是可以传递多个主资源的，比如我们做项目的时候，想要每个模块包彼此分离，即可传递多个包的主资源路径。 <code>new SpringApplication(primarySources).run(args);</code> 才是真正的进入容器的准备阶段： 首先看看构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line"> Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line"> <span class="comment">// 初始化主资源链表，用于下面需要读取的时候可以遍历.</span></span><br><span class="line"> <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"> <span class="comment">// 判断Web环境，有webFlux/web/普通三个环境，主要通过类路径是否带有相对应需要的类来判断，如果都没有则初始化为普通Java项目.</span></span><br><span class="line"> <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line"> <span class="comment">// 初始化环境，这个接口多用于web环境，因为需要从web上下文加载一些信息.</span></span><br><span class="line"> setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line"> <span class="comment">// 初始化监听器，监听容器生命周期中需要回调的函数</span></span><br><span class="line"> setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"> <span class="comment">// 从运行堆栈中寻找运行这个类的main方法所在的类</span></span><br><span class="line"> <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加载不同模块的元信息"><a href="#加载不同模块的元信息" class="headerlink" title="加载不同模块的元信息"></a>加载不同模块的元信息</h2><p>在上面的构造器中看到 <code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code>，<code>Spring</code> 还是跟以前获取 <code>handlers</code> 一样。通过在 <code>META-INF</code> 类加载路径定义不同的 <code>spring.factories</code>，使用类加载器读取这些配置文件资源，解析，加载配置文件中的类，初始化对象，来共同完成业务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line"> <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line"> <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line"> Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line"> List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line"> AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"> <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>SpringFactoriesLoader.loadFactoryNames(type, classLoader)</code>，加载当前 <code>ClassLoader</code> 中的指定类，源码显示如何读取，后面的 <code>getOrDefault(factoryTypeName, Collections.emptyList())</code> 还是比较好理解的，如果加载到工厂类的名字就返回不然返回个空集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> factoryType.getName();</span><br><span class="line"> <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line"> <span class="comment">// 相当于Map&lt;String, List&lt;String&gt;&gt;结构，先从缓存命中.</span></span><br><span class="line"> MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line"> <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 属性定义了元信息的路径以及名字</span></span><br><span class="line"><span class="comment"> public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 开始加载类路径下特定名字的元信息文件</span></span><br><span class="line">  Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ?</span><br><span class="line">    classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">    ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">  result = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">   <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">   <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">   <span class="comment">// 通过UrlResource解析成Properties对象</span></span><br><span class="line">   <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">   <span class="comment">// 遍历所有模块的指定文件，然后加入缓存</span></span><br><span class="line">   <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">    <span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">     result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cache.put(classLoader, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">    FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动项目SpringApplication-run"><a href="#启动项目SpringApplication-run" class="headerlink" title="启动项目SpringApplication.run"></a>启动项目SpringApplication.run</h2><p>可以看到 <code>run</code> 的源码跟之前的 <code>AbstractApplicationContext#refresh</code> 的味道还是一样的，先加载一系列容器运行时需要的生命周期类（<code>Spring</code> 模块间的也有用户自定义的），然后 <code>refreshContext(context)</code> 刷新容器上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line"> <span class="comment">// 这是用来打印加载时间的工具类，暂时可以略过.</span></span><br><span class="line"> <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line"> stopWatch.start();</span><br><span class="line"> <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">// 主要设置JVM虚拟机支持无设备情况下让awt可运行的属性</span></span><br><span class="line"> configureHeadlessProperty();</span><br><span class="line"> <span class="comment">// 一. 加载所有SpringApplicationRunListeners并开始遍历所有Lintener启动监听回调函数</span></span><br><span class="line"> <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line"> listeners.starting();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">  <span class="comment">// 二. 开始准备ConfigurableEnvironment环境</span></span><br><span class="line">  <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">  configureIgnoreBeanInfo(environment);</span><br><span class="line">  <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">  <span class="comment">// 三. 创建应用上下文</span></span><br><span class="line">  context = createApplicationContext();</span><br><span class="line">  exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">  <span class="comment">// 四. 做一些准备工作</span></span><br><span class="line">  prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">  <span class="comment">// 五. 刷新上下文</span></span><br><span class="line">  refreshContext(context);</span><br><span class="line">  <span class="comment">// 六. 刷新完成后做的一些清理、回调工作</span></span><br><span class="line">  afterRefresh(context, applicationArguments);</span><br><span class="line">  stopWatch.stop();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 七. 启动完成后，调用所有SpringApplicationRunListener的完成启动的回调函数</span></span><br><span class="line">  listeners.started(context);</span><br><span class="line">  <span class="comment">// 八. 主要处理ApplicationRunner和CommandLineRunner的回调</span></span><br><span class="line">  callRunners(context, applicationArguments);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 九. 运行时的SpringApplicationRunListener回调函数</span></span><br><span class="line">  listeners.running(context);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  handleRunFailure(context, ex, exceptionReporters, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="装载SpringApplicationRunListener"><a href="#装载SpringApplicationRunListener" class="headerlink" title="装载SpringApplicationRunListener"></a>装载SpringApplicationRunListener</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title function_">getRunListeners</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationRunListeners</span>(logger,</span><br><span class="line">   getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="built_in">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看第一步，加载所有的 <code>SpringApplicationRunListener</code> 子类，这个加载方式跟上面所说的加载元信息是一样的，只不过指定加载 <code>SpringApplicationRunListener.class</code> 类。 我们知道，<code>Spring</code> 经常会定义很多生命周期回调，供用户根据需求切入框架。这次 <code>SpringBoot</code> 的生命周期是 <code>SpringApplicationRunListener</code>。 首先看看 <code>SpringApplicationRunListener</code> 定义哪些生命周期函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SpringApplicationRunListener</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 项目开始时调用</span></span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 环境准备好时</span></span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 上下文准备好时</span></span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 上下文读取完成</span></span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 启动完成</span></span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 项目运行时调用</span></span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 项目失败时</span></span><br><span class="line"> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="准备ConfigurableEnvironment环境"><a href="#准备ConfigurableEnvironment环境" class="headerlink" title="准备ConfigurableEnvironment环境"></a>准备ConfigurableEnvironment环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span><br><span class="line"><span class="params">  ApplicationArguments applicationArguments)</span> &#123;</span><br><span class="line"> <span class="comment">// 首先根据环境类型获取对象的配置实现对象</span></span><br><span class="line"> <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> getOrCreateEnvironment();</span><br><span class="line"> <span class="comment">// 配置ConversionService单例对象，以及判断有没有设置Profiles环境</span></span><br><span class="line"> configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line"> <span class="comment">// 读取其他环境中（比如web.xml）读取的配置属性</span></span><br><span class="line"> ConfigurationPropertySources.attach(environment);</span><br><span class="line"> <span class="comment">// 继续上面的SpringApplicationRunListener生命周期调用</span></span><br><span class="line"> listeners.environmentPrepared(environment);</span><br><span class="line"> <span class="comment">// 把环境绑定到Binder中，Binder是Spring提供的一个记录对象的容器</span></span><br><span class="line"> bindToSpringApplication(environment);</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">  <span class="comment">// 如果当前的配置环境和重新判断的环境不同，则转换成当前的环境（有可能在生命周期修改了加载的环境？）</span></span><br><span class="line">  environment = <span class="keyword">new</span> <span class="title class_">EnvironmentConverter</span>(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">    deduceEnvironmentClass());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 重新读取特定环境的配置</span></span><br><span class="line"> ConfigurationPropertySources.attach(environment);</span><br><span class="line"> <span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">getOrCreateEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.environment;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;</span><br><span class="line">    <span class="keyword">case</span> SERVLET:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardServletEnvironment</span>();</span><br><span class="line">    <span class="keyword">case</span> REACTIVE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardReactiveWebEnvironment</span>();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主线程中配置忽略 <code>Boolean</code> 的 <code>Bean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">  configureIgnoreBeanInfo(environment);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureIgnoreBeanInfo</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">ignore</span> <span class="operator">=</span> environment.getProperty(<span class="string">&quot;spring.beaninfo.ignore&quot;</span>, Boolean.class, Boolean.TRUE);</span><br><span class="line">    System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, ignore.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建上下文"><a href="#创建上下文" class="headerlink" title="创建上下文"></a>创建上下文</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context = createApplicationContext();</span><br><span class="line"><span class="comment">// 获取模块的错误解释器，用于项目启动的时候解析是什么错误</span></span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                                                 <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br></pre></td></tr></table></figure>
<p>根据不同环境创建不同的上下文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title function_">createApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line"> Class&lt;?&gt; contextClass = <span class="built_in">this</span>.applicationContextClass;</span><br><span class="line"> <span class="keyword">if</span> (contextClass == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;</span><br><span class="line">   <span class="keyword">case</span> SERVLET:</span><br><span class="line">    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> REACTIVE:</span><br><span class="line">    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">     <span class="string">&quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Context准备工作"><a href="#Context准备工作" class="headerlink" title="Context准备工作"></a>Context准备工作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span><br><span class="line"><span class="params">        SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;</span><br><span class="line"><span class="comment">// 设置上面准备好的环境信息</span></span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line"><span class="comment">// 处理之前做一些事情，但是当前环境下，只是注册了一个 ConversionService 到 BeanFactory 中</span></span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line"><span class="comment">// 调用之前注册的所有Initializers</span></span><br><span class="line">    applyInitializers(context);</span><br><span class="line"><span class="comment">// 再调用所有的listeners</span></span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="literal">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册SpringBoot独有的一些Bean</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 接下来跟之前一样</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazyInitialization) &#123;</span><br><span class="line">        context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">LazyInitializationBeanFactoryPostProcessor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line"><span class="comment">// 根据我们传递的主类进行读取，放入BeanFactory中</span></span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实当前 <code>postProcessApplicationContext</code> 除了注册 <code>ConversionService</code> 以外其他事情都没做。</p>
<h2 id="refreshContext刷新上下文"><a href="#refreshContext刷新上下文" class="headerlink" title="refreshContext刷新上下文"></a>refreshContext刷新上下文</h2><p>因为我要看看自动装配的问题，所以这个时候为了故事比较好说，我加了 <code>mybatis-spring-boot-starter</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.0.BUILD-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;cn.liweidan.web&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;web-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;web-test&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.h2database&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;h2&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.197&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>刷新上下文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line"> refresh(context);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   context.registerShutdownHook();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">   <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">  Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">  ((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后接下来就去到我们熟悉的 <code>AbstractApplicationContext</code> 中，重温一下这个 <code>refresh()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      initMessageSource();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      registerListeners();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">      destroyBeans();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">      <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同之前一样，在 <code>invokeBeanFactoryPostProcessors(beanFactory)</code> 这句话出现了 <code>BeanDefinition</code> 数量的剧增，那么我们可以推断出，这句话还是关键，就是在这句话开始解析我们的项目依赖。</p>
<blockquote>
<p>其实按照我的猜测，自动配置应该是 starter 提供了一些配置类交给 SpringBoot 注入 Spring 的 BeanFactory 中，但是现在看来，好像 SpringBoot 就不需要做什么东西，直接委托给容器扫描解析执行了。</p>
</blockquote>
<h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"> <span class="comment">// 利用委派模式委托给 PostProcessorRegistrationDelegate 进行执行</span></span><br><span class="line"> PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"> <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"> <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">  beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PostProcessorRegistrationDelegate委派对象"><a href="#PostProcessorRegistrationDelegate委派对象" class="headerlink" title="PostProcessorRegistrationDelegate委派对象"></a>PostProcessorRegistrationDelegate委派对象</h3><p>这是一个在 <code>Context</code> 模块下对象，主要处理 <code>PostProcessor</code> 相关的事情，看到签名只提供两个方法：</p>
<ul>
<li>  <code>invokeBeanFactoryPostProcessors</code> 执行 BF 的 PostProcessors</li>
<li>  <code>registerBeanPostProcessors</code> 注册 PostProcessors 到 BF 中</li>
</ul>
<p>关于普通的配置类解析，之前在 <code>chapters3_高级的Beafctory—Spring上下文</code> 已经有提到，解析项目中配置类不明白的话可以先看看那篇文章。 不过我们现在重点是怎么读取到 <code>starter</code> 框架里边的自动配置信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">  Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">  postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前 <code>postProcessors</code> 里边只有一个 <code>ConfigurationClassPostProcessor</code> 那我们进入对应的 <code>postProcessBeanDefinitionRegistry</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">    <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">    <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line"> processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="processConfigBeanDefinitions-解析配置"><a href="#processConfigBeanDefinitions-解析配置" class="headerlink" title="processConfigBeanDefinitions 解析配置"></a>processConfigBeanDefinitions 解析配置</h3><blockquote>
<p>由于我们现在需要跟自动导入的配置，所以我们应该需要跟的类配置是我们的主类，也就是 <code>WebTestApplication</code> 这个类，这个类上修饰的注解 <code>@SpringBootApplication</code> 是自动注入的关键</p>
</blockquote>
<p>这个才是执行自动配置的重点之重：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build and validate a configuration model based on the registry of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"> List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">  <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">   configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line"> <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Sort by previously determined @Order value, if applicable</span></span><br><span class="line"> configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">  <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">  <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line"> <span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">  sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">   <span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">     AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">   <span class="keyword">if</span> (generator != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">    <span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Parse each @Configuration class</span></span><br><span class="line"> <span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">   <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">   <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line"> Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line"> Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line"> <span class="comment">// ↑ 这上面属于解析开始的准备工作 ↑</span></span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  parser.parse(candidates);</span><br><span class="line">  parser.validate();</span><br><span class="line"></span><br><span class="line">  Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">  configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">     registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">     <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">  alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">  candidates.clear();</span><br><span class="line">  <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">   String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">   Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">   Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">    alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">     <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">     <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">       !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">      candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   candidateNames = newCandidateNames;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line"> <span class="keyword">if</span> (sbr != <span class="literal">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">  sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">  <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">  <span class="comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span></span><br><span class="line">  ((CachingMetadataReaderFactory) <span class="built_in">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点看看 <code>parser.parse(candidates);</code> 这句话是怎么解析的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">    <span class="comment">// 因为这是一个使用注解的Bean，所以应该关注这里</span></span><br><span class="line">    parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">    parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">     <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(AnnotationMetadata metadata, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(metadata, beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// 如果当前的类是一个解析类，则跳过解析</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否已经解析过了</span></span><br><span class="line">  <span class="type">ConfigurationClass</span> <span class="variable">existingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(configClass);</span><br><span class="line">  <span class="keyword">if</span> (existingClass != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">        existingClass.mergeImportedBy(configClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">      <span class="comment">// Let&#x27;s remove the old one and go with the new one.</span></span><br><span class="line">      <span class="built_in">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">      <span class="built_in">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归解析配置类以及他的父类、接口等等</span></span><br><span class="line">  <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> asSourceClass(configClass);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们要进入 <code>doProcessConfigurationClass</code> 观察解析的过程。 这串代码其实有点长……：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">  <span class="comment">// Recursively process any member (nested) classes first</span></span><br><span class="line">  processMemberClasses(configClass, sourceClass);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析需要导入Property配置文件的类</span></span><br><span class="line"> <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">   sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">   org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">   processPropertySource(propertySource);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">     <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析 @ComponentScan </span></span><br><span class="line"> Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">   sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"> <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">   !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">   <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">     <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">   <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">   <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">    <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">     bdCand = holder.getBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">     parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析 @Import 的类，这句话是重点</span></span><br><span class="line"> processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Process any @ImportResource annotations</span></span><br><span class="line"> <span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">   AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line"> <span class="keyword">if</span> (importResource != <span class="literal">null</span>) &#123;</span><br><span class="line">  String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">   configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析 @Bean 方法</span></span><br><span class="line"> Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line"> <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">  configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 解析接口默认方法</span></span><br><span class="line"> processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果有父类，返回父类，由上一层继续调用这个方法继续解析</span></span><br><span class="line"> <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">  <span class="keyword">if</span> (superclass != <span class="literal">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">    !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">   <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">   <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">   <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 返回Null表示解析结束</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，可以看到通过 <code>Java</code> 类的解析可谓覆盖到尼玛我想象不到的地方….但他们就是应该要有 挑重点来看吧，我的主类没有父级也没有接口，直接重点看 <code>processImports(configClass, sourceClass, getImports(sourceClass), true)</code> 这句话。 这句话首先需要获取所有的导入配置 <code>getImports(sourceClass)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;SourceClass&gt; <span class="title function_">getImports</span><span class="params">(SourceClass sourceClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> Set&lt;SourceClass&gt; imports = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"> Set&lt;SourceClass&gt; visited = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"> collectImports(sourceClass, imports, visited);</span><br><span class="line"> <span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">collectImports</span><span class="params">(SourceClass sourceClass, Set&lt;SourceClass&gt; imports, Set&lt;SourceClass&gt; visited)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (visited.add(sourceClass)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (SourceClass annotation : sourceClass.getAnnotations()) &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">annName</span> <span class="operator">=</span> annotation.getMetadata().getClassName();</span><br><span class="line">   <span class="keyword">if</span> (!annName.equals(Import.class.getName())) &#123;</span><br><span class="line">    collectImports(annotation, imports, visited);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  imports.addAll(sourceClass.getAnnotationAttributes(Import.class.getName(), <span class="string">&quot;value&quot;</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两个东西，切忌不要去 <code>debug</code> 一个一个看….我在这里看晕了好几个小时，应该是条件断点判断 <code>sourceClass.getAnnotationAttributes(Import.class.getName(), &quot;value&quot;).size() &gt; 0</code> 再停住</p>
</blockquote>
<p>好了等到断点停住的时候，发现是 <code>@interface SpringBootApplication</code> &gt; <code>@interface EnableAutoConfiguration</code> 上面的 <code>@Import(AutoConfigurationImportSelector.class)</code> 在这里导入了。以及这个类上边的 <code>@AutoConfigurationPackage</code> 导入了 <code>@Import(AutoConfigurationPackages.Registrar.class)</code> 所以当前需要解析的 <code>importCandidates</code> 是 <code>AutoConfigurationPackages.Registrar.class</code> 以及 <code>AutoConfigurationImportSelector.class</code> 两个类。 那么这两个类是什么用的，我现在也还不知道…先知道他被导入就好了，接下去看 <code>processImports</code> 方法了，这个方法应该有答案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">  Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 由上面传递的 checkForCircularImports 参数决定是否判断有没有循环引入</span></span><br><span class="line"> <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">  <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 开始解析导入类</span></span><br><span class="line">   <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">    <span class="comment">// 第一层，根据不同的导入类型进行解析</span></span><br><span class="line">    <span class="comment">// AutoConfigurationImportSelector 来到这个分支</span></span><br><span class="line">    <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">     <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">     Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">     <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,</span><br><span class="line">       <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">     <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">      String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">      Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">      <span class="comment">// 递归解析</span></span><br><span class="line">      processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AutoConfigurationPackages.Registrar进入这个分支</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line">     <span class="comment">// Candidate class is an ImportBeanDefinitionRegistrar -&gt;</span></span><br><span class="line">     <span class="comment">// delegate to it to register additional bean definitions</span></span><br><span class="line">     Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">     <span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">       ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,</span><br><span class="line">         <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">     configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 直接以@Configuration的方式进行处理</span></span><br><span class="line">     <span class="built_in">this</span>.importStack.registerImport(</span><br><span class="line">       currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());</span><br><span class="line">     processConfigurationClass(candidate.asConfigClass(configClass));</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">     <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">     configClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.importStack.pop();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不行呀，因为需要根据类型来做，先给两个类的类型吧： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot%E6%89%AB%E6%8F%8F%E4%B8%8E%E8%A7%A3%E6%9E%90.md/3.png"></p>
<p> <img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot%E6%89%AB%E6%8F%8F%E4%B8%8E%E8%A7%A3%E6%9E%90.md/4.png"></p>
<p> 这三个分支对应着三个不同的配置类型：</p>
<ol>
<li> <code>ImportSelector</code> 用于导入配置类的信息</li>
<li> <code>Registrar</code> 用于解析自定义注解动态生成 <code>Bean</code> 的信息</li>
<li> <code>@Configuration</code> 读取到配置类，直接解析</li>
</ol>
<p>那我们就先按照上图的顺序来解析这些配置类吧，首先是 <code>AutoConfigurationPackages.Registrar</code> 对象的解析。我先从上面一大串截取代码片段来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123;</span><br><span class="line"> <span class="comment">// 额外注册BeanDefinition用</span></span><br><span class="line"> Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line"> <span class="type">ImportBeanDefinitionRegistrar</span> <span class="variable">registrar</span> <span class="operator">=</span></span><br><span class="line">   ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,</span><br><span class="line">     <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line"> <span class="comment">// 简单的添加（导入）到当前的 configClass 中</span></span><br><span class="line"> configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>先放到后面，应该是解析的时候会调用到。 接下来看第二个 <code>AutoConfigurationImportSelector.class</code> 的解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line"> <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line"> Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line"> <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,</span><br><span class="line">   <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line"> <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">  <span class="comment">// 进入这里</span></span><br><span class="line">  <span class="built_in">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">  Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">  processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一块比较麻烦，在上面 <code>uml</code> 可以看到，<code>AutoConfigurationImportSelector.class</code> 属于 <code>DeferredImportSelector</code>，所以交给 <code>deferredImportSelectorHandler</code> 进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(ConfigurationClass configClass, DeferredImportSelector importSelector)</span> &#123;</span><br><span class="line"> <span class="type">DeferredImportSelectorHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorHolder</span>(</span><br><span class="line">   configClass, importSelector);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.deferredImportSelectors == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="type">DeferredImportSelectorGroupingHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorGroupingHandler</span>();</span><br><span class="line">  handler.register(holder);</span><br><span class="line">  handler.processGroupImports();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 来到这里，简单的加入</span></span><br><span class="line">  <span class="built_in">this</span>.deferredImportSelectors.add(holder);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="导入刚刚注册的配置"><a href="#导入刚刚注册的配置" class="headerlink" title="导入刚刚注册的配置"></a>导入刚刚注册的配置</h3><p>上面一大堆全是解析，然后接下来就要处理这些自动配置了。 回到 <code>parser.parse(candidates);</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">    parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">    parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">     <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 处理导入配置类（第三方配置）</span></span><br><span class="line"> <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AutoConfigurationImportSelector解析"><a href="#AutoConfigurationImportSelector解析" class="headerlink" title="AutoConfigurationImportSelector解析"></a>AutoConfigurationImportSelector解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// AutoConfigurationImportSelector集合 只有一个元素</span></span><br><span class="line"> List&lt;DeferredImportSelectorHolder&gt; deferredImports = <span class="built_in">this</span>.deferredImportSelectors;</span><br><span class="line"> <span class="built_in">this</span>.deferredImportSelectors = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (deferredImports != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="type">DeferredImportSelectorGroupingHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeferredImportSelectorGroupingHandler</span>();</span><br><span class="line">   deferredImports.sort(DEFERRED_IMPORT_COMPARATOR);</span><br><span class="line">   <span class="comment">// 注册到 DeferredImportSelectorGroupingHandler 中</span></span><br><span class="line">   deferredImports.forEach(handler::register);</span><br><span class="line">   <span class="comment">// 重点看这边</span></span><br><span class="line">   handler.processGroupImports();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.deferredImportSelectors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processGroupImports</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (DeferredImportSelectorGrouping grouping : <span class="built_in">this</span>.groupings.values()) &#123;</span><br><span class="line">  grouping.getImports().forEach(entry -&gt; &#123;</span><br><span class="line">   <span class="type">ConfigurationClass</span> <span class="variable">configurationClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(</span><br><span class="line">     entry.getMetadata());</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    processImports(configurationClass, asSourceClass(configurationClass),</span><br><span class="line">      asSourceClasses(entry.getImportClassName()), <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">      <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">        configurationClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先进入这里 <code>grouping.getImports()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterable&lt;Group.Entry&gt; getImports() &#123;</span><br><span class="line"> <span class="keyword">for</span> (DeferredImportSelectorHolder deferredImport : <span class="built_in">this</span>.deferredImports) &#123;</span><br><span class="line">  <span class="built_in">this</span>.group.process(deferredImport.getConfigurationClass().getMetadata(),</span><br><span class="line">    deferredImport.getImportSelector());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.group.selectImports();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程就是 <code>SpringBoot</code> 提供的，在类路径提供 <code>additional-spring-configuration-metadata.json</code> 提供导入配置的，然而看起来好像所有的 <code>SpringBoot</code> 模块都在这里了，他只是通过导入类路径的包来判断是否要加载配置。 跳过这一段吧，看着有点累。我们现在只要知道，读取了类路径下的 <code>additional-spring-configuration-metadata.json</code> 后，我们想要看到的 <code>MybatisAutoConfiguration</code> 已经被读取到了就好了。 </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot%E6%89%AB%E6%8F%8F%E4%B8%8E%E8%A7%A3%E6%9E%90.md/5.png"></p>
<p> 同样的，<code>spring-boot-mybatis-starter</code> 也提供了上面的注册文件： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91springboot%E6%89%AB%E6%8F%8F%E4%B8%8E%E8%A7%A3%E6%9E%90.md/6.jpg"> 好了，接下来回到上面的解析方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processGroupImports</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (DeferredImportSelectorGrouping grouping : <span class="built_in">this</span>.groupings.values()) &#123;</span><br><span class="line">  grouping.getImports().forEach(entry -&gt; &#123;</span><br><span class="line">   <span class="type">ConfigurationClass</span> <span class="variable">configurationClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(</span><br><span class="line">     entry.getMetadata());</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 此时进入processImports的时候就不需要再导入配置了</span></span><br><span class="line">    <span class="comment">// 直接以 @Configuration 去实现配置</span></span><br><span class="line">    processImports(configurationClass, asSourceClass(configurationClass),</span><br><span class="line">      asSourceClasses(entry.getImportClassName()), <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">      <span class="string">&quot;Failed to process import candidates for configuration class [&quot;</span> +</span><br><span class="line">        configurationClass.getMetadata().getClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么关于 <code>@Configuration</code> 的解析，在我 <a href="chapters3_%E9%AB%98%E7%BA%A7%E7%9A%84Beafctory%E2%80%94Spring%E4%B8%8A%E4%B8%8B%E6%96%87.md">之前的文章</a> 就可以看到了。 现在就看看怎么根据主类的所在的包，扫描该包下的所有 <code>Bean</code>。</p>
<h3 id="自动包扫描注册Bean"><a href="#自动包扫描注册Bean" class="headerlink" title="自动包扫描注册Bean"></a>自动包扫描注册Bean</h3><p>我们得回到 <code>doProcessConfigurationClass</code> 的这个地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析 @ComponentScan，会从主类 WebTestApplication 中拿到 BasePackage</span></span><br><span class="line"><span class="comment">// 然后根据这个 BasePackage 的配置进行扫描下面的类</span></span><br><span class="line">Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">  sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">  !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line"> <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">  <span class="comment">// 通过 componentScanParser 进行解析</span></span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">    <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">  <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">  <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">   <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">   <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">    bdCand = holder.getBeanDefinition();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">    parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">parse</span><span class="params">(AnnotationAttributes componentScan, <span class="keyword">final</span> String declaringClass)</span> &#123;</span><br><span class="line"> <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>.registry,</span><br><span class="line">   componentScan.getBoolean(<span class="string">&quot;useDefaultFilters&quot;</span>), <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader);</span><br><span class="line"></span><br><span class="line"> Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; generatorClass = componentScan.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line"> <span class="type">boolean</span> <span class="variable">useInheritedGenerator</span> <span class="operator">=</span> (BeanNameGenerator.class == generatorClass);</span><br><span class="line"> scanner.setBeanNameGenerator(useInheritedGenerator ? <span class="built_in">this</span>.beanNameGenerator :</span><br><span class="line">   BeanUtils.instantiateClass(generatorClass));</span><br><span class="line"></span><br><span class="line"> <span class="type">ScopedProxyMode</span> <span class="variable">scopedProxyMode</span> <span class="operator">=</span> componentScan.getEnum(<span class="string">&quot;scopedProxy&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">  scanner.setScopedProxyMode(scopedProxyMode);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  Class&lt;? <span class="keyword">extends</span> <span class="title class_">ScopeMetadataResolver</span>&gt; resolverClass = componentScan.getClass(<span class="string">&quot;scopeResolver&quot;</span>);</span><br><span class="line">  scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> scanner.setResourcePattern(componentScan.getString(<span class="string">&quot;resourcePattern&quot;</span>));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;includeFilters&quot;</span>)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">   scanner.addIncludeFilter(typeFilter);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="string">&quot;excludeFilters&quot;</span>)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;</span><br><span class="line">   scanner.addExcludeFilter(typeFilter);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">boolean</span> <span class="variable">lazyInit</span> <span class="operator">=</span> componentScan.getBoolean(<span class="string">&quot;lazyInit&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (lazyInit) &#123;</span><br><span class="line">  scanner.getBeanDefinitionDefaults().setLazyInit(<span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Set&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"> String[] basePackagesArray = componentScan.getStringArray(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (String pkg : basePackagesArray) &#123;</span><br><span class="line">  String[] tokenized = StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.environment.resolvePlaceholders(pkg),</span><br><span class="line">    ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">  Collections.addAll(basePackages, tokenized);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class="line">  basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">  <span class="comment">// 没有指定扫描包，进入这里获取主类的包名</span></span><br><span class="line">  basePackages.add(ClassUtils.getPackageName(declaringClass));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> scanner.addExcludeFilter(<span class="keyword">new</span> <span class="title class_">AbstractTypeHierarchyTraversingFilter</span>(<span class="literal">false</span>, <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">matchClassName</span><span class="params">(String className)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> declaringClass.equals(className);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 上面基本上都是解析配置的一些东西，过滤器啊，LazyInit等等，到这一步才是真正的扫描</span></span><br><span class="line"> <span class="comment">// StringUtils.toStringArray(basePackages) 获取包名</span></span><br><span class="line"> <span class="keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的扫描，做的事情可谓多得多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line"> Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line"> Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"> <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">  <span class="comment">// 这里又是一个大的模块了，也就是读取ClassPath下所有的文件</span></span><br><span class="line">  Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">  <span class="comment">// 拿到扫描到的 BeanDefinition 注册到工厂中</span></span><br><span class="line">  <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">   <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">   candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">   <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">   <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">    definitionHolder =</span><br><span class="line">      AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">    beanDefinitions.add(definitionHolder);</span><br><span class="line">    registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扫描：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title function_">findCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">  <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="built_in">this</span>.componentsIndex, basePackage);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title function_">scanCandidateComponents</span><span class="params">(String basePackage)</span> &#123;</span><br><span class="line"> Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">    resolveBasePackage(basePackage) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">this</span>.resourcePattern;</span><br><span class="line">  Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">traceEnabled</span> <span class="operator">=</span> logger.isTraceEnabled();</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">  <span class="comment">// 拿到包下两个文件的 Resource 实例</span></span><br><span class="line">  <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">   <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Scanning &quot;</span> + resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">     <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">      <span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">      sbd.setResource(resource);</span><br><span class="line">      sbd.setSource(resource);</span><br><span class="line">      <span class="comment">// 符合某种条件，暂且就当BF中还没存在这个Bean吧</span></span><br><span class="line">      <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 添加</span></span><br><span class="line">       candidates.add(sbd);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">       logger.trace(<span class="string">&quot;Ignored because not matching any filter: &quot;</span> + resource);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">       <span class="string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">     logger.trace(<span class="string">&quot;Ignored because not readable: &quot;</span> + resource);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(<span class="string">&quot;I/O failure during classpath scanning&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 返回</span></span><br><span class="line"> <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，扫描完成，后在 <code>finishBeanFactoryInitialization</code> 进行初始化就可以了</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring源码】Spring数据库事务源码解析</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91spring%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html</url>
    <content><![CDATA[<h2 id="准备个需求"><a href="#准备个需求" class="headerlink" title="准备个需求"></a>准备个需求</h2><p>之前读其他无关数据库源码的时候，只是简单的依赖了 <code>spring-boot-starter-web</code>，现在由于需要数据库的参与，所以需要加上 <code>MySQL</code> 的驱动，以及一个最简单的 <code>jdbc</code> 框架。</p>
<a id="more"></a>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p><code>application.yml</code> 配置数据库连接信息。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.1.152:3306/spring_trans?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>一个接收需要插入数据库的请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostMapping(&quot;users&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, <span class="meta">@RequestParam(&quot;orgName&quot;)</span> String orgName)</span> &#123;</span><br><span class="line">    userService.add(name, orgName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于示例，就使用最简单的例子，插入一个用户以及他所属的组织机构，一对一的关系。使用 <code>JdbcTemplate</code> 直接插入 <code>SQL</code> 语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name, String orgName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name, String orgName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;insert into user_info(user_uuid, user_name)\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;values (?,?);&quot;</span>, userId, name);</span><br><span class="line">    <span class="comment">// 使用一个RuntimeEx来触发事务回滚</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">orgUUID</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;insert into org_info(org_uuid, org_name, user_uuid)\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;VALUES (?, ?, ?);&quot;</span>, orgUUID, orgName, userId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用事务"><a href="#应用事务" class="headerlink" title="应用事务"></a>应用事务</h2><ul>
<li>  编程式注解：使用 <code>@Transactional</code> 修饰的类或者方法，具有事务特性。（<code>SpringBoot</code> 时代一般用这个）</li>
<li>  声明式事务：通过定义配置文件，需要定义一套基于公司内部的方法命名规范。如以下的配置，<code>update</code> 以及 <code>insert</code> 为名的方法，使用事务，不然使用只读事务。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;tx:advice id=&quot;advice&quot; transaction-manager=&quot;transactionManager&quot;&gt;  </span><br><span class="line">    &lt;tx:attributes&gt;  </span><br><span class="line">        &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; rollback-for=&quot;java.lang.Exception&quot;/&gt;  </span><br><span class="line">        &lt;tx:method name=&quot;insert&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;  </span><br><span class="line">    &lt;/tx:attributes&gt;  </span><br><span class="line">&lt;/tx:advice&gt;  </span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;  </span><br><span class="line">    &lt;aop:pointcut id=&quot;testService&quot; expression=&quot;execution (* com.liweidan.service.MyBatisService.*(..))&quot;/&gt;  </span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;testService&quot;/&gt;  </span><br><span class="line">&lt;/aop:config&gt;  </span><br></pre></td></tr></table></figure>
<hr>
<p>在上面例子中的 <code>UserServiceImpl</code> 是使用编程式事务处理的，当没有加上 <code>@Transactional</code> 时，在 <code>int i = 1 / 0;</code> 处发生异常时，上面已经插入的用户信息并不会被回滚，这就不符合我们日常的业务需求了。OK，从这里开始将要开始看看 <code>Spring</code> 是如何应用事务到我们的代码上的。</p>
<h2 id="依赖结构"><a href="#依赖结构" class="headerlink" title="依赖结构"></a>依赖结构</h2><p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91spring%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md/0.png"></p>
<p> OK，简单看看我们依赖了 <code>spring-boot-starter-jdbc</code> 都依赖了些什么东西。从图中可以看到，<code>spring-jdbc</code> 和 <code>spring-tx</code> 以及 <code>HicariCP</code> 都进来了，<code>spring-jdbc</code> 模块也还好，封装了 <code>JdbcTemplate</code> 等一些偏向于原生 <code>JDBC</code> 的操作，<code>spring-tx</code> 就是此次需要说的重点了，事务管理模块，主要管理 <code>Spring</code> 自己定义的一些事务模型。<code>HicariCP</code> 则是一个高性能的数据库连接池。</p>
<h2 id="基于AOP"><a href="#基于AOP" class="headerlink" title="基于AOP"></a>基于AOP</h2><p>我记得很清楚的，《从零开始架构WEB系统》中说到，可以使用 <code>AOP</code> 方式切入项目，获取 <code>Connection</code> 保存在线程的 <code>ThreadLocal</code> 中，在调用插入更新的时候，取出来开启事务，方法执行结束后判定是否是正常执行，如果遇到异常了，就 <code>roolBack</code> 插入的数据，否则 <code>commit</code>。那我们现在大概可以带着这个思路来看 <code>Spring</code> 源码。</p>
<h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>上一篇我们说过，<code>SpringBoot</code> 会自动扫描导入 <code>org.springframework.boot.autoconfigure</code> 包下的所有的配置，这次，事务的自动配置是 <code>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</code>。因为导入项目已经有 <code>PlatformTransactionManager</code> 类，所以该配置将被自动执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransactionAutoConfiguration.java: </span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(PlatformTransactionManager.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; JtaAutoConfiguration.class, HibernateJpaAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">  DataSourceTransactionManagerAutoConfiguration.class, Neo4jDataAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(TransactionProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"> <span class="keyword">public</span> TransactionManagerCustomizers <span class="title function_">platformTransactionManagerCustomizers</span><span class="params">(</span></span><br><span class="line"><span class="params">   ObjectProvider&lt;PlatformTransactionManagerCustomizer&lt;?&gt;&gt; customizers)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionManagerCustomizers</span>(customizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"> <span class="meta">@ConditionalOnSingleCandidate(ReactiveTransactionManager.class)</span></span><br><span class="line"> <span class="keyword">public</span> TransactionalOperator <span class="title function_">transactionalOperator</span><span class="params">(ReactiveTransactionManager transactionManager)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> TransactionalOperator.create(transactionManager);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"> <span class="meta">@ConditionalOnSingleCandidate(PlatformTransactionManager.class)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TransactionTemplateConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(TransactionOperations.class)</span></span><br><span class="line">  <span class="keyword">public</span> TransactionTemplate <span class="title function_">transactionTemplate</span><span class="params">(PlatformTransactionManager transactionManager)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"> <span class="meta">@ConditionalOnBean(TransactionManager.class)</span></span><br><span class="line"> <span class="meta">@ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableTransactionManagementConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">  <span class="comment">// 重点是这个注解，导入了些东西</span></span><br><span class="line">  <span class="meta">@EnableTransactionManagement(proxyTargetClass = false)</span></span><br><span class="line">  <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = false)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">  <span class="meta">@EnableTransactionManagement(proxyTargetClass = true)</span></span><br><span class="line">  <span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnableTransactionManagement.java</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 导入一个Selector</span></span><br><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Indicate whether subclass-based (CGLIB) proxies are to be created (&#123;<span class="doctag">@code</span> true&#125;) as</span></span><br><span class="line"><span class="comment">  * opposed to standard Java interface-based proxies (&#123;<span class="doctag">@code</span> false&#125;). The default is</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@code</span> false&#125;. &lt;strong&gt;Applicable only if &#123;<span class="doctag">@link</span> #mode()&#125; is set to</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> AdviceMode#PROXY&#125;&lt;/strong&gt;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Note that setting this attribute to &#123;<span class="doctag">@code</span> true&#125; will affect &lt;em&gt;all&lt;/em&gt;</span></span><br><span class="line"><span class="comment">  * Spring-managed beans requiring proxying, not just those marked with</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@code</span> <span class="doctag">@Transactional</span>&#125;. For example, other beans marked with Spring&#x27;s</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@code</span> <span class="doctag">@Async</span>&#125; annotation will be upgraded to subclass proxying at the same</span></span><br><span class="line"><span class="comment">  * time. This approach has no negative impact in practice unless one is explicitly</span></span><br><span class="line"><span class="comment">  * expecting one type of proxy vs another, e.g. in tests.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Indicate how transactional advice should be applied.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;&lt;b&gt;The default is &#123;<span class="doctag">@link</span> AdviceMode#PROXY&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">  * Please note that proxy mode allows for interception of calls through the proxy</span></span><br><span class="line"><span class="comment">  * only. Local calls within the same class cannot get intercepted that way; an</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> Transactional&#125; annotation on such a method within a local call will be</span></span><br><span class="line"><span class="comment">  * ignored since Spring&#x27;s interceptor does not even kick in for such a runtime</span></span><br><span class="line"><span class="comment">  * scenario. For a more advanced mode of interception, consider switching this to</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> AdviceMode#ASPECTJ&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> AdviceMode <span class="title function_">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Indicate the ordering of the execution of the transaction advisor</span></span><br><span class="line"><span class="comment">  * when multiple advices are applied at a specific joinpoint.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;The default is &#123;<span class="doctag">@link</span> Ordered#LOWEST_PRECEDENCE&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TransactionManagementConfigurationSelector.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagementConfigurationSelector</span> <span class="keyword">extends</span> <span class="title class_">AdviceModeImportSelector</span>&lt;EnableTransactionManagement&gt; &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns &#123;<span class="doctag">@link</span> ProxyTransactionManagementConfiguration&#125; or</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@code</span> AspectJ(Jta)TransactionManagementConfiguration&#125; for &#123;<span class="doctag">@code</span> PROXY&#125;</span></span><br><span class="line"><span class="comment">  * and &#123;<span class="doctag">@code</span> ASPECTJ&#125; values of &#123;<span class="doctag">@link</span> EnableTransactionManagement#mode()&#125;,</span></span><br><span class="line"><span class="comment">  * respectively.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">   <span class="keyword">case</span> PROXY:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;AutoProxyRegistrar.class.getName(),</span><br><span class="line">      ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">   <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;determineTransactionAspectClass()&#125;;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String <span class="title function_">determineTransactionAspectClass</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (ClassUtils.isPresent(<span class="string">&quot;javax.transaction.Transactional&quot;</span>, getClass().getClassLoader()) ?</span><br><span class="line">    TransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME :</span><br><span class="line">    TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processImports</span><span class="params">(ConfigurationClass configClass, SourceClass currentSourceClass,</span></span><br><span class="line"><span class="params">  Collection&lt;SourceClass&gt; importCandidates, <span class="type">boolean</span> checkForCircularImports)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (importCandidates.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (checkForCircularImports &amp;&amp; isChainedImportOnStack(configClass)) &#123;</span><br><span class="line">  <span class="built_in">this</span>.problemReporter.error(<span class="keyword">new</span> <span class="title class_">CircularImportProblem</span>(configClass, <span class="built_in">this</span>.importStack));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.importStack.push(configClass);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (SourceClass candidate : importCandidates) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidate.isAssignable(ImportSelector.class)) &#123;</span><br><span class="line">     <span class="comment">// Candidate class is an ImportSelector -&gt; delegate to it to determine imports</span></span><br><span class="line">     Class&lt;?&gt; candidateClass = candidate.loadClass();</span><br><span class="line">     <span class="type">ImportSelector</span> <span class="variable">selector</span> <span class="operator">=</span> ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,</span><br><span class="line">       <span class="built_in">this</span>.environment, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.registry);</span><br><span class="line">     <span class="keyword">if</span> (selector <span class="keyword">instanceof</span> DeferredImportSelector) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在导入其他配置类的时候会使用上面的 selectImports 函数导入配置类</span></span><br><span class="line">      <span class="comment">// 然后重新解析配置</span></span><br><span class="line">      String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());</span><br><span class="line">      Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames);</span><br><span class="line">      processImports(configClass, currentSourceClass, importSourceClasses, <span class="literal">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>来到这里，配置类的东西就已经被注册到 <code>BeanFactory</code> 中去，那么据之前的 <code>SpringAOP</code> 的介绍，<code>BeanFactory</code> 会在每次初始化 <code>Bean</code> 的时候，调用 <code>BeanPostProcessor#postProcessAfterInitialization</code> 这个函数来创建真实 <code>Bean</code> 的代理对象。 然后这件事情就交给了 <code>AOP模块</code> 的 <code>InfrastructureAdvisorAutoProxyCreator</code> 来实现包装代理模式。</p>
<blockquote>
<p>篇幅关系我只放关键的代码片段，快速过一下前面的内容</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="comment">// 包装实际Bean</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                        mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// initializeBean</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;, getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="literal">null</span>  !mbd.isSynthetic()) &#123;</span><br><span class="line">    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">      (mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">      beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mbd == <span class="literal">null</span>  !mbd.isSynthetic()) &#123;</span><br><span class="line">    <span class="comment">// 创建完成，使用集成的后处理器处理对应的Bean</span></span><br><span class="line">    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// applyBeanPostProcessorsAfterInitialization使用后处理器包装Bean</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span><br><span class="line">  <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="comment">// 轮询到InfrastructureAdvisorAutoProxyCreator或AnnotationAwareAspectJAutoProxyCreator进行代理处理</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">current</span> <span class="operator">=</span> processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：使用 InfrastructureAdvisorAutoProxyCreator 还是 AnnotationAwareAspectJAutoProxyCreator 取决于当前项目有没有依赖 Spring-AOP 模块，如果依赖 Spring-AOP 模块则会交给 AnnotationAwareAspectJAutoProxyCreator 进行处理。 两者的区别是：InfrastructureAdvisorAutoProxyCreator 不负责织入用户自定义的 AOP 类</p>
</blockquote>
<p>然后，<code>AbstractAdvisorAutoProxyCreator</code> （两者的共同父类） 会找到所有的 <code>Advisor</code> 实现来织入这个实际对象的方法中。 因为在解析配置类的时候，<code>BeanFactoryTransactionAttributeSourceAdvisor</code> 这个类已经被注册到 <code>BeanFactory</code> 的 <code>BeanDefinitionMap</code> 中，所以第一个 <code>Bean</code>（大概率都是 <code>Spring</code> 自己需要的 <code>Bean</code>）创建的时候，就会触发上面自动配置中，创建 <code>BeanFactoryTransactionAttributeSourceAdvisor</code> 的配置类，调用方法进行相对应的创建。 然后又走了一遍 <code>getBean</code> 啊，<code>doCreateBean</code> 啊….创建 <code>BeanFactoryTransactionAttributeSourceAdvisor</code>。 好了，走完创建 <code>BeanFactoryTransactionAttributeSourceAdvisor</code> 的过程。我们现在需要看看怎么被织入。</p>
<h2 id="织入方法"><a href="#织入方法" class="headerlink" title="织入方法"></a>织入方法</h2><p>至于判定的方法，之前已经说过基于 <code>@PointCut</code> 切入，那么这个解析方式，应该很容易想到了吧，就是 <code>类注解</code> + <code>方法级别注解</code> 判定是否要切入当前方法。 上面两个织入类，无论怎么样都会来到这个函数织入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (isInfrastructureClass(bean.getClass())  shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">  <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取当前Bean所需要的AOP拦截器链</span></span><br><span class="line"> Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line"> <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">  <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">  <span class="comment">// 进入创建代理对象</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">    bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">  <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"> <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入配置并使用 <code>ProxyFactory</code> 来创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">  <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">  AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line"> proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">   proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line"> proxyFactory.addAdvisors(advisors);</span><br><span class="line"> proxyFactory.setTargetSource(targetSource);</span><br><span class="line"> customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line"> proxyFactory.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line"> <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">  proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 <code>getProxy</code> 方法，通过配置来指定配置工厂（<code>jdk代理</code> 或 <code>cglib</code>），然后调用两个工厂都有的 <code>getProxy</code> 来获取代理实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    activate();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DefaultAopProxyFactory.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.isOptimize()  config.isProxyTargetClass()  hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">    <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                   <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (targetClass.isInterface()  Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 虽然我的类是带有接口的，但是来到这里，使用cglib进行创建</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SpringBoot代理模式"><a href="#SpringBoot代理模式" class="headerlink" title="SpringBoot代理模式"></a>SpringBoot代理模式</h2><p>上面跑出来的小问题，为啥带有接口还是使用了 <code>cglib</code> 创建，跟我之前读 <code>Spring-AOP</code> 的时候是不一样的结果。 这里就要说到 <code>SpringBoot</code> 的自动创建配置了：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// META-INF/additional-spring-configuration-metadata.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;spring.aop.proxy-target-class&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.Boolean&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Whether subclass-based (CGLIB) proxies are to be created (true), as opposed to standard Java interface-based proxies (false).&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<p>然而搜遍谷歌 <code>Spring</code> 项目，只看到 <code>Spring</code> 成员说了一句： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91spring%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md/1.png"> </p>
<p>意思是 <code>Cglib</code> 代理能够减少类转换异常。</p>
<h2 id="织入拦截器"><a href="#织入拦截器" class="headerlink" title="织入拦截器"></a>织入拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">  <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line">  <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">   enhancer.setClassLoader(classLoader);</span><br><span class="line">   <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">     ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">    enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">  enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised));</span><br><span class="line">  enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">  enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">ClassLoaderAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Callback这里即会织入BeanFactoryTransactionAttributeSourceAdvisor中的拦截器：</span></span><br><span class="line">  <span class="comment">// TransactionInterceptor</span></span><br><span class="line">  Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">  Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[callbacks.length];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">   types[x] = callbacks[x].getClass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">  enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">ProxyCallbackFilter</span>(</span><br><span class="line">    <span class="built_in">this</span>.advised.getConfigurationOnlyCopy(), <span class="built_in">this</span>.fixedInterceptorMap, <span class="built_in">this</span>.fixedInterceptorOffset));</span><br><span class="line">  enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">  <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (CodeGenerationException  IllegalArgumentException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="built_in">this</span>.advised.getTargetClass() +</span><br><span class="line">    <span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">    ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拦截器织入完成接下来就需要看看怎么被调用的了。</p>
<hr>
<h2 id="插入事务"><a href="#插入事务" class="headerlink" title="插入事务"></a>插入事务</h2><p>真男人要直接，直接在 <code>Controller</code> 打断点，进入业务方法之前，会先进入 <code>TransactionInterceptor#invoke</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="comment">// 获取目标类</span></span><br><span class="line"> Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 开启事务执行方法</span></span><br><span class="line"> <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呃，代码还是挺长的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">  <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取所有配置的事务属性元数据类，如果为null，代表默认事务（默认是autoCommit=true）</span></span><br><span class="line"> <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line"> <span class="comment">// 从缓存中命中当前方法的事务配置</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line"> <span class="comment">// 获取事务管理器</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Reactive环境走这里，先跳过</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.reactiveAdapterRegistry != <span class="literal">null</span> &amp;&amp; tm <span class="keyword">instanceof</span> ReactiveTransactionManager) &#123;</span><br><span class="line">  <span class="type">ReactiveTransactionSupport</span> <span class="variable">txSupport</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionSupportCache.computeIfAbsent(method, key -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass()) &amp;&amp; KotlinDelegate.isSuspend(method)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionUsageException</span>(</span><br><span class="line">      <span class="string">&quot;Unsupported annotated transaction on suspending function detected: &quot;</span> + method +</span><br><span class="line">      <span class="string">&quot;. Use TransactionalOperator.transactional extensions instead.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">ReactiveAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="built_in">this</span>.reactiveAdapterRegistry.getAdapter(method.getReturnType());</span><br><span class="line">   <span class="keyword">if</span> (adapter == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot apply reactive transaction to non-reactive return type: &quot;</span> +</span><br><span class="line">      method.getReturnType());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReactiveTransactionSupport</span>(adapter);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> txSupport.invokeWithinTransaction(</span><br><span class="line">    method, targetClass, invocation, txAttr, (ReactiveTransactionManager) tm);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取Spring提供的统一事务管理器</span></span><br><span class="line"> <span class="type">PlatformTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> asPlatformTransactionManager(tm);</span><br><span class="line"> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (txAttr == <span class="literal">null</span>  !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">  <span class="comment">// 创建或者加入当前事务</span></span><br><span class="line">  <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">  Object retVal;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 执行目标方法，如果有下一个AOP链则接下去执行</span></span><br><span class="line">   retVal = invocation.proceedWithInvocation();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">   <span class="comment">// 遇到异常，回滚数据库事务</span></span><br><span class="line">   completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">   cleanupTransactionInfo(txInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应式数据库操作 也是先跳过</span></span><br><span class="line">  <span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">   <span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">   <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txInfo.getTransactionStatus();</span><br><span class="line">   <span class="keyword">if</span> (status != <span class="literal">null</span> &amp;&amp; txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">    retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交数据库事务</span></span><br><span class="line">  commitTransactionAfterReturning(txInfo);</span><br><span class="line">  <span class="keyword">return</span> retVal;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// CallbackPreferringPlatformTransactionManager 可回调的管理器</span></span><br><span class="line"> <span class="comment">// 也是响应式的内容</span></span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ThrowableHolder</span> <span class="variable">throwableHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThrowableHolder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It&#x27;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -&gt; &#123;</span><br><span class="line">    <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> invocation.proceedWithInvocation();</span><br><span class="line">     <span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">      <span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">      retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">     <span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">      <span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">       <span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ThrowableHolderException</span>(ex);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line">      throwableHolder.throwable = ex;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">     cleanupTransactionInfo(txInfo);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check result state: It might indicate a Throwable to rethrow.</span></span><br><span class="line">   <span class="keyword">if</span> (throwableHolder.throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> throwableHolder.throwable;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line">   <span class="keyword">throw</span> ex.getCause();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">   <span class="keyword">if</span> (throwableHolder.throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">    ex2.initApplicationException(throwableHolder.throwable);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> ex2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">   <span class="keyword">if</span> (throwableHolder.throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> ex2;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那下面就一步一步来看。</p>
<h2 id="TransactionAttribute事务属性"><a href="#TransactionAttribute事务属性" class="headerlink" title="TransactionAttribute事务属性"></a>TransactionAttribute事务属性</h2><p>这是一个定义了事务级别以及其他比如超时信息的事务元信息类，当前获取的是一个 <code>RuleBasedTransactionAttribute</code> 基于一定规则的事务属性，定义了必须在抛出 <code>Runtime</code> 异常的时候回滚数据库。 父级是 <code>TransactionDefinition</code>，这可是一个元老级别的类了，定义了事务管理器常见所需的隔离级别。 </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91spring%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md/2.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ------------------------------ Spring事务隔离级别 ------------------------------</span></span><br><span class="line"> <span class="comment">// 如果当前没有事务，则创建一个新事务</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果当前没有事务则以无事务的方式运行</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">PROPAGATION_SUPPORTS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 当前有事务就加入没有就抛异常</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">PROPAGATION_MANDATORY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 阻塞当前事务，创建一个子事务</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRES_NEW</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 一直以无事务的状态运行</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">PROPAGATION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果当前有事务则抛出异常</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">PROPAGATION_NEVER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果存在事务则在嵌套事务中运行</span></span><br><span class="line"> <span class="comment">// 行为类似于 PROPAGATION_REQUIRED</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">PROPAGATION_NESTED</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ------------------------------ jdbc原生事务隔离级别 ------------------------------</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用数据库默认的级别</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">ISOLATION_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 未提交读</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">ISOLATION_READ_UNCOMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// same as java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不可重复读</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">ISOLATION_READ_COMMITTED</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// same as java.sql.Connection.TRANSACTION_READ_COMMITTED;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 可重复读</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">ISOLATION_REPEATABLE_READ</span> <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">// same as java.sql.Connection.TRANSACTION_REPEATABLE_READ;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 串行执行事务</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">ISOLATION_SERIALIZABLE</span> <span class="operator">=</span> <span class="number">8</span>;  <span class="comment">// same as java.sql.Connection.TRANSACTION_SERIALIZABLE;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Use the default timeout of the underlying transaction system,</span></span><br><span class="line"><span class="comment">  * or none if timeouts are not supported.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">TIMEOUT_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Return the propagation behavior.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Must return one of the &#123;<span class="doctag">@code</span> PROPAGATION_XXX&#125; constants</span></span><br><span class="line"><span class="comment">  * defined on &#123;<span class="doctag">@link</span> TransactionDefinition this interface&#125;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;The default is &#123;<span class="doctag">@link</span> #PROPAGATION_REQUIRED&#125;.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the propagation behavior</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #PROPAGATION_REQUIRED</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.transaction.support.TransactionSynchronizationManager#isActualTransactionActive()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> PROPAGATION_REQUIRED;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Return the isolation level.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Must return one of the &#123;<span class="doctag">@code</span> ISOLATION_XXX&#125; constants defined on</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> TransactionDefinition this interface&#125;. Those constants are designed</span></span><br><span class="line"><span class="comment">  * to match the values of the same constants on &#123;<span class="doctag">@link</span> java.sql.Connection&#125;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Exclusively designed for use with &#123;<span class="doctag">@link</span> #PROPAGATION_REQUIRED&#125; or</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #PROPAGATION_REQUIRES_NEW&#125; since it only applies to newly started</span></span><br><span class="line"><span class="comment">  * transactions. Consider switching the &quot;validateExistingTransactions&quot; flag to</span></span><br><span class="line"><span class="comment">  * &quot;true&quot; on your transaction manager if you&#x27;d like isolation level declarations</span></span><br><span class="line"><span class="comment">  * to get rejected when participating in an existing transaction with a different</span></span><br><span class="line"><span class="comment">  * isolation level.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;The default is &#123;<span class="doctag">@link</span> #ISOLATION_DEFAULT&#125;. Note that a transaction manager</span></span><br><span class="line"><span class="comment">  * that does not support custom isolation levels will throw an exception when</span></span><br><span class="line"><span class="comment">  * given any other level than &#123;<span class="doctag">@link</span> #ISOLATION_DEFAULT&#125;.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the isolation level</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #ISOLATION_DEFAULT</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.transaction.support.AbstractPlatformTransactionManager#setValidateExistingTransaction</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ISOLATION_DEFAULT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Return the transaction timeout.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Must return a number of seconds, or &#123;<span class="doctag">@link</span> #TIMEOUT_DEFAULT&#125;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Exclusively designed for use with &#123;<span class="doctag">@link</span> #PROPAGATION_REQUIRED&#125; or</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #PROPAGATION_REQUIRES_NEW&#125; since it only applies to newly started</span></span><br><span class="line"><span class="comment">  * transactions.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Note that a transaction manager that does not support timeouts will throw</span></span><br><span class="line"><span class="comment">  * an exception when given any other timeout than &#123;<span class="doctag">@link</span> #TIMEOUT_DEFAULT&#125;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;The default is &#123;<span class="doctag">@link</span> #TIMEOUT_DEFAULT&#125;.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the transaction timeout</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> TIMEOUT_DEFAULT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Return whether to optimize as a read-only transaction.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;The read-only flag applies to any transaction context, whether backed</span></span><br><span class="line"><span class="comment">  * by an actual resource transaction (&#123;<span class="doctag">@link</span> #PROPAGATION_REQUIRED&#125;/</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #PROPAGATION_REQUIRES_NEW&#125;) or operating non-transactionally at</span></span><br><span class="line"><span class="comment">  * the resource level (&#123;<span class="doctag">@link</span> #PROPAGATION_SUPPORTS&#125;). In the latter case,</span></span><br><span class="line"><span class="comment">  * the flag will only apply to managed resources within the application,</span></span><br><span class="line"><span class="comment">  * such as a Hibernate &#123;<span class="doctag">@code</span> Session&#125;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This just serves as a hint for the actual transaction subsystem;</span></span><br><span class="line"><span class="comment">  * it will &lt;i&gt;not necessarily&lt;/i&gt; cause failure of write access attempts.</span></span><br><span class="line"><span class="comment">  * A transaction manager which cannot interpret the read-only hint will</span></span><br><span class="line"><span class="comment">  * &lt;i&gt;not&lt;/i&gt; throw an exception when asked for a read-only transaction.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the transaction is to be optimized as read-only</span></span><br><span class="line"><span class="comment">  * (&#123;<span class="doctag">@code</span> false&#125; by default)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.transaction.support.TransactionSynchronization#beforeCommit(boolean)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.transaction.support.TransactionSynchronizationManager#isCurrentTransactionReadOnly()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Return the name of this transaction. Can be &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This will be used as the transaction name to be shown in a</span></span><br><span class="line"><span class="comment">  * transaction monitor, if applicable (for example, WebLogic&#x27;s).</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;In case of Spring&#x27;s declarative transactions, the exposed name will be</span></span><br><span class="line"><span class="comment">  * the &#123;<span class="doctag">@code</span> fully-qualified class name + &quot;.&quot; + method name&#125; (by default).</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the name of this transaction (&#123;<span class="doctag">@code</span> null&#125; by default&#125;</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.transaction.interceptor.TransactionAspectSupport</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.transaction.support.TransactionSynchronizationManager#getCurrentTransactionName()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Static builder methods</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Return an unmodifiable &#123;<span class="doctag">@code</span> TransactionDefinition&#125; with defaults.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;For customization purposes, use the modifiable</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> org.springframework.transaction.support.DefaultTransactionDefinition&#125;</span></span><br><span class="line"><span class="comment">  * instead.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 5.2</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">static</span> TransactionDefinition <span class="title function_">withDefaults</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> StaticTransactionDefinition.INSTANCE;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这个东西用在哪里呢，后面就会看到处理方式了，先放一放。</p>
<h2 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h2><p>这一步没做什么，就当是单纯获得了一个事务管理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TransactionManager <span class="title function_">determineTransactionManager</span><span class="params">(<span class="meta">@Nullable</span> TransactionAttribute txAttr)</span> &#123;</span><br><span class="line"> <span class="comment">// Do not attempt to lookup tx manager if no tx attributes are set</span></span><br><span class="line"> <span class="keyword">if</span> (txAttr == <span class="literal">null</span>  <span class="built_in">this</span>.beanFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> getTransactionManager();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">String</span> <span class="variable">qualifier</span> <span class="operator">=</span> txAttr.getQualifier();</span><br><span class="line"> <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">  <span class="keyword">return</span> determineQualifiedTransactionManager(<span class="built_in">this</span>.beanFactory, qualifier);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.transactionManagerBeanName)) &#123;</span><br><span class="line">  <span class="keyword">return</span> determineQualifiedTransactionManager(<span class="built_in">this</span>.beanFactory, <span class="built_in">this</span>.transactionManagerBeanName);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="type">TransactionManager</span> <span class="variable">defaultTransactionManager</span> <span class="operator">=</span> getTransactionManager();</span><br><span class="line">  <span class="keyword">if</span> (defaultTransactionManager == <span class="literal">null</span>) &#123;</span><br><span class="line">   defaultTransactionManager = <span class="built_in">this</span>.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);</span><br><span class="line">   <span class="keyword">if</span> (defaultTransactionManager == <span class="literal">null</span>) &#123;</span><br><span class="line">    defaultTransactionManager = <span class="built_in">this</span>.beanFactory.getBean(TransactionManager.class);</span><br><span class="line">    <span class="built_in">this</span>.transactionManagerCache.putIfAbsent(</span><br><span class="line">      DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> defaultTransactionManager;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开启数据库事务"><a href="#开启数据库事务" class="headerlink" title="开启数据库事务"></a>开启数据库事务</h2><p>可以看到，传递了一个事务定义元数据来创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span><br><span class="line"><span class="params">  <span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 处理名字</span></span><br><span class="line"> <span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; txAttr.getName() == <span class="literal">null</span>) &#123;</span><br><span class="line">  txAttr = <span class="keyword">new</span> <span class="title class_">DelegatingTransactionAttribute</span>(txAttr) &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line">   status = tm.getTransaction(txAttr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line">      <span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 管理当前开启的事务管理器</span></span><br><span class="line"> <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，先根据当前的事务管理级别创建 <code>TransactionStatus</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span><br><span class="line">  <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取 TransactionDefinition，如果配置中没有定义则获取默认的事务定义.</span></span><br><span class="line"> <span class="type">TransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> (definition != <span class="literal">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取事务状态对象</span></span><br><span class="line"> <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line"> <span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">  <span class="comment">// 当前存在事务，根据不同等级返回 TransactionStatus.</span></span><br><span class="line">  <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 超时的话抛出异常.</span></span><br><span class="line"> <span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTimeoutException</span>(<span class="string">&quot;Invalid transaction timeout&quot;</span>, def.getTimeout());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不存在事务的时候，需要根据上面的事务定义来继续行为.</span></span><br><span class="line"> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">  <span class="comment">// 这个等级是没有事务即抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">    <span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED </span><br><span class="line">   def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW </span><br><span class="line">   def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">  <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">   logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 创建新的 TransactionStatus 然后开启数据库事务</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">   <span class="comment">// 创建一个新的DefaultTransactionStatus贯穿整个事务</span></span><br><span class="line">   <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> newTransactionStatus(</span><br><span class="line">     def, transaction, <span class="literal">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">     <span class="comment">// 开启新事务</span></span><br><span class="line">   doBegin(transaction, def);</span><br><span class="line">   <span class="comment">// 设置激活程序中的事务管理器，设置只读属性、事务名字、隔离级别等信息</span></span><br><span class="line">   prepareSynchronization(status, def);</span><br><span class="line">   <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (RuntimeException  Error ex) &#123;</span><br><span class="line">   resume(<span class="literal">null</span>, suspendedResources);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">  <span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">   logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line">     <span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + def);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">  <span class="keyword">return</span> prepareTransactionStatus(def, <span class="literal">null</span>, <span class="literal">true</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，接下来看看 <code>doBegin</code> 怎么管理 <code>Connection</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启事务管理器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> &#123;</span><br><span class="line"> <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line"> <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!txObject.hasConnectionHolder() </span><br><span class="line">    txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">   <span class="comment">// 通过数据库连接池拿到 Connection</span></span><br><span class="line">   <span class="type">Connection</span> <span class="variable">newCon</span> <span class="operator">=</span> obtainDataSource().getConnection();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Acquired Connection [&quot;</span> + newCon + <span class="string">&quot;] for JDBC transaction&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 使用ConnectionHolder管理当前的连接</span></span><br><span class="line">   txObject.setConnectionHolder(<span class="keyword">new</span> <span class="title class_">ConnectionHolder</span>(newCon), <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="literal">true</span>);</span><br><span class="line">  con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connection属性设置（之前的隔离级别、是否只读）</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">previousIsolationLevel</span> <span class="operator">=</span> DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">  txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line">  txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改Connection的只读状态</span></span><br><span class="line">  <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">   txObject.setMustRestoreAutoCommit(<span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前是只读事务则发送 SET TRANSACTION READ ONLY 给数据库切换事务状态</span></span><br><span class="line">  prepareTransactionalConnection(con, definition);</span><br><span class="line">  txObject.getConnectionHolder().setTransactionActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> determineTimeout(definition);</span><br><span class="line">  <span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">   txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把ConnectionHolder绑定到TransactionSynchronizationManager</span></span><br><span class="line">  <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">   TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">   DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">   txObject.setConnectionHolder(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CannotCreateTransactionException</span>(<span class="string">&quot;Could not open JDBC Connection for transaction&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开始执行"><a href="#开始执行" class="headerlink" title="开始执行"></a>开始执行</h2><p>为了防止需要拖拉到上面去阅读，我先把之前执行到哪个地方放在这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params">  <span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取所有配置的事务属性元数据类，如果为null，代表默认事务（默认是autoCommit=true）</span></span><br><span class="line"> <span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line"> <span class="comment">// 从缓存中命中当前方法的事务配置</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line"> <span class="comment">// 获取事务管理器</span></span><br><span class="line"> <span class="keyword">final</span> <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Reactive环境走这里，先跳过</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.reactiveAdapterRegistry != <span class="literal">null</span> &amp;&amp; tm <span class="keyword">instanceof</span> ReactiveTransactionManager) &#123;</span><br><span class="line">  <span class="type">ReactiveTransactionSupport</span> <span class="variable">txSupport</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionSupportCache.computeIfAbsent(method, key -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass()) &amp;&amp; KotlinDelegate.isSuspend(method)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionUsageException</span>(</span><br><span class="line">      <span class="string">&quot;Unsupported annotated transaction on suspending function detected: &quot;</span> + method +</span><br><span class="line">      <span class="string">&quot;. Use TransactionalOperator.transactional extensions instead.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">ReactiveAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="built_in">this</span>.reactiveAdapterRegistry.getAdapter(method.getReturnType());</span><br><span class="line">   <span class="keyword">if</span> (adapter == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot apply reactive transaction to non-reactive return type: &quot;</span> +</span><br><span class="line">      method.getReturnType());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReactiveTransactionSupport</span>(adapter);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> txSupport.invokeWithinTransaction(</span><br><span class="line">    method, targetClass, invocation, txAttr, (ReactiveTransactionManager) tm);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取Spring提供的统一事务管理器</span></span><br><span class="line"> <span class="type">PlatformTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> asPlatformTransactionManager(tm);</span><br><span class="line"> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (txAttr == <span class="literal">null</span>  !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">  <span class="comment">// 创建或者加入当前事务</span></span><br><span class="line">  <span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">  Object retVal;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 执行目标方法，如果有下一个AOP链则接下去执行</span></span><br><span class="line">   <span class="comment">// ---------------&gt; 已经准备好了事务信息，可以开始执行整个AOP链条了</span></span><br><span class="line">   retVal = invocation.proceedWithInvocation();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">   <span class="comment">// 遇到异常，回滚数据库事务</span></span><br><span class="line">   completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">// 清空当前事务，如果当前是嵌套事务，管理器会重新拿到之前的事务</span></span><br><span class="line">   cleanupTransactionInfo(txInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应式数据库操作 也是先跳过</span></span><br><span class="line">  <span class="keyword">if</span> (vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line">   <span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">   <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txInfo.getTransactionStatus();</span><br><span class="line">   <span class="keyword">if</span> (status != <span class="literal">null</span> &amp;&amp; txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">    retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交数据库事务</span></span><br><span class="line">  commitTransactionAfterReturning(txInfo);</span><br><span class="line">  <span class="keyword">return</span> retVal;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// CallbackPreferringPlatformTransactionManager 可回调的管理器</span></span><br><span class="line"> <span class="comment">// 也是响应式的内容</span></span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 省略响应式内容.........</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正常提交"><a href="#正常提交" class="headerlink" title="正常提交"></a>正常提交</h2><p>拿到事务管理器，提交事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commitTransactionAfterReturning</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   logger.trace(<span class="string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要经过判断来做是否真正提交：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line"> <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">    <span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 根据用户TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();设置</span></span><br><span class="line"> <span class="comment">// 是否不让提交（比如校验没有通过，但是没有抛出异常） 如果设置了则回滚数据库</span></span><br><span class="line"> <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">   logger.debug(<span class="string">&quot;Transactional code has requested rollback&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 这里是判断全局事务中配置了只能在全局回滚并且当前已经出现错误，如果当前是内部事务，会标记业务层事务出现错误</span></span><br><span class="line"> <span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">   logger.debug(<span class="string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  processRollback(defStatus, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 处理提交事务</span></span><br><span class="line"> processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理提交，可以说，我们项目中使用到提交事务生命周期都在这里被调用到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">beforeCompletionInvoked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="variable">unexpectedRollback</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">// 下面三个是调用相对应的生命周期</span></span><br><span class="line">   prepareForCommit(status);</span><br><span class="line">   triggerBeforeCommit(status);</span><br><span class="line">   triggerBeforeCompletion(status);</span><br><span class="line">   beforeCompletionInvoked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// SavePoint 先不看</span></span><br><span class="line">   <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">     logger.debug(<span class="string">&quot;Releasing transaction savepoint&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">    status.releaseHeldSavepoint();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 当前是一个新的事务</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">     logger.debug(<span class="string">&quot;Initiating transaction commit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">    <span class="comment">// 真正做提交的地方</span></span><br><span class="line">    doCommit(status);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">    unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Throw UnexpectedRollbackException if we have a global rollback-only</span></span><br><span class="line">   <span class="comment">// marker but still didn&#x27;t get a corresponding exception from commit.</span></span><br><span class="line">   <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedRollbackException</span>(</span><br><span class="line">      <span class="string">&quot;Transaction silently rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (UnexpectedRollbackException ex) &#123;</span><br><span class="line">   <span class="comment">// can only be caused by doCommit</span></span><br><span class="line">   triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (TransactionException ex) &#123;</span><br><span class="line">   <span class="comment">// can only be caused by doCommit</span></span><br><span class="line">   <span class="keyword">if</span> (isRollbackOnCommitFailure()) &#123;</span><br><span class="line">    doRollbackOnCommitException(status, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (RuntimeException  Error ex) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!beforeCompletionInvoked) &#123;</span><br><span class="line">    triggerBeforeCompletion(status);</span><br><span class="line">   &#125;</span><br><span class="line">   doRollbackOnCommitException(status, ex);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger afterCommit callbacks, with an exception thrown there</span></span><br><span class="line">  <span class="comment">// propagated to callers but the transaction still considered as committed.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 调用事务生命周期的后处理器</span></span><br><span class="line">   triggerAfterCommit(status);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">   triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  cleanupAfterCompletion(status);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到 <code>Connection</code> 调用 <code>Commit</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doCommit</span><span class="params">(DefaultTransactionStatus status)</span> &#123;</span><br><span class="line"> <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line"> <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> txObject.getConnectionHolder().getConnection();</span><br><span class="line"> <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">  logger.debug(<span class="string">&quot;Committing JDBC transaction on Connection [&quot;</span> + con + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  con.commit();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionSystemException</span>(<span class="string">&quot;Could not commit JDBC transaction&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回滚数据库"><a href="#回滚数据库" class="headerlink" title="回滚数据库"></a>回滚数据库</h2><p>业务代码加一个除以 <code>0</code> 的计算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name, String orgName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;insert into user_info(user_uuid, user_name)\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;values (?,?);&quot;</span>, userId, name);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">orgUUID</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    jdbcTemplate.update(<span class="string">&quot;insert into org_info(org_uuid, org_name, user_uuid)\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;VALUES (?, ?, ?);&quot;</span>, orgUUID, orgName, userId);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么出现了异常了，这一步会来到 try-catch 中的 catch：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 执行目标方法，如果有下一个AOP链则接下去执行</span></span><br><span class="line">  retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="comment">// 遇到异常，回滚数据库事务</span></span><br><span class="line">  completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是简单了很多了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">completeTransactionAfterThrowing</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (txInfo != <span class="literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   logger.trace(<span class="string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() +</span><br><span class="line">     <span class="string">&quot;] after exception: &quot;</span> + ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前抛出的异常是否需要回滚数据库</span></span><br><span class="line">  <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);</span><br><span class="line">    ex2.initApplicationException(ex);</span><br><span class="line">    <span class="keyword">throw</span> ex2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (RuntimeException  Error ex2) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex2;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果不会滚，继续提交</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// We don&#x27;t roll back on this exception.</span></span><br><span class="line">   <span class="comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, ex);</span><br><span class="line">    ex2.initApplicationException(ex);</span><br><span class="line">    <span class="keyword">throw</span> ex2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (RuntimeException  Error ex2) &#123;</span><br><span class="line">    logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex2;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧来到了处理方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line"> <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">    <span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">DefaultTransactionStatus</span> <span class="variable">defStatus</span> <span class="operator">=</span> (DefaultTransactionStatus) status;</span><br><span class="line"> processRollback(defStatus, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么其实跟提交的套路是一样的，触发一系列的生命周期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="type">boolean</span> unexpected)</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">unexpectedRollback</span> <span class="operator">=</span> unexpected;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">     logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    status.rollbackToHeldSavepoint();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">     logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    doRollback(status);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Participating in larger transaction</span></span><br><span class="line">    <span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">     <span class="keyword">if</span> (status.isLocalRollbackOnly()  isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">       logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      doSetRollbackOnly(status);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">       logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">     logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Unexpected rollback only matters here if we&#x27;re asked to fail early</span></span><br><span class="line">    <span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">     unexpectedRollback = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (RuntimeException  Error ex) &#123;</span><br><span class="line">   triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line">  <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedRollbackException</span>(</span><br><span class="line">     <span class="string">&quot;Transaction rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  cleanupAfterCompletion(status);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到 <code>Connection</code> 进行回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> &#123;</span><br><span class="line"> <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line"> <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> txObject.getConnectionHolder().getConnection();</span><br><span class="line"> <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">  logger.debug(<span class="string">&quot;Rolling back JDBC transaction on Connection [&quot;</span> + con + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  con.rollback();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransactionSystemException</span>(<span class="string">&quot;Could not roll back JDBC transaction&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring源码】一个我们日常使用的AOP实现</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84aop%E5%AE%9E%E7%8E%B0/index.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于 <code>AOP</code> 在日常开发中应该不算是一个新的名词了，<code>AOP</code> 可以帮助我们把业务之外，但是很多方法都需要调用的方法，无感的方外外部，并且通过配置让外部的 <code>AOP</code> 函数自动织入目标方法中。 常见的业务有：</p>
<ol>
<li> 记录方法调用的信息，时长；</li>
<li> 初始化当前用户信息上下文，方便在业务内部快速获取。</li>
</ol>
<p>那我就改改我之前的 <code>Context</code> 用的例子，来康康 <code>Spring</code> 是怎么做的。</p>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><code>applicationContext.xml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">       http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">       http://www.springframework.org/schema/aop</span><br><span class="line">       http://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class="line">&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;cn.liweidan.confbean.MyBeanConfiguration&quot;/&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;!-- 开启自动代理支持 --&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p><code>MyBeanConfiguration.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  @Bean</span></span><br><span class="line"><span class="comment">//  public MyBean myBean() &#123;</span></span><br><span class="line"><span class="comment">//    MyBean myBean = new MyBean();</span></span><br><span class="line"><span class="comment">//    myBean.setName(&quot;Weidan&quot;);</span></span><br><span class="line"><span class="comment">//    return myBean;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> NoInterfaceService <span class="title function_">noInterfaceService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NoInterfaceService</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> MethodAop <span class="title function_">methodAop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodAop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> HasInterfaceService <span class="title function_">hasInterfaceService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HasInterfaceServiceImpl</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个没有接口实现的业务层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoInterfaceService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是方法里面的内容&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个有接口实现的业务层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HasInterfaceService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">testHasInterface</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasInterfaceServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HasInterfaceService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHasInterface</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;一个有接口的方法的内部&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个注解方式的自动织入 <code>Bean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAop</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* cn.liweidan.confbean.service.*.*(..))  execution(* cn.liweidan.confbean.services.impl.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aopPoint</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;aopPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;方法开始执行&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        System.out.println(joinPoint.getSignature().getDeclaringTypeName() + <span class="string">&quot;方法完成执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigBeanTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">NoInterfaceService</span> <span class="variable">bean</span> <span class="operator">=</span> bf.getBean(NoInterfaceService.class);</span><br><span class="line">    bean.test();</span><br><span class="line">    <span class="type">HasInterfaceService</span> <span class="variable">hasInterfaceService</span> <span class="operator">=</span> bf.getBean(HasInterfaceService.class);</span><br><span class="line">    hasInterfaceService.testHasInterface();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试运行一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cn.liweidan.confbean.service.NoInterfaceService方法开始执行</span><br><span class="line">这是方法里面的内容</span><br><span class="line">cn.liweidan.confbean.service.NoInterfaceService方法完成执行</span><br><span class="line">cn.liweidan.confbean.services.HasInterfaceService方法开始执行</span><br><span class="line">一个有接口的方法的内部</span><br><span class="line">cn.liweidan.confbean.services.HasInterfaceService方法完成执行</span><br></pre></td></tr></table></figure>
<p>好了成功！</p>
<h2 id="注册标签处理器"><a href="#注册标签处理器" class="headerlink" title="注册标签处理器"></a>注册标签处理器</h2><p>之前几篇我都直接跳过 <code>xml</code> 解析，这次终于跳不过去了。因为在处理器这一块，<code>Spring</code> 确实能够让我特别惊喜，模块间的解耦仿佛就是我不知道你有什么东西我也不关心但是最后我就能够调用到你的傲娇姑娘的任性。 让我们回到第一篇的 <code>BeanDefinitionDocumentReader读取配置文档</code> 这一节中（<a href="https://liweidan.cn/java/frame/spring-source/2019/12/03/379/#BeanDefinitionDocumentReader">传送门</a>），我重新贴一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line"> <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"> <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"> <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"> <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"> <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"> <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line"> <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line"> <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">   String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">     profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">   <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">   <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">   <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">     logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">       <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> preProcessXml(root);</span><br><span class="line"> <span class="comment">// 来到这句话中，因为这句话会解析到配置文件中的 &lt;aop:aspectj-autoproxy/&gt; 元素中。</span></span><br><span class="line"> parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line"> postProcessXml(root);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个方法中实现解析：</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">          parseDefaultElement(ele, delegate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 因为 &lt;aop:aspectj-autoproxy/&gt; 并不是默认的命名空间(默认只有：http://www.springframework.org/schema/beans)，</span></span><br><span class="line">          <span class="comment">// 所以需要调用自定义的处理器来解析元素.</span></span><br><span class="line">          delegate.parseCustomElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parse a custom element (outside of the default namespace).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele the element to parse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the resulting bean definition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> parseCustomElement(ele, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Parse a custom element (outside of the default namespace).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ele the element to parse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> containingBd the containing bean definition (if any)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the resulting bean definition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line">  <span class="comment">// AOP的命名空间是http://www.springframework.org/schema/aop</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> getNamespaceURI(ele);</span><br><span class="line">  <span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开始从上下文中寻找合适的解析器，第一个方法只是简单地返回一个实例</span></span><br><span class="line">  <span class="comment">// 那下面直接看看 resolve 怎么处理的</span></span><br><span class="line">  <span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">  <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在寻找解析器这一步就挺骚了，直接从所有模块中的 <code>META-INF/spring.handlers</code> 中开始查找其他模块配置的解析器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> NamespaceHandler <span class="title function_">resolve</span><span class="params">(String namespaceUri)</span> &#123;</span><br><span class="line"><span class="comment">// 获取所有的解析器，依赖的所有 jar 包都会读取</span></span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">    <span class="comment">// 因为获取的是字符串，所以需要通过反射实例化解析器对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">handlerOrClassName</span> <span class="operator">=</span> handlerMappings.get(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handlerOrClassName == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">        <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> (String) handlerOrClassName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="built_in">this</span>.classLoader);</span><br><span class="line">            <span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FatalBeanException</span>(<span class="string">&quot;Class [&quot;</span> + className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri +</span><br><span class="line">                        <span class="string">&quot;] does not implement the [&quot;</span> + NamespaceHandler.class.getName() + <span class="string">&quot;] interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">// 实例化对象</span></span><br><span class="line">            <span class="type">NamespaceHandler</span> <span class="variable">namespaceHandler</span> <span class="operator">=</span> (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">            namespaceHandler.init();</span><br><span class="line">    <span class="comment">// 覆盖之前的字符串，以便后面如果还需要可以直接返回对象。</span></span><br><span class="line">            handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">            <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FatalBeanException</span>(<span class="string">&quot;Could not find NamespaceHandler class [&quot;</span> + className +</span><br><span class="line">                    <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FatalBeanException</span>(<span class="string">&quot;Unresolvable class definition for NamespaceHandler class [&quot;</span> +</span><br><span class="line">                    className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 惰性读取所有解析器.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">getHandlerMappings</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = <span class="built_in">this</span>.handlerMappings;</span><br><span class="line">    <span class="keyword">if</span> (handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            handlerMappings = <span class="built_in">this</span>.handlerMappings;</span><br><span class="line">            <span class="keyword">if</span> (handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(<span class="string">&quot;Loading NamespaceHandler mappings from [&quot;</span> + <span class="built_in">this</span>.handlerMappingsLocation + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这一步就是从配置的 handlerMappingsLocation=DEFAULT_HANDLER_MAPPINGS_LOCATION = &quot;META-INF/spring.handlers&quot; 中去查找其他模块编写的配置文件，然后获取到对象的自定义标签的解析器</span></span><br><span class="line">                    <span class="type">Properties</span> <span class="variable">mappings</span> <span class="operator">=</span></span><br><span class="line">                            PropertiesLoaderUtils.loadAllProperties(<span class="built_in">this</span>.handlerMappingsLocation, <span class="built_in">this</span>.classLoader);</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Loaded NamespaceHandler mappings: &quot;</span> + mappings);</span><br><span class="line">                    &#125;</span><br><span class="line">        <span class="comment">// 开始加载解析器，然后缓存起来返回到上面的方法中。</span></span><br><span class="line">                    handlerMappings = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(mappings.size());</span><br><span class="line">                    CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line">                    <span class="built_in">this</span>.handlerMappings = handlerMappings;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                            <span class="string">&quot;Unable to load NamespaceHandler mappings from location [&quot;</span> + <span class="built_in">this</span>.handlerMappingsLocation + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AOP模块中的 <code>META-INF/spring.handlers</code> ：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">http\://www.springframework.org/schema/aop</span>=<span class="string">org.springframework.aop.config.AopNamespaceHandler</span></span><br></pre></td></tr></table></figure>
<p>然后就可以开始使用其他模块的处理器开始处理元素了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line">  <span class="comment">// AOP的命名空间是http://www.springframework.org/schema/aop</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> getNamespaceURI(ele);</span><br><span class="line">  <span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开始从上下文中寻找合适的解析器，第一个方法只是简单地返回一个实例</span></span><br><span class="line">  <span class="comment">// 那下面直接看看 resolve 怎么处理的</span></span><br><span class="line">  <span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">  <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">    error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开始处理</span></span><br><span class="line">  <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化AOP所需环境"><a href="#初始化AOP所需环境" class="headerlink" title="初始化AOP所需环境"></a>初始化AOP所需环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NamespaceHandler内的方法：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line"> <span class="type">BeanDefinitionParser</span> <span class="variable">parser</span> <span class="operator">=</span> findParserForElement(element, parserContext);</span><br><span class="line"> <span class="keyword">return</span> (parser != <span class="literal">null</span> ? parser.parse(element, parserContext) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还有一个抽象的方法</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AopNamespaceHandler处理器的实现：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">  AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">  extendBeanDefinition(element, parserContext);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看看 <code>AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</code> 这句话，看方法名初步判断是注册一个 <code>BeanDefinition</code> 以便后续用来解析基于 <code>Java注解</code> 的 <code>AOP Advisor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span><br><span class="line"><span class="params">  ParserContext parserContext, Element sourceElement)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">   parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line"> <span class="comment">// 因为只是简单配置标签，没有定义属性，所以这个方法里面是个空的执行</span></span><br><span class="line"> useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line"> <span class="comment">// 将第一句话拿到的 beanDefinition 注册到 bf 中去，使用 Component 组的形式进行注册。</span></span><br><span class="line"> registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用了这里：</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span><br><span class="line"><span class="params">  BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后再继续调用了这里：</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerOrEscalateApcAsRequired</span><span class="params">(</span></span><br><span class="line"><span class="params">  Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">  Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">apcDefinition</span> <span class="operator">=</span> registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">    <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">currentPriority</span> <span class="operator">=</span> findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">      <span class="type">int</span> <span class="variable">requiredPriority</span> <span class="operator">=</span> findPriorityForClass(cls);</span><br><span class="line">      <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">        apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">RootBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(cls);</span><br><span class="line">  beanDefinition.setSource(source);</span><br><span class="line">  beanDefinition.getPropertyValues().add(<span class="string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">  beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">  registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">  <span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然就是注册了一个 <code>AnnotationAwareAspectJAutoProxyCreator</code> 这个东西，用来创建代理的玩意儿。 先看看这个类的继承体系： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84aop%E5%AE%9E%E7%8E%B0.md/2.png"> </p>
<p>稍微看看左上角的 <code>BeanPostProcessor</code>，OK，是初始化容器的时候通过他来注入 <code>AOP</code> 内容。</p>
<h2 id="解析Advisor配置的Bean"><a href="#解析Advisor配置的Bean" class="headerlink" title="解析Advisor配置的Bean"></a>解析Advisor配置的Bean</h2><p>好了，那么环境初始化好了，<code>MethodAop</code> 这个 <code>Advisor</code> 也注册进去了，接下来就是运行的时候织入 <code>Bean</code> 的时候了。 根据调试查看，配置中的 <code>Bean</code> 是在 <code>refresh()</code> 方法中的 <code>finishBeanFactoryInitialization(beanFactory);</code> 这句话来织入并且生成代理对象的。 至于怎么创建对象的，之前有说过，现在要说的只不过是创建对象以后，使用 <code>BeanPostProcessor</code> 把建好的对象给替换掉。 所以直接点，来到 <code>AbstractAutowireCapableBeanFactory#doCreateBean()</code> 看看怎么操作的。（所以无论是不是配置中的 <code>Bean</code>，只要使用该方法来创建的，就是该 <code>Bean</code> 被织入的时机）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">  <span class="comment">// 初始化对象，这句话会调用BeanPostProcessor的before和After的方法</span></span><br><span class="line">  <span class="comment">// 织入的时机主要是在 postProcessAfterInitialization 方法中.</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span>： </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">  AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">   invokeAwareMethods(beanName, bean);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;, getAccessControlContext());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  invokeAwareMethods(beanName, bean);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line"> <span class="keyword">if</span> (mbd == <span class="literal">null</span>  !mbd.isSynthetic()) &#123;</span><br><span class="line">  wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">    (mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">    beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (mbd == <span class="literal">null</span>  !mbd.isSynthetic()) &#123;</span><br><span class="line">  <span class="comment">// 应用Bean创建的后处理器，包装Bean</span></span><br><span class="line">  wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个Bean创建就一顿循环 BeanPostProcessors，调用 BeanPostProcessor#postProcessAfterInitialization来处理实例</span></span><br><span class="line"><span class="comment">// 那么刚刚上面我们说过，环境初始化的时候，Spring偷偷放进去了一个 AnnotationAwareAspectJAutoProxyCreator</span></span><br><span class="line"><span class="comment">// 他其实就是一个BeanPostProcessors，所以不用说肯定在这个类里边处理</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span><br><span class="line">  <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">  <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">current</span> <span class="operator">=</span> processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分享个 debug 小技巧，因为是个循环，然后又很难看出来他循环到哪个类，稍微手抖了一下，又跳过了这个类又要重新开始 debug。所以我们可以使用 idea 提供的条件断点，我这里是使用 class 来比较，如果是我想要的这个 class 那么就停止在这个断点： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84aop%E5%AE%9E%E7%8E%B0.md/3.png"></p>
</blockquote>
<p>接下来进入看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a proxy with the configured interceptors if the bean is</span></span><br><span class="line"><span class="comment"> * identified as one to proxy by the subclass.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getAdvicesAndAdvisorsForBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);</span><br><span class="line">  <span class="comment">// 提早曝光的代理引用，如果不是相同的，则调用 wrapIfNecessary 进行包装</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">   <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里通过 cacheKey 判断当前 Bean 是否之前记录不需要切入（使用 advisedBeans 存储）</span></span><br><span class="line">  <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1. 如果是 Advice/Pointcut 等 AOP 相关的类则跳过；</span></span><br><span class="line">  <span class="comment">// 2. BeanName以.ORIGINAL结尾的话，不做代理，如：com.mypackage.MyClass.ORIGINAL </span></span><br><span class="line">  <span class="keyword">if</span> (isInfrastructureClass(bean.getClass())  shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里开始获取 Advisor</span></span><br><span class="line">  Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">    <span class="comment">// 开始创建代理对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">      bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">    <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取advisor"><a href="#获取advisor" class="headerlink" title="获取advisor"></a>获取advisor</h2><blockquote>
<p>如果暂时对如何获取 advisor 没兴趣的话，可以先跳过，后面再回来看</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>这句话是用来获取 <code>advisor</code> 的，并且缓存起来项目中配置的 <code>advisor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">  Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line"> List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"> <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">  List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">  List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">  extendAdvisors(eligibleAdvisors);</span><br><span class="line">  <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">    eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</code> 这句话使用来获取已经缓存起来了的所有 <code>Advisors</code>。因为在当前我们已经无法进入到怎么解析并缓存的问题上来了（因为已经缓存起来了），所以我们需要退回到前面的步骤中来。</p>
<h3 id="解析Advisor"><a href="#解析Advisor" class="headerlink" title="解析Advisor"></a>解析Advisor</h3><p>然而什么时候做的解析和缓存，我们刚刚在上一节中说了 <code>initializeBean</code> 会在创建所有 <code>Bean</code> 的时候调用所有 <code>beanPostProcessor</code> 的前置处理器。那我们来看看 <code>AnnotationAwareAspectJAutoProxyCreator</code> 的前置处理器做了什么，并且第一次调用该方法是什么时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"> <span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 这里在前置的时候就开始记录哪些 Bean 需要织入，哪些不需要了</span></span><br><span class="line"> <span class="keyword">if</span> (!StringUtils.hasLength(beanName)  !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化第一个 Bean（在我这里是我那个配置类的初始化）的时候就开始调用 shouldSkip</span></span><br><span class="line">  <span class="keyword">if</span> (isInfrastructureClass(beanClass)  shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">   <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line"> <span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line"> <span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line"> <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line"> <span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">   <span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">  <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前 BeanFactory 中所有的 advisor 对象，并且做缓存</span></span><br><span class="line">  List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">  <span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;</span><br><span class="line">        ((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 先调用下面那个在父类的方法</span></span><br><span class="line">  List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line">  <span class="comment">// 开始构建存在 BeanFactory 中的 Advisor</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.aspectJAdvisorsBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">    advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">  Assert.state(<span class="built_in">this</span>.advisorRetrievalHelper != <span class="literal">null</span>, <span class="string">&quot;No BeanFactoryAdvisorRetrievalHelper available&quot;</span>);</span><br><span class="line">  <span class="comment">// 通过一个 advisorRetrievalHelper 来获取所有的 advisor Bean</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.advisorRetrievalHelper.findAdvisorBeans();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>advisorRetrievalHelper</code> 是配置 <code>auto-proxy</code> 的时候，会被使用的一个类，他在 <code>AnnotationAwareAspectJAutoProxyCreator</code> 中传入一个 <code>ConfigurableListableBeanFactory</code> 作为参数调用构造器初始化。 所以，<code>advisorRetrievalHelper</code> 可以在当前容器中，查找所有的 <code>BeanDefinition</code>，并且取出是 <code>Advisor</code> 的 <code>Bean</code>。 接下来来看看这个方法做了什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find all eligible Advisor beans in the current bean factory,</span></span><br><span class="line"><span class="comment"> * ignoring FactoryBeans and excluding beans that are currently in creation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the list of &#123;<span class="doctag">@link</span> org.springframework.aop.Advisor&#125; beans</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isEligibleBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">findAdvisorBeans</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// Determine list of advisor bean names, if not cached already.</span></span><br><span class="line"> String[] advisorNames = <span class="built_in">this</span>.cachedAdvisorBeanNames;</span><br><span class="line"> <span class="keyword">if</span> (advisorNames == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">  <span class="comment">// uninitialized to let the auto-proxy creator apply to them!</span></span><br><span class="line">  advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">    <span class="built_in">this</span>.beanFactory, Advisor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 第一次调用的时候，还没找到，所以直接就在这里被返回出去</span></span><br><span class="line"> <span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">     logger.trace(<span class="string">&quot;Skipping currently created advisor &#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     advisors.add(<span class="built_in">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">            .....</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，既然返回了一个空的集合，那么就来看看，后面做了什么事情了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findCandidateAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 先调用下面那个在父类的方法</span></span><br><span class="line">  List&lt;Advisor&gt; advisors = <span class="built_in">super</span>.findCandidateAdvisors();</span><br><span class="line">  <span class="comment">// 开始构建存在 BeanFactory 中的 Advisor</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.aspectJAdvisorsBuilder != <span class="literal">null</span>) &#123;</span><br><span class="line">    advisors.addAll(<span class="built_in">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title function_">buildAspectJAdvisors</span><span class="params">()</span> &#123;</span><br><span class="line">  List&lt;String&gt; aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 因为 aspectBeanNames 现在是 NULL，所以进入开始初始化</span></span><br><span class="line">      aspectNames = <span class="built_in">this</span>.aspectBeanNames;</span><br><span class="line">      <span class="keyword">if</span> (aspectNames == <span class="literal">null</span>) &#123;</span><br><span class="line">        List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        aspectNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取 BeanFactory 中所有的 beanNames</span></span><br><span class="line">        String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">          <span class="built_in">this</span>.beanFactory, Object.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 二话不说就来了个循环</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">          <span class="comment">// 是否是个有资格的类？然而方法都是直接返回 true...也就是这一步永远不会进去</span></span><br><span class="line">          <span class="comment">// 感觉这个方法是个有故事的方法，先不看</span></span><br><span class="line">          <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 这一步必须使用 getType 调用 getBean 可能会导致错误（那个Bean需要被织入但是太早初始化的</span></span><br><span class="line">          <span class="comment">// 话会导致没有织入成功）</span></span><br><span class="line">          Class&lt;?&gt; beanType = <span class="built_in">this</span>.beanFactory.getType(beanName);</span><br><span class="line">          <span class="keyword">if</span> (beanType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 这一步会判断类有没有被 @Aspect 修饰</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">            aspectNames.add(beanName);</span><br><span class="line">              <span class="type">AspectMetadata</span> <span class="variable">amd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectMetadata</span>(beanType, beanName);</span><br><span class="line">            <span class="comment">// 根据 Advisor 是否可以为单例（这个是AOP定义的单例）来缓存 AOP 信息以便后面可以使用</span></span><br><span class="line">            <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">              <span class="comment">// 构建 Advisor 工厂</span></span><br><span class="line">              <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BeanFactoryAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">              List&lt;Advisor&gt; classAdvisors = <span class="built_in">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">              <span class="comment">// 如果是单例（BeanFactory的单例）的 Bean，则直接缓存 Advisor 对象</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                <span class="built_in">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">              &#125;</span><br><span class="line">              advisors.addAll(classAdvisors);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 每个目标对象或者每个对象都去织入.</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName +</span><br><span class="line">                                                   <span class="string">&quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PrototypeAspectInstanceFactory</span>(<span class="built_in">this</span>.beanFactory, beanName);</span><br><span class="line">              <span class="built_in">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">              advisors.addAll(<span class="built_in">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">        <span class="keyword">return</span> advisors;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一次再调用该方法的时候，即可直接通过缓存中取出 Advisor 使用</span></span><br><span class="line">  <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;Advisor&gt; advisors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">    List&lt;Advisor&gt; cachedAdvisors = <span class="built_in">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">    <span class="keyword">if</span> (cachedAdvisors != <span class="literal">null</span>) &#123;</span><br><span class="line">      advisors.addAll(cachedAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">MetadataAwareAspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="built_in">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">      advisors.addAll(<span class="built_in">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取所有的Advisor"><a href="#获取所有的Advisor" class="headerlink" title="获取所有的Advisor"></a>获取所有的Advisor</h3><blockquote>
<p>刚刚我们来到这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line"> Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line"> <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title function_">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"> List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<span class="comment">// &lt;-----</span></span><br><span class="line"> <span class="comment">// 获取装配当前 Bean 的 Advisor</span></span><br><span class="line"> <span class="comment">// 这一步其实就是获取 @Pointcut 中配置的装配规则来匹配所有的方法，我偷懒，先过</span></span><br><span class="line"> List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line"> <span class="comment">// 扩展Advisor</span></span><br><span class="line"> extendAdvisors(eligibleAdvisors);</span><br><span class="line"> <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">   eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在在这个方法内部，已经获取我们自己配置的 <code>MethodAop</code> 对象了，但是下面还有个扩展，看看扩展了什么东西：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Adds an &#123;<span class="doctag">@link</span> ExposeInvocationInterceptor&#125; to the beginning of the advice chain.</span></span><br><span class="line"><span class="comment">    * These additional advices are needed when using AspectJ expression pointcuts</span></span><br><span class="line"><span class="comment">    * and when using AspectJ-style advice.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">extendAdvisors</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors)</span> &#123;</span><br><span class="line">  AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">makeAdvisorChainAspectJCapableIfNecessary</span><span class="params">(List&lt;Advisor&gt; advisors)</span> &#123;</span><br><span class="line">  <span class="comment">// Don&#x27;t add advisors to an empty list; may indicate that proxying is just not required</span></span><br><span class="line">  <span class="keyword">if</span> (!advisors.isEmpty()) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">foundAspectJAdvice</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">      <span class="comment">// 如果是 AspectJAdvice 则不添加</span></span><br><span class="line">      <span class="keyword">if</span> (isAspectJAdvice(advisor)) &#123;</span><br><span class="line">        foundAspectJAdvice = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们织入的方法中，都会添加一个 ExposeInvocationInterceptor 实例</span></span><br><span class="line">    <span class="keyword">if</span> (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) &#123;</span><br><span class="line">      advisors.add(<span class="number">0</span>, ExposeInvocationInterceptor.ADVISOR);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个概念：</p>
<ol>
<li><p><code>AspectJAdvice</code>：通过编译器织入 <code>AOP</code> 代码的一个框架；</p>
</li>
<li><p><code>ExposeInvocationInterceptor</code>：这是一个运行期织入时可以随时获取整个调用链的内置的 <code>AOP</code> 拦截器，如果在使用过程中需要获取调用链的话，可以通过 <code>ExposeInvocationInterceptor.currentInvocation</code> 来获取。<code>SpringAOP</code> 在织入的时候默认在第一个织入这个实例。</p>
</li>
</ol>
<p>好了，走完全部，获取所有 <code>advisors</code> 的过程终于完成。</p>
<h2 id="织入运行期对象"><a href="#织入运行期对象" class="headerlink" title="织入运行期对象"></a>织入运行期对象</h2><p>回到 <code>postProcessAfterInitialization -&gt; wrapIfNecessary</code> 方法中来：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里通过 cacheKey 判断当前 Bean 是否之前记录不需要切入（使用 advisedBeans 存储）</span></span><br><span class="line">  <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="built_in">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 1. 如果是 Advice/Pointcut 等 AOP 相关的类则跳过；</span></span><br><span class="line">  <span class="comment">// 2. BeanName以.ORIGINAL结尾的话，不做代理，如：com.mypackage.MyClass.ORIGINAL </span></span><br><span class="line">  <span class="keyword">if</span> (isInfrastructureClass(bean.getClass())  shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里开始获取 Advisor</span></span><br><span class="line">  Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">    <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">    <span class="comment">// 开始创建代理对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(</span><br><span class="line">      bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> <span class="title class_">SingletonTargetSource</span>(bean));</span><br><span class="line">    <span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是开始创建代理对象了。创建对象有两种方式：<code>cglib</code> 和 <code>jdk代理</code>，使用哪种方式取决于当前那个类有没有接口实现，如果是一个普通的类（没有实现接口的方式），则使用前者，否则用后者。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">  <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">  <span class="comment">// 记录原始数据</span></span><br><span class="line">  AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="built_in">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建 ProxyFactory 用于创建代理</span></span><br><span class="line"> <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line"> proxyFactory.copyFrom(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">   <span class="comment">// 直接代理类实例（通过BeanDefinition配置的属性来判断）</span></span><br><span class="line">   proxyFactory.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 计算所有的接口设置到工厂，如果没有接口，同上直接代理实例</span></span><br><span class="line">   evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 通过上一步获取的所有 advisors，过滤获取匹配的 advisors</span></span><br><span class="line"> Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line"> proxyFactory.addAdvisors(advisors);</span><br><span class="line"> proxyFactory.setTargetSource(targetSource);</span><br><span class="line"> customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line"> proxyFactory.setFrozen(<span class="built_in">this</span>.freezeProxy);</span><br><span class="line"> <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">  proxyFactory.setPreFiltered(<span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 开始构建</span></span><br><span class="line"> <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">  <span class="comment">// 调用 DefaultAopProxyFactory 开始构建代理</span></span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    activate();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getAopProxyFactory返回DefaultAopProxyFactory实例</span></span><br><span class="line">  <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">DefaultAopProxyFactory#createAopProxy</span><br><span class="line"><span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.isOptimize()  config.isProxyTargetClass()  hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">    <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                                   <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (targetClass.isInterface()  Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有接口，来到这</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>createAopProxy</code> 之后就是调用各自的实现 <code>getProxy(classLoader)</code></p>
<h3 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Creating CGLIB proxy: &quot;</span> + <span class="built_in">this</span>.advised.getTargetSource());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对象的实际类型</span></span><br><span class="line">    Class&lt;?&gt; rootClass = <span class="built_in">this</span>.advised.getTargetClass();</span><br><span class="line">    Assert.state(rootClass != <span class="literal">null</span>, <span class="string">&quot;Target class must be available for creating a CGLIB proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经是一个 cglib 对象的时候，获取其父级（实际类型）</span></span><br><span class="line">    Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">    <span class="keyword">if</span> (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) &#123;</span><br><span class="line">      proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">      Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">        <span class="built_in">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">    validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始生成 cglib 对象</span></span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> createEnhancer();</span><br><span class="line">    <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">      enhancer.setClassLoader(classLoader);</span><br><span class="line">      <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">          ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">        enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">    <span class="comment">// 这里Spring混合了自己的两个接口：SpringProxy和Advised</span></span><br><span class="line">    enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised));</span><br><span class="line">        <span class="comment">// 类加上 BySpringCGLIB 的标志</span></span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> <span class="title class_">ClassLoaderAwareGeneratorStrategy</span>(classLoader));</span><br><span class="line"></span><br><span class="line">    Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[callbacks.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">      types[x] = callbacks[x].getClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">    enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">ProxyCallbackFilter</span>(</span><br><span class="line">      <span class="built_in">this</span>.advised.getConfigurationOnlyCopy(), <span class="built_in">this</span>.fixedInterceptorMap, <span class="built_in">this</span>.fixedInterceptorOffset));</span><br><span class="line">    enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代理对象</span></span><br><span class="line">    <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (CodeGenerationException  IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Could not generate CGLIB subclass of &quot;</span> + <span class="built_in">this</span>.advised.getTargetClass() +</span><br><span class="line">                                 <span class="string">&quot;: Common causes of this problem include using a final class or a non-visible class&quot;</span>,</span><br><span class="line">                                 ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;Unexpected AOP exception&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，那让我们来看看调用的时候是什么情况： 现在我的对象已经变成 <code>NoInterfaceService$$EnhancerBySpringCGLIB</code> 类型了，那我在调用的时候不可否认的会进入到真实的对象里边去，此时我调用一下 <code>test()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.advised = advised;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 这里才是我的真实对象</span></span><br><span class="line">  <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.getTargetSource();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">    <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">    oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">    setProxyContext = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">   target = targetSource.getTarget();</span><br><span class="line">   Class&lt;?&gt; targetClass = (target != <span class="literal">null</span> ? target.getClass() : <span class="literal">null</span>);</span><br><span class="line">   List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">   Object retVal;</span><br><span class="line">   <span class="comment">// 然后拿到了我们上面装配的 Advisor 执行链条</span></span><br><span class="line">   <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">    <span class="comment">// 如果链条是空的并且方法是共有的话，直接执行方法！</span></span><br><span class="line">    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">    retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 CglibMethodInvocation 对象执行我们的方法</span></span><br><span class="line">    retVal = <span class="keyword">new</span> <span class="title class_">CglibMethodInvocation</span>(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果方法有返回值，转换为指定的类型.</span></span><br><span class="line">   retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">   <span class="keyword">return</span> retVal;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">    targetSource.releaseTarget(target);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">    <span class="comment">// Restore old proxy.</span></span><br><span class="line">    AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，接下来看看 <code>CglibMethodInvocation#proceed()</code> 做了什么事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CglibMethodInvocation#proceed：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ReflectionUtils.declaresException(getMethod(), ex.getClass())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReflectiveMethodInvocation#proceed:</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">// 当在MethodAop中调用 Object proceed = joinPoint.proceed(); 的时候，此处会直接调用切入点的那个方法，就是当前的拦截器index === 最后一个的时候，是直接调用目标方法。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.currentInterceptorIndex == <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Object</span> <span class="variable">interceptorOrInterceptionAdvice</span> <span class="operator">=</span></span><br><span class="line">    <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="built_in">this</span>.currentInterceptorIndex);</span><br><span class="line">  <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">    <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">    <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">    <span class="type">InterceptorAndDynamicMethodMatcher</span> <span class="variable">dm</span> <span class="operator">=</span></span><br><span class="line">      (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">    Class&lt;?&gt; targetClass = (<span class="built_in">this</span>.targetClass != <span class="literal">null</span> ? <span class="built_in">this</span>.targetClass : <span class="built_in">this</span>.method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="built_in">this</span>.method, targetClass, <span class="built_in">this</span>.arguments)) &#123;</span><br><span class="line">      <span class="keyword">return</span> dm.interceptor.invoke(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">      <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">      <span class="keyword">return</span> proceed();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// It&#x27;s an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">    <span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">    <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，第一个切入类是 <code>Spring</code> 的 <code>ExposeInvocationInterceptor</code>，直接走到下面的 <code>return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="comment">// 保存一个老的调用链</span></span><br><span class="line">  <span class="type">MethodInvocation</span> <span class="variable">oldInvocation</span> <span class="operator">=</span> invocation.get();</span><br><span class="line">  <span class="comment">// 当前调用链给了新的</span></span><br><span class="line">  invocation.set(mi);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 调用下一个拦截器</span></span><br><span class="line">    <span class="keyword">return</span> mi.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 恢复回去</span></span><br><span class="line">    invocation.set(oldInvocation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新进来还是调用 <code>((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this)</code> 这段代码： 此时进来的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AspectJAroundAdvice#invoke:</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation mi)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(mi <span class="keyword">instanceof</span> ProxyMethodInvocation)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot;</span> + mi);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">ProxyMethodInvocation</span> <span class="variable">pmi</span> <span class="operator">=</span> (ProxyMethodInvocation) mi;</span><br><span class="line">  <span class="comment">// 这个参数就是我们写在 around 方法参数中的那个</span></span><br><span class="line">  <span class="comment">// 此时我们的方法已经被织入在这个类的方法里边去</span></span><br><span class="line">  <span class="comment">// 所以只要执行我们的 around 方法就是变相执行我们真实对象的方法了。</span></span><br><span class="line">  <span class="type">ProceedingJoinPoint</span> <span class="variable">pjp</span> <span class="operator">=</span> lazyGetProceedingJoinPoint(pmi);</span><br><span class="line">  <span class="type">JoinPointMatch</span> <span class="variable">jpm</span> <span class="operator">=</span> getJoinPointMatch(pmi);</span><br><span class="line">  <span class="keyword">return</span> invokeAdviceMethod(pjp, jpm, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// As above, but in this case we are given the join point.</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeAdviceMethod</span><span class="params">(JoinPoint jp, <span class="meta">@Nullable</span> JoinPointMatch jpMatch,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> Object returnValue, <span class="meta">@Nullable</span> Throwable t)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeAdviceMethodWithGivenArgs</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  Object[] actualArgs = args;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.aspectJAdviceMethod.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">    actualArgs = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(<span class="built_in">this</span>.aspectJAdviceMethod);</span><br><span class="line">    <span class="comment">// 使用反射直接调用advisor中的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.aspectJAdviceMethod.invoke(<span class="built_in">this</span>.aspectInstanceFactory.getAspectInstance(), actualArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(<span class="string">&quot;Mismatch on arguments to advice method [&quot;</span> +</span><br><span class="line">                                     <span class="built_in">this</span>.aspectJAdviceMethod + <span class="string">&quot;]; pointcut expression [&quot;</span> +</span><br><span class="line">                                     <span class="built_in">this</span>.pointcut.getPointcutExpression() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">  logger.trace(<span class="string">&quot;Creating JDK dynamic proxy: &quot;</span> + <span class="built_in">this</span>.advised.getTargetSource());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 同样获取到所有的接口</span></span><br><span class="line"> <span class="comment">// 这次 Spring 混入了三个：SpringProxy、Advised 和 DecoratingProxy</span></span><br><span class="line"> Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="built_in">this</span>.advised, <span class="literal">true</span>);</span><br><span class="line"> <span class="comment">// 获取接口中定义的 equals 方法</span></span><br><span class="line"> findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line"> <span class="comment">// 通过直接调用 jdk 的 Proxy 创建代理对象</span></span><br><span class="line"> <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时候则是使用 jdk 的 <code>invoke</code> 方式进行调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"> <span class="type">Object</span> <span class="variable">oldProxy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="type">boolean</span> <span class="variable">setProxyContext</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> <span class="built_in">this</span>.advised.targetSource;</span><br><span class="line"> <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">   <span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">   <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">   <span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">   <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">   <span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">   <span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="built_in">this</span>.advised);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">    method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">   <span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">   <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="built_in">this</span>.advised, method, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object retVal;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上面均是特殊方法的代理形式，直接走到这里</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">   <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">   oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">   setProxyContext = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target,</span></span><br><span class="line">  <span class="comment">// in case it comes from a pool.</span></span><br><span class="line">  target = targetSource.getTarget();</span><br><span class="line">  Class&lt;?&gt; targetClass = (target != <span class="literal">null</span> ? target.getClass() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取AOP拦截链</span></span><br><span class="line">  List&lt;Object&gt; chain = <span class="built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span></span><br><span class="line">  <span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">  <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">   <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">   <span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">   <span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">   Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">   retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 这一步就跟上面一样了</span></span><br><span class="line">   <span class="type">MethodInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span></span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain);</span><br><span class="line">   <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">   retVal = invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Massage return value if necessary.</span></span><br><span class="line">  Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">  <span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">    returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">    !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">   <span class="comment">// Special case: it returned &quot;this&quot; and the return type of the method</span></span><br><span class="line">   <span class="comment">// is type-compatible. Note that we can&#x27;t help if the target sets</span></span><br><span class="line">   <span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">   retVal = proxy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="literal">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopInvocationException</span>(</span><br><span class="line">     <span class="string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retVal;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (target != <span class="literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">   <span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">   targetSource.releaseTarget(target);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">   <span class="comment">// Restore old proxy.</span></span><br><span class="line">   AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AOP中this的问题"><a href="#AOP中this的问题" class="headerlink" title="AOP中this的问题"></a>AOP中this的问题</h2><p>这个问题是我印象最深的一个问题，曾经使用了 <code>spring-cache</code>，预想着通过注解，就可以解决缓存的问题，实在是一件很有感觉的事情，然而，在清理的时候，并不是这么简单…经常遇到我明明注解已经写了，但是就是没有给我清理的问题。后面就直接没有使用了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value=&quot;userCache&quot;,key=&quot;#u.getUID()&quot;)</span></span><br><span class="line">pubic <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User u)</span> &#123;</span><br><span class="line">    <span class="comment">// ....逻辑</span></span><br><span class="line">    <span class="comment">//调用其他方法让其重新缓存</span></span><br><span class="line">    userOfUID(u.getUID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;userCache&quot;,key=&quot;#result.getUID()&quot;)</span></span><br><span class="line">pubic User <span class="title function_">userOfUID</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">    userDao.userOfUID(uid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然而走完 <code>updateUser</code> 缓存直接没了，并没有帮我刷新。 这个确实是 <code>AOP</code> 中模糊了 <code>this</code> 指向的问题。 我们通过刚刚的例子可以看到，其实 <code>AOP</code> 生效的时机是你从 <code>BeanFactory</code> 中拿到 <code>Bean</code> 的时候，因为这个时候你拿到的就是一个代理对象，那么会执行 <code>AOP</code> 中 <code>Advisor</code> 中定义的方法。但是如果我们直接在我们的类中使用 <code>this</code> 的时候，其实指向的是我们自己的类实例，没有走 <code>Spring</code> 外部的逻辑。 那咋办呢… 重点就在于怎么拿到 <code>Spring</code> 的代理对象！<a href="https://blog.csdn.net/qq_39951411/article/details/80363121">参考资料</a> 通过配置 <code>exposeProxy</code> ，然后通过 <code>((UserService) AopContext.currentProxy()).userOfUID();</code> 来调用。 配置： 注解：<code>@EnableAspectJAutoProxy(proxyTargteClass = true, exposeProxy = true)</code> <code>xml</code> ：<code>&lt;aop:aspectj-autoproxy expose-proxy=&quot;true&quot;/&gt;</code> 那我就比较懒（sao）了…「好了 还是不要这么用吧…」</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Lazy</span></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CacheEvict(value=&quot;userCache&quot;,key=&quot;#u.getUID()&quot;)</span></span><br><span class="line">    pubic <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User u)</span> &#123;</span><br><span class="line">    <span class="comment">// ....逻辑</span></span><br><span class="line">    <span class="comment">//调用其他方法让其重新缓存</span></span><br><span class="line">    userService.userOfUID(u.getUID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Cacheable(value = &quot;userCache&quot;,key=&quot;#result.getUID()&quot;)</span></span><br><span class="line">  pubic User <span class="title function_">userOfUID</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">    userDao.userOfUID(uid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring源码</tag>
        <tag>springAOP</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring源码】一个我们日常接触的ApplicationContext</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E6%8E%A5%E8%A7%A6%E7%9A%84applicationcontext/index.html</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>回顾一下上一篇，使用的是一个简单的 <code>BeanFactory</code> 实现 <code>XmlBeanFactory</code>。这个容器已经是一个过时的容器了，因为他并不能实现除了注册 <code>BeanDefinition</code> 之外的事情（比如 <code>i18n</code> <code>访问资源（骚一点的话可以加载网络 Spring 配置文件）</code> <code>应用事件</code>）。所以，就有了 <code>spring-context</code> 的出现。 我们现在知道了，<code>Spring</code> 把载入、解析、注册解耦成不同的模块，所以我们现在可以大概的知道：</p>
<ol>
<li> 载入：我们可以使用不同的方式载入配置文件，然后配置解析方式，生成 <code>BeanDefinition</code> 注册到底层的 <code>Bean</code> 容器中；</li>
<li> 解析：不同的配置文件解析方式有所不同，但是有个共同的目的就是解析成 <code>BeanDefinition</code> 注册到容器中去；</li>
<li> 注册：这块 <code>Spring</code> 已经提供了 <code>DefaultListableBeanFactory</code> 这个成熟的实现，所以即使我们想通过其他配置文件来配置我们的 <code>Spring</code> 项目的话，不用慌，只要用它就好了（奥森！）</li>
</ol>
<p>那么仔细想想，我们是不是可以实现由 <code>JSON</code> 格式配置文件来配置的 <code>BeanFactory</code>。</p>
<a id="more"></a>
<h2 id="一-一个可运行的DEMO"><a href="#一-一个可运行的DEMO" class="headerlink" title="一.一个可运行的DEMO"></a>一.一个可运行的DEMO</h2><blockquote>
<p>因为 Spring 现在支持 Java注解 来生成对象，所以我想在看 ApplicationContext 源码的时候，顺便把怎么从配置里面取出 Bean 的过程给看了，所以配置文件只配置了一个 Java配置类。</p>
</blockquote>
<h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">       http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;cn.liweidan.confbean.MyBeanConfiguration&quot;/&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="MyBeanConfiguration-java"><a href="#MyBeanConfiguration-java" class="headerlink" title="MyBeanConfiguration.java"></a>MyBeanConfiguration.java</h3><p>这个写法在 <code>SpringBoot</code> 横行霸道的时候应该不会陌生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.confbean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    myBean.setName(<span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> myBean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MyBean-java"><a href="#MyBean-java" class="headerlink" title="MyBean.java"></a>MyBean.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.confbean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.confbean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigBeanTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConfigBean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> bf.getBean(MyBean.class);</span><br><span class="line">    Assert.assertNotNull(bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跑一下测试用例，恩！是绿色的感觉！（绿色？）</p>
<h2 id="二-源码解析"><a href="#二-源码解析" class="headerlink" title="二.源码解析"></a>二.源码解析</h2><blockquote>
<p>其实我一直没有经验怎么写源码的解析，看得人才能容易看的明白，所以我就按照 debug 走的顺序来走了，在哪个类的哪个方法，都会放在三级标题上。</p>
</blockquote>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E6%8E%A5%E8%A7%A6%E7%9A%84applicationcontext.md/0.png"> 好了，我们已经可以看到，<code>application</code> 是一个 <code>BeanFactory</code> 但是他又没有去继承我们之前看到的 <code>BeanFactory</code> 的实现类。为啥，他并不是一个单纯的 <code>BeanFactory</code> 实现，而是聚合了 <code>BeanFactory</code> 实现类，来实现 <code>BeanFactory</code> 的所有功能，所以，它拥有 <code>BeanFactory</code> 接口的所有功能。（还记得那句话吗？接口表示实现类会什么（<code>class has xxx</code>），继承表示实现类是什么（<code>class is xxx</code>））</p>
<h3 id="2-1-ClassPathXmlApplicationContext构造器"><a href="#2-1-ClassPathXmlApplicationContext构造器" class="headerlink" title="2.1 ClassPathXmlApplicationContext构造器"></a>2.1 ClassPathXmlApplicationContext构造器</h3><p>好，首先从这段代码开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>ClassPathXmlApplicationContext</code> 其实是一个简单到不能再简单的类了，他的主要功能就是记录用户传递的 <code>applicationContext.xml</code> 的路径，是一个字符串数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractXmlApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 这是我们进入的时候调用的构造方法 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String... configLocations)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 调用了下面的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(configLocations, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(</span></span><br><span class="line"><span class="params">            String[] configLocations, <span class="type">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span><br><span class="line">            <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="comment">// 这里是一个 Null，我就不进去看了，反正就是之前熟悉的</span></span><br><span class="line">    <span class="comment">// 设置 parentBeanFactory </span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">            refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，接下来我们进入这句话：<code>setConfigLocations(configLocations);</code></p>
<h3 id="2-2-AbstractRefreshableConfigApplicationContext-setConfigLocations"><a href="#2-2-AbstractRefreshableConfigApplicationContext-setConfigLocations" class="headerlink" title="2.2 AbstractRefreshableConfigApplicationContext#setConfigLocations"></a>2.2 AbstractRefreshableConfigApplicationContext#setConfigLocations</h3><p>这句话的实现是在父级 <code>AbstractRefreshableConfigApplicationContext</code> 实现的，先简单了解下这句话是做什么用的，这句话是设置我 <code>AbstractRefreshableConfigApplicationContext</code> 的配置路径的属性，顺便通过环境的配置，把类似于 <code>application-$&#123;someProp&#125;</code> 的配置，给还原成我们配置再环境的内容。 先看下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRefreshableConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractRefreshableApplicationContext</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigLocations</span><span class="params">(<span class="meta">@Nullable</span> String... locations)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (locations != <span class="literal">null</span>) &#123;</span><br><span class="line">            Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.configLocations = <span class="keyword">new</span> <span class="title class_">String</span>[locations.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 重点要跟着这一句走</span></span><br><span class="line">                <span class="built_in">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.configLocations = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">resolvePath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      getEnvironment()这一句还是在父类 AbstractApplicationContext 实现的：</span></span><br><span class="line"><span class="comment">    protected ConfigurableEnvironment createEnvironment() &#123;</span></span><br><span class="line"><span class="comment">        return new StandardEnvironment();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的创建了一个 <code>StandardEnvironment</code> 对象，我想这是因为我在类似于 <code>main</code> 方法运行的缘故，如果是 <code>web</code> 环境有另外一种实现 <code>StandardServletEnvironment</code>。 <code>StandardServletEnvironment#resolveRequiredPlaceholders</code> 代码则是把这件事情交给 <code>core</code> 里面的工具类 <code>PropertyPlaceholderHelper#parseStringValue</code> 来实现，由于这件事情不是我要看的重点，所以我先直接跳过去好了。 然后直接下一步，<code>if (refresh) &#123;...&#125;</code> 因为构造器直接写死传递了一个 <code>true</code>，所以现在需要直接进入 <code>refresh()</code> 方法来做。</p>
<h3 id="2-3-AbstractApplicationContext-refresh"><a href="#2-3-AbstractApplicationContext-refresh" class="headerlink" title="2.3 AbstractApplicationContext#refresh"></a>2.3 AbstractApplicationContext#refresh</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AbstractApplicationContext</code> 看起来就是一个快要成型的 <code>ApplicationContext</code> 了，这里 <code>refresh()</code> 方法看起来就是调用一些其他方法来做启动的。</p>
<h3 id="2-3-1-AbstractApplicationContext-prepareRefresh"><a href="#2-3-1-AbstractApplicationContext-prepareRefresh" class="headerlink" title="2.3.1 AbstractApplicationContext#prepareRefresh"></a>2.3.1 AbstractApplicationContext#prepareRefresh</h3><p>那首先就是准备环境：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Switch to active.</span></span><br><span class="line">    <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 设置非关闭状态</span></span><br><span class="line">    <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 已激活状态</span></span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个空的方法，允许子类重写，做一些其他属性源的准备。</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证用户设置的必要的属性，如果这些属性确实则会抛出异常</span></span><br><span class="line"><span class="comment">// 目前来说我没有设置任何必要的属性，所以这一步是空的实现</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码都是初始化 applicationListeners 的容器</span></span><br><span class="line"><span class="comment">// 也就是 applicationContext 启动前我们注册的事件监听器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationListeners == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.earlyApplicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.applicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">        <span class="built_in">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="built_in">this</span>.applicationListeners.addAll(<span class="built_in">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">    <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化我感觉没做什么特别的事情，也就是初始化一些必要的容器。 接下来就是大事情了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure>
<p>创建一个 <code>BeanFactory</code>！</p>
<h3 id="2-3-2-AbstractApplicationContext-obtainFreshBeanFactory"><a href="#2-3-2-AbstractApplicationContext-obtainFreshBeanFactory" class="headerlink" title="2.3.2 AbstractApplicationContext#obtainFreshBeanFactory"></a>2.3.2 AbstractApplicationContext#obtainFreshBeanFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">  refreshBeanFactory();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ConfigurableListableBeanFactory <span class="title function_">getBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException;</span><br></pre></td></tr></table></figure>
<p>好了，这就是一个模板方法的设计模式，调用了两个需要子类实现的方法。 </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E6%8E%A5%E8%A7%A6%E7%9A%84applicationcontext.md/1.png"></p>
<hr>
<p>接下来看看子类怎么创建的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ConfigurableListableBeanFactory <span class="title function_">getBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;BeanFactory not initialized or already closed - &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;call &#x27;refresh&#x27; before accessing beans via the ApplicationContext&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，我们现在看到，首先检测当前是否有工厂实例存在，如果有，直接清理掉里面的数据。然后创建、配置、并且返回回去。在子类看来就只有做这几件事情。 那在当前类的 <code>refreshBeanFactory</code> 方法中，就是着重的看着，是怎么配置并且构建的就 ok 了。 首先看 <code>DefaultListableBeanFactory beanFactory = createBeanFactory();</code> 这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title function_">createBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好吧，过！ 然后开始设置 <code>SerializationId</code> 这个也不需要看。 下一个是 <code>customizeBeanFactory(beanFactory);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) &#123;</span><br><span class="line">  beanFactory.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.allowCircularReferences != <span class="literal">null</span>) &#123;</span><br><span class="line">  beanFactory.setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是两个自定义的属性，一个是是否允许覆盖 <code>Bean</code> 的定义，一个是是否允许相互依赖，但是这两个 <code>this.</code> 开头的都是 <code>null</code>，如果子类需要修改这两个值的话，则需要在子类调用相对应的 <code>setter</code>。因为没有调用，所以均使用 <code>DefaultListableBeanFactory</code> 默认设置的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ConfigurableListableBeanFactory</span>, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Whether to allow re-registration of a different definition with the same name. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">allowBeanDefinitionOverriding</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactory</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether to automatically try to resolve circular references between beans. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">allowCircularReferences</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后开始读取配置，然而读取配置的实现也是需要留给子类去实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span><br><span class="line">            <span class="keyword">throws</span> BeansException, IOException;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line"> <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line"> <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line"> <span class="comment">// resource loading environment.</span></span><br><span class="line"> beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line"> beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line"> beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line"> <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line"> initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"> loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，子类要准备开始读取配置了。不过读取的实现和上一篇大同小异，我就不再重复了。 还记得我们刚刚在哪里吗，我们在 <code>AbstractApplicationContext#refresh</code> 进入了 <code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code> 这句话，接下来要进一步加工了。</p>
<h3 id="2-3-3-AbstractApplicationContext-prepareBeanFactory"><a href="#2-3-3-AbstractApplicationContext-prepareBeanFactory" class="headerlink" title="2.3.3 AbstractApplicationContext#prepareBeanFactory"></a>2.3.3 AbstractApplicationContext#prepareBeanFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"> <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line"> beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"> beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line"> beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 注册事件回调</span></span><br><span class="line"> beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line"> <span class="comment">// 实现这些接口的类不允许被注入</span></span><br><span class="line"> <span class="comment">// 他们的作用只是用来回调</span></span><br><span class="line"> beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line"> beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line"> beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line"> beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line"> beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line"> beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 手动注册一些必要的接口的实现类，比如监听器，可以用于回调</span></span><br><span class="line"> beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line"> beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line"> beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line"> beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 内部类调用的事件回调</span></span><br><span class="line"> beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定类在加载时织入AOP操作</span></span><br><span class="line"> <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">  <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 一些记录环境信息的Bean</span></span><br><span class="line"> <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">  beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">  beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">  beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-AbstractApplicationContext-postProcessBeanFactory"><a href="#2-3-4-AbstractApplicationContext-postProcessBeanFactory" class="headerlink" title="2.3.4 AbstractApplicationContext#postProcessBeanFactory"></a>2.3.4 AbstractApplicationContext#postProcessBeanFactory</h3><p>这个函数是留给子类实现，这时候 <code>BeanFactory</code> 中的 <code>BeanDefinition</code> 已经全部注册完毕，子类想删除新增或者其他操作都可以继续在这里实现。</p>
<h3 id="2-3-5-AbstractApplicationContext-invokeBeanFactoryPostProcessors"><a href="#2-3-5-AbstractApplicationContext-invokeBeanFactoryPostProcessors" class="headerlink" title="2.3.5 AbstractApplicationContext#invokeBeanFactoryPostProcessors"></a>2.3.5 AbstractApplicationContext#invokeBeanFactoryPostProcessors</h3><p>来到这一步，说明 <code>BeanFactory</code> 一切准备就绪，这时候开始调用我们项目中注册到 <code>BeanFactory</code> 中的 <code>BeanFactoryPostProcessors</code> 处理器。 这一步呢，在我们项目中的应用就是，开始自动向权限中心注册当前项目中的用于管理数据的接口，以便项目更新即可分配新的权限。</p>
<h3 id="2-3-6-AbstractApplicationContext-registerBeanPostProcessors"><a href="#2-3-6-AbstractApplicationContext-registerBeanPostProcessors" class="headerlink" title="2.3.6 AbstractApplicationContext#registerBeanPostProcessors"></a>2.3.6 AbstractApplicationContext#registerBeanPostProcessors</h3><p>这一步是注册用户配置的实现 <code>BeanPostProcessor</code> 的实现类，用于监听每一个 <code>Bean</code> 实例化的前后所需要做的操作。</p>
<h3 id="2-3-7-其他初始化"><a href="#2-3-7-其他初始化" class="headerlink" title="2.3.7 其他初始化"></a>2.3.7 其他初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化i18n资源的转换接口</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化当前Context的消息广播</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类可覆写的其他refresh事件</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查、注册监听器</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化非 lazy-init 的 Bean，如果配置了 lazy-init=false 则</span></span><br><span class="line"><span class="comment">// 配置的 Bean 以及关联的 Bean 会在这个时候被初始化</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播事件、清理初始化中的缓存</span></span><br><span class="line">finishRefresh();</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 清理初始化过程中用到的 Class 缓存</span></span><br><span class="line">  resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-4-初始化配置类配置的Bean"><a href="#2-4-初始化配置类配置的Bean" class="headerlink" title="2.4 初始化配置类配置的Bean"></a>2.4 初始化配置类配置的Bean</h3><p>在上面我没有看到配置类配置的 <code>Bean</code>，因为我在 <code>debug</code> 的时候，前几步观察 <code>BeanFactory</code> 的情况，都没看到我注册的 <code>MyBean</code>，后面就跳过了。 然而我错了，我发现在 <code>getBean</code> 的时候，我的 <code>MyBean</code> 他居然已经准备好了，所以肯定是在上面某个环节偷偷给我注册进去了的。 所以我现在需要返回去看看是哪一步进入的。 通过观察，我发现是在 <code>invokeBeanFactoryPostProcessors(beanFactory);</code> 这句话之后发生了 <code>BeanDefinitionMap</code> 的长度变化。 所以现在要看这句话做了什么事情。</p>
<blockquote>
<p>其实因为在我想象中，xml 属于一种解析方式，javaConfig 应该跟 xml 平行的属于另外一种，但是貌似完全不是。Spring 是通过 <code>BeanFactoryPostProcessor</code> 来处理的。也就是说 SpringBoot 他启动貌似不需要解析器？</p>
</blockquote>
<p>OK，来看下这个方法做了什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"> PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"> <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"> <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">  beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面那句话说了，是织入运行时处理器，那么肯定是在第一句话就做了注册的。继续进入观察。 <code>getBeanFactoryPostProcessors()</code> 在目前的状态，是一个空的集合，所以我们现在需要进入看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">  ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line"> Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">  <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为我们目前没有任何的 beanFactoryPostProcessors 所以这个循环并不会进入。</span></span><br><span class="line">  <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">   <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">    <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">      (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">    registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">    registryProcessors.add(registryProcessor);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    regularPostProcessors.add(postProcessor);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">  <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">  <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">  <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">  <span class="comment">// 在这里不初始化 FactoryBeans 从而可以让 beanfactory 的 post-processors 来处理他们</span></span><br><span class="line">  <span class="comment">// 因为下面需要排序这些配置 Bean 的执行顺序。</span></span><br><span class="line">  List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始排序这些Bean的顺序</span></span><br><span class="line">  String[] postProcessorNames =</span><br><span class="line">    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">   <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">    processedBeans.add(ppName);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">  registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">  <span class="comment">// 开始执行这些处理器！</span></span><br><span class="line">  invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">  currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">  postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">    processedBeans.add(ppName);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">  registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">  <span class="comment">// ---&gt; 在这里开始执行配置的装配</span></span><br><span class="line">  invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 循环所有的 postProcessors 开始调用。目前只有一个 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">    // 是在 applicationContext 准备工作中加入的</span></span><br><span class="line"><span class="comment">    private static void invokeBeanDefinitionRegistryPostProcessors(</span></span><br><span class="line"><span class="comment">            Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span></span><br><span class="line"><span class="comment">            postProcessor.postProcessBeanDefinitionRegistry(registry);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    下面这些目前可以先不用看了。是用来执行其他 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line"><span class="comment">    因为我目前的主要点在于怎么解析我的配置类。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">   reiterate = <span class="literal">false</span>;</span><br><span class="line">   postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">     currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">     processedBeans.add(ppName);</span><br><span class="line">     reiterate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">   registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">   invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">   currentRegistryProcessors.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">  invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">  invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"> <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"> String[] postProcessorNames =</span><br><span class="line">   beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"> <span class="comment">// Ordered, and the rest.</span></span><br><span class="line"> List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">  <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">   <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">   priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">   orderedPostProcessorNames.add(ppName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"> sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"> invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line"> List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"> <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">  orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line"> &#125;</span><br><span class="line"> sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"> invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line"> List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"> <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">  nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line"> &#125;</span><br><span class="line"> invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"> <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line"> beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好我现在要在装配那部分开始进入了，因为 Spring 在开始的时候调用了 <code>ConfigurationClassPostProcessor</code> 的 <code>postProcessBeanDefinitionRegistry</code> 方法，现在要看看这个方法做了什么事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">registryId</span> <span class="operator">=</span> System.identityHashCode(registry);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">    <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">    <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 开始解析 ConfigBean 的内容</span></span><br><span class="line"> processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始拿 registry 中的所有 Bean 一顿循环。</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> registry.getBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      <span class="comment">// 如果 Bean 定义上有 @Configuration 加入 configCandidates 集合中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">                configCandidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">        <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序，但是目前这一步并不需要</span></span><br><span class="line">        configCandidates.sort((bd1, bd2) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());</span><br><span class="line">            <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(i1, i2);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">        <span class="type">SingletonBeanRegistry</span> <span class="variable">sbr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">            sbr = (SingletonBeanRegistry) registry;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.localBeanNameGeneratorSet) &#123;</span><br><span class="line">                <span class="type">BeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> (BeanNameGenerator) sbr.getSingleton(</span><br><span class="line">                        AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">                <span class="keyword">if</span> (generator != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">                    <span class="built_in">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.environment == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.environment = <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始使用 ConfigurationClassParser 来解析配置类</span></span><br><span class="line">        <span class="type">ConfigurationClassParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassParser</span>(</span><br><span class="line">                <span class="built_in">this</span>.metadataReaderFactory, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.environment,</span><br><span class="line">                <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(configCandidates);</span><br><span class="line">        Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(configCandidates.size());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parser.parse(candidates);</span><br><span class="line">            parser.validate();</span><br><span class="line"></span><br><span class="line">            Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">            configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 ConfigurationClassBeanDefinitionReader 来解析配置类</span></span><br><span class="line">      <span class="comment">// 这一步就跟 xml reader 一样，解析里面各个标签</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.reader == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinitionReader</span>(</span><br><span class="line">                        registry, <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>.resourceLoader, <span class="built_in">this</span>.environment,</span><br><span class="line">                        <span class="built_in">this</span>.importBeanNameGenerator, parser.getImportRegistry());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">            alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">            candidates.clear();</span><br><span class="line">            <span class="keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;</span><br><span class="line">                String[] newCandidateNames = registry.getBeanDefinitionNames();</span><br><span class="line">                Set&lt;String&gt; oldCandidateNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(candidateNames));</span><br><span class="line">                Set&lt;String&gt; alreadyParsedClasses = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;</span><br><span class="line">                    alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String candidateName : newCandidateNames) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;</span><br><span class="line">                        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> registry.getBeanDefinition(candidateName);</span><br><span class="line">                        <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="built_in">this</span>.metadataReaderFactory) &amp;&amp;</span><br><span class="line">                                !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;</span><br><span class="line">                            candidates.add(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, candidateName));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                candidateNames = newCandidateNames;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">        <span class="keyword">if</span> (sbr != <span class="literal">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">            sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">            <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">            <span class="comment">// for a shared cache since it&#x27;ll be cleared by the ApplicationContext.</span></span><br><span class="line">            ((CachingMetadataReaderFactory) <span class="built_in">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先看看 <code>ConfigurationClassParser</code> 是怎么解析配置的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationClassParser#parse</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                    parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 直接进入到这里解析（其实上面看起来就是强转之前的判断）</span></span><br><span class="line">                    parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                        <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>parse</code> 里边先根据环境，简单封装了配置类的信息以及其他的相关信息 <code>MetadataReader</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(<span class="meta">@Nullable</span> String className, String beanName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> Assert.notNull(className, <span class="string">&quot;No bean class name for configuration class bean definition&quot;</span>);</span><br><span class="line"> <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="built_in">this</span>.metadataReaderFactory.getMetadataReader(className);</span><br><span class="line"> processConfigurationClass(<span class="keyword">new</span> <span class="title class_">ConfigurationClass</span>(reader, beanName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ConfigurationClass</span> <span class="variable">existingClass</span> <span class="operator">=</span> <span class="built_in">this</span>.configurationClasses.get(configClass);</span><br><span class="line">  <span class="keyword">if</span> (existingClass != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (existingClass.isImported()) &#123;</span><br><span class="line">        existingClass.mergeImportedBy(configClass);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Explicit bean definition found, probably replacing an import.</span></span><br><span class="line">      <span class="comment">// Let&#x27;s remove the old one and go with the new one.</span></span><br><span class="line">      <span class="built_in">this</span>.configurationClasses.remove(configClass);</span><br><span class="line">      <span class="built_in">this</span>.knownSuperclasses.values().removeIf(configClass::equals);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环解析到父级 但是我们现在</span></span><br><span class="line">  <span class="type">SourceClass</span> <span class="variable">sourceClass</span> <span class="operator">=</span> asSourceClass(configClass);</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 这里面解析了 @ComponentScan @Import 等注解，见下面，如果有父级，会返回父级，否则返回NULL</span></span><br><span class="line">    sourceClass = doProcessConfigurationClass(configClass, sourceClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (sourceClass != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.configurationClasses.put(configClass, configClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> SourceClass <span class="title function_">doProcessConfigurationClass</span><span class="params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123;</span><br><span class="line">    <span class="comment">// 解析内部类</span></span><br><span class="line">    processMemberClasses(configClass, sourceClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析配置类（SpringBoot 熟悉的写配置自动提示那种配置）</span></span><br><span class="line">  <span class="keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">    sourceClass.getMetadata(), PropertySources.class,</span><br><span class="line">    org.springframework.context.annotation.PropertySource.class)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.environment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">      processPropertySource(propertySource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +</span><br><span class="line">                  <span class="string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @ComponentScan 这块打算后面再看了</span></span><br><span class="line">  Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(</span><br><span class="line">    sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);</span><br><span class="line">  <span class="keyword">if</span> (!componentScans.isEmpty() &amp;&amp;</span><br><span class="line">      !<span class="built_in">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;</span><br><span class="line">      <span class="comment">// The config class is annotated with @ComponentScan -&gt; perform the scan immediately</span></span><br><span class="line">      Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =</span><br><span class="line">        <span class="built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());</span><br><span class="line">      <span class="comment">// Check the set of scanned definitions for any further config classes and parse recursively if needed</span></span><br><span class="line">      <span class="keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bdCand</span> <span class="operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();</span><br><span class="line">        <span class="keyword">if</span> (bdCand == <span class="literal">null</span>) &#123;</span><br><span class="line">          bdCand = holder.getBeanDefinition();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="built_in">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">          parse(bdCand.getBeanClassName(), holder.getBeanName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @Import 注解</span></span><br><span class="line">  processImports(configClass, sourceClass, getImports(sourceClass), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @ImportResource 注解</span></span><br><span class="line">  <span class="type">AnnotationAttributes</span> <span class="variable">importResource</span> <span class="operator">=</span></span><br><span class="line">    AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);</span><br><span class="line">  <span class="keyword">if</span> (importResource != <span class="literal">null</span>) &#123;</span><br><span class="line">    String[] resources = importResource.getStringArray(<span class="string">&quot;locations&quot;</span>);</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="string">&quot;reader&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String resource : resources) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">resolvedResource</span> <span class="operator">=</span> <span class="built_in">this</span>.environment.resolveRequiredPlaceholders(resource);</span><br><span class="line">      configClass.addImportedResource(resolvedResource, readerClass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析 @Bean ，不过现在只是整理配置了 @Bean 的方法</span></span><br><span class="line">  Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);</span><br><span class="line">  <span class="keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;</span><br><span class="line">    configClass.addBeanMethod(<span class="keyword">new</span> <span class="title class_">BeanMethod</span>(methodMetadata, configClass));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process default methods on interfaces</span></span><br><span class="line">  processInterfaces(configClass, sourceClass);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process superclass, if any</span></span><br><span class="line">  <span class="keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">superclass</span> <span class="operator">=</span> sourceClass.getMetadata().getSuperClassName();</span><br><span class="line">    <span class="keyword">if</span> (superclass != <span class="literal">null</span> &amp;&amp; !superclass.startsWith(<span class="string">&quot;java&quot;</span>) &amp;&amp;</span><br><span class="line">        !<span class="built_in">this</span>.knownSuperclasses.containsKey(superclass)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.knownSuperclasses.put(superclass, configClass);</span><br><span class="line">      <span class="comment">// Superclass found, return its annotation metadata and recurse</span></span><br><span class="line">      <span class="keyword">return</span> sourceClass.getSuperClass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No superclass -&gt; processing is complete</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可不可以这么说，在使用 <code>JavaBean</code> 进行配置的时候，<code>Spring</code> 做了一个能够解读里面每一句的意思的类编译器。 接下来，回到 <code>ConfigurationClassPostProcessor</code> 的 <code>processConfigBeanDefinitions</code> 里边。调用了 <code>parser.validate();</code> 主要验证 <code>cglib</code> 生成的配置类。 紧接着开始解析 <code>this.reader.loadBeanDefinitions(configClasses);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Set&lt;ConfigurationClass&gt; configurationModel)</span> &#123;</span><br><span class="line"> <span class="comment">// 我们知道，Configurator是可以增加条件判断的</span></span><br><span class="line"> <span class="type">TrackedConditionEvaluator</span> <span class="variable">trackedConditionEvaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrackedConditionEvaluator</span>();</span><br><span class="line"> <span class="keyword">for</span> (ConfigurationClass configClass : configurationModel) &#123;</span><br><span class="line">  <span class="comment">// 开始读取 BeanDefinitions</span></span><br><span class="line">  loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span><br><span class="line"><span class="params">  ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果条线显示，不需要启动此配置，则将其从 BeanFactory 中移除掉</span></span><br><span class="line">  <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> configClass.getBeanName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">    registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开始解析每个被 @Bean 修饰的方法</span></span><br><span class="line">  <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">    loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取完成后，读取其他资源</span></span><br><span class="line">  loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">  loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForBeanMethod</span><span class="params">(BeanMethod beanMethod)</span> &#123;</span><br><span class="line">  <span class="type">ConfigurationClass</span> <span class="variable">configClass</span> <span class="operator">=</span> beanMethod.getConfigurationClass();</span><br><span class="line">  <span class="type">MethodMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> beanMethod.getMetadata();</span><br><span class="line">  <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> metadata.getMethodName();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 继续条件判断，判断是否需要创建 Bean</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">    configClass.skippedBeanMethods.add(methodName);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (configClass.skippedBeanMethods.contains(methodName)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">AnnotationAttributes</span> <span class="variable">bean</span> <span class="operator">=</span> AnnotationConfigUtils.attributesFor(metadata, Bean.class);</span><br><span class="line">  Assert.state(bean != <span class="literal">null</span>, <span class="string">&quot;No @Bean annotation attributes&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Consider name and any aliases</span></span><br><span class="line">  List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(bean.getStringArray(<span class="string">&quot;name&quot;</span>)));</span><br><span class="line">    <span class="comment">// 这一步让我知道了，方法名就是 bean 的名字= =</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> (!names.isEmpty() ? names.remove(<span class="number">0</span>) : methodName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register aliases even when overridden</span></span><br><span class="line">  <span class="keyword">for</span> (String alias : names) &#123;</span><br><span class="line">    <span class="built_in">this</span>.registry.registerAlias(beanName, alias);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 xml 配置的 override 是否跟 JavaConfig 冲突了</span></span><br><span class="line">  <span class="keyword">if</span> (isOverriddenByExistingDefinition(beanMethod, beanName)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanName.equals(beanMethod.getConfigurationClass().getBeanName())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanMethod.getConfigurationClass().getResource().getDescription(),</span><br><span class="line">                                             beanName, <span class="string">&quot;Bean name derived from @Bean method &#x27;&quot;</span> + beanMethod.getMetadata().getMethodName() +</span><br><span class="line">                                             <span class="string">&quot;&#x27; clashes with bean name for containing configuration class; please make those names unique!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ConfigurationClassBeanDefinition</span> <span class="variable">beanDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinition</span>(configClass, metadata);</span><br><span class="line">  beanDef.setResource(configClass.getResource());</span><br><span class="line">  beanDef.setSource(<span class="built_in">this</span>.sourceExtractor.extractSource(metadata, configClass.getResource()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非 static 方法</span></span><br><span class="line">  <span class="keyword">if</span> (metadata.isStatic()) &#123;</span><br><span class="line">    <span class="comment">// static @Bean method</span></span><br><span class="line">    <span class="keyword">if</span> (configClass.getMetadata() <span class="keyword">instanceof</span> StandardAnnotationMetadata) &#123;</span><br><span class="line">      beanDef.setBeanClass(((StandardAnnotationMetadata) configClass.getMetadata()).getIntrospectedClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      beanDef.setBeanClassName(configClass.getMetadata().getClassName());</span><br><span class="line">    &#125;</span><br><span class="line">    beanDef.setUniqueFactoryMethodName(methodName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 我的配置被当成 FactoryBean 来处理了</span></span><br><span class="line">    beanDef.setFactoryBeanName(configClass.getBeanName());</span><br><span class="line">    beanDef.setUniqueFactoryMethodName(methodName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (metadata <span class="keyword">instanceof</span> StandardMethodMetadata) &#123;</span><br><span class="line">    beanDef.setResolvedFactoryMethod(((StandardMethodMetadata) metadata).getIntrospectedMethod());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  beanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">  beanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.</span><br><span class="line">                       SKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">  AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始解析一系列的属性</span></span><br><span class="line">  <span class="type">Autowire</span> <span class="variable">autowire</span> <span class="operator">=</span> bean.getEnum(<span class="string">&quot;autowire&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (autowire.isAutowire()) &#123;</span><br><span class="line">    beanDef.setAutowireMode(autowire.value());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">autowireCandidate</span> <span class="operator">=</span> bean.getBoolean(<span class="string">&quot;autowireCandidate&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!autowireCandidate) &#123;</span><br><span class="line">    beanDef.setAutowireCandidate(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> bean.getString(<span class="string">&quot;initMethod&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasText(initMethodName)) &#123;</span><br><span class="line">    beanDef.setInitMethodName(initMethodName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">destroyMethodName</span> <span class="operator">=</span> bean.getString(<span class="string">&quot;destroyMethod&quot;</span>);</span><br><span class="line">  beanDef.setDestroyMethodName(destroyMethodName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Consider scoping</span></span><br><span class="line">  <span class="type">ScopedProxyMode</span> <span class="variable">proxyMode</span> <span class="operator">=</span> ScopedProxyMode.NO;</span><br><span class="line">  <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> AnnotationConfigUtils.attributesFor(metadata, Scope.class);</span><br><span class="line">  <span class="keyword">if</span> (attributes != <span class="literal">null</span>) &#123;</span><br><span class="line">    beanDef.setScope(attributes.getString(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    proxyMode = attributes.getEnum(<span class="string">&quot;proxyMode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">      proxyMode = ScopedProxyMode.NO;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replace the original bean definition with the target one, if necessary</span></span><br><span class="line">  <span class="type">BeanDefinition</span> <span class="variable">beanDefToRegister</span> <span class="operator">=</span> beanDef;</span><br><span class="line">  <span class="keyword">if</span> (proxyMode != ScopedProxyMode.NO) &#123;</span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">proxyDef</span> <span class="operator">=</span> ScopedProxyCreator.createScopedProxy(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDef, beanName), <span class="built_in">this</span>.registry,</span><br><span class="line">      proxyMode == ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">    beanDefToRegister = <span class="keyword">new</span> <span class="title class_">ConfigurationClassBeanDefinition</span>(</span><br><span class="line">      (RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(String.format(<span class="string">&quot;Registering bean definition for @Bean method %s.%s()&quot;</span>,</span><br><span class="line">                               configClass.getMetadata().getClassName(), beanName));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 好了，第一篇解析 xml 的时候已经说过了，复用了之前的方法</span></span><br><span class="line">  <span class="built_in">this</span>.registry.registerBeanDefinition(beanName, beanDefToRegister);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在回到上面刚刚的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    下面这些目前可以先不用看了。是用来执行其他 BeanDefinitionRegistryPostProcessors</span></span><br><span class="line"><span class="comment">    因为我目前的主要点在于怎么解析我的配置类。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 开始运行其他的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">   reiterate = <span class="literal">false</span>;</span><br><span class="line">   postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">     currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">     processedBeans.add(ppName);</span><br><span class="line">     reiterate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">   registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">   invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">   currentRegistryProcessors.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">  invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">  invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 然后按照，配置了 PriorityOrdered、配置了 Ordered、未配置顺序的执行顺序来执行这些生命周期回调函数</span></span><br><span class="line"> <span class="comment">// 其中使用了 processedBeans 来记录已经执行过的 processor，如果执行过的则会跳过</span></span><br><span class="line"> String[] postProcessorNames =</span><br><span class="line">   beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"> <span class="comment">// Ordered, and the rest.</span></span><br><span class="line"> List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">  <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">   <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">   priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">   orderedPostProcessorNames.add(ppName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line"> sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"> invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line"> List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"> <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">  orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line"> &#125;</span><br><span class="line"> sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"> invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line"> List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"> <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">  nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line"> &#125;</span><br><span class="line"> invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line"> <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line"> beanFactory.clearMetadataCache();</span><br></pre></td></tr></table></figure>
<p>这串动作做好了以后，我们在 <code>MyBeanConfiguration</code> 里面配置的 <code>MyBean.class</code>，已经被注册到了当前的 <code>BeanFactory</code> 中去了。然后回到这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractApplicationContext#refresh():</span><br><span class="line">...</span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里实例化我们没有加上 @LazyInit 的对象，也就是 MyBean 在这里进行实例化</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="2-5-初始化配置的Bean对象"><a href="#2-5-初始化配置的Bean对象" class="headerlink" title="2.5 初始化配置的Bean对象"></a>2.5 初始化配置的Bean对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"> <span class="comment">// 注册数据转换器</span></span><br><span class="line"> <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">   beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">  beanFactory.setConversionService(</span><br><span class="line">    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 注册配置文件解析器，解析注入配置文件的那种方式</span></span><br><span class="line"> <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">  beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line"> <span class="comment">// AOP相关的先跳过</span></span><br><span class="line"> String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"> <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">  getBean(weaverAwareName);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line"> beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 缓存BeanDefinition的内容，这时候过后已经停止修改BeanDefinition的内容了</span></span><br><span class="line"> beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 在这里做配置类中所有对象的初始化</span></span><br><span class="line"> beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory#preInstantiateSingletons</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 便利所有非LazyInit的BeanNames，拿到BeanDefinition进行初始化。</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="type">boolean</span> isEagerInit;</span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                                                        ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                                        getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                           ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里触发初始化，进去后直接到AbstractBeanFactory#getBean</span></span><br><span class="line">        <span class="comment">// 已经很熟悉的函数了，不再细说。</span></span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发post-initialization回调函数</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2>]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>【Spring源码】第三步：从一个简单的BeanFactory开始</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84beanfactory/index.html</url>
    <content><![CDATA[<h2 id="简单的DEMO"><a href="#简单的DEMO" class="headerlink" title="简单的DEMO"></a>简单的DEMO</h2><p>看源码，不就是打断点，看断点代码，重复这个步骤。 然而要运行这个容器，我需要一个简单的例子： 一个简单的 <code>Bean</code>，只有一个属性：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的测试Bean.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weidan &lt;emailto&gt;toweidan@126.com&lt;/emailto&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBean</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TestBean</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TestBean</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;TestBean&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot; value=&quot;WeidanLi&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>主要通过构造函数来构造了 <code>Bean</code> 的值。 还有一个程序入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的IOC测试用例.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weidan &lt;emailto&gt;toweidan@126.com&lt;/emailto&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyXmlFactoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetBean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line">    <span class="type">TestBean</span> <span class="variable">bean</span> <span class="operator">=</span> bf.getBean(TestBean.class);</span><br><span class="line">    Assert.hasLength(bean.getName(), <span class="string">&quot;没有获取到配置文件的配置信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了 <code>XmlBeanFactory</code>，一个简单的 <code>BeanFactory</code> 实例。这个类提供了最基础的 <code>IOC</code> 功能，少了消息通知，生命周期等等这些东西，在日常中都不用这个类，使用 <code>ApplicationContext</code>，他是增强很多功能的 <code>BeanFactory</code>，不过作为出入门的菜逼，我就是用 <code>XmlBeanFactory</code> 这个好了，也是很多 <code>Spring</code> 源码书籍推荐的入门类。 可以看进入的代码，简单的创建容器，指定配置文件，然后断言我在配置文件中注入的值。 可以先看看这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultListableBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>(resource, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="built_in">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到这个类的作者是大名鼎鼎的 <code>Rod Johnson</code>，这是一个左脑用来拿计算机博士，右脑用来拿音乐博士的男人，简直就是我的光头偶像。后来创建了 <code>Spring</code> 项目以及维护的公司，所以说这个类其实已经很元老级别了。然后我现在的光标就在他的署名上闪动，想想还有点小激动。</p>
</blockquote>
<p>我们调用的构造函数传递一个 <code>Resource</code> 接口参数，这个参数我并不打算深究，因为他就是一个简单的工具接口（在 <code>spring-core</code> 模块中定义的），里面指定了配置文件从哪个流出来（所以我们不仅仅可以使用 <code>File</code> 流，只要是 <code>IO流</code> 都可以作为配置文件的来源。） 除开构造函数构造的参数，他还直接定义了一个 <code>XmlBeanDefinitionReader</code>，就是一个配置文件的读取器，用来读取、解析配置内容的。然而这个类，先放一边，只需要看他在哪里调用的注册就可以了，因为我现在的目的不是怎么解析 <code>xml</code> 文件，而是怎么注册 <code>Bean</code>。</p>
<h2 id="XmlBeanDefinitionReader解析ClassBean"><a href="#XmlBeanDefinitionReader解析ClassBean" class="headerlink" title="XmlBeanDefinitionReader解析ClassBean"></a>XmlBeanDefinitionReader解析ClassBean</h2><p>现在我们把 <code>debug</code> 指针进入这个 <code>XmlBeanDefinitionReader.loadBeanDefinitions(resource)</code> 里边去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用封装编码的对象 <code>EncodedResource</code> 继续调用了同名的重载函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">    <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">        currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">            <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>粘了代码觉得挺长的，那么通过调用 <code>loadBeanDefinitions(EncodedResource encodedResource)</code> 开始进行当前 <code>BeanFactory</code> 进行检测，如果已经存在了同样的解析进程，则抛出异常，这个异常我先放着，应该大概意思就是重复注册了配置文件吧？因为我们知道 <code>applicationContext</code> 是可以导入其他配置的，如果同样的配置注册了两次那么以为着配置有问题，则抛出异常。我们可以试一下： 修改 <code>applicationContext.xml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- import他自己 --&gt;</span><br><span class="line">    &lt;import resource=&quot;applicationContext.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=&quot;TestBean&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot; value=&quot;WeidanLi&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>运行： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84beanfactory.md/0.png"> </p>
<p>果然，在第一次解析的时候，拿到了我的 <code>import</code> 节点，继续调用当前方法来注册的时候，因为文件是同一个，<code>Set&lt;EncodedResource&gt;.add()</code> 的时候添加失败了，抛出异常，直接解析失败。而 <code>Set</code> 这个实例是存储在当前线程的<code>ThreadLocal</code> 中的，防止重复读取配置文件。可以在这里看出来设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">if (currentResources == null) &#123;</span><br><span class="line">    currentResources = new HashSet&lt;&gt;(4);</span><br><span class="line">    this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来进入一个 <code>try-catch</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步就是拆解上一步封装的 <code>EncodedResource</code> 拿到我们的文件资源，然后开始进入 <code>doLoadBeanDefinitions</code> 开始真正的读取。</p>
<blockquote>
<p>这其实是 <code>spring</code> 项目的一个编码风格，xxx() 函数一般做数据准备，包括验证，设置什么东西，然后doXxx() 才开始做真正的事情。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ... 省略一堆catch代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，这个方法很简单，就两句话，不过第一句读取可以跳过，无非就是 <code>文件流</code> 读成了熟悉的 <code>Document</code> 对象了。然后第二句话，没有 <code>do</code> 开头，说明又要进入准备：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title function_">createBeanDefinitionDocumentReader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.instantiateClass(<span class="built_in">this</span>.documentReaderClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> XmlReaderContext <span class="title function_">createReaderContext</span><span class="params">(Resource resource)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlReaderContext</span>(resource, <span class="built_in">this</span>.problemReporter, <span class="built_in">this</span>.eventListener,</span><br><span class="line">            <span class="built_in">this</span>.sourceExtractor, <span class="built_in">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是调用的时候需要的三个属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ProblemReporter</span> <span class="variable">problemReporter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FailFastProblemReporter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReaderEventListener</span> <span class="variable">eventListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmptyReaderEventListener</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">SourceExtractor</span> <span class="variable">sourceExtractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullSourceExtractor</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>准备了一个 <code>BeanDefinitionDocumentReader</code>，通过反射实例化了这个类，这个类作用就是记录了配置文件中，节点代表的含义，以及在解析过程中，遇到这些节点要干什么事情，比如遇到 <code>import</code> 要回来调用继续读取，遇到 <code>bean</code> 要实例化对象，并且注册到 <code>BeanFactory</code> 中。 而 <code>XmlReaderContext createReaderContext(Resource resource)</code> 构建一个对象 <code>XmlReaderContext</code>，应该说就是当前的上下文状态，包含了事件监听器、日志记录以及元信息提取器，然而在当前这个简单的 <code>BeanFactory</code> 中，这三个对象，都是很简单的实现（非空即NULL，<code>problemReporter</code> 则是一个记录器上下文，抛抛异常什么的）。 <code>XmlBeanDefinitionReader</code> 的任务基本上已经做完了，接下来就是交给解析器 <code>BeanDefinitionDocumentReader</code> 来做了。 接下来我们进入 <code>documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</code> 这句话，看看里面做了什么。</p>
<h2 id="BeanDefinitionDocumentReader读取配置文档"><a href="#BeanDefinitionDocumentReader读取配置文档" class="headerlink" title="BeanDefinitionDocumentReader读取配置文档"></a>BeanDefinitionDocumentReader读取配置文档</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionDocumentReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">        doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title function_">createDelegate</span><span class="params">(</span></span><br><span class="line"><span class="params">            XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionParserDelegate</span>(readerContext);</span><br><span class="line">        delegate.initDefaults(root, parentDelegate);</span><br><span class="line">        <span class="keyword">return</span> delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">        <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">        <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">                <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">                <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，可以简单看到，<code>registerBeanDefinitions</code> 函数只是简单的设置了一下 <code>上一个类中的 xml 读取环境XmlReaderContext</code>，然后直接进入 <code>doRegisterBeanDefinitions</code> 开始解析。</p>
<blockquote>
<p>又见到这个 xxx() 和 doXxx() 的风格了。</p>
</blockquote>
<p>在 <code>doRegisterBeanDefinitions</code> 方法中，首先通过判断父类有没有 <code>BeanDefinitionParserDelegate</code> 解析器，如果没有，直接传递当前的 <code>XmlReaderContext上下文</code> <code>new</code> 一个新的解析器，先康康这个解析器是干嘛的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinitionParserDelegate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BEANS_NAMESPACE_URI</span> <span class="operator">=</span> <span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MULTI_VALUE_ATTRIBUTE_DELIMITERS</span> <span class="operator">=</span> <span class="string">&quot;,; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Value of a T/F attribute that represents true.</span></span><br><span class="line"><span class="comment">     * Anything else represents false. Case seNsItive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TRUE_VALUE</span> <span class="operator">=</span> <span class="string">&quot;true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FALSE_VALUE</span> <span class="operator">=</span> <span class="string">&quot;false&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_VALUE</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DESCRIPTION_ELEMENT</span> <span class="operator">=</span> <span class="string">&quot;description&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTOWIRE_NO_VALUE</span> <span class="operator">=</span> <span class="string">&quot;no&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTOWIRE_BY_NAME_VALUE</span> <span class="operator">=</span> <span class="string">&quot;byName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTOWIRE_BY_TYPE_VALUE</span> <span class="operator">=</span> <span class="string">&quot;byType&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTOWIRE_CONSTRUCTOR_VALUE</span> <span class="operator">=</span> <span class="string">&quot;constructor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTOWIRE_AUTODETECT_VALUE</span> <span class="operator">=</span> <span class="string">&quot;autodetect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BEAN_ELEMENT</span> <span class="operator">=</span> <span class="string">&quot;bean&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">META_ELEMENT</span> <span class="operator">=</span> <span class="string">&quot;meta&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;id&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，直接下结论，这就是一个与我们配置文件节点、属性名字对应的解析器。 走到了中间的 <code>if</code> 代码，无非就是判断节点是否是根节点，以及有没有配置 <code>profile</code> 环境。如果有，是否跟当前配置想要的环境一致，如果不一致，跳过解析，一致就继续走到下面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionDocumentReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">        <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">        <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">                <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">                <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">preProcessXml</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessXml</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过了 <code>profile</code> 判断后，就开始解析配置文件了。 先开始 <code>preProcessXml</code> ，然而，默认的实现是不做任何事情，这就预留给我们，可以在子类里边做一些事情。如果我们用了自定义的标签，可以实现这个方法来实现我们标签想要的功能。比如我们可以实现一个 <code>author</code> 的 <code>xml</code> 节点，然后在日志打印这个配置文件的作者（防止有 <code>bug</code> 找不到当事人祭天~） 哦对了，<code>postProcessXml</code> 也没有实现，跟 <code>preProcessXml</code> 一样留给使用者。 紧接着，开始 <code>parseBeanDefinitions</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，摄影师，把聚光灯投向 <code>BeanDefinitionParserDelegate</code> 类。</p>
<h2 id="BeanDefinitionParserDelegate解析BeanDefinition"><a href="#BeanDefinitionParserDelegate解析BeanDefinition" class="headerlink" title="BeanDefinitionParserDelegate解析BeanDefinition"></a>BeanDefinitionParserDelegate解析BeanDefinition</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinitionParserDelegate</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略上面一堆的常量</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">                        beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                                beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                        <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">                        <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">                        <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">                        <span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                                beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                                !<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                            aliases.add(beanClassName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    error(ex.getMessage(), ele);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我在配置文件什么都没有定义，所以直接来到了这句话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">checkNameUniqueness</span><span class="params">(String beanName, List&lt;String&gt; aliases, Element beanElement)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">foundName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(beanName) &amp;&amp; <span class="built_in">this</span>.usedNames.contains(beanName)) &#123;</span><br><span class="line">        foundName = beanName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundName == <span class="literal">null</span>) &#123;</span><br><span class="line">        foundName = CollectionUtils.findFirstMatch(<span class="built_in">this</span>.usedNames, aliases);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundName != <span class="literal">null</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;Bean name &#x27;&quot;</span> + foundName + <span class="string">&quot;&#x27; is already used in this &lt;beans&gt; element&quot;</span>, beanElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.usedNames.add(beanName);</span><br><span class="line">    <span class="built_in">this</span>.usedNames.addAll(aliases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后他就通过一个集合（这个集合记录我配置里面定义的所有名字 <code>name属性</code>）来判断名字是否是唯一的。 然而我都没有定义，所以还是不必要关心，过。 接下来继续关心 <code>BeanDefinitionParserDelegate</code> 的解析过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionElement</span><span class="params">(</span></span><br><span class="line"><span class="params">        Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">BeanEntry</span>(beanName));</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">        parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="built_in">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (... ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先有一个 <code>parseState</code> 来记录解析的状态（<code>finally</code> 里面会弹出来，所以这个是个栈结构），获取到 <code>类名</code> 以及 <code>父类</code>，然后进入 <code>createBeanDefinition</code> 开始创建 <code>BeanDefinition</code>。</p>
<blockquote>
<p><code>BeanDefinition</code> 是一个将配置文件中的内容抽象到内存对象的数据结构（就是业务中常用的DTO）。</p>
</blockquote>
<p>再来看看 <code>createBeanDefinition</code> 中做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title function_">createBeanDefinition</span><span class="params">(<span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> String parentName)</span></span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">            parentName, className, <span class="built_in">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinitionReaderUtils.createBeanDefinition: </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title function_">createBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">GenericBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">    bd.setParentName(parentName);</span><br><span class="line">    <span class="keyword">if</span> (className != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">            bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bd.setBeanClassName(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个 <code>GenericBeanDefinition</code>，指定了 <code>Bean</code> 的 <code>Class</code> 对象。</p>
<blockquote>
<p>GenericBeanDefinition 就是我们定义的，我们可以自己使用的，普通 <code>Bean</code> 的数据结构。</p>
</blockquote>
<p>然后接下来所做的事情，就是把标签里边的属性给设置到当前这个 <code>GenericBeanDefinition</code> 中去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码片段：</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="built_in">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br></pre></td></tr></table></figure>
<p>由于我们使用的是构造器注入值的方式，所以可以简单看看 <code>parseConstructorArgElements(ele, bd);</code> 这一段，其他的解析，如果没有设置，都会直接无操作的跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">indexAttr</span> <span class="operator">=</span> ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">    <span class="type">String</span> <span class="variable">typeAttr</span> <span class="operator">=</span> ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">    <span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(indexAttr);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="string">&quot;&#x27;index&#x27; cannot be lower than 0&quot;</span>, ele);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">ConstructorArgumentEntry</span>(index));</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> parsePropertyValue(ele, bd, <span class="literal">null</span>);</span><br><span class="line">                    ConstructorArgumentValues.<span class="type">ValueHolder</span> <span class="variable">valueHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>.ValueHolder(value);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">                        valueHolder.setType(typeAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                        valueHolder.setName(nameAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    valueHolder.setSource(extractSource(ele));</span><br><span class="line">                    <span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">                        error(<span class="string">&quot;Ambiguous constructor-arg entries for index &quot;</span> + index, ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.parseState.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">            error(<span class="string">&quot;Attribute &#x27;index&#x27; of tag &#x27;constructor-arg&#x27; must be an integer&quot;</span>, ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">ConstructorArgumentEntry</span>());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> parsePropertyValue(ele, bd, <span class="literal">null</span>);</span><br><span class="line">            ConstructorArgumentValues.<span class="type">ValueHolder</span> <span class="variable">valueHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>.ValueHolder(value);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">                valueHolder.setType(typeAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                valueHolder.setName(nameAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            valueHolder.setSource(extractSource(ele));</span><br><span class="line">            bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.parseState.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无非就是拿到我配置文件中配置的值，然后注入到 <code>GenericBeanDefinition</code> 中去，我不想解读了。。。😑 注册完，返回到我们上面的主流程中来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">  <span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">    aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">    beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                   <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">  <span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">          beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">            beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">          <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">          <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">          <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">          <span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">              beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">              !<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">            aliases.add(beanClassName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        error(ex.getMessage(), ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我没有定义名字，所以，<code>XmlReaderContext</code> 需要帮我生成一个名字，默认是 <code>TestBean#0</code>，添加到 <code>alias</code> 数组中，然后返回去。</p>
<h2 id="BeanDefinitionDocumentReader注册BeanDefinition"><a href="#BeanDefinitionDocumentReader注册BeanDefinition" class="headerlink" title="BeanDefinitionDocumentReader注册BeanDefinition"></a>BeanDefinitionDocumentReader注册BeanDefinition</h2><p><code>BeanDefinitionParserDelegate</code> 昨晚解析的工作并且产生 <code>BeanDefinition</code> 返回回去了，接下来，生成实例的任务又回到了 <code>BeanDefinitionDocumentReader</code> 的头上。 先回忆一下刚刚到哪一步了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">  <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">  <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">  <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">  <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">  <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">  <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">  <span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">  <span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">      <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                       <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    <span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        <span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">          parseDefaultElement(ele, delegate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          delegate.parseCustomElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">    importBeanDefinitionResource(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">    processAliasRegistration(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">    processBeanDefinition(ele, delegate);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">    <span class="comment">// recurse</span></span><br><span class="line">    doRegisterBeanDefinitions(ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">  <span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);<span class="comment">// ← 刚刚来到这一步</span></span><br><span class="line">  <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来 <code>bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder)</code> 里面做的事情是用户自定义标签要做的事情，所以可以先不看。直接过，接下来就是将 <code>BeanDefinition</code> 放入当前的容器中了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BeanDefinitionRegistry</code> 从哪里来的，他其实就是刚开始进入的时候，传递了 <code>this</code> 实现将当前的 <code>BeanFactory</code> 放进去的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">DefaultListableBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new XmlBeanFactory with the given resource,</span></span><br><span class="line"><span class="comment">     * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>(resource, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new XmlBeanFactory with the given input stream,</span></span><br><span class="line"><span class="comment">     * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentBeanFactory parent bean factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="built_in">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以此时，<code>registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())</code> 这句话就是注册 <code>BeanDefinition</code> 的关键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                        existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>  <span class="title function_">containsSingleton</span><span class="params">(beanName)</span>) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有点长，仔细看了一下，验证和和真正注册都写在这里面，有点反之前 <code>xxx</code> 和 <code>doXxx</code> 的约定啊。总感觉是某个老鼠屎（比较大颗的那种，因为比我牛逼）写的。我来裁减掉日志记录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<span class="comment">// ←直接来到这里</span></span><br><span class="line">            <span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>  <span class="title function_">containsSingleton</span><span class="params">(beanName)</span>) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通篇很长，然而我现在的情况就是直接去到代码中我指示的地方，这两个就很好说了，到了 <code>removeManualSingletonName</code> 这一句则是移除当前已经存在的单例的名字。</p>
<h2 id="完成注册"><a href="#完成注册" class="headerlink" title="完成注册"></a>完成注册</h2><p>通篇讲完，我发现他并没有实例化我要的 <code>Bean</code>，然后在 <code>getBean</code> 的方法里面我发现我需要的时候他才开始创建真正的对象。</p>
<h2 id="getBean初始化"><a href="#getBean初始化" class="headerlink" title="getBean初始化"></a>getBean初始化</h2><p>我的测试用例第二句话是 <code>TestBean bean = bf.getBean(TestBean.class);</code>，就是这个时候拿到对应的对象的。</p>
<blockquote>
<p>那 lazy-init 有什么用呢… 可能其他容器用到了吧。</p>
</blockquote>
<p>现在我们进入 <code>getBean</code> 来看看了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">return</span> getBean(requiredType, (Object[]) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">resolved</span> <span class="operator">=</span> resolveBean(ResolvableType.forRawClass(requiredType), args, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (resolved == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) resolved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用了重载的方法，然后重载方法也比较简单，就是通过 <code>resolveBean</code> 拿到我的对象然后返回。那重点应该是 <code>resolveBean</code> 这个方法了。 <code>ResolvableType.forRawClass(requiredType)</code> 只是包装了一层对象，包含了我指定的 <code>Class</code> 其他没什么了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; NamedBeanHolder&lt;T&gt; <span class="title function_">resolveNamedBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (namedBean != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> namedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">parent</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AutowireCapableBeanFactory) parent).resolveNamedBean(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(requiredType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; NamedBeanHolder&lt;T&gt; <span class="title function_">resolveNamedBean</span><span class="params">(</span></span><br><span class="line"><span class="params">        ResolvableType requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> nonUniqueAsNull)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    String[] candidateNames = getBeanNamesForType(requiredType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        List&lt;String&gt; autowireCandidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!containsBeanDefinition(beanName)  getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">                autowireCandidates.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!autowireCandidates.isEmpty()) &#123;</span><br><span class="line">            candidateNames = StringUtils.toStringArray(autowireCandidates);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> candidateNames[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NamedBeanHolder</span>&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; candidates = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> getBean(beanName);</span><br><span class="line">                candidates.put(beanName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="literal">null</span> : beanInstance));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                candidates.put(beanName, getType(beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">candidateName</span> <span class="operator">=</span> determinePrimaryCandidate(candidates, requiredType.toClass());</span><br><span class="line">        <span class="keyword">if</span> (candidateName == <span class="literal">null</span>) &#123;</span><br><span class="line">            candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (candidateName != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> candidates.get(candidateName);</span><br><span class="line">            <span class="keyword">if</span> (beanInstance == <span class="literal">null</span>  beanInstance <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                beanInstance = getBean(candidateName, requiredType.toClass(), args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NamedBeanHolder</span>&lt;&gt;(candidateName, (T) beanInstance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nonUniqueAsNull) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoUniqueBeanDefinitionException</span>(requiredType, candidates.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单参数的 <code>resolveNamedBean</code> 调用了重载的 <code>resolveNamedBean</code> 方法，下面的代码是如果没有找到，继续从父级容器寻找，然而我们都没有父级容器而且可以直接就拿到实例，所以下面的代码基本可以不看。 首先，他通过 <code>String[] candidateNames = getBeanNamesForType(requiredType)</code> 拿到了容器中帮我生成的默认名字。然而由于只有一个名字，所以她走了这段代码：<code>return new NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</code>，首先通过 <code>getBean(beanName, requiredType.toClass(), args)</code> 拿到实例。但是这个方法已经进入到了父类 <code>AbstractBeanFactory</code> 中，所以父类应该是做了实例化操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title class_">ConfigurableBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span></span><br><span class="line">            <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">              <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">      <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">              nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">          <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">        markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            registerDependentBean(dep, beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create bean instance.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">              <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">              <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">          <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">          <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">finally</span> &#123;</span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">          bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">          <span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">          <span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">              beforePrototypeCreation(beanName);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">                <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">convertedBean</span> <span class="operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (convertedBean == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">              ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doGetBean</code> 方法还是很长，所以我感觉我还是需要裁减掉一些东西：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">  Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">    <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">    <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">T</span> <span class="variable">convertedBean</span> <span class="operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> convertedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">            ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在 <code>doGetBean</code> 代码就只做几件事情了：</p>
<ol>
<li> 尝试获取正在创建的单例，如果没有，创建、放入容器、返回；</li>
<li> 检查是否有循环以来，类似于 A 依赖 B，B 依赖 A 的操作；</li>
<li> 转换为我们制定的类（有接口的情况下）；</li>
</ol>
<h2 id="创建Bean对象"><a href="#创建Bean对象" class="headerlink" title="创建Bean对象"></a>创建Bean对象</h2><p>所以我们现在需要看的是这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">                ...</span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 在子类的 AbstractAutowireCapableBeanFactory 实现</span></span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------&gt; AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException  ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然而，我们注册的是 <code>GenericBeanDefinition</code> 来到这里被转换成 <code>RootBeanDefinition</code>，进去看了注释发现，他说 <code>GenericBeanDefinition</code> 拥有高级的功能。所以这里的转换应该是为了兼容老版本的吧。 因为我们在配置文件定义的类，是可以通过其他方法来覆盖他原来拥有的方法的（但其实我还是不明白这么做的含义是什么，一般日常都是直接修改的吧，唯一能想到的就是临时拓展功能），所以在这里需要准备一下覆盖的配置：<code>mbdToUse.prepareMethodOverrides();</code> 接下来，来到了 <code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>，看注释的意思是可以注入 <code>AOP</code> 然后获取到了一个代理增强的实例，但是由于目前我还没设置 <code>AOP</code>，姑且先跳过不管吧。毕竟他也是直接返回一个 <code>null</code> 值。 下一步就是 <code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code> 了，这一步有点复杂….不过慢慢来吧。</p>
<hr>
<p>我们来看看 <code>doCreateBean(beanName, mbdToUse, args)</code> 做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    <span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line">                            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哦~~~~，出现了一个 <code>BeanWrapper</code> 的创建了。</p>
<blockquote>
<p><code>BeanWrapper</code> 与 <code>BeanDefinition</code> 的道理差不多，<code>BeanDefinition</code> 记录着配置信息，那 <code>BeanWrapper</code> 也一样记录着创建的信息了。 忽然间感觉好像很少需要用到配置记录这类东西？</p>
</blockquote>
<p>然后来到了这两个 <code>if</code> 里边：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">  instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实第一个 <code>if</code> 就没什么作用了，是用于给 <code>FactoryBean</code> 的，直接移除，但是移除返回的是 <code>null</code>，所以顺利的进入了第二个 <code>if</code> 语句。我现在贴出 <code>createBeanInstance</code> 的代码出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  调用了这个方法</span></span><br><span class="line"><span class="comment">    @Nullable</span></span><br><span class="line"><span class="comment">    protected Class&lt;?&gt; resolveBeanClass(final RootBeanDefinition mbd, String beanName, final Class&lt;?&gt;... typesToMatch)</span></span><br><span class="line"><span class="comment">            throws CannotLoadBeanClassException &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            if (mbd.hasBeanClass()) &#123;</span></span><br><span class="line"><span class="comment">                return mbd.getBeanClass();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ----------------- 先不看 Start ----------------- */</span></span><br><span class="line">        <span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">        <span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ----------------- 先不看 END ----------------- */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">                    resolved = <span class="literal">true</span>;</span><br><span class="line">                    autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">            <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">                <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (ctors != <span class="literal">null</span>  mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR </span><br><span class="line">                mbd.hasConstructorArgumentValues()  !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">        ctors = mbd.getPreferredConstructors();</span><br><span class="line">        <span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">        <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么当前的 <code>BeanDefinition</code> 已经记录了我们使用的，也就是 <code>TestBean.class</code>，所以直接返回这个 <code>Class</code> 实例即可。然后继续接下来的动作，因为已经支持了 <code>j8</code> 的 <code>Lambda</code> 函数（<code>j8</code> ？~），所以此处可以编写函数进行创建，先不看，过。 然而我在 <code>getBean</code> 的时候并没有传递参数，只是传递了一个 <code>Class</code>，所以此处所有的 <code>args</code> 都是 <code>Null</code>。 那 <code>Spring</code> 该怎么办呢？我也没有提供 <code>factoryMethod</code> 也没有指定 <code>构造方法</code>， 他只能从配置文件来获取了。 所以设置了 <code>resolved</code> 为 <code>true</code>（<code>resolved</code> 意思是解决，我想这里可以当成自己解决的意思吧）</p>
<h2 id="查找对应的构造器"><a href="#查找对应的构造器" class="headerlink" title="查找对应的构造器"></a>查找对应的构造器</h2><p>接下来 <code>Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</code> 用于获取 <code>Bean</code> 创建的后处理器，看看是否有做什么后备操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(<span class="meta">@Nullable</span> Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">            <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    <span class="type">SmartInstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">                    <span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ctors;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然而我没有给，直接给 <code>null</code> 返回出来了。 接下来 <code>mbd.hasConstructorArgumentValues()</code> 返回 <code>true</code>，因为我提供了构造器的值，所以使用 <code>return autowireConstructor(beanName, mbd, ctors, args);</code> 这个函数进行创建并返回。 <code>autowireConstructor</code> 只有一句话，就是 <code>new</code> 一个构造器构建器进行注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">autowireConstructor</span><span class="params">(</span></span><br><span class="line"><span class="params">        String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] ctors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConstructorResolver</span>(<span class="built_in">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>this</code> 是当前的 <code>BeanFactory</code>，然后我们可以直接进入 <code>autowireConstructor</code> 构造器注入方式的函数了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanWrapper <span class="title function_">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanWrapperImpl</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>();</span><br><span class="line">    <span class="built_in">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; constructorToUse = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ArgumentsHolder</span> <span class="variable">argsHolderToUse</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Object[] argsToUse = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">        argsToUse = explicitArgs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] argsToResolve = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">                <span class="comment">// Found a cached constructor...</span></span><br><span class="line">                argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">                <span class="keyword">if</span> (argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                    argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argsToResolve != <span class="literal">null</span>) &#123;</span><br><span class="line">            argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructorToUse == <span class="literal">null</span>  argsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">        Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="literal">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">                        beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line">                        <span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="literal">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">            Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">                    mbd.constructorArgumentsResolved = <span class="literal">true</span>;</span><br><span class="line">                    mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">                &#125;</span><br><span class="line">                bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">                <span class="keyword">return</span> bw;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to resolve the constructor.</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">autowiring</span> <span class="operator">=</span> (chosenCtors != <span class="literal">null</span> </span><br><span class="line">                mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">        <span class="type">ConstructorArgumentValues</span> <span class="variable">resolvedValues</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minNrOfArgs;</span><br><span class="line">        <span class="keyword">if</span> (explicitArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">            minNrOfArgs = explicitArgs.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ConstructorArgumentValues</span> <span class="variable">cargs</span> <span class="operator">=</span> mbd.getConstructorArgumentValues();</span><br><span class="line">            resolvedValues = <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>();</span><br><span class="line">            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AutowireUtils.sortConstructors(candidates);</span><br><span class="line">        <span class="type">int</span> <span class="variable">minTypeDiffWeight</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="literal">null</span>;</span><br><span class="line">        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> candidate.getParameterCount();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; argsToUse != <span class="literal">null</span> &amp;&amp; argsToUse.length &gt; parameterCount) &#123;</span><br><span class="line">                <span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span><br><span class="line">                <span class="comment">// do not look any further, there are only less greedy constructors left.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parameterCount &lt; minNrOfArgs) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ArgumentsHolder argsHolder;</span><br><span class="line">            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (resolvedValues != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);</span><br><span class="line">                    <span class="keyword">if</span> (paramNames == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">ParameterNameDiscoverer</span> <span class="variable">pnd</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">                        <span class="keyword">if</span> (pnd != <span class="literal">null</span>) &#123;</span><br><span class="line">                            paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">                            getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Ignoring constructor [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Swallow and try next constructor.</span></span><br><span class="line">                    <span class="keyword">if</span> (causes == <span class="literal">null</span>) &#123;</span><br><span class="line">                        causes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    causes.add(ex);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line">                <span class="keyword">if</span> (parameterCount != explicitArgs.length) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                argsHolder = <span class="keyword">new</span> <span class="title class_">ArgumentsHolder</span>(explicitArgs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">typeDiffWeight</span> <span class="operator">=</span> (mbd.isLenientConstructorResolution() ?</span><br><span class="line">                    argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">            <span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line">            <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">                constructorToUse = candidate;</span><br><span class="line">                argsHolderToUse = argsHolder;</span><br><span class="line">                argsToUse = argsHolder.arguments;</span><br><span class="line">                minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">                ambiguousConstructors = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="literal">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ambiguousConstructors == <span class="literal">null</span>) &#123;</span><br><span class="line">                    ambiguousConstructors = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">                    ambiguousConstructors.add(constructorToUse);</span><br><span class="line">                &#125;</span><br><span class="line">                ambiguousConstructors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constructorToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (causes != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">UnsatisfiedDependencyException</span> <span class="variable">ex</span> <span class="operator">=</span> causes.removeLast();</span><br><span class="line">                <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Could not resolve matching constructor &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="literal">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Ambiguous constructor matches found in bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">                    ambiguousConstructors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (explicitArgs == <span class="literal">null</span> &amp;&amp; argsHolderToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">            argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Assert.state(argsToUse != <span class="literal">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line">    bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line">    <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这函数的长度还是挺恶心人的。。。 首先，在 <code>BeanFactory</code> 里边记录些东西并进行初始化 <code>BeanWrapImpl</code>，我就先不看了，我现在目标是进入初始化的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">  beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br></pre></td></tr></table></figure>
<p>这句话是个三元表达式，<code>nonPublicAccessAllowed</code> 默认是 <code>true</code>，所以走 <code>beanClass.getDeclaredConstructors()</code>，这个是 <code>jdk</code> <code>Class</code> 的方法，获取到所有声明的构造函数，不出意外的话是两个。 接下来就是判断拿哪个构造器了，第一个 <code>if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues())</code> 显然不是，因为我有两个构造函数。所以又可以跳过一大段无聊的代码~然而因为传递的 <code>args</code> 是 <code>Null</code> 所以开始拿到配置文件中构造器参数的长度：<code>minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</code>。 接下来就是找到哪个构造器来匹配了，采用 <code>for</code> 所有构造器，比对长度的方式来做：<code>for (Constructor&lt;?&gt; candidate : candidates) &#123;</code> 如果不符合条件的就 <code>Continue</code>，接下来获取名字，不出意外的话，是为了能够写日志hhhh？下面还有使用到这个参数，接着看下去。 先是记录了使用的配置文件的值，使用的构造器，然后 <code>argsHolderToUse.storeCache(mbd, constructorToUse);</code> 保存到缓存中以便后面使用（是不是有点没必要的）。</p>
<h2 id="开始初始化对象"><a href="#开始初始化对象" class="headerlink" title="开始初始化对象"></a>开始初始化对象</h2><p>然后调用 <code>instantiate</code> 进行真正的对象初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">instantiate</span><span class="params">(</span></span><br><span class="line"><span class="params">  String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt; constructorToUse, Object[] argsToUse)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">InstantiationStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="built_in">this</span>.beanFactory.getInstantiationStrategy();</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">     strategy.instantiate(mbd, beanName, <span class="built_in">this</span>.beanFactory, constructorToUse, argsToUse),</span><br><span class="line">     <span class="built_in">this</span>.beanFactory.getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> strategy.instantiate(mbd, beanName, <span class="built_in">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">    <span class="string">&quot;Bean instantiation via constructor failed&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有系统安全管理器，所以使用 <code>SimpleInstantiationStrategy.instantiate</code> 开始初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span><br><span class="line"><span class="params">  <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// use own privileged to change accessibility (when security is on)</span></span><br><span class="line">   AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args); <span class="comment">// 直接进入这里</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BeanUtils</code> 就是封装 <code>jdk</code> 反射调用构造器构造对象的方法了。 好了一层一层的返回去，最后回到了这里 <code>AbstractBeanFactory</code> 里边刚刚路过的 <code>Lambda</code> 里面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">      <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">      <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">      destroySingleton(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册刚刚创建的Bean到BeanFactory中"><a href="#注册刚刚创建的Bean到BeanFactory中" class="headerlink" title="注册刚刚创建的Bean到BeanFactory中"></a>注册刚刚创建的Bean到BeanFactory中</h2><p>拿到了 <code>sharedInstance</code> 之前呢，其实 <code>AbstractBeanFactory</code> 是调用父级 <code>DefaultSingletonBeanRegistry</code> 的 <code>getSingleton</code> 先从容器中查找，没有的话再调用了我们刚刚看的一堆创建过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName); <span class="comment">// 因为第一次取没有找到所以进入创建流程</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationNotAllowedException</span>(beanName,</span><br><span class="line">                            <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                beforeSingletonCreation(beanName); <span class="comment">// 开始通知</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    newSingleton = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                    <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                    singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Exception suppressedException : <span class="built_in">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                            ex.addRelatedCause(suppressedException);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    afterSingletonCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    addSingleton(beanName, singletonObject); <span class="comment">// 然后做了记录</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="built_in">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">            <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            <span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此一个真正创建 <code>Bean</code> 的流程就完成了。 我们接下来看 <code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</code> 这句话，这句话说是 <code>get</code> 但是内部其实就是验证 <code>Bean</code> 是否创建完整，是否返回的是 <code>Null对象</code> 或者 <code>工厂对象</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">  Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">  <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(beanName, beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">  <span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">  <span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">  <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  省略下面代码因为上面已经直接返回回去了，下面其实就是说拿到了 FactoryBean 的话，调用创建真正的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，这个返回一路前进，就出来到我们自己写的 <code>TestBean bean = bf.getBean(TestBean.class);</code></p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>我用类图来说说看法： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84beanfactory.md/1.png"> 代码的分割还有意思：</p>
<ol>
<li> 定义基础的 <code>BeanFactory</code> 能干嘛（能拿能顺序能父子容器的 <code>BeanFactory</code>）；</li>
<li> 定义了 <code>Registry</code> 能干嘛（无非就是容器的增删查改）；</li>
<li> 初步实现了第 <code>2</code> 点的功能；</li>
<li> 上面功能都有了，接下来要自动装配了，自动化的 <code>BeanFactory</code>；</li>
<li> 能自动组装了，还要可以配置，定义根据配置做上面动作的增删查改；</li>
<li> 然后就是一个完整的 <code>BeanFactory</code> 类：<code>XmlBeanFactory</code>。</li>
</ol>
<h2 id="小看法"><a href="#小看法" class="headerlink" title="小看法"></a>小看法</h2><p>第一次写 <code>Spring</code> 相关的源码文章，写的可能不是很好，已经跟随断点慢慢一步一步的走过来了。其实读完有那么一瞬间我感觉，针对一个函数做一个小事情的做法，<code>Spring</code> 貌似并没有做到？不过后面仔细思考了一下，因为我看源码的时候会忽略掉函数权限的问题，所以其实接口暴露的方法能够拿到正确的值才是关键。 不得不说，<code>XmlBeanFactory</code> 这个类走得有点复杂，但是我看后面的 <code>Context</code> 已经没有使用上面所说的所有类了。这个类现在的责任应该就是当成学习来供读者感受的吧。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring源码】第一步：开始读源码--基于idea</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E5%BC%80%E5%A7%8B%E8%AF%BB%E6%BA%90%E7%A0%81-%E5%9F%BA%E4%BA%8Eidea/index.html</url>
    <content><![CDATA[<p>心心想念很久读 <code>Spring</code> 源码，但是一直没有坚持下去。也看了一些别人怎么读源码的教程，然而有一天忽然在上班的公交上来了灵感，最方便的工具就在我手上啊！ 对，就是那个叫 <code>idea</code> 的编码工具！</p>
<a id="more"></a>
<h2 id="看类层次图"><a href="#看类层次图" class="headerlink" title="看类层次图"></a>看类层次图</h2><p>有两种方式，一种是直接生成 <code>UML</code> 图： 在想要看的类上面，右键选择这里（当然建议记住这里的快捷键），就可以出现 <code>idea</code> 绘制好的 <code>UML</code> 图： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144402.png"> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144409.png" alt="image-20191202144945669"> </p>
<p>然后，如果想看其中某个节点的源码，比如 <code>MessageSource</code> 那么只要鼠标选中这个节点，然后按 <code>F4</code> 即可进入类源码： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E5%BC%80%E5%A7%8B%E8%AF%BB%E6%BA%90%E7%A0%81-%E5%9F%BA%E4%BA%8Eidea.md/1.png" alt="image-20191202145300345"> </p>
<p>好，这是第一种方法，我也比较喜欢这种方式。那么第二种方法是让 <code>idea</code> 出现树形的结构，然后可以直接看层次，但是我感觉单纯的树形并不能很好的表达 <code>继承</code> 和 <code>实现</code>，不过还是说一下吧： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E5%BC%80%E5%A7%8B%E8%AF%BB%E6%BA%90%E7%A0%81-%E5%9F%BA%E4%BA%8Eidea.md/2.png"> </p>
<p>就是这个，<code>osx</code> 系统使用的是 <code>^ + H</code>，可以看看自己电脑是哪个快捷键，方便快速调用出来。</p>
<h2 id="运行轨迹图"><a href="#运行轨迹图" class="headerlink" title="运行轨迹图"></a>运行轨迹图</h2><p>这个问题尼玛就是困扰我没有去读源码的动力，但是，在 <code>Debug</code> 窗口，他就是提供了，悔恨自己没早点发现！！！ 很多时候，我们在源码打了断点，但是因为跳来跳去，然后后面忘了，忘了在哪个地方进来了，然后就稀里糊涂的出去了。 然而其实在这里，是记录了 <code>Debug</code> 走过的函数的： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E5%BC%80%E5%A7%8B%E8%AF%BB%E6%BA%90%E7%A0%81-%E5%9F%BA%E4%BA%8Eidea.md/3.png"> </p>
<p>只要用鼠标点击函数名字，就可以去到这个函数所在的代码块，特么太香了！！！</p>
<h2 id="导入Spring源码"><a href="#导入Spring源码" class="headerlink" title="导入Spring源码"></a>导入Spring源码</h2><p>其实这一步在源码下的 <code>import-into-idea.md</code> 文件已经有提及到了，不过还是简单说说吧： 下载完源码，先不要急着导入 <code>idea</code>，而是在代码所在的目录中运行这个命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>
<p>我估计是这个项目会先安装一些代码所需要的依赖工程（这些工程就在源码里边），让 <code>idea</code> 打开的时候不至于扫描的时候报错。 然后再导入源码到 <code>idea</code> 中，这时候大概的十多分钟的索引+下依赖，就可以试着运行 <code>Spring</code> 提供的测试用例来简单的测试环境。</p>
<p> <img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E5%BC%80%E5%A7%8B%E8%AF%BB%E6%BA%90%E7%A0%81-%E5%9F%BA%E4%BA%8Eidea.md/4.png"> </p>
<p>通过了大概就是这样吧，绿色的小沟子√。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>【Spring源码】第二步：了解Spring的项目架构</title>
    <url>//spring/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%BA%86%E8%A7%A3spring%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/index.html</url>
    <content><![CDATA[<h2 id="Spring项目模块"><a href="#Spring项目模块" class="headerlink" title="Spring项目模块"></a>Spring项目模块</h2><p>下了源码一看，我去（我其实没有那么惊讶毕竟功能强大，多也正常），<code>Spring</code> 居然有这么多的模块划分，但是这些模块都是做什么的，可能我们平常观察项目集成的时候，能够感受一些东西出来。比如：<code>spring-web</code> 是 <code>SpringMVC</code> 的内容。所以在日常中，把 <code>SpringMVC</code> 当成一个独立框架是一个很有问题的说法，他其实也就是 <code>Spring</code> 家族中的一个小模块而已。除了这个模块比较常见，我们还使用了 <code>AOP</code> <code>Transction</code> 这些模块，因为很多时候，在框架的集成中，已经依赖好了这些中间对接模块，但是他其实存在于每一个基本的 <code>web</code> 项目中。 我一直很喜欢 <code>Spring</code> 提供的说明书：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/index.html">说明书链接</a> 这个说明书开头就已经把所有模块，做什么事情的都总结好了，需要用到哪个模块的说明，进入对应的链接就好了： </p>
<a id="more"></a>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%BA%86%E8%A7%A3spring%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.md/1.png" alt="image-20191202151902551"></p>
<p> 简单说说：</p>
<ol>
<li> 总览：介绍 <code>Spring</code> 的背景故事；</li>
<li> <code>Core核心模块</code>：<code>Spring</code> 的核心是什么，就是 <code>容器+AOP</code>。一切的事情都是基于这两个模块而来，现有容器，容器装着我们定义的 <code>Bean</code> 配置，然后再是 <code>AOP</code>，<code>AOP</code> 可以增强很多额外的功能，比如 <code>spring-cache</code> 缓存。然而这里的介绍还包含了事件通知、资源管理、<code>i18n</code>、数据校验、数据绑定以及类型转变；</li>
<li> <code>Testing测试模块</code>：我们公司倒是很少写测试用例，然而这个模块包含了一系列的测试模块，包括 <code>Mock数据</code>、测试的Spring上下文、<code>SpringMVC</code> 的测试等等；</li>
<li> <code>DataAccess数据访问模块</code>：包含了数据库事务，<code>Dao层</code> 的支持，也就是常见的 <code>MyBatis</code> 整合 <code>Spring</code> 需要用到的一些接口，还有 <code>jdbcTemplate</code>；</li>
<li> <code>WebServlet 和 WebReactive</code>：包含有新版才有的 <code>WebFlux</code> 模块还有他的客户端，我们常见的 <code>SpringMVC</code>，<code>WebSocket</code>；</li>
<li> <code>Integration集成模块</code>：这个模块可能用的不是很多？有远程调用过时的 <code>JMS</code> 技术，<code>Email</code>，任务，调度以及缓存模块；</li>
<li> <code>Language</code> 就不用说啦，支持的编程语言。</li>
</ol>
<h2 id="spring-core项目"><a href="#spring-core项目" class="headerlink" title="spring-core项目"></a>spring-core项目</h2><p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%BA%86%E8%A7%A3spring%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.md/2.png"></p>
<p> 有点报错，但是不影响运行呀~ 为啥这个模块要在这里说，因为这个模块是最基础的一个，基本 <code>Spring</code> 所有的子模块都以来这个项目，那么他有什么用，因为他是一个工具人工具模块，比如这个 <code>StringUtils</code>： </p>
<p><img src="/images/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%BA%86%E8%A7%A3spring%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.md/3.png"> </p>
<p>还有个点，他的 <code>utils</code> 都是抽象类的（防止实例化），提供静态方法使用。在日常业务搬砖中，也可以直接使用这些工具类，节省了很多依赖包。 好了，可以开始进入源码的阶段了，这篇稍稍短点，但是那时候知道文档地址的时候简直如获珍宝，一切我们所需要的东西都可以在这里找到。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>spring源码</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的入门 web 项目</title>
    <url>//spring/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%A5%E9%97%A8-web-%E9%A1%B9%E7%9B%AE/index.html</url>
    <content><![CDATA[<h1 id="一个简单的入门-web-项目"><a href="#一个简单的入门-web-项目" class="headerlink" title="一个简单的入门 web 项目"></a>一个简单的入门 web 项目</h1><p>[toc]</p>
<h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>其实，<code>spring</code> 在我们职业生涯中，大部分只做一件事情，那就是：<code>web</code> 项目 <code>bean</code> 的管理和整合。所以，<code>web</code> 应用是至关重要的，本文将从一个简单的 <code>hello world</code> 开始 <code>web</code> 的构建。 <strong>示例代码：<code>web-simple</code></strong></p>
<a id="more"></a>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-mvn-新增-web-starter-的依赖"><a href="#1-mvn-新增-web-starter-的依赖" class="headerlink" title="1. mvn 新增 web-starter 的依赖"></a>1. <code>mvn</code> 新增 <code>web-starter</code> 的依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- 引入 web-starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<!-- more -->
<h3 id="2-controller-编写"><a href="#2-controller-编写" class="headerlink" title="2. controller 编写"></a>2. <code>controller</code> 编写</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.simpleweb.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：HelloWorld 控制器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/19 12:14 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// 使用 RestController，指定该控制器输出都是 json 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span> <span class="comment">// 使用 GetMapping 代替 RequestMapping、同理还有 PostMapping PutMapping DeleteMapping</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">helloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; helloMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        helloMap.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> helloMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-编写启动器"><a href="#3-编写启动器" class="headerlink" title="3. 编写启动器"></a>3. 编写启动器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.springboot.simpleweb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：启动器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/19 12:24 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// 使用注解指定这是 spring-boot 项目的启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleWebApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 固定写法，传入本类以及参数 该参数是可以在启动的时候指定覆盖配置的</span></span><br><span class="line">        SpringApplication.run(SimpleWebApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，一个最基本的 <code>spring-boot</code> 项目就完成了</p>
<h3 id="4-测试接口"><a href="#4-测试接口" class="headerlink" title="4. 测试接口"></a>4. 测试接口</h3><p><img src="/images/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%A5%E9%97%A8-web-%E9%A1%B9%E7%9B%AE.md/0.png"></p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>OK，至此一个简单的（虽然简单，但是可以在生产中使用）例子就完结了。可以对比以前，首先需要在 <code>web.xml</code> 中指定 <code>listener</code> 以及 <code>DispatchServlet</code> ，然后编写几个 <code>spring</code> 的配置文件，现在的步骤基本简单了很多。 当然在实际生产中肯定还有其他的东西需要配置，比如服务之间传递的协议、拦截器、验证器等等，我将放在后续进行编写。 这里可能会遇到一个坑：就是启动类没有在顶级的目录下导致扫描不到配置的东西，这里需要说明一下： </p>
<p><img src="/images/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%A5%E9%97%A8-web-%E9%A1%B9%E7%9B%AE.md/1.png"></p>
<p> 也就是说，比如包名 <code>cn.liweidan.endpoint</code> 他是扫描不到的，他只能扫描到 <code>cn.liweidan.springboot.simpleweb</code> 下的带有 <code>spring</code> 注解的类。 当然如果你觉得你不想这样编排，想把启动类抽出来放在一个包里面，然后又要扫描其他地方，就需要在启动类上加一个注解 <code>@SpringBootApplication(scanBasePackages = &#123;&quot;cn.liweidan.springboot&quot;&#125;)</code> 传递字符串数组，即要扫描到的所有包名。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;cn.liweidan.springboot&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleWebApplication</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>微服务Feign本地契约测试--SpringCloudContract</title>
    <url>//spring/%E5%BE%AE%E6%9C%8D%E5%8A%A1feign%E6%9C%AC%E5%9C%B0%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95-springcloudcontract/index.html</url>
    <content><![CDATA[<h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>在项目开发的时候，特别是使用 <code>TDD</code> 进行开发的项目，测试便是不可或缺的一个环节。然而我们的服务一般都需要配合其他服务接口来进行开发，那么测试的时候就需要开启所有服务来配合测试，机器配置跟不上，在构建的时候也会出现很多问题。 这时候就需要有一个东西来把调用第三方接口的事情给做了。最近看了<code>Clossoverjie</code>的一篇文章 <a href="https://crossoverjie.top/2018/10/15/SpringBoot/SpringBoot-tips/#more">分享几个 SpringBoot 实用的小技巧</a>，他很巧妙的利用 <code>Spring</code> 的容器把连接第三方接口的 <code>bean</code> 给替换掉。但我感觉始终还不是那么优雅（嗯，<code>Spring</code> 脑残粉，<code>Spring</code> 提供了就会用）。 现在 <code>Spring-Cloud</code> 提供了一个插件，<code>Spring-Cloud-Contract</code> 可以巧妙的对消费者项目进行打桩，让项目的测试调用访问的时候，可以模拟第三方业务，这也需要生产者提供一个 <code>Contract</code> 来使用。（当然，挺适合我这种一个人开发多个服务的开发者） </p>
<p><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1feign%E6%9C%AC%E5%9C%B0%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95-springcloudcontract.md/1.png"></p>
<a id="more"></a>
<h2 id="二-搭建一个环境"><a href="#二-搭建一个环境" class="headerlink" title="二. 搭建一个环境"></a>二. 搭建一个环境</h2><p>OK，演示需要有个大概的业务示例来做。 我这里模拟了订单服务需要从产品服务获取产品的描述（不要吐槽，随便想到罢了）。那么调用订单服务就需要调用到产品服务了，我将演示如何在订单服务中将产品服务给 <code>Mock</code> 掉。 项目情况：</p>
<ul>
<li>  Eureka: 注册中心</li>
<li>  product-server：产品服务</li>
<li>  order-server：订单服务</li>
<li>  SpringCloud：<code>Edgware.SR3</code></li>
<li>  SpringBoot：<code>1.5.10.RELEASE</code></li>
</ul>
<h3 id="2-1-订单服务"><a href="#2-1-订单服务" class="headerlink" title="2.1 订单服务"></a>2.1 订单服务</h3><p>获取一个订单的时候，需要获取产品信息的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProductClient productClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderEndpoint</span><span class="params">(ProductClient productClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.productClient = productClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">get</span><span class="params">(<span class="meta">@RequestParam(&quot;productUuid&quot;)</span> String productUuid)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里需要调用产品服务接口来获取产品信息</span></span><br><span class="line">        <span class="type">ProductDesciption</span> <span class="variable">productDesciption</span> <span class="operator">=</span> productClient.uuidOf(productUuid);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Order</span>(UUID.randomUUID().toString(), productDesciption);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品客户端</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;product-server&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line">    ProductDesciption <span class="title function_">uuidOf</span><span class="params">(<span class="meta">@RequestParam(&quot;uuid&quot;)</span> String uuid)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订单DTO类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProductDesciption productDesciption;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略getter&amp;setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品类，用于接收上游接口返回的信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductDesciption</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prodName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略getter&amp;setter</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-产品服务"><a href="#2-2-产品服务" class="headerlink" title="2.2 产品服务"></a>2.2 产品服务</h3><p>产品服务随意的提供了产品信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductEndpoint</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">uuidOf</span><span class="params">(<span class="meta">@RequestParam(&quot;uuid&quot;)</span> String uuid)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (uuid) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;电视&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;iPhone&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prodName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略getter&amp;setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-请求订单接口"><a href="#2-3-请求订单接口" class="headerlink" title="2.3 请求订单接口"></a>2.3 请求订单接口</h3><p>我用了 <code>idea</code> 自带的 <code>HTTP</code> 工具来测试接口，返回正常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8082?productUuid=1</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 </span><br><span class="line">X-Application-Context: order-server:8082</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Tue, 11 Dec 2018 02:41:59 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;uuid&quot;: &quot;53ddfe48-0bf9-43d9-abb5-65a59468a5b5&quot;,</span><br><span class="line">  &quot;productDesciption&quot;: &#123;</span><br><span class="line">    &quot;prodName&quot;: &quot;电视&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-生产者提供contract包"><a href="#三-生产者提供contract包" class="headerlink" title="三. 生产者提供contract包"></a>三. 生产者提供contract包</h2><h3 id="3-1-引入相关包"><a href="#3-1-引入相关包" class="headerlink" title="3.1 引入相关包"></a>3.1 引入相关包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--契约测试服务提供端依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-contract-verifier&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--以下需要放在 plugins 标签中--&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-contract-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;!-- Don&#x27;t forget about this value !! --&gt;</span><br><span class="line">    &lt;extensions&gt;true&lt;/extensions&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;!-- MvcMockTest为生成本地测试案例的基类 --&gt;</span><br><span class="line">        &lt;baseClassForTests&gt;com.springboot.services.producer.MvcMockTest&lt;/baseClassForTests&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-编写-Contract"><a href="#3-1-编写-Contract" class="headerlink" title="3.1 编写 Contract"></a>3.1 编写 <code>Contract</code></h3><p>可以使用 <code>groovy</code> 或者 <code>yaml</code> 进行编写，我就提供 <code>groovy</code> 版本了。 需要放在 <code>src/test/resources/contracts/ProductEndpoint.groovy</code> 中，注意资源包下的那个目录。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> contracts</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.contract.spec.Contract</span><br><span class="line"></span><br><span class="line">Contract.make &#123;</span><br><span class="line">    request &#123;</span><br><span class="line">        <span class="comment">// 请求方法</span></span><br><span class="line">        method <span class="string">&#x27;GET&#x27;</span></span><br><span class="line">        <span class="comment">// 路径</span></span><br><span class="line">        url(<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            queryParameters &#123;</span><br><span class="line">                parameter(<span class="string">&quot;uuid&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    response &#123; <span class="comment">// 响应设置</span></span><br><span class="line">        status <span class="number">200</span></span><br><span class="line">        body(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">          &#123;</span></span><br><span class="line"><span class="string">              &quot;uuid&quot;: &quot;1&quot;,</span></span><br><span class="line"><span class="string">              &quot;prodName&quot;: &quot;电视&quot;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span>)</span><br><span class="line">        headers &#123;</span><br><span class="line">            header(<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-生成桩"><a href="#3-2-生成桩" class="headerlink" title="3.2 生成桩"></a>3.2 生成桩</h3><p>生成 <code>Mapping.json</code>，放在<code>product-server/target/stubs/META-INF/cn.liweidan.contract/product-server/1.0.0-SNAPSHOT/mappings/ProductEndpoint.json</code> 中，里面是对请求响应的设定</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd product-server # pom.xml 所在目录</span><br><span class="line">mvn spring-cloud-contract:convert # 转换成mapping.json</span><br><span class="line">mvn spring-cloud-contract:generateStubs # 生成 jar 包</span><br><span class="line">mvn install:install-file -DgroupId=cn.liweidan.contract \</span><br><span class="line">    -DartifactId=product-server -Dversion=1.0.0-SNAPSHOT \</span><br><span class="line">    -Dpackaging=jar -Dclassifier=stubs -Dfile=target/product-server-1.0.0-SNAPSHOT-stubs.jar # 安装到本地仓库</span><br></pre></td></tr></table></figure>
<p>OK，已经将 <code>product-server</code> 的桩打进 <code>maven</code> 仓库了，现在可以在消费者那边进行使用</p>
<h2 id="四-消费者使用contract包"><a href="#四-消费者使用contract包" class="headerlink" title="四. 消费者使用contract包"></a>四. 消费者使用contract包</h2><h3 id="4-1-引入相关包"><a href="#4-1-引入相关包" class="headerlink" title="4.1 引入相关包"></a>4.1 引入相关包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- SpringBoot 测试 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--契约测试服务提供端依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-contract-stub-runner&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-编写测试类"><a href="#4-2-编写测试类" class="headerlink" title="4.2 编写测试类"></a>4.2 编写测试类</h3><p>这里跟参考资料作者写的就有点区别了，可能是因为升级了版本 <code>@AutoConfigureStubRunner</code> 的 <code>stubsMode</code> 属性已经取消了。 这里是去 <code>maven</code> 仓库查找。 <code>ids</code> 属性指定的是刚刚打包的桩的坐标 格式是：<code>groupId:artifactId:version:classifier:port</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.contract.order.endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hamcrest.core.Is;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.contract.stubrunner.spring.AutoConfigureStubRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：测试订单端口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-12-11 12:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="comment">// ids 指定需要打桩的服务，记住写 workOffline</span></span><br><span class="line"><span class="meta">@AutoConfigureStubRunner(ids = &#123;&quot;cn.liweidan.contract:product-server:1.0.0-SNAPSHOT:stubs:9080&quot;&#125;, workOffline = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEndpointTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetOrder</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/&quot;</span>).param(<span class="string">&quot;productUuid&quot;</span>, <span class="string">&quot;1&quot;</span>))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;productDesciption.prodName&quot;</span>, Is.is(<span class="string">&quot;电视&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-3-配置服务名称"><a href="#4-3-配置服务名称" class="headerlink" title="4.3 配置服务名称"></a>4.3 配置服务名称</h3><p>我已经顺便把测试的时候把 <code>eureka</code> 的链接关闭了。 完整配置（<code>test/resources</code>）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">order-server</span></span><br><span class="line"><span class="attr">stubrunner:</span></span><br><span class="line">  <span class="attr">idsToServiceIds:</span> <span class="comment"># 用于指定 feign 名字对应的 stubs 包。前面是 stubs 包的 artifactId，后面是  feign 名字</span></span><br><span class="line">    <span class="attr">product-server:</span> <span class="string">product-server</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-运行测试"><a href="#4-4-运行测试" class="headerlink" title="4.4 运行测试"></a>4.4 运行测试</h3><p><img src="/images/%E5%BE%AE%E6%9C%8D%E5%8A%A1feign%E6%9C%AC%E5%9C%B0%E5%A5%91%E7%BA%A6%E6%B5%8B%E8%AF%95-springcloudcontract.md/2.png"></p>
<p>OK，单机测试可以用过了。 当然测试还包括数据库使用内存数据库等等，可以防止在 <code>maven</code> 编译的时候报错，这块其他文章再说</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/WeidanLi/spring-cloud-contract-demo">示例代码</a> <a href="https://segmentfault.com/a/1190000015555626">基于Feign的微服务调用之契约测试 Spring Cloud Contract</a> <a href="https://cloud.spring.io/spring-cloud-contract/single/spring-cloud-contract.html#contract-dsl">Contract-dsl</a> <a href="https://cloud.spring.io/spring-cloud-static/Edgware.SR3/single/spring-cloud.html">SpringCloudContractDocs</a></p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>SpringCloudContract</tag>
      </tags>
  </entry>
  <entry>
    <title>测试你的 springboot 项目</title>
    <url>//spring/%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9A%84-springboot-%E9%A1%B9%E7%9B%AE/index.html</url>
    <content><![CDATA[<h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>测试用例，在日常开发来说，可能刚开始写代码的小厂不会在乎，不过也有很多公司根本就没有测试用例，开发的时候一直写下去。写完一部分，直接启动项目，调用接口进行 <code>debug</code> 调试，然后修改报错的地方。等到了所有功能都实现了以后，就可以合并分支并且发布给测试环境去测试了。 以前刚开始我也是没有写测试用例的习惯，慢慢的接触了 <code>TDD</code> 开发模式，简直被深深吸引住了。测试驱动开发的步骤简单的说就是先写出来你期待的功能，期待的返回值，然后开始启动项目进行运行，由程序自动识别返回的结果是否是错误的。小步开发，一直到功能完成为止。<br>乍一听好像没什么用处，但是好处还在后面，当部门经理提出来这个功能需要加入新的需求的时候，这时候测试用例就是开发人员的利器了。在开始加入新功能之前，保证测试用例正常通过，然后开始小步加入新的需求，修改新需求结果的用例，知道满足新的需求为止。这个过程开发体验是及其舒服的，测试用例可以保证程序的正常运行，及早发现漏洞和错误。暂时把新加入需求这一项放一边，在后面看到这段代码想要重构的时候，测试用例就是心中的奠基石，修改代码的结果，然后运行测试用例，顺利通过，心情愉悦的提交代码。 ok，说了这么多测试的好处，那就要看看怎么实施了，怎么结合 <code>springboot</code> 来编写运行我们的测试用例。<code>web</code> 的测试来说，应该是要复杂一点，应为涉及到容器的启动以及正确初始化，常规的整合 <code>spring</code> 框架那么自动化注入也是测试中的一部分，所以不妨每次测试用例开始的时候，运行 <code>spring</code> 让其正确的进行运行，再测试我们的业务代码，岂不美哉。 <strong>示例代码：spring-boot-test</strong> <strong>项目地址：<a href="https://github.com/WeidanLi/spring-boot-tutorial/">https://github.com/WeidanLi/spring-boot-tutorial/</a></strong></p>
<a id="more"></a>
<h2 id="二-开发"><a href="#二-开发" class="headerlink" title="二. 开发"></a>二. 开发</h2><h3 id="1-引入测试库"><a href="#1-引入测试库" class="headerlink" title="1. 引入测试库"></a>1. 引入测试库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- springboot web starter --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- SpringBoot 测试 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-准备简单的业务环境"><a href="#2-准备简单的业务环境" class="headerlink" title="2. 准备简单的业务环境"></a>2. 准备简单的业务环境</h3><p><code>UserDo</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uuid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UserService</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, UserDo&gt; userDB = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(UserDo userDo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(userDo.getUuid())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;用户uuid不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(userDo.getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;用户姓名不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        userDB.put(userDo.getUuid(), userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">findByUID</span><span class="params">(String UID)</span> &#123;</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> userDB.get(UID);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(userDo)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userDo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UserEndpoint</code> 接口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpoint</span> &#123;                                                              ··`</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(<span class="meta">@RequestBody</span> UserDo userDo)</span> &#123;</span><br><span class="line">        userService.create(userDo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;userUID&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserDo <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;userUID&quot;)</span> String userUID)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findByUID(userUID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的说就是实现了两个接口，一个是新增用户的接口，如果用户的两个属性有一个为空，将会抛出错误参数的属性。另外一个是查询，如果查询不到也会抛出错误参数的信息（此步日常中应该是 <code>NotFoundException</code> ）。</p>
<h3 id="3-开始测试"><a href="#3-开始测试" class="headerlink" title="3. 开始测试"></a>3. 开始测试</h3><h4 id="1）编写测试环境的配置文件"><a href="#1）编写测试环境的配置文件" class="headerlink" title="1）编写测试环境的配置文件"></a>1）编写测试环境的配置文件</h4><p>我们知道，<code>mvn</code> 或 <code>gradle</code> 提供了测试包的 <code>resources</code> 可以隔离生产环境的配置文件，当然如果觉得生产环境的配置文件已经配置了一些测试的配置，此处可以略过，因为如果读取不到测试包下的 <code>resources</code> ，测试会自动读取生产下的 <code>resources</code> 。这里为了省时省力，也好像没什么需要特别指出的，我就不写了（主要还是因为懒…） 哎呀不行不行，还是要简单说下配置吧。像 <code>springboot</code> 测试环境下的配置，我觉得几点是我踩坑来的。比如当前项目调用了第三方项目，可以在测试配置里面写打桩的配置（比如使用了 <code>spring-cloud-contract</code> ），数据库的配置可以直接连接内存数据库，一来呢比较快，二来呢也不会存储测试过的垃圾数据（就是说会影响下一次测试的数据）。当然像连接第三方中间件的方式，目前来说，Emm，好像还没什么比较好的解决方案，就是直接连接真实存在的链接。所以我们公司在开发的时候，测试的流程中基本连接公司本地的测试服务器的中间件。</p>
<h4 id="2）编写测试基类"><a href="#2）编写测试基类" class="headerlink" title="2）编写测试基类"></a>2）编写测试基类</h4><p>测试基类呢，主要是关于配置，关于测试前需要准备的数据，每个测试用例过后需要清理动作的抽象，由子测试类继承，拥有基类的配置以及常用的数据。 我这里就是简单的装配一些套件，当测试的一个范围里面总是需要一部分测试数据的时候，可以在这里进行装配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description：测试基类</span></span><br><span class="line"><span class="comment"> * 测试基类在类级别上主要定义了测试基类的安装（一般就是 SpringBootTest 的一些注解）</span></span><br><span class="line"><span class="comment"> * 安装数据</span></span><br><span class="line"><span class="comment"> * 清理数据等等</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/25 7:34 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = TestApplication.class)</span> <span class="comment">// 定义这个类是一个 SpringBoot 项目的测试，指定启动器（当然只有一个的话不指定也是可以的）</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span> <span class="comment">// 使用 SpringRunner 进行运行，常规写法，照抄就可以了</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">// 测试过后是否回滚数据，这么写是会自动回滚的，如果不想要回滚，可以省略该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试是否按需抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">ExpectedException</span> <span class="variable">thrown</span> <span class="operator">=</span> ExpectedException.none();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试mvn层接口套件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext context;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在测试用来开始的时候装配 MockMvc 套件</span></span><br><span class="line">        mvc = MockMvcBuilders.webAppContextSetup(context).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3）测试业务层"><a href="#3）测试业务层" class="headerlink" title="3）测试业务层"></a>3）测试业务层</h4><p>OK，那么我们现在可以开始编写我们自己代码的测试用例了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * describe: 用户业务层的测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/25 7:44 PM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> <span class="keyword">extends</span> <span class="title class_">BaseTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 测试传递空数据的时候是否正常抛出异常，首先传递想要出现的异常</span></span><br><span class="line">        thrown.expect(IllegalArgumentException.class);</span><br><span class="line">        <span class="comment">// 调用实例</span></span><br><span class="line">        userService.create(<span class="keyword">new</span> <span class="title class_">UserDo</span>());</span><br><span class="line">        <span class="comment">// 如果没有抛出异常，代码走到这里，将会直接抛出错误（因为不应该会走到这里来的）</span></span><br><span class="line">        fail();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以逐个缺少参数进行测试但好像没这个必要，毕竟业务开发时间不允许那么长时间花在编写测试上面</span></span><br><span class="line">        <span class="comment">// 不过话说回来，这里缺失的在后面如果对参数验证进行重构的话，绝对需要补上来的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编写一个正确的参数传递进去，然后需要回过头来查询插入的数据是否存在</span></span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>();</span><br><span class="line">        userDo.setUuid(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        userDo.setName(<span class="string">&quot;Adan&quot;</span>);</span><br><span class="line">        userService.create(userDo);</span><br><span class="line">        <span class="comment">// 查询是否存在，当实际项目中这里是使用仓库进行存储的时候，理应应该使用仓库进行查询</span></span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">dbUserDo</span> <span class="operator">=</span> userService.findByUID(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        assertNotNull(<span class="string">&quot;用户信息不应该为null&quot;</span>, dbUserDo);</span><br><span class="line">        assertTrue(<span class="string">&quot;用户uuid不应为空&quot;</span>, !StringUtils.isEmpty(dbUserDo.getUuid()));</span><br><span class="line">        assertTrue(<span class="string">&quot;用户name不应为空&quot;</span>, !StringUtils.isEmpty(dbUserDo.getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findByUID</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的测试步骤基本和上面差不多，不过反过来的，先使用findByUID查询，期望为找不到，</span></span><br><span class="line">        thrown.expect(IllegalArgumentException.class);</span><br><span class="line">        userService.findByUID(<span class="string">&quot;999&quot;</span>);</span><br><span class="line">        fail();</span><br><span class="line">        <span class="comment">// 再插入再查询，期望不为空</span></span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>();</span><br><span class="line">        userDo.setUuid(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        userDo.setName(<span class="string">&quot;Adan&quot;</span>);</span><br><span class="line">        userService.create(userDo);</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">dbUserDo</span> <span class="operator">=</span> userService.findByUID(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        assertNotNull(<span class="string">&quot;用户信息不应该为null&quot;</span>, dbUserDo);</span><br><span class="line">        assertTrue(<span class="string">&quot;用户uuid不应为空&quot;</span>, !StringUtils.isEmpty(dbUserDo.getUuid()));</span><br><span class="line">        assertTrue(<span class="string">&quot;用户name不应为空&quot;</span>, !StringUtils.isEmpty(dbUserDo.getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例其实也不怎么难吧，其实可以说一种心理来编写是最好的，就是你别当做代码是你自己写的，你当做是别人写的，然后你现在要找茬，为难这个方法调用，写出来的测试用例就有用多了。 还有一点，有些同事喜欢直接打印出来结果，然后用肉眼去看。其实我刚开始也是，不过这种方式很痛苦，你需要在控制台一个一个去寻找，然后在脑袋里面去判断这个值是否正确。那为什么不解放你的脑袋，让程序来做呢，这就是 <code>Assert.assertXXX</code> 的用途了，使用他来判断，测试运行的时候，完全可以当成放松自己的脑袋。当所有测试用例慢慢的一个一个通过的时候，全部绿色，那就皆大欢喜了，有红色了，一个一个来修正然后重复运行。直到所有测试用例通过。说实在的，我很享受全部绿色给我的那种激励感，完全可以让我更有信心的去做另外一个任务了。</p>
<h4 id="4）测试接口层"><a href="#4）测试接口层" class="headerlink" title="4）测试接口层"></a>4）测试接口层</h4><p>老实讲，我很少测试接口层，因为公司的需求就是只要请求到达我们的服务的时候，都是需要返回 <code>200</code> 状态码的，那么这个时候，运行测试用例来测试控制器层，对于我来说只会加大我的判断力度，我需要拿到结果再去判断我们的业务代码，所以显得有点多余了。 那么如果你们公司使用的是 <code>RESTful</code> 规范的时候，那么恭喜你，这个测试你完全可以写的很舒适。我就简单演示一下接口层的测试吧。 因为只是简单的演示项目，所以测试接口显得有点吃力。比如，查找不到数据的时候应该返回 <code>404</code> 但是我这里没做接口层的监听，所以根本做不了。按照现在来看，接口层的测试一般是测试状态码是否正常返回，以及数据是否正常的返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserEndpointTest</span> <span class="keyword">extends</span> <span class="title class_">BaseTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findById</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">UserDo</span> <span class="variable">userDo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDo</span>();</span><br><span class="line">        userDo.setUuid(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        userDo.setName(<span class="string">&quot;Adan&quot;</span>);</span><br><span class="line">        userService.create(userDo);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">&quot;/1&quot;</span>)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andExpect(mvcResult -&gt; &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">contentAsString</span> <span class="operator">=</span> mvcResult.getResponse().getContentAsString();</span><br><span class="line">                    <span class="type">UserDo</span> <span class="variable">respUserDo</span> <span class="operator">=</span> mapper.readValue(contentAsString, UserDo.class);</span><br><span class="line">                    assertNotNull(<span class="string">&quot;用户信息不能为空&quot;</span>, respUserDo);</span><br><span class="line">                &#125;)</span><br><span class="line">                .andDo(MockMvcResultHandlers.print());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>编写项目的代码的同时，可以结合测试驱动开发编写代码，先写测试用例再写代码体，逐步让测试用例通过，这时候测试用例将变得很强大还完善，代码也不会再是孤单存在着。测试用例完善了，重构起来就显得特别方便。 在我心中完整的测试应该是项目中分层，每一层都有自己独特的测试用例，下层暴露给上层接口，这时候接口都是被测试过的，所以不害怕被调用。但是可能因为项目开发的时间并不多，所以我使用起来还是蛮吃力的。只能在业务层上做测试。不过按照日常贫血性开发，下一层也并没有东西可以测试了，项目最主要的逻辑都落在了业务层，所以好像并没有什么毛病。</p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>junit</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 spring-boot</title>
    <url>//spring/%E4%BB%80%E4%B9%88%E6%98%AF-spring-boot/index.html</url>
    <content><![CDATA[<h1 id="什么是-spring-boot"><a href="#什么是-spring-boot" class="headerlink" title="什么是 spring-boot"></a>什么是 <code>spring-boot</code></h1><p>[toc]</p>
<h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>用了一年多的 <code>spring-boot</code> 进行项目开发了，我想我有必要把平时开发遇到的，我自己个人在项目中要求 <code>spring-boot</code> 做到的整理成一份主题博客。一来整理一下用了 <code>spring-boot</code> 这么久以来的收获，二来也好给自己有个知识的重新整理和归纳。</p>
<a id="more"></a>
<h2 id="二-spring-boot-介绍"><a href="#二-spring-boot-介绍" class="headerlink" title="二. spring-boot 介绍"></a>二. spring-boot 介绍</h2><p>讲真，项目还在用 <code>spring</code> 的时候，听说别人在用 <code>spring-boot</code> 感觉，哇塞，好高大上的样子。于是乎我就去百度了解一圈，查了一下相关资料，按照我印象中来说：<code>spring-boot</code> 就是官方为了解决经常在项目中整合第三方中间件的时候，需要配置一堆 <code>xml</code> 的麻烦，开发出来的，通过非常简单的依赖和配置，从而完成与第三方中间件的整合，也可以解决常常因为版本的不兼容导致项目的出错，也可以减轻项目开发中对 <code>spring</code> 的重量级配置（这句话我下面会反驳）。</p>
<!-- more -->
<h2 id="三-spring-boot-是否真的轻量级？"><a href="#三-spring-boot-是否真的轻量级？" class="headerlink" title="三. spring-boot 是否真的轻量级？"></a>三. <code>spring-boot</code> 是否真的轻量级？</h2><p>答案：<strong>否</strong>（对上一节中最后一句话的回答） 通过使用我发现几点：</p>
<ol>
<li><p>需要依赖第三方的时候，常常是官方会提供一个 <code>starter</code> 相关的整合包，放于 <code>mvn</code> 中。打开 <code>mvn</code> 的依赖其实可以发现，其实就是通过 <code>mvn</code> 的级联依赖的特性，以前该依赖进来的，还是会依赖进来；</p>
</li>
<li><p>配置是 <code>yml</code> 文件，通过定义一些前缀，然后到里面的属性，只需要短短几行代码就可以启动运行了，因为大部分配置，都有<strong>默认</strong>的配置</p>
</li>
</ol>
<p>而做这几件事情的，就是依赖的对应的第三方插件提供的 <code>starter</code></p>
<h2 id="四-什么是-starter"><a href="#四-什么是-starter" class="headerlink" title="四. 什么是 starter"></a>四. 什么是 <code>starter</code></h2><p>概括一下：<code>starter</code> 就是中间件官方根据 <code>spring-boot</code> 提供的一系列接口，让中间件官方可以在这个 <code>starter</code> 里面去定义初始化的流程，包括读取的配置以及依赖的第三方 <code>jar</code> 包，以便让使用者可以通过简单的配置，就可以整合第三方中间件。 <code>mvn</code> 的 <code>starter</code> 依赖示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span></span><br><span class="line">   <span class="string">&lt;!--</span> <span class="string">&lt;version&gt;1.1.1&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从下图可以看到，<code>mybatis</code> 官方提供的 <code>starter</code> 里面的东西其实看起来都是那么熟悉。 </p>
<p><img src="/images/%E4%BB%80%E4%B9%88%E6%98%AF-spring-boot.md/0.png"></p>
<h2 id="五-构建"><a href="#五-构建" class="headerlink" title="五. 构建"></a>五. 构建</h2><p><code>spring</code> 官方提供了几个构建方式：</p>
<ul>
<li>  可以直接从官网定制下载已经构建好的包 <a href="/images/%E4%BB%80%E4%B9%88%E6%98%AF-spring-boot.md/1.io/">spring 脚手架</a></li>
</ul>
<p><img src="/images/%E4%BB%80%E4%B9%88%E6%98%AF-spring-boot.md/2.png" alt="spring-initial"></p>
<ul>
<li>  <code>idea</code> 提供的构建方式（数据是从上面接口读取的，所以属性什么的基本一样）</li>
</ul>
<p><img src="/images/%E4%BB%80%E4%B9%88%E6%98%AF-spring-boot.md/3.png"></p>
<ul>
<li>  <code>eclipse</code> 搭载 <code>spring</code> 提供的 <code>spring tool suite</code></li>
<li>  手写 <code>mvn</code> 的 <code>pom</code> 搭建（推荐）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;cn.liweidan.springboot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-tutorial&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- 导入官方的 spring-boot 父类作为依赖 --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>一般来说，我们项目都需要有自己的父类，这时候又要使用 <code>spring-boot</code> 官方的父类，只需要把他的导进来即可，这样子项目就都可以使用 <code>spring-boot</code> 的相关组件了。</p>
<blockquote>
<p>接下来的所有项目我将在这个父级下进行构建</p>
</blockquote>
<h2 id="六-参考资料"><a href="#六-参考资料" class="headerlink" title="六. 参考资料"></a>六. 参考资料</h2><p>感谢各位大佬的付出 <a href="http://www.ityouknow.com/spring-boot.html">纯洁的微笑 – springboot</a> <a href="https://blog.battcn.com/categories/SpringBoot/">唐亚峰 – spring-boot</a></p>
]]></content>
      <categories>
        <category>技能</category>
        <category>Java</category>
        <category>Spring</category>
      </categories>
  </entry>
</search>
