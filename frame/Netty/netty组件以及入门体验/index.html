<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Netty组件以及入门体验 - 丹崽的技术博客
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 5.2.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>丹崽的技术博客</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <ul>
<li><a href="/">Home</a></li>
</ul>
<h1 id="计算机碎碎念"><a href="#计算机碎碎念" class="headerlink" title="计算机碎碎念"></a>计算机碎碎念</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li><a href="/Computer/Network/1-Find-Computer-Network/">生活中的网络</a></li>
<li><a href="/Computer/Network/2-TCP-IP-PROTOCOL/">TCP/IP之数据链路层</a></li>
<li><a href="/Computer/Network/3-IP/">TCP/IP之网络层IP协议</a></li>
<li><a href="/Computer/Network/4-TCP-UDP/">TCP/IP之传输层TCP/UDP协议</a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h2 id="零-Netty"><a href="#零-Netty" class="headerlink" title="零.Netty"></a>零.Netty</h2><p>其实了解到 <code>Netty</code> 已经很久了，一直想用，但是因为之前的水平还不够格，回调事件 <code>TCP</code> 什么的还没感觉，所以学起来一头雾水，加上官网的文档，哎呀，官网貌似就没有文档只有示例代码，读不懂。 写了挺多的回调函数，渐渐地有了感觉（通常使用 <code>CompleteFuture</code> 来请求其他服务的数据信息，请求完在执行自己的业务）。其实我也不知道我做了什么，貌似什么没做就突然融会贯通了，所以我感觉理解回调还是蛮重要的一点吧。 突然看到自己的书本库有本书《Netty实战》翻起来阅读，还是蛮好的，这篇文章其实是我读这本书，加上自己的一些理解写出来的。 <code>Netty</code> 是什么应该没人不会知道吧，就是 <code>Java</code> 行业中一个能够顶级处理网络通讯的轻量级框架，如果公司在使用 <code>Dubbo</code> 或者 <code>Thrift</code> 的话，那么也是间接在使用 <code>Netty</code> 框架了。所以学一学无伤大雅还可以了解一些很有趣的东西。</p>
<h2 id="一-Netty服务端"><a href="#一-Netty服务端" class="headerlink" title="一.Netty服务端"></a>一.Netty服务端</h2><p>所有 <code>Netty服务器</code> 通常需要以下两部分：</p>
<ol>
<li>至少一个 <code>ChannelHandler</code> 来接手客户端的数据以及处理数据；</li>
<li>引导服务器启动的配置，配置启动参数，这个就没啥好说的了。</li>
</ol>
<p><code>ChannelHandler</code> 是 <code>Netty</code> 中一个接口族的父接口，它主要负责接收和响应事件通知。 在 <code>Netty</code> 中 <code>ChannelHandler</code> 有很多默认实现，用来处理服务器中常见的数据传输问题。 因为服务器会响应传入的消息，所以需要实现 <code>ChannelInboundHandler</code> 接口，用来定义响应入站事件的方法。由于刚开始的程序只需要简单的方式即可，所以我们实现 <code>ChannelInboundHandlerAdapter</code> 即可，他提供了 <code>ChannelInboundHandler</code> 接口的默认实现。 我现在想要简单的实现一个服务，就是能够把把我发送的字符串，给反转过来，即发送 <code>abc</code> 服务器给我响应 <code>cba</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转服务器的处理逻辑类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringReverseHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(<span class="string">&quot;Server Receive Message: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    String newMsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] strings = message.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      newMsg += strings[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用工具类构建 ByteBuf 对象写出去 */</span></span><br><span class="line">    ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes());</span><br><span class="line">    ctx.writeAndFlush(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要编写服务的引导类，这个引导类主要实现两大功能：</p>
<ol>
<li>绑定哪个端口；</li>
<li>绑定上面写的 <code>Handler</code> 实现业务处理.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoop;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> StringReverseHandler handler = <span class="keyword">new</span> StringReverseHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此服务端任务就完成了，这时候只要启动服务端，等待客户端的介入即可处理业务。</p>
<h2 id="二-Netty客户端"><a href="#二-Netty客户端" class="headerlink" title="二.Netty客户端"></a>二.Netty客户端</h2><p>同上，所有的 <code>Netty客户端</code> 基本也是跟服务端差不多的事情：</p>
<ol>
<li>连接服务端；</li>
<li>发送消息；</li>
<li>获取服务端处理的结果；</li>
<li>关闭连接.</li>
</ol>
<p>同服务端处理一致，客户端也拥有一个 <code>ChannelInboundHandler</code> 来处理我们需要请求的业务。我们暂时可以使用 <code>SimpleChannelInboundHandler</code> 来执行我们必须的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.deploy.net.CrossDomainXML;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 服务端发送消息后执行的逻辑，直接打印 */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Client Receive Message: &quot;</span> + byteBuf.toString(Charset.defaultCharset()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们需要实现客户端的启动器，除了客户端需要使用 <code>OIO</code> 传输以外，其他需要做的事情基本是一致的。</p>
<h2 id="三-运行服务端和客户端"><a href="#三-运行服务端和客户端" class="headerlink" title="三.运行服务端和客户端"></a>三.运行服务端和客户端</h2><img src="/frame/Netty/netty%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/SimpleNettyDemoTest.gif" class=""> 

<p>OK，我们分别启动 <code>服务端</code> 和 <code>客户端</code>，可见 <code>客户端</code> 在连接完成的时候，像 <code>服务端</code> 发送了 <code>HelloWorld</code>，服务端处理完成后，客户端即接收到 <code>Client Receive Message: dlroWolleH</code></p>
<h2 id="三-Netty组件"><a href="#三-Netty组件" class="headerlink" title="三.Netty组件"></a>三.Netty组件</h2><p>OK，硬着头皮写到这里，项目也运行还算正常，感觉还不错。那么接下来就需要来了解一下各个组件了。</p>
<h3 id="3-1-Netty主要组件"><a href="#3-1-Netty主要组件" class="headerlink" title="3.1 Netty主要组件"></a>3.1 Netty主要组件</h3><p>组件的顺序是从业务处理器，再到软件启动引导：</p>
<ol>
<li><code>ChannelHandler</code></li>
<li><code>EventLoopGroup</code></li>
<li><code>Channel</code></li>
<li><code>ServerBootstrap</code> 服务端启动类，而客户端使用的是 <code>Bootstrap</code></li>
<li><code>ChannelInitializer</code> 主要用来初始化注册安装 <code>ChannelHandler</code></li>
<li><code>ChannelPipeline</code> 存放 <code>ChannelHandler</code> 的链表容器</li>
</ol>
<p>而下面的顺序则没有按照上面的顺序，因为我想从里面了解到外面，里面相对看起来比较简单。</p>
<h3 id="3-2-ChannelHandler和ChannelPipeline"><a href="#3-2-ChannelHandler和ChannelPipeline" class="headerlink" title="3.2 ChannelHandler和ChannelPipeline"></a>3.2 ChannelHandler和ChannelPipeline</h3><h4 id="3-2-1-ChannelHandler"><a href="#3-2-1-ChannelHandler" class="headerlink" title="3.2.1 ChannelHandler"></a>3.2.1 ChannelHandler</h4><p>从上面的例子上可以看到，我们在服务端使用了继承 <code>ChannelHandler</code> 的方式去做业务逻辑，其实这块一般也是业务的重要地方，需要做什么处理，然后写出什么数据，跟 <code>Controller</code> 的作用相同。 在上面的服务端例子中，业务处理通过继承 <code>ChannelInboundHandlerAdapter</code>（是一个 <code>ChannelHandler</code> 的子类，下面说） 的方式来处理，它的作用是：</p>
<ol>
<li>接收入站事件和数据；</li>
<li>处理完以后，冲刷数据到客户端；</li>
<li>可以关闭连接的方式来结束客户端的连接。</li>
</ol>
<p>通常来说，一个项目会有多个 <code>ChannelInboundHandler</code> 在运行着，处理着业务数据。</p>
<h4 id="3-2-1-ChannelPipeline"><a href="#3-2-1-ChannelPipeline" class="headerlink" title="3.2.1 ChannelPipeline"></a>3.2.1 ChannelPipeline</h4><p>在服务端和客户端都可以看到 <code>socketChannel.pipeline().addLast(new RequestHandler())</code> 这段代码，那么根据编码经验来说，他应该是个容器。 没错，他还真的是一个容器，一个链表容器，里面装着一个一个的 <code>ChannelHandler</code> 。 具体过程是：</p>
<ol>
<li>启动的时候定义 <code>ChannelInitializer</code>，他将在 <code>Bootstrap</code> 或者 <code>ServerBootstrap</code> 启动的时候进行初始化操作；</li>
<li>当 <code>initChannel</code> 被调用的时候，我们即可安装我们自己的 <code>ChannelHandler</code> 实现，来处理数据传输；</li>
<li><code>ChannelInitializer</code> 将自己从 <code>ChannelPipeline</code> 中移除。</li>
</ol>
<p><code>ChannelHandler</code> 以及子类：</p>
<p>21901</p>
<p>21969</p>
<p>数据入站的时候，将按照安装的顺序，依次执行 <code>ChannelInboundHandler</code> 中的逻辑，其实说到底就是处理链吧，当数据到达 <code>Pipeline</code> 尾端的时候，表示数据处理已经结束。 数据的出站运动（正在被写的数据）则是从 <code>Pipeline</code> 末端开始执行，与 <code>ChannelInboundHandler</code> 执行顺序相反的情况下依次处理。</p>
<blockquote>
<p>Netty 中 提供了 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 两个适配类，其实这两个类就是已经解决了简单顺序传值的问题，Netty 会简单的帮你按照上面的顺序执行 ChannelHandler 我们只需要覆写与业务相关的处理即可。所以如果我们只是想简单的传递的话可以直接使用这两个类。</p>
</blockquote>
<p>在覆写我们感兴趣的函数的时候，通常都可以看到有一个 <code>ChannelHandlerContext</code> 而且示例中也是使用他来写出消息的，除了这种方法写出消息，还有另外一种方法就是使用 <code>Channel</code> 写出（调用：<code>ctx.channel().writeAndFlush()</code>）。前者写出会将消息写到下一个 <code>ChannelHandler</code> 而后者则是让消息从上图中的 <code>ChannelPipeline</code> 末端开始走（与上面区别就是跳过下一个 <code>ChannelInboundHandler</code>）</p>
<h3 id="3-3-Channel和EventLoop"><a href="#3-3-Channel和EventLoop" class="headerlink" title="3.3 Channel和EventLoop"></a>3.3 Channel和EventLoop</h3><h4 id="3-3-1-Channel"><a href="#3-3-1-Channel" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h4><h5 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h5><p>说到 <code>Channel</code> 就要说到 <code>Java NIO</code> ，说到 <code>NIO</code> 就要说到 <code>Selector</code> 和 <code>Socket</code>。 说到 <code>NIO</code> 就要先说说这个有趣的名字~</p>
<blockquote>
<p>NIO 刚开始我感觉就是 New IO，可是这么多年过去了，再叫 New IO 就有点不合适了。 所以现在大多数人认为应该叫 Non-blocking IO，而阻塞IO则是 block IO 或者 old IO (BIO/OIO)</p>
</blockquote>
<p>其实聊到 <code>NIO</code> 就应该是，传统的 <code>IO</code> 如果同时执行同一个业务的话，而且想要多人都可以同时并行处理的话，那么就需要开启多个线程来同时执行。 </p>
<p>23002 </p>
<p>那么每一个新的客户端进来，我就需要预留一个线程来处理，线程中 <code>BIO</code> 在读取文件或者其他 <code>IO</code> 输入的时候，需要阻塞进入等待，这都算是一种资源浪费（CPU还需要切换线程去查看哪个线程已经阻塞完成了）。据我们所知，一个线程占用栈空间 <code>64k</code> - <code>1m</code>，理论线程越多每个线程拿到的栈空间就更少了。这时候线程他就在那里等待了什么事情都不做，然后还占用了系统上一个线程的位置（系统限制可开启线程数）。如果小数量的线程数（用户数）那么勉强还是撑得过去的，而且工作的也还不错。那么如果上万个用户上十万个用户呢，这时候，<code>CPU</code> 需要浪费很大的力气来切换轮询。 于是乎这时候，<code>NIO</code> 横空出世（其实系统早就支持了，在 <code>jdk1.4</code> 之前都没有支持） <code>NIO</code> 有个很牛逼的管理员 <code>Selector</code>，他的任务就是提交 <code>IO</code> 任务并且告诉系统，他做完了告诉我，我会执行下一步操作。于是乎模型就编程这样：</p>
<p> 23484 </p>
<p>这个模型只要一个线程就够了，他找 <code>Selector</code> 要已经完成 <code>IO</code> 操作的名单，然后放到自己的线程开始执行我们的业务逻辑，如果没有 <code>IO</code> 那么这个线程还可以去做其他的事情。</p>
<h5 id="Netty中的Channel"><a href="#Netty中的Channel" class="headerlink" title="Netty中的Channel"></a>Netty中的Channel</h5><p>在 <code>Netty</code> 中，一个 <code>Channel</code> 代表一个实体（硬件设备，文件，Socket，能够执行一个或不同 <code>IO</code> 操作的程序组件）的连接。这里可以套用 <code>Linux</code> 中万物皆文件的理念，只要是一个物，他就有输入输出，那么她就是 <code>Channel</code>。 而 <code>Channel</code> 中我们实现了他的一些方法如 <code>channelRead</code> <code>channelReadComplete</code>，其实这些是回调事件，我们也可以称实现这些动作是实现回调事件。那么啥是回调事件：</p>
<blockquote>
<p>某件事情执行时间很长，你让他执行完告诉你你去接收他的参数并且接下去做。 比如洗衣服，你扔进洗衣机，洗衣机一般要洗1个小时，洗完了发出滴滴滴的声音。这就是回调了，在这1个小时里面你这个线程就可以去做其他事情，他滴滴滴响了你拿到了结果（衣服洗完了）再去执行一个函数：晾衣服。</p>
</blockquote>
<p>如果你熟悉 <code>JavaScript</code> 那么这一切都很自然，异步请求 <code>Promise</code> 类，<code>Promise.then((result) =&gt; &#123;...&#125;)</code> 里面的 <code>function</code> 她就是回调函数。 <code>jdk8</code> 中提供了很好的回调事件方式的线程类 <code>CompleteFuture</code> 就是用来做这个事情的，你可以使用这个类来体验一下回调事件的感受。（参考文章：<a target="_blank" rel="noopener" href="https://liweidan.cn/java/jdk8/2017/10/25/141/">jdk8 多线程处理的使用</a>） 而 <code>Netty</code> 时代 <code>jdk</code> 还没有到 <code>j8</code> 呀，只提供了 <code>CompleteFuture</code> 的爸爸 <code>Future</code>，那怎么办嘛，<code>Netty</code> 就自己写提个，这就是 <code>ChannelFuture</code> 的出现了。<code>ChannelFuture</code> 也提供了可以自定义的 <code>ChannelFutureListener</code> 来拓展，可以说比 <code>jdk8</code> 的 <code>CompleteFuture</code> 还厉害，可以监听连接完成时做什么（比如检查连接是否正常，远程服务是否能够正确返回信息）。只需要在引导代码里面，使用 <code>ChannelFuture.addListener</code> 即可添加相对应的逻辑。这么说的话，那么 <code>ChannelFutureListener</code> 就是 <code>Future</code> 生命周期中执行的钩子函数。</p>
<h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2>
</div>




<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="W"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>Weidan</div>
      <div>2019-07-18</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/frame/">frame</a> <a class="category-link" href="/categories/frame/Netty/">Netty</a>

      <a class="tag-none-link" href="/tags/Channel/" rel="tag">#Channel</a> <a class="tag-none-link" href="/tags/ChannelHandler/" rel="tag">#ChannelHandler</a> <a class="tag-none-link" href="/tags/NIO/" rel="tag">#NIO</a> <a class="tag-none-link" href="/tags/Netty/" rel="tag">#Netty</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
