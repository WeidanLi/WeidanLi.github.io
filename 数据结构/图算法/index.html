<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="codeva-18Edjlpyk5">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"weidanli.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="图的介绍怎么说呢，通过前两篇的编写，我发现学数据结构真的是从一个有序，再到另外一个有序，最后到一个杂乱的东西。那么回想一下，我们在写代码的时候，刚开始，代码是井然有序的，然后慢慢的随着功能的新增，产品经理的无理，我们的项目就会慢慢的变成一碗意大利面（用白话说就是 屎💩）当然，目前知道了图的概念以后，我发现，一碗 屎💩 还有点用处，就是可以研究我们接下来要说的数据结构：图。 大概我们把之前说到的">
<meta property="og:type" content="article">
<meta property="og:title" content="图算法">
<meta property="og:url" content="http://weidanli.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="丹崽的技术博客">
<meta property="og:description" content="图的介绍怎么说呢，通过前两篇的编写，我发现学数据结构真的是从一个有序，再到另外一个有序，最后到一个杂乱的东西。那么回想一下，我们在写代码的时候，刚开始，代码是井然有序的，然后慢慢的随着功能的新增，产品经理的无理，我们的项目就会慢慢的变成一碗意大利面（用白话说就是 屎💩）当然，目前知道了图的概念以后，我发现，一碗 屎💩 还有点用处，就是可以研究我们接下来要说的数据结构：图。 大概我们把之前说到的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151557.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151612.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151633.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151646.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151655.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151706.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151727.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151748.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151809.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151836.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151906.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151932.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151950.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152017.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152043.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152107.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152120.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152141.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152241.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152300.jpeg">
<meta property="article:published_time" content="2020-07-23T09:30:09.000Z">
<meta property="article:modified_time" content="2023-01-27T12:02:55.562Z">
<meta property="article:author" content="Weidan">
<meta property="article:tag" content="图">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151557.jpeg">


<link rel="canonical" href="http://weidanli.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%AE%97%E6%B3%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"http://weidanli.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%AE%97%E6%B3%95/","path":"数据结构/图算法/","title":"图算法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>图算法 | 丹崽的技术博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">丹崽的技术博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">丹崽的计算机知识博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section">分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section">归档</a></li>
        <li class="menu-item menu-item-数据结构"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="section">数据结构</a></li>
        <li class="menu-item menu-item-spring源码"><a href="/spring-sources/" rel="section">Spring源码</a></li>
        <li class="menu-item menu-item-mysql底层"><a href="/mysql/" rel="section">MySQL底层</a></li>
        <li class="menu-item menu-item-tomcat源码"><a href="/tomcat-sources/" rel="section">Tomcat源码</a></li>
        <li class="menu-item menu-item-计算机网络"><a href="/network/" rel="section">计算机网络</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">图的介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">图的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97"><span class="nav-number">4.</span> <span class="nav-text">森林</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A0%91%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">生成树森林算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-number">6.</span> <span class="nav-text">无向图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.</span> <span class="nav-text">图的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E6%90%9C%E7%B4%A2"><span class="nav-number">6.2.</span> <span class="nav-text">图搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.</span> <span class="nav-text">深度优先搜索实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.4.</span> <span class="nav-text">广度优先搜索实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">图相关基础问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="nav-number">7.1.</span> <span class="nav-text">连通分量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%BF%9E%E9%80%9A%E8%B7%AF%E5%BE%84"><span class="nav-number">7.2.</span> <span class="nav-text">最短连通路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">有向图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.1.</span> <span class="nav-text">有向图的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="nav-number">8.2.</span> <span class="nav-text">可达性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%92%8C%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF"><span class="nav-number">8.3.</span> <span class="nav-text">环和有向无环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">8.4.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="nav-number">8.5.</span> <span class="nav-text">强连通性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E6%9D%83%E5%9B%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">9.</span> <span class="nav-text">加权图和最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%9D%83%E5%9B%BE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">9.1.</span> <span class="nav-text">加权图的数据结构表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="nav-number">9.2.</span> <span class="nav-text">最小生成树算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E5%92%8C%E6%9C%80%E7%9F%AD%E7%BA%BF%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="nav-number">10.</span> <span class="nav-text">加权有向图和最短线路问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">10.1.</span> <span class="nav-text">加权有向图数据结构表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">10.2.</span> <span class="nav-text">最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">10.3.</span> <span class="nav-text">加权有向无环图的最短路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E8%B4%9F%E6%9D%83%E9%87%8D%E7%9A%84%E6%9C%89%E5%90%91%E5%8A%A0%E6%9D%83%E5%9B%BE"><span class="nav-number">10.4.</span> <span class="nav-text">有负权重的有向加权图</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weidan</p>
  <div class="site-description" itemprop="description">计算机基础 计算机网络 Java Vue 前端 后端</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/WeidanLi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WeidanLi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:toweidan@126.com" title="E-Mail → mailto:toweidan@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/WeidanLi" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-23 17:30:09" itemprop="dateCreated datePublished" datetime="2020-07-23T17:30:09+08:00">2020-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-27 20:02:55" itemprop="dateModified" datetime="2023-01-27T20:02:55+08:00">2023-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>38 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="图的介绍"><a href="#图的介绍" class="headerlink" title="图的介绍"></a>图的介绍</h2><p>怎么说呢，通过前两篇的编写，我发现学数据结构真的是从一个有序，再到另外一个有序，最后到一个杂乱的东西。那么回想一下，我们在写代码的时候，刚开始，代码是井然有序的，然后慢慢的随着功能的新增，产品经理的无理，我们的项目就会慢慢的变成一碗意大利面（用白话说就是 <code>屎💩</code>）当然，目前知道了图的概念以后，我发现，一碗 <code>屎💩</code> 还有点用处，就是可以研究我们接下来要说的数据结构：<code>图</code>。 大概我们把之前说到的树，连多几条边，就可以感受到 <code>图</code> 了，不过，<code>查找树</code> 也是 <code>图</code>，<code>链表</code> <code>数组</code> 均为图，只不过因为他们的性质让我们利用起来做一些应用的时候会更加的方便，而且 <code>高效</code> <code>性价比高</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151557.jpeg"></p>
<a id="more"></a>
<p> 连上边，我们之前的 <code>节点</code>，变成了另外一个概念 <code>顶点</code>，而连接线则由另外一个名称：<code>边</code>。不过人类该死的视觉总是会产生差错，会误以为下面这幅 <code>图</code> 和上面这幅 <code>图</code> 表示的是不同的 <code>图</code>： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151612.jpeg"> </p>
<p>但其实，这两幅图是 <strong>一样的</strong>。为啥，因为 <code>顶点</code> 一样，<code>顶点之间</code> 的连接情况也一样，所以这两幅图是相等的（<code>WPS</code> 真好用，拖动节点的时候，会自动的把 <code>边</code> 给带上hhhhh）。</p>
<h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><p>那是因为无聊才提出这个概念吗，不是，我们研究地图，美团外卖小哥送外卖，滴滴打车的时候都需要用到 <code>图</code> 这个概念来计算最短的线路，或者编译我们写的 <code>屎山</code> 的时候，编译器需要用他来规划我们的模块之间、类之间的联系，甚至是 <code>Java</code> 的 <code>JVM虚拟机</code>，也需要用到 <code>图</code> 来 <code>标记-清除</code> 系统产生的垃圾。 而且前面学的 <code>数组</code> 呀 <code>二叉树</code> 呀都可以使用 <code>图</code> 这个结构来做，但是没必要。毕竟在我们程序这个 <code>“1D”</code> 的东西里面，表示一幅 <code>图</code>，还是需要额外的空间的，不如直接使用 <code>数组</code> 或者 <code>链表</code> 表示来得实在。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>如果一幅图 <code>G</code>，含有 <code>V</code> 个顶点，而 <code>V-1</code> 条边不含有 <code>环</code> 切相互连通，并且任意一对顶点之间只存在一条连通的路径，我们可以称 <code>图</code> 为 一棵 <code>树</code>。并且 <code>树</code> 中任意新增一条 <code>边</code> 都会产生 <code>环</code>，任意删除一条 <code>边</code> 都会得到两棵独立的 <code>树</code>。 我们先来看看 <code>环</code> 的定义： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151633.jpeg"> 如图，黄色部分组成一个 <code>环</code>。 而 <code>树</code> 是没有 <code>环</code> 的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151646.jpeg"> 如上图所示，<code>12</code> 个顶点，含有 <code>11</code> 条边，每个顶点相互连通，增删任意一条边都会使这棵 <code>树</code> 变为 <code>图</code>。</p>
<h2 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h2><p><code>树</code> 多了就是 <code>森林</code>： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151655.jpeg"> 如 <code>图</code>，两棵 <code>树</code> 组成一篇 <code>森林</code>。</p>
<h2 id="生成树森林算法"><a href="#生成树森林算法" class="headerlink" title="生成树森林算法"></a>生成树森林算法</h2><p>那结合应用，我们要在一个 <code>图</code> 里面 <code>规划</code> 最短路径的 <code>树</code>，实际应用大概就是 <code>地图</code> 寻找最短线路的应用了吧，所以我们就需要在一个 <code>图</code> 里面去查找 <code>线路</code>，而 <code>线路</code> 连接起来，刚好就是一个 <code>树</code>： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151706.jpeg"> </p>
<p>如图，在一个 <code>图</code> 里面查找顶点之间，然后连接边使其生成一棵 <code>树</code>，称之为 <code>生成树森林算法</code>。</p>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><h3 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151727.jpeg"></p>
<p> <code>无向图</code> 比较简单，所以我们先来说说 <code>无向图</code> 吧，首先，我们得考虑一下，怎么样才能把上面这幅图（为了方便我改成 <code>0-11</code> 的数字了）给初始化到内存中去，可是内存中貌似只有 <code>数组</code> 这种结构比较好用了，所以肯定是数组啦，但是怎么表示还是个问题，我们的程序一般都要求要又快又省空间，所以我们有几个方案，<code>矩阵</code>（类似于一个正方形的数组，如果两个边连接，我们就在 <code>array[x][y]</code> 做一个标记，一般用 <code>bool</code> 表示），不过当顶点几百上千万的时候，就跟捉鸡了；<code>Edge</code> 集合，但是我们查找边的时候，每次总是需要遍历整个 <code>Edge</code> 集合，也显得不好；第三个方案就是 <code>动静结合</code> 了，初始化一个 <code>V个顶点</code> 的数组，而数组里边的数组是一个可拓展性的数组，这样我们只需要记录当前这个 <code>顶点</code> 和 <code>另外一个顶点</code> 连接的情况就可以了，大概就会变成下面这个样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0 -&gt; [1,2,3,4]</span><br><span class="line">1 -&gt; [0,8]</span><br><span class="line">2 -&gt; [0,3,5]</span><br><span class="line">3 -&gt; [0,2,6,10]</span><br><span class="line">4 -&gt; [0,7,8]</span><br><span class="line">5 -&gt; [2,6]</span><br><span class="line">6 -&gt; [5,9,3,10]</span><br><span class="line">7 -&gt; [4]</span><br><span class="line">8 -&gt; [1,4]</span><br><span class="line">9 -&gt; [6]</span><br><span class="line">10 -&gt; [3,6,11]</span><br><span class="line">11 -&gt; [10]</span><br></pre></td></tr></table></figure>
<p>所以我们就可以来写代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 顶点的数目</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> V;</span><br><span class="line">  <span class="comment">// 边的数目</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">  <span class="comment">// 记录连接情况；</span></span><br><span class="line">  List&lt;Integer&gt;[] lists;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    V = v;</span><br><span class="line">    E = <span class="number">0</span>;</span><br><span class="line">    lists = (List&lt;Integer&gt;[]) <span class="keyword">new</span> <span class="title class_">ArrayList</span>[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">      lists[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常量级</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> V;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 常量级</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 常量级</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">    lists[v].add(w);</span><br><span class="line">    lists[w].add(v);</span><br><span class="line">    E++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个顶点所有连接的另外一个顶点</span></span><br><span class="line">  <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lists[e];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以把我们的图给输入进去，等我一下，我写个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 所有连接线</span></span><br><span class="line">    String[] line = &#123;</span><br><span class="line">        <span class="string">&quot;0-1&quot;</span>, <span class="string">&quot;0-2&quot;</span>, <span class="string">&quot;0-3&quot;</span>, <span class="string">&quot;0-4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-8&quot;</span>, <span class="string">&quot;2-3&quot;</span>, <span class="string">&quot;2-5&quot;</span>, <span class="string">&quot;3-6&quot;</span>, <span class="string">&quot;3-10&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-8&quot;</span>, <span class="string">&quot;4-7&quot;</span>, <span class="string">&quot;5-6&quot;</span>, <span class="string">&quot;6-9&quot;</span>, <span class="string">&quot;6-10&quot;</span>, <span class="string">&quot;10-11&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图用例</span></span><br><span class="line">    <span class="type">Graph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _l : line) &#123;</span><br><span class="line">      String[] split = _l.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      g.addEdge(Integer.parseInt(split[<span class="number">0</span>]), Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：[0, 8, 7]</span></span><br><span class="line">    System.out.println(g.adj(<span class="number">4</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="图搜索"><a href="#图搜索" class="headerlink" title="图搜索"></a>图搜索</h3><p>那么有图了，就应该用他来做点什么事情了，假设上面那个图，每个顶点是一个城市，我们自然就会想找出 <code>城市0</code> 到 <code>城市11</code> 的有哪些走法，哪种走法最快。所以这时候就出现了 <code>图搜索</code> 的问题了。搜索的方式也有两种，我重新放一下这幅图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151748.jpeg"> </p>
<p>图涉及的搜索方式有两种：<code>深度优先遍历（dfs -- Deep First Search）</code> 和 <code>广度优先遍历（bfs -- Breadth First Search）</code>，两种搜索遍历的方式不相同：</p>
<ol>
<li> 深度优先遍历：顾名思义，深度优先，也就是我从起点出发，从邻近第一个点开始，继续查找接下来的这个顶点，直到查找到的顶点都已经被标记走过了，才回退回来，继续第二个邻近的顶点，比如 <code>0</code> 找到 <code>1</code> 这个顶点，而 <code>1</code> 与 <code>[0, 8]</code> 相邻，<code>0</code> 是进来的点已经被标记过了，所以再走到 <code>顶点8</code>，<code>顶点8</code> 再走到 <code>顶点4</code>，而 <code>顶点4</code> 邻接顶点只有 <code>顶点7</code> 还没标记，<code>顶点7</code> 就是极限了，这时候要回退到 <code>顶点4</code>，<code>顶点4</code> 也没有未标记的顶点，再回退到 <code>顶点8</code>，再退 <code>顶点1</code>，然后再按照上面的思路开始遍历 <code>顶点2</code> 以及 <code>顶点2的邻接顶点</code>，也就是我们的指针只有走到底层无路可走才会回退继续遍历上一个顶点未标记的点。</li>
<li> 广度优先遍历：如果说深度是遍历到最深处无路可走的时候才返回的话，而广度则是一步一步推进的去遍历，我们先想象成多线程的情况，<code>顶点0</code> 开始，分裂出了 <code>3个线程：[顶点1、顶点2、顶点3]</code>，然后 <code>3个子线程</code> 再分别分裂其 <code>子线程</code>，类似于细胞分裂的情况，但是我们研究的时候肯定不会用这么高级的特性，所以我们需要一个数据结构：<code>队列</code>。首先，<code>顶点0</code> 开始，将 <code>[顶点1、顶点2、顶点3]</code> 推入队列中，然后 <code>顶点1</code> 出列并做标记，将其邻接未被标记的顶点：<code>[顶点8]</code> 推入队列，所以我们程序的遍历顺序将会变成 <code>顶点0、顶点1、顶点2、顶点3、顶点8（顶点1出列时标记）、顶点5（顶点2出列时标记）...</code>。</li>
</ol>
<p>搞两个动态图看看，不过因为大小限制我删除了右边的顶点 <code>orz</code> 深度优先搜索动图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151809.gif"> </p>
<p>广度优先搜索动图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151836.gif"></p>
<p>两个算法的应用场景：<code>广度优先搜索</code> 我们可以搜索两个点之间最短的距离（其实不然，但是可以先简单这么理解，经过哪几条线路最快到达，因为线路还带有距离的嘛，所以下面的加权才是真正的场景）而 <code>深度优先搜索</code> 呢，好像针对上面的问题没什么作为，但是如果读过 <code>Spring</code> 源码的话，就可以很简单的明白，依赖搜索我写的 <code>屎山</code> 的时候，用的恰恰好就是 <code>深度优先搜索</code>，找到最后一个没有依赖的开始向上初始化，直达所有的 <code>Bean</code> 都初始化好了，就可以开始工作了。</p>
<hr>
<h3 id="深度优先搜索实现"><a href="#深度优先搜索实现" class="headerlink" title="深度优先搜索实现"></a>深度优先搜索实现</h3><p>那么因为上面那张图，基本所有顶点都是连通的，为了测试，断开部分连接： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151906.jpeg"></p>
<p> 然后我们使用工具类的形式来做搜索：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DFS</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 有多少个顶点可达 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">/** 使用数组的下标表示顶点，记录哪些点被遍历过了 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DFS</span><span class="params">(Graph g, <span class="type">int</span> startPoint)</span> &#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    dfs(g, startPoint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 递归搜索，递归到最底层的时候才会返回来递归前一个顶点.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> g 图实例.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> startPoint 顶点.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Graph g, <span class="type">int</span> startPoint)</span> &#123;</span><br><span class="line">    marked[startPoint] = <span class="literal">true</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : g.adj(startPoint)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (marked[v]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 递归遍历底层的所有节点</span></span><br><span class="line">      dfs(g, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取有多少个与构造方法的起点关联的个数.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取所有可达的顶点.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] available() &#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.range(<span class="number">0</span>, marked.length)</span><br><span class="line">        .filter(i -&gt; marked[i])</span><br><span class="line">        .toArray();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 所有顶点</span></span><br><span class="line">    <span class="type">int</span>[] E = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">        <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">        <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 所有连接线</span></span><br><span class="line">    String[] line = &#123;</span><br><span class="line">        <span class="string">&quot;0-2&quot;</span>, <span class="string">&quot;0-3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-8&quot;</span>, <span class="string">&quot;2-3&quot;</span>, <span class="string">&quot;2-5&quot;</span>, <span class="string">&quot;3-6&quot;</span>, <span class="string">&quot;3-10&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-8&quot;</span>, <span class="string">&quot;4-7&quot;</span>, <span class="string">&quot;5-6&quot;</span>, <span class="string">&quot;6-9&quot;</span>, <span class="string">&quot;6-10&quot;</span>, <span class="string">&quot;10-11&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图用例</span></span><br><span class="line">    <span class="type">Graph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(E.length);</span><br><span class="line">    <span class="keyword">for</span> (String _l : line) &#123;</span><br><span class="line">      String[] split = _l.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      g.addEdge(Integer.parseInt(split[<span class="number">0</span>]), Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(g.adj(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">DFS</span> <span class="variable">dfs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DFS</span>(g, <span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;从顶点0出发，共有&quot;</span> + dfs.getCount() +</span><br><span class="line">        <span class="string">&quot;个顶点可达，分别有：&quot;</span> + Arrays.toString(dfs.available()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">从顶点<span class="number">0</span>出发，共有<span class="number">8</span>个顶点可达，分别有：[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>
<h3 id="广度优先搜索实现"><a href="#广度优先搜索实现" class="headerlink" title="广度优先搜索实现"></a>广度优先搜索实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BFS</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 有多少个顶点可达 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">/** 使用数组的下标表示顶点，记录哪些点被遍历过了 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BFS</span><span class="params">(Graph g, <span class="type">int</span> startPoint)</span> &#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    bfs(g, startPoint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 递归搜索，递归到最底层的时候才会返回来递归前一个顶点.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> g 图实例.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> startPoint 顶点.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Graph g, <span class="type">int</span> startPoint)</span> &#123;</span><br><span class="line">    <span class="comment">// 队列代替递归循环</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    marked[startPoint] = <span class="literal">true</span>;</span><br><span class="line">    q.add(startPoint);</span><br><span class="line">    count++; <span class="comment">// 标记第一个可达</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> q.poll();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> point : g.adj(first)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (marked[point]) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        marked[point] = <span class="literal">true</span>;</span><br><span class="line">        q.add(point);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取有多少个与构造方法的起点关联的个数.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span>[] available() &#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.range(<span class="number">0</span>, marked.length)</span><br><span class="line">        .filter(i -&gt; marked[i])</span><br><span class="line">        .toArray();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GraphApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 所有顶点</span></span><br><span class="line">    <span class="type">int</span>[] E = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">        <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">        <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 所有连接线</span></span><br><span class="line">    String[] line = &#123;</span><br><span class="line">        <span class="string">&quot;0-2&quot;</span>, <span class="string">&quot;0-3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-8&quot;</span>, <span class="string">&quot;2-3&quot;</span>, <span class="string">&quot;2-5&quot;</span>, <span class="string">&quot;3-6&quot;</span>, <span class="string">&quot;3-10&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-8&quot;</span>, <span class="string">&quot;4-7&quot;</span>, <span class="string">&quot;5-6&quot;</span>, <span class="string">&quot;6-9&quot;</span>, <span class="string">&quot;6-10&quot;</span>, <span class="string">&quot;10-11&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图用例</span></span><br><span class="line">    <span class="type">Graph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(E.length);</span><br><span class="line">    <span class="keyword">for</span> (String _l : line) &#123;</span><br><span class="line">      String[] split = _l.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      g.addEdge(Integer.parseInt(split[<span class="number">0</span>]), Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(g.adj(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">DFS</span> <span class="variable">dfs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DFS</span>(g, <span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;从顶点0出发，共有&quot;</span> + dfs.getCount() +</span><br><span class="line">        <span class="string">&quot;个顶点可达，分别有：&quot;</span> + Arrays.toString(dfs.available()));</span><br><span class="line"></span><br><span class="line">    <span class="type">BFS</span> <span class="variable">bfs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BFS</span>(g, <span class="number">0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;从顶点0出发，共有&quot;</span> + bfs.getCount() +</span><br><span class="line">        <span class="string">&quot;个顶点可达，分别有：&quot;</span> + Arrays.toString(bfs.available()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">[<span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">从顶点<span class="number">0</span>出发，共有<span class="number">8</span>个顶点可达，分别有：[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">从顶点<span class="number">0</span>出发，共有<span class="number">8</span>个顶点可达，分别有：[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="图相关基础问题"><a href="#图相关基础问题" class="headerlink" title="图相关基础问题"></a>图相关基础问题</h2><p>那么这些问题，我们都可以使用 <code>委托模式</code> 来做，将一个图交给委托者，让他来做计算。</p>
<h3 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h3><p>连通分量，我们可以简单的认为就是一个图，有多少个独立的连通，比如上图，很明显有2个，那么这个问题我们可以使用 <code>深度优先搜索</code> 来做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnGraphUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 连通分量计数器 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">/** 使用数组的下标表示顶点，记录哪些点被遍历过了 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ConnGraphUtil</span><span class="params">(Graph g, <span class="type">int</span> startPoint)</span> &#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    <span class="comment">// 修改为遍历所有的顶点，如果每次dfs搜索出来以后</span></span><br><span class="line">    <span class="comment">// 还有没有被记录的顶点，count加1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; g.V(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!marked[i]) &#123;</span><br><span class="line">        dfs(g, i);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Graph g, <span class="type">int</span> startPoint)</span> &#123;</span><br><span class="line">    marked[startPoint] = <span class="literal">true</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : g.adj(startPoint)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (marked[v]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 递归遍历底层的所有节点</span></span><br><span class="line">      dfs(g, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，我们使用深度，将会遍历所有顶点。如果搜索一次以后，还有的点没有被记录到，则我们记录的分量数 <code>加1</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">// 所有顶点</span></span><br><span class="line">  <span class="type">int</span>[] E = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">    <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 所有连接线</span></span><br><span class="line">  String[] line = &#123;</span><br><span class="line">    <span class="string">&quot;0-2&quot;</span>, <span class="string">&quot;0-3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;1-8&quot;</span>, <span class="string">&quot;2-3&quot;</span>, <span class="string">&quot;2-5&quot;</span>, <span class="string">&quot;3-6&quot;</span>, <span class="string">&quot;3-10&quot;</span>,</span><br><span class="line">    <span class="string">&quot;4-8&quot;</span>, <span class="string">&quot;4-7&quot;</span>, <span class="string">&quot;5-6&quot;</span>, <span class="string">&quot;6-9&quot;</span>, <span class="string">&quot;6-10&quot;</span>, <span class="string">&quot;10-11&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建图用例</span></span><br><span class="line">  <span class="type">Graph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(E.length);</span><br><span class="line">  <span class="keyword">for</span> (String _l : line) &#123;</span><br><span class="line">    String[] split = _l.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    g.addEdge(Integer.parseInt(split[<span class="number">0</span>]), Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;一共有&quot;</span> + <span class="keyword">new</span> <span class="title class_">ConnGraphUtil</span>(g).getCount() + <span class="string">&quot;个连通分量&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">一共有<span class="number">2</span>个连通分量</span><br></pre></td></tr></table></figure>
<p>我们可以使用这种模型，来查找一个网络中，有多少个局域网。</p>
<h3 id="最短连通路径"><a href="#最短连通路径" class="headerlink" title="最短连通路径"></a>最短连通路径</h3><p>而最短连通的路径中，则需要使用 <code>广度优先搜索</code> 来做，然后我们需要一个数组来保存 <code>连接的点-起点</code> 的数值 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortestGraphUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 使用数组的下标表示顶点，记录哪些点被遍历过了 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> endPoint;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> startPoint;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span>[] edgeTo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ShortestGraphUtil</span><span class="params">(Graph g, <span class="type">int</span> startPoint, <span class="type">int</span> endPoint)</span> &#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    edgeTo = <span class="keyword">new</span> <span class="title class_">int</span>[g.V()];</span><br><span class="line">    <span class="built_in">this</span>.endPoint = endPoint;</span><br><span class="line">    <span class="built_in">this</span>.startPoint = startPoint;</span><br><span class="line">    bfs(g, startPoint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 递归搜索，递归到最底层的时候才会返回来递归前一个顶点.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> g 图实例.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> startPoint 顶点.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Graph g, <span class="type">int</span> startPoint)</span> &#123;</span><br><span class="line">    <span class="comment">// 队列代替递归循环</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    marked[startPoint] = <span class="literal">true</span>;</span><br><span class="line">    q.add(startPoint);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">point</span> <span class="operator">=</span> q.poll();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> _point : g.adj(point)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (marked[_point]) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        marked[_point] = <span class="literal">true</span>;</span><br><span class="line">        q.add(_point);</span><br><span class="line">        <span class="comment">// 下标保存被连接的点的值，数组值保存上一个点的值</span></span><br><span class="line">        edgeTo[_point] = point;</span><br><span class="line">        <span class="keyword">if</span> (_point == endPoint) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">pathTo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用栈反过来查找edgeTo</span></span><br><span class="line">    Stack&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> endPoint; x != startPoint; x = edgeTo[x]) &#123;</span><br><span class="line">      path.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    path.push(startPoint);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 所有顶点</span></span><br><span class="line">    <span class="type">int</span>[] E = &#123;</span><br><span class="line">      <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">      <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">      <span class="number">10</span>, <span class="number">11</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 所有连接线</span></span><br><span class="line">    String[] line = &#123;</span><br><span class="line">      <span class="string">&quot;0-2&quot;</span>, <span class="string">&quot;0-3&quot;</span>,</span><br><span class="line">      <span class="string">&quot;1-8&quot;</span>, <span class="string">&quot;2-3&quot;</span>, <span class="string">&quot;2-5&quot;</span>, <span class="string">&quot;3-6&quot;</span>, <span class="string">&quot;3-10&quot;</span>,</span><br><span class="line">      <span class="string">&quot;4-8&quot;</span>, <span class="string">&quot;4-7&quot;</span>, <span class="string">&quot;5-6&quot;</span>, <span class="string">&quot;6-9&quot;</span>, <span class="string">&quot;6-10&quot;</span>, <span class="string">&quot;10-11&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图用例</span></span><br><span class="line">    <span class="type">Graph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(E.length);</span><br><span class="line">    <span class="keyword">for</span> (String _l : line) &#123;</span><br><span class="line">      String[] split = _l.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      g.addEdge(Integer.parseInt(split[<span class="number">0</span>]), Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ShortestGraphUtil</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortestGraphUtil</span>(g, <span class="number">0</span>, <span class="number">11</span>);</span><br><span class="line">    System.out.println(u.pathTo());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><h3 id="有向图的实现"><a href="#有向图的实现" class="headerlink" title="有向图的实现"></a>有向图的实现</h3><p>有向图和无向图的区别就只是在于，顶点到另外一个顶点是有方向的，所以我们只需要改改无向图的实现即可实现有向图了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Digraph</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 顶点的数目</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> V;</span><br><span class="line">  <span class="comment">// 边的数目</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">  <span class="comment">// 记录连接情况；</span></span><br><span class="line">  List&lt;Integer&gt;[] lists;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Digraph</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    V = v;</span><br><span class="line">    E = <span class="number">0</span>;</span><br><span class="line">    lists = (List&lt;Integer&gt;[]) <span class="keyword">new</span> <span class="title class_">List</span>[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">      lists[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> V;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">    <span class="comment">// 只是添加一个方向的，比无向图少了一个返回</span></span><br><span class="line">    lists[v].add(w);</span><br><span class="line">    E++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个顶点所有连接的另外一个顶点</span></span><br><span class="line">  <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lists[e];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反转图的方向</span></span><br><span class="line">  <span class="keyword">public</span> Digraph <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Digraph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digraph</span>(V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Integer j : adj(i)) &#123;</span><br><span class="line">        g.addEdge(j, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们 <code>GraphApplication</code> 中的连接就会变成： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151932.jpeg"></p>
<h3 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h3><p>然后上面 <code>无向图</code> 的 <code>深度优先搜索</code> 和 <code>广度优先搜索</code> 的代码只要把接参改为 <code>Diagraph</code> 参数即可完美运行（啊呀真方便，不用重新写了 <code>orz</code>）</p>
<h3 id="环和有向无环"><a href="#环和有向无环" class="headerlink" title="环和有向无环"></a>环和有向无环</h3><p>环就是一个顶点出发遍历他周围的顶点，然后发现，他可以回到第一个顶点，所以我们就可以通过深度优先搜索来写这个算法了，所以其实就是计算 <code>图</code> 中所有的路径中加点计算： 为了实验，构建了这样一幅图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151950.jpeg"></p>
<p> 然后，我们用 <code>深度优先</code> 来做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CycleDiagraphUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 使用数组的下标表示顶点，记录哪些点被遍历过了 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] edgeTo;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span>[] onStack;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; cycle;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CycleDiagraphUtil</span><span class="params">(Digraph g, <span class="type">int</span> startPoint)</span> &#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    edgeTo = <span class="keyword">new</span> <span class="title class_">int</span>[g.V()];</span><br><span class="line">    onStack = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    dfs(g, startPoint);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Digraph g, <span class="type">int</span> point)</span> &#123;</span><br><span class="line">    onStack[point] = <span class="literal">true</span>;</span><br><span class="line">    marked[point] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Integer v : g.adj(point)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasCycle()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!marked[v]) &#123;</span><br><span class="line">        edgeTo[v] = point;</span><br><span class="line">        dfs(g, v);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onStack[v]) &#123;</span><br><span class="line">        cycle = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> point; x != v; x = edgeTo[x]) &#123;</span><br><span class="line">          cycle.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        cycle.push(v);</span><br><span class="line">        cycle.push(point);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onStack[point] = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">cycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cycle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cycle != <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 所有连接线</span></span><br><span class="line">    String[] line = &#123;</span><br><span class="line">        <span class="string">&quot;2-0&quot;</span>, <span class="string">&quot;0-3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-8&quot;</span>, <span class="string">&quot;3-2&quot;</span>, <span class="string">&quot;2-5&quot;</span>, <span class="string">&quot;3-6&quot;</span>, <span class="string">&quot;3-10&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-8&quot;</span>, <span class="string">&quot;4-7&quot;</span>, <span class="string">&quot;5-6&quot;</span>, <span class="string">&quot;6-9&quot;</span>, <span class="string">&quot;6-10&quot;</span>, <span class="string">&quot;10-11&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图用例</span></span><br><span class="line">    <span class="type">Digraph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digraph</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _l : line) &#123;</span><br><span class="line">      String[] split = _l.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      g.addEdge(Integer.parseInt(split[<span class="number">0</span>]), Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">CycleDiagraphUtil</span> <span class="variable">cycleDiagraphUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CycleDiagraphUtil</span>(g, <span class="number">2</span>);</span><br><span class="line">    System.out.println(cycleDiagraphUtil.cycle());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><code>拓扑排序</code> 指的是一个 <code>有向无环图</code>，顶点的按照依赖的顺序来排序的 <code>图排序算法</code>，而顺序也分为 <code>前序</code> <code>后序</code> <code>逆后序</code> 的不同顺序。举一些比较简单的🌰，比如 <code>任务调度</code>，我们在执行一系列任务的时候，一般都有任务优先级，比如先执行查询产品的库存是否充足，才会去创建订单，只有创建了订单以后，才能进行订单的支付等等。 而前序遍历，可以让我们清楚的识别任务的依赖顺序，后序则可以让我们清楚了解任务完成执行的顺序，而逆后序则更加类似于任务执行中，日志在我们的文件中打印的情况。 那么排序，我们用的还是需要 <code>深度优先搜索</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DFSIter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 使用队列来存储前序和后续遍历 */</span></span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; pre;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; post;</span><br><span class="line">  <span class="comment">/** 栈存储逆后序的顺序 */</span></span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; reversePost;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DFSIter</span><span class="params">(Digraph g)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    <span class="built_in">this</span>.pre = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.post = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.reversePost = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; g.V(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!marked[i]) &#123;</span><br><span class="line">        dfs(g, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Digraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pre.offer(v);</span><br><span class="line">    <span class="built_in">this</span>.marked[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer w : g.adj(v)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.marked[w]) &#123;</span><br><span class="line">        dfs(g, w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.post.offer(v);</span><br><span class="line">    <span class="built_in">this</span>.reversePost.push(v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Queue&lt;Integer&gt; <span class="title function_">getPre</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Queue&lt;Integer&gt; <span class="title function_">getPost</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">getReversePost</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> reversePost.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      l.add(reversePost.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 所有连接线</span></span><br><span class="line">    String[] line = &#123;</span><br><span class="line">        <span class="string">&quot;0-2&quot;</span>, <span class="string">&quot;0-3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-8&quot;</span>, <span class="string">&quot;3-2&quot;</span>, <span class="string">&quot;2-5&quot;</span>, <span class="string">&quot;3-6&quot;</span>, <span class="string">&quot;3-10&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-8&quot;</span>, <span class="string">&quot;4-7&quot;</span>, <span class="string">&quot;5-6&quot;</span>, <span class="string">&quot;6-9&quot;</span>, <span class="string">&quot;6-10&quot;</span>, <span class="string">&quot;10-11&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图用例</span></span><br><span class="line">    <span class="type">Digraph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digraph</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _l : line) &#123;</span><br><span class="line">      String[] split = _l.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      g.addEdge(Integer.parseInt(split[<span class="number">0</span>]), Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">DFSIter</span> <span class="variable">dfsIter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DFSIter</span>(g);</span><br><span class="line">    System.out.println(dfsIter.getPre());</span><br><span class="line">    System.out.println(dfsIter.getPost());</span><br><span class="line">    System.out.println(dfsIter.getReversePost());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="强连通性"><a href="#强连通性" class="headerlink" title="强连通性"></a>强连通性</h3><p>强连通性表示的是，给定一个图和两个顶点 <code>A</code> <code>B</code>，同时存在一条线路可以从 <code>A</code> 到达 <code>B</code>，也存在另外一条线路从 <code>B</code> 到 <code>A</code>，就说明 <code>A</code> 和 <code>B</code> 是具有 <code>强连通性</code> 的。而 <code>环</code> 就是 <code>强连通性的一种方式</code> 那么，一个叫做 <code>Kosaraju</code> 的人，就发现了，如果我对一个有向图进行 <code>深度遍历</code>，发现 <code>A -&gt; B</code>，而如果存在一个路径是 <code>B-&gt;A</code> 的话，那么在这个有向图的反向图中，必定存在 <code>A -&gt; B</code> 的路径： 首先，先构建一个图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152017.jpeg"></p>
<p> 图中，<code>2</code> 和 <code>8</code> 组成了强连通性的分量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KosarajuCC</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">KosarajuCC</span><span class="params">(Digraph g)</span> &#123;</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    id = <span class="keyword">new</span> <span class="title class_">int</span>[g.V()];</span><br><span class="line">    <span class="type">DFSIter</span> <span class="variable">dfsIter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DFSIter</span>(g.reverse());</span><br><span class="line">    <span class="keyword">for</span> (Integer i : dfsIter.getReversePost()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!marked[i]) &#123;</span><br><span class="line">        dfs(g, i);</span><br><span class="line">        count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Digraph g, Integer i)</span> &#123;</span><br><span class="line">    marked[i] = <span class="literal">true</span>;</span><br><span class="line">    id[i] = count;</span><br><span class="line">    <span class="keyword">for</span> (Integer v : g.adj(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!marked[v]) &#123;</span><br><span class="line">        dfs(g, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">strongConnect</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 所有连接线</span></span><br><span class="line">    String[] line = &#123;</span><br><span class="line">        <span class="string">&quot;0-2&quot;</span>, <span class="string">&quot;1-0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-7&quot;</span>, <span class="string">&quot;2-4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2-6&quot;</span>, <span class="string">&quot;6-3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-5&quot;</span>, <span class="string">&quot;5-2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-8&quot;</span>, <span class="string">&quot;8-6&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建图用例</span></span><br><span class="line">    <span class="type">Digraph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digraph</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _l : line) &#123;</span><br><span class="line">      String[] split = _l.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      g.addEdge(Integer.parseInt(split[<span class="number">0</span>]), Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">KosarajuCC</span> <span class="variable">kosarajuCC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KosarajuCC</span>(g);</span><br><span class="line">    System.out.println(<span class="string">&quot;1和7是强连通性的吗？&quot;</span> + kosarajuCC.strongConnect(<span class="number">1</span>, <span class="number">7</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;2和8是强连通性的吗？&quot;</span> + kosarajuCC.strongConnect(<span class="number">8</span>, <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，这个算法感觉我们需要来分析一下。 首先反转一下这个图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152043.jpeg"> </p>
<p>那么现在有这个理论，如果原图中存在一条 <code>2 -&gt; 8</code> 并且这个连接是强连通性的话，那么就需要证明还存在一条 <code>8 -&gt; 2</code> 的路径，也就是说他的反向图中，存在一个 <code>2 -&gt; 8</code> 的连接。那么 <code>长得帅的同学</code> 就要问了，我直接使用原图来证明 <code>8 -&gt; 2</code> 不就行了吗，为什么还要 <code>反向图</code> 来出场？还不是为了速度和递归的程度。 证明 <code>2</code> 到 <code>8</code> 有两个路径，那么原图从反向图就能优先得到类似“最后处理”的顶点，开始在原图往回深度遍历标记 <code>count变量</code>，因为正向深度如果很深的话，那么反向图来遍历正向图，所需要的递归深度将会更少。这也是 <code>Kosaraju</code> 发现的这个算法的奇妙之点。</p>
<h2 id="加权图和最小生成树"><a href="#加权图和最小生成树" class="headerlink" title="加权图和最小生成树"></a>加权图和最小生成树</h2><h3 id="加权图的数据结构表示"><a href="#加权图的数据结构表示" class="headerlink" title="加权图的数据结构表示"></a>加权图的数据结构表示</h3><p><code>图</code> 生成 <code>最小树</code>，意思就是，通过寻找 <code>图</code> 中所有 <code>顶点</code> 和 <code>边</code>，然后找出来能构建 <code>一棵树</code> 的一种算法。</p>
<blockquote>
<p>上面所说的 <code>树</code> 的定义：如果一幅图 <code>G</code>，含有 <code>V</code> 个顶点，而 <code>V-1</code> 条边不含有 <code>环</code> 切相互连通，并且任意一对顶点之间只存在一条连通的路径，我们可以称 <code>图</code> 为 一棵 <code>树</code>。并且 <code>树</code> 中任意新增一条 <code>边</code> 都会产生 <code>环</code>，任意删除一条 <code>边</code> 都会得到两棵独立的 <code>树</code>。</p>
</blockquote>
<p>但是，我们说了这么久的 <code>图</code>，<code>边</code> 都是没有数值表示其 <code>大小</code> 的，虽然画在上面的 <code>图</code> <code>边</code> 的长短让我们产生了错觉以为是有数值的。那么现在我们就需要给 <code>边</code> 进行赋值，术语称为 <code>权重</code>。 <code>权重</code> 在实际应用中可以表示很多东西，比如说 <code>顶点</code> 表示城市，<code>边</code> 表示线路，那么 <code>权重</code> 可以表示堵车程度，或者线路的长短。 <code>SO</code>，我们就需要构建 <code>加权图</code> 的类了，构建图的边情况，我就直接抄书中的案例了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EdgeWeightedGraph</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 顶点的数量 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> V;</span><br><span class="line">  <span class="comment">/** 边的数量 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Edge&gt;[] adj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 表示加权图的两个顶点以及边的权重.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Edge&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w, <span class="type">double</span> weight)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.v = v;</span><br><span class="line">      <span class="built_in">this</span>.w = w;</span><br><span class="line">      <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Edge o)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Double.compare(<span class="built_in">this</span>.weight, o.weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">weight</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">other</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (vertex == v) <span class="keyword">return</span> w;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (vertex == w) <span class="keyword">return</span> v;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal endpoint&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">EdgeWeightedGraph</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    V = v;</span><br><span class="line">    E = <span class="number">0</span>;</span><br><span class="line">    adj = (List&lt;Edge&gt;[]) <span class="keyword">new</span> <span class="title class_">List</span>[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 增加一条权重边.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> edge Edge.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(Edge edge)</span> &#123;</span><br><span class="line">    adj[edge.v].add(edge);</span><br><span class="line">    adj[edge.w].add(edge);</span><br><span class="line">    E++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] lines = &#123;</span><br><span class="line">        <span class="string">&quot;4-5-0.35&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-7-0.37&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-7-0.28&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-7-0.16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-5-0.32&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-4-0.38&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2-3-0.17&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-7-0.19&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-2-0.26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-2-0.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-3-0.29&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2-7-0.34&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-2-0.40&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3-6-0.52&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-0-0.58&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-4-0.9&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">EdgeWeightedGraph</span> <span class="variable">ewg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EdgeWeightedGraph</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _line : lines) &#123;</span><br><span class="line">      String[] split = _line.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> split[<span class="number">0</span>], w = split[<span class="number">1</span>], weight = split[<span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> Integer.parseInt(v), vw = Integer.parseInt(w);</span><br><span class="line">      ewg.addEdge(<span class="keyword">new</span> <span class="title class_">Edge</span>(vi, vw, Double.parseDouble(weight)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> ewg.E() == lines.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那大概这幅图就是这样的：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152107.jpeg"> </p>
<p>这时候边的长短就真的是代表权重了。</p>
<h3 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h3><p>那么先来宏观观察一下上面这幅图生成一棵最小树是什么样子的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152120.jpeg"> </p>
<p>然后我们尝试把这棵树一分为二：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152141.jpeg"> </p>
<p>我们即可发现，<code>0-2</code> 这条边，是两棵树的最小连接边（权重是 <code>0.26</code>）。所以我们可以推出来，两个顶点集合中，连接的边肯定是最小 <code>横切边</code>，并且这条最小 <code>横切边</code>肯定存在于我们要生成的 <code>树</code> 中。 所以我们要生成一棵 <code>树</code>，就可以这么做了，首先遍历当前这个顶点，假设其他所有顶点是另外一棵 <code>树</code> 的顶点的集合，那么我们只要从这个顶点出发，遍历连接的 <code>横切边们</code>，最小的那条取出来就可以了，这也是我们常听说的 <code>贪心算法</code>。</p>
<blockquote>
<p>度娘的解释：贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。贪心算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。</p>
</blockquote>
<hr>
<p>那么第一个算法就是 <code>prim算法</code>，他采用了一个优先级队列来保存当前遍历到的顶点的所有路径，然后从一个顶点开始，通过总是弹出来目前队列中最小的路径来标记图中所有的顶点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prim</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 标记属性 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 最小树的队列 */</span></span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Edge&gt; result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 一个优先级队列，在计算中需要用到 */</span></span><br><span class="line">  <span class="keyword">private</span> PriorityQueue&lt;Edge&gt; tmp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Prim</span><span class="params">(EdgeWeightedGraph g)</span> &#123;</span><br><span class="line">    tmp = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    result = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line"></span><br><span class="line">    marked(g, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!tmp.isEmpty()) &#123;</span><br><span class="line">      <span class="type">Edge</span> <span class="variable">poll</span> <span class="operator">=</span> tmp.poll();</span><br><span class="line">      <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> poll.either();</span><br><span class="line">      <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> poll.other(v);</span><br><span class="line">      <span class="keyword">if</span> (marked[v] &amp;&amp; marked[w]) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result.add(poll);</span><br><span class="line">      <span class="keyword">if</span> (!marked[v]) marked(g, v);</span><br><span class="line">      <span class="keyword">if</span> (!marked[w]) marked(g, w);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">marked</span><span class="params">(EdgeWeightedGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    marked[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Edge edge : g.adj(v)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!marked[edge.other(v)]) &#123;</span><br><span class="line">        tmp.add(edge);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Queue&lt;Edge&gt; <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] lines = &#123;</span><br><span class="line">        <span class="string">&quot;4-5-0.35&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-7-0.37&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-7-0.28&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-7-0.16&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-5-0.32&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-4-0.38&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2-3-0.17&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-7-0.19&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-2-0.26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-2-0.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-3-0.29&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2-7-0.34&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-2-0.40&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3-6-0.52&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-0-0.58&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-4-0.9&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">EdgeWeightedGraph</span> <span class="variable">ewg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EdgeWeightedGraph</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _line : lines) &#123;</span><br><span class="line">      String[] split = _line.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> split[<span class="number">0</span>], w = split[<span class="number">1</span>], weight = split[<span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> Integer.parseInt(v), vw = Integer.parseInt(w);</span><br><span class="line">      ewg.addEdge(<span class="keyword">new</span> <span class="title class_">Edge</span>(vi, vw, Double.parseDouble(weight)));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Prim</span>(ewg).getResult());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">[Edge&#123;v=<span class="number">0</span>, w=<span class="number">7</span>, weight=<span class="number">0.16</span>&#125;, Edge&#123;v=<span class="number">1</span>, w=<span class="number">7</span>, weight=<span class="number">0.19</span>&#125;, Edge&#123;v=<span class="number">0</span>, w=<span class="number">2</span>, weight=<span class="number">0.26</span>&#125;, Edge&#123;v=<span class="number">2</span>, w=<span class="number">3</span>, weight=<span class="number">0.17</span>&#125;, Edge&#123;v=<span class="number">5</span>, w=<span class="number">7</span>, weight=<span class="number">0.28</span>&#125;, Edge&#123;v=<span class="number">4</span>, w=<span class="number">5</span>, weight=<span class="number">0.35</span>&#125;, Edge&#123;v=<span class="number">6</span>, w=<span class="number">2</span>, weight=<span class="number">0.4</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>很明显就是通过一个优先级队列将目前我所知道的所有边进行排序，然后我只处理目前最短的那条边认为他就是我要的最小生成树的边了。</p>
<hr>
<p>那么另外一个算法就是 <code>Kruskal</code> 算法，他的构造方法也是和 <code>Prim</code> 一样一步一步的读取树的连接线，但是不同的是，他不是从顶点出发去遍历，而是读取所有边进行排序，然后遍历这些边去连接，直到连接的新的图的边树等于 <code>顶点数 - 1</code>。不过实现还是蛮简单的，但是需要一个额外的类，也就是 <code>连通器类</code>，用于记录新的图连接的顶点，那我就直接拿《算法》里边的实现来演示就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先需要一个连通类来记录，通过数组以及下标一致来寻找连通的分量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UF</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span>[] parent;  </span><br><span class="line">  <span class="keyword">private</span> <span class="type">byte</span>[] rank;   </span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count;     </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    count = n;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    rank = <span class="keyword">new</span> <span class="title class_">byte</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      parent[i] = i;</span><br><span class="line">      rank[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断两个顶点是否已经连接</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 连接两个连通分量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootP</span> <span class="operator">=</span> find(p);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootQ</span> <span class="operator">=</span> find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>      (rank[rootP] &lt; rank[rootQ]) parent[rootP] = rootQ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootP] &gt; rank[rootQ]) parent[rootQ] = rootP;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      parent[rootQ] = rootP;</span><br><span class="line">      rank[rootP]++;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KruskalMST</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Edge&gt; mst = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">KruskalMST</span><span class="params">(EdgeWeightedGraph G)</span> &#123;</span><br><span class="line">    <span class="comment">// more efficient to build heap by passing array of edges</span></span><br><span class="line">    MinPQ&lt;Edge&gt; pq = <span class="keyword">new</span> <span class="title class_">MinPQ</span>&lt;Edge&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Edge e : G.edges()) &#123;</span><br><span class="line">      pq.insert(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run greedy algorithm</span></span><br><span class="line">    <span class="type">UF</span> <span class="variable">uf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>(G.V());</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; mst.size() &lt; G.V() - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">Edge</span> <span class="variable">e</span> <span class="operator">=</span> pq.delMin();</span><br><span class="line">      <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> e.either();</span><br><span class="line">      <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> e.other(v);</span><br><span class="line">      <span class="keyword">if</span> (uf.find(v) != uf.find(w)) &#123; <span class="comment">// v-w does not create a cycle</span></span><br><span class="line">        uf.union(v, w);  <span class="comment">// merge v and w components</span></span><br><span class="line">        mst.enqueue(e);  <span class="comment">// add edge e to mst</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到只需要一个队列，然后配合连通分量就可以实现查找最小树。</p>
<h2 id="加权有向图和最短线路问题"><a href="#加权有向图和最短线路问题" class="headerlink" title="加权有向图和最短线路问题"></a>加权有向图和最短线路问题</h2><h3 id="加权有向图数据结构表示"><a href="#加权有向图数据结构表示" class="headerlink" title="加权有向图数据结构表示"></a>加权有向图数据结构表示</h3><p>加权有向图就更加贴近实际生活用处了，比如一个顶点去到另外一个顶点，我们可以使用我们最熟悉的地图导航来说。顶点就是一个一个的建筑物，而我们通常需要查询从当前点去到另外一个点的最短距离。所以这时候边就拥有了两个特性：1. 边的权重表示距离；2. 边的方法代表路的方向。 当然啦，不仅仅是地图有这个用处，像线路、优先级任务等等，都需要有向图这种数据结构来表示。所以首先我们还是需要一个加权有向图的类，用来表示一副加权有向图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectedEdgeWeightedGraph</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 顶点的数量 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> V;</span><br><span class="line">  <span class="comment">/** 边的数量 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> E;</span><br><span class="line">  <span class="keyword">private</span> List&lt;DirectedEdge&gt;[] adj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 表示加权图的两个顶点以及边的权重.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DirectedEdge</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;DirectedEdge&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> to;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DirectedEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">double</span> weight)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.from = from;</span><br><span class="line">      <span class="built_in">this</span>.to = to;</span><br><span class="line">      <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(DirectedEdge o)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Double.compare(<span class="built_in">this</span>.weight, o.weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">weight</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">from</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">to</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DirectedEdgeWeightedGraph</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    V = v;</span><br><span class="line">    E = <span class="number">0</span>;</span><br><span class="line">    adj = (List&lt;DirectedEdge&gt;[]) <span class="keyword">new</span> <span class="title class_">List</span>[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 增加一条权重边.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> edge Edge.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(DirectedEdge edge)</span> &#123;</span><br><span class="line">    adj[edge.from].add(edge);</span><br><span class="line">    E++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;DirectedEdge&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> adj[v];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> V;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] lines = &#123;</span><br><span class="line">        <span class="string">&quot;4-5-0.35&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-4-0.35&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-7-0.37&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-7-0.28&quot;</span>,</span><br><span class="line">        <span class="string">&quot;7-5-0.28&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-1-0.32&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-4-0.38&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-2-0.26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;7-3-0.39&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-3-0.29&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2-7-0.34&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-2-0.40&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3-6-0.52&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-0-0.58&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-4-0.93&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">DirectedEdgeWeightedGraph</span> <span class="variable">ewg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectedEdgeWeightedGraph</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _line : lines) &#123;</span><br><span class="line">      String[] split = _line.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> split[<span class="number">0</span>], w = split[<span class="number">1</span>], weight = split[<span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> Integer.parseInt(v), vw = Integer.parseInt(w);</span><br><span class="line">      ewg.addEdge(<span class="keyword">new</span> <span class="title class_">DirectedEdge</span>(vi, vw, Double.parseDouble(weight)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> ewg.E() == lines.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 <code>main</code> 函数中的这个图大概长的是这样子：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152241.jpeg"> </p>
<p>好了，图有了，就可以来研究一些算法了。</p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>那么需要特别注意几个性质：</p>
<ol>
<li> 路径是有向的：首先，路径需要注意数据结构中方向的表示，也就是 <code>from -&gt; to</code>；</li>
<li> 权重不一定是距离：可以是电阻呀、汇率呀等等我们可以想到的可以表示数值的元素；</li>
<li> 并不是所有顶点相互可达：因为有方向了，所以难免会进死胡同；</li>
<li> 最短路径可能存在多个</li>
<li> 可能有平行边或者自环：自环看起来一般没有意义（当然如果权重不为零我们需要另外说事），而平行边我们通常选择的是权重最小的，所以先不考虑这些扰人的元素。</li>
</ol>
<p>那么首先我们来看一个算法：<code>Dijkstra算法</code>，它的实现有点类似于 <code>Kruskal算法</code> ，就是总是遍历目前已发现的最小权重的 <code>边</code>，并且遍历已经有路径的可达点中，把这些点已经保存的权重和线路的集合作比较，如果比目前的小的话，就把原先处理的删掉，替换成目前的边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraShortest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>[] distTo;</span><br><span class="line">  DirectedEdge[] edgeTo;</span><br><span class="line">  <span class="comment">/** 总是计算当前队列中最小的边 */</span></span><br><span class="line">  IndexMinPQ&lt;Double&gt; pq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DijkstraShortest</span><span class="params">(DirectedEdgeWeightedGraph g, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    edgeTo = <span class="keyword">new</span> <span class="title class_">DirectedEdge</span>[g.V()];</span><br><span class="line">    distTo = <span class="keyword">new</span> <span class="title class_">double</span>[g.V()];</span><br><span class="line">    pq = <span class="keyword">new</span> <span class="title class_">IndexMinPQ</span>&lt;&gt;(g.V());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; g.V(); i++) &#123;</span><br><span class="line">      distTo[i] = Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    distTo[s] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    pq.insert(s, <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">/* 放松当前遍历到的点 */</span></span><br><span class="line">      relax(g, pq.delMin());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relax</span><span class="params">(DirectedEdgeWeightedGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge directedEdge : g.adj(v)) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> directedEdge.to();</span><br><span class="line">      <span class="comment">/* 遍历当前顶点连接的所有点，然后计算如果现有的距离比目前存储的大的话，就开始替换 */</span></span><br><span class="line">      <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + directedEdge.weight()) &#123;</span><br><span class="line">        distTo[w] = distTo[v] + directedEdge.weight();</span><br><span class="line">        edgeTo[w] = directedEdge;</span><br><span class="line">        <span class="keyword">if</span> (pq.contains(w)) pq.changeKey(w, distTo[w]);</span><br><span class="line">        <span class="keyword">else</span> pq.insert(w, distTo[w]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> <span class="title function_">distTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> distTo[v];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasPathTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> distTo[v] &lt; Double.POSITIVE_INFINITY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterable&lt;DirectedEdge&gt; <span class="title function_">pathTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;DirectedEdge&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">DirectedEdge</span> <span class="variable">e</span> <span class="operator">=</span> edgeTo[v]; e != <span class="literal">null</span>; e = edgeTo[e.from()]) &#123;</span><br><span class="line">      path.push(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] lines = &#123;</span><br><span class="line">        <span class="string">&quot;4-5-0.35&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-4-0.35&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-7-0.37&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-7-0.28&quot;</span>,</span><br><span class="line">        <span class="string">&quot;7-5-0.28&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-1-0.32&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-4-0.38&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-2-0.26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;7-3-0.39&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-3-0.29&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2-7-0.34&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-2-0.40&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3-6-0.52&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-0-0.58&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-4-0.93&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">DirectedEdgeWeightedGraph</span> <span class="variable">ewg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectedEdgeWeightedGraph</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _line : lines) &#123;</span><br><span class="line">      String[] split = _line.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> split[<span class="number">0</span>], w = split[<span class="number">1</span>], weight = split[<span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> Integer.parseInt(v), vw = Integer.parseInt(w);</span><br><span class="line">      ewg.addEdge(<span class="keyword">new</span> <span class="title class_">DirectedEdge</span>(vi, vw, Double.parseDouble(weight)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">DijkstraShortest</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DijkstraShortest</span>(ewg, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ewg.V(); i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;0到&quot;</span> + i + <span class="string">&quot;的最短距离是：&quot;</span> + d.distTo(i) + <span class="string">&quot;，路径是：&quot;</span> + d.pathTo(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">0</span>到<span class="number">0</span>的最短距离是：<span class="number">0.0</span>，路径是：[]</span><br><span class="line"><span class="number">0</span>到<span class="number">1</span>的最短距离是：<span class="number">1.05</span>，路径是：[DirectedEdge&#123;from=<span class="number">5</span>, to=<span class="number">1</span>, weight=<span class="number">0.32</span>&#125;, DirectedEdge&#123;from=<span class="number">4</span>, to=<span class="number">5</span>, weight=<span class="number">0.35</span>&#125;, DirectedEdge&#123;from=<span class="number">0</span>, to=<span class="number">4</span>, weight=<span class="number">0.38</span>&#125;]</span><br><span class="line"><span class="number">0</span>到<span class="number">2</span>的最短距离是：<span class="number">0.26</span>，路径是：[DirectedEdge&#123;from=<span class="number">0</span>, to=<span class="number">2</span>, weight=<span class="number">0.26</span>&#125;]</span><br><span class="line"><span class="number">0</span>到<span class="number">3</span>的最短距离是：<span class="number">0.9900000000000001</span>，路径是：[DirectedEdge&#123;from=<span class="number">7</span>, to=<span class="number">3</span>, weight=<span class="number">0.39</span>&#125;, DirectedEdge&#123;from=<span class="number">2</span>, to=<span class="number">7</span>, weight=<span class="number">0.34</span>&#125;, DirectedEdge&#123;from=<span class="number">0</span>, to=<span class="number">2</span>, weight=<span class="number">0.26</span>&#125;]</span><br><span class="line"><span class="number">0</span>到<span class="number">4</span>的最短距离是：<span class="number">0.38</span>，路径是：[DirectedEdge&#123;from=<span class="number">0</span>, to=<span class="number">4</span>, weight=<span class="number">0.38</span>&#125;]</span><br><span class="line"><span class="number">0</span>到<span class="number">5</span>的最短距离是：<span class="number">0.73</span>，路径是：[DirectedEdge&#123;from=<span class="number">4</span>, to=<span class="number">5</span>, weight=<span class="number">0.35</span>&#125;, DirectedEdge&#123;from=<span class="number">0</span>, to=<span class="number">4</span>, weight=<span class="number">0.38</span>&#125;]</span><br><span class="line"><span class="number">0</span>到<span class="number">6</span>的最短距离是：<span class="number">1.5100000000000002</span>，路径是：[DirectedEdge&#123;from=<span class="number">3</span>, to=<span class="number">6</span>, weight=<span class="number">0.52</span>&#125;, DirectedEdge&#123;from=<span class="number">7</span>, to=<span class="number">3</span>, weight=<span class="number">0.39</span>&#125;, DirectedEdge&#123;from=<span class="number">2</span>, to=<span class="number">7</span>, weight=<span class="number">0.34</span>&#125;, DirectedEdge&#123;from=<span class="number">0</span>, to=<span class="number">2</span>, weight=<span class="number">0.26</span>&#125;]</span><br><span class="line"><span class="number">0</span>到<span class="number">7</span>的最短距离是：<span class="number">0.6000000000000001</span>，路径是：[DirectedEdge&#123;from=<span class="number">2</span>, to=<span class="number">7</span>, weight=<span class="number">0.34</span>&#125;, DirectedEdge&#123;from=<span class="number">0</span>, to=<span class="number">2</span>, weight=<span class="number">0.26</span>&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="加权有向无环图的最短路径"><a href="#加权有向无环图的最短路径" class="headerlink" title="加权有向无环图的最短路径"></a>加权有向无环图的最短路径</h3><p>那如果我们知道一幅图是无环的，并且我们假设顶点是一个一个的任务，而且这些任务相互依赖，而我们需要找到指定的某个任务到达另外一个任务的最短路径。我们就可以改造上面的 <code>Dijkstra算法</code>，使其支持更快的搜索出 <strong>无环有向图</strong> 中的最短路径。那么既然是 <strong>无环有向图</strong>，那么就可以从遍历放松边的思路开始思考，我们上面对于 <code>无环</code> 提出了一个顶点排序法叫做 <code>拓扑排序</code>，那么现在我们可以利用这个排序来寻找图中最短的路径。 那么现在改造一下上面那幅图：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152300.jpeg"> </p>
<p>然后我们目前需要一个针对无环有向加权图的拓扑排序算法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopologicalIter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 使用队列来存储前序和后续遍历 */</span></span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; pre;</span><br><span class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; post;</span><br><span class="line">  <span class="comment">/** 栈存储逆后序的顺序 */</span></span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; reversePost;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TopologicalIter</span><span class="params">(DirectedEdgeWeightedGraph g)</span> &#123;</span><br><span class="line"><span class="comment">//    if (new CycleDiagraphUtil(g, 0).hasCycle()) &#123;</span></span><br><span class="line"><span class="comment">//      throw new RuntimeException(&quot;出现环，无法计算拓扑结构&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="built_in">this</span>.marked = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    <span class="built_in">this</span>.pre = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.post = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.reversePost = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; g.V(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!marked[i]) &#123;</span><br><span class="line">        dfs(g, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(DirectedEdgeWeightedGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pre.offer(v);</span><br><span class="line">    <span class="built_in">this</span>.marked[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge w : g.adj(v)) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> w.to();</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.marked[to]) &#123;</span><br><span class="line">        dfs(g, to);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.post.offer(v);</span><br><span class="line">    <span class="built_in">this</span>.reversePost.push(v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Queue&lt;Integer&gt; <span class="title function_">getPre</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Queue&lt;Integer&gt; <span class="title function_">getPost</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> post;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title function_">getReversePost</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> reversePost.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      l.add(reversePost.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] lines = &#123;</span><br><span class="line">      <span class="string">&quot;5-4-0.35&quot;</span>,</span><br><span class="line">      <span class="string">&quot;4-7-0.37&quot;</span>,</span><br><span class="line">      <span class="string">&quot;5-7-0.28&quot;</span>,</span><br><span class="line">      <span class="string">&quot;5-1-0.32&quot;</span>,</span><br><span class="line">      <span class="string">&quot;4-0-0.38&quot;</span>,</span><br><span class="line">      <span class="string">&quot;0-2-0.26&quot;</span>,</span><br><span class="line">      <span class="string">&quot;3-7-0.39&quot;</span>,</span><br><span class="line">      <span class="string">&quot;1-3-0.29&quot;</span>,</span><br><span class="line">      <span class="string">&quot;7-2-0.34&quot;</span>,</span><br><span class="line">      <span class="string">&quot;6-2-0.40&quot;</span>,</span><br><span class="line">      <span class="string">&quot;3-6-0.52&quot;</span>,</span><br><span class="line">      <span class="string">&quot;6-0-0.58&quot;</span>,</span><br><span class="line">      <span class="string">&quot;6-4-0.93&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">DirectedEdgeWeightedGraph</span> <span class="variable">ewg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectedEdgeWeightedGraph</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _line : lines) &#123;</span><br><span class="line">      String[] split = _line.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> split[<span class="number">0</span>], w = split[<span class="number">1</span>], weight = split[<span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> Integer.parseInt(v), vw = Integer.parseInt(w);</span><br><span class="line">      ewg.addEdge(<span class="keyword">new</span> <span class="title class_">DirectedEdge</span>(vi, vw, Double.parseDouble(weight)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TopologicalIter</span> <span class="variable">top</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopologicalIter</span>(ewg);</span><br><span class="line">    System.out.println(top.getReversePost());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>那么我们就需要这个顺序来寻找最短的路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraNoCycleShortest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>[] distTo;</span><br><span class="line">  DirectedEdge[] edgeTo;</span><br><span class="line">  <span class="comment">/** 总是计算当前队列中最小的边 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DijkstraNoCycleShortest</span><span class="params">(DirectedEdgeWeightedGraph g, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    edgeTo = <span class="keyword">new</span> <span class="title class_">DirectedEdge</span>[g.V()];</span><br><span class="line">    distTo = <span class="keyword">new</span> <span class="title class_">double</span>[g.V()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; g.V(); i++) &#123;</span><br><span class="line">      distTo[i] = Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    distTo[s] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">TopologicalIter</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopologicalIter</span>(g);</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : t.getReversePost()) &#123;</span><br><span class="line">      relax(g, integer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relax</span><span class="params">(DirectedEdgeWeightedGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge directedEdge : g.adj(v)) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> directedEdge.to();</span><br><span class="line">      <span class="comment">/* 遍历当前顶点连接的所有点，然后计算如果现有的距离比目前存储的大的话，就开始替换 */</span></span><br><span class="line">      <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + directedEdge.weight()) &#123;</span><br><span class="line">        distTo[w] = distTo[v] + directedEdge.weight();</span><br><span class="line">        edgeTo[w] = directedEdge;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> <span class="title function_">distTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> distTo[v];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasPathTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> distTo[v] &lt; Double.POSITIVE_INFINITY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterable&lt;DirectedEdge&gt; <span class="title function_">pathTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;DirectedEdge&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">DirectedEdge</span> <span class="variable">e</span> <span class="operator">=</span> edgeTo[v]; e != <span class="literal">null</span>; e = edgeTo[e.from()]) &#123;</span><br><span class="line">      path.push(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] lines = &#123;</span><br><span class="line">        <span class="string">&quot;5-4-0.35&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-7-0.37&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-7-0.28&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5-1-0.32&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4-0-0.38&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0-2-0.26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3-7-0.39&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1-3-0.29&quot;</span>,</span><br><span class="line">        <span class="string">&quot;7-2-0.34&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-2-0.40&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3-6-0.52&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-0-0.58&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6-4-0.93&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">DirectedEdgeWeightedGraph</span> <span class="variable">ewg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectedEdgeWeightedGraph</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _line : lines) &#123;</span><br><span class="line">      String[] split = _line.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> split[<span class="number">0</span>], w = split[<span class="number">1</span>], weight = split[<span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> Integer.parseInt(v), vw = Integer.parseInt(w);</span><br><span class="line">      ewg.addEdge(<span class="keyword">new</span> <span class="title class_">DirectedEdge</span>(vi, vw, Double.parseDouble(weight)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">DijkstraNoCycleShortest</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DijkstraNoCycleShortest</span>(ewg, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ewg.V(); i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;5 -&gt; &quot;</span> + i + <span class="string">&quot;: &quot;</span> + d.pathTo(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那为啥说引入拓扑结构就会使算法变得高效呢，因为我们知道拓扑排序，是基于图相互依赖的关系（前提是一个无环图）来排序的，那么，我们使用这个排序再来放松顶点边的时候，当 <code>v-w</code> 这条边被放松了过后，起点 <code>v</code> 因为拓扑排序的关系一定排在 <code>w</code> 之前，所以他在被放松以后，就不会继续被访问到，也不会继续被放松，所以算法经过放松的次数比原生的 <code>Dijkstra算法</code> 更少，所以说针对 <code>无环</code> 的有向图，使用拓扑排序会比原来的算法高效。 那么如果我们需要计算出图中的最长路径呢，那么我们只需要将 <code>distTo</code> 数组所有值先初始化为无限小，然后改变放松计算中的大小方向就可以了。</p>
<h3 id="有负权重的有向加权图"><a href="#有负权重的有向加权图" class="headerlink" title="有负权重的有向加权图"></a>有负权重的有向加权图</h3><p>如果有向加权图中出现了 <code>负权值</code> 的边，那么我们在寻找顶点与顶点之间距离的时候，就需要识别这些 <code>负权值</code> 所在的顶点是否会跟其他顶点组成一个 <code>环</code>，而这个 <code>环</code> 他的 <code>环总权值</code> 是否 <code>小于0</code>，如果 <code>小于0</code> 则我们需要避开这些 <code>负权值环</code> 否则问题的解决方案将会变得没有意义。这种情况归纳为有可能是输入数值的错误，在现实中我们很少出现问题是有 <code>负数</code> 这种说法的，所以需要去纠正这个错误。 所以，<code>BellmanFordSP</code> 提出了下面这个算法，它能够周期性的检测 <code>负权值环</code> 并避开他：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BellmanFordShortest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span>[] distTo;</span><br><span class="line">  DirectedEdge[] edgeTo;</span><br><span class="line">  <span class="type">boolean</span>[] onQ;</span><br><span class="line">  Queue&lt;Integer&gt; queue;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> cost;</span><br><span class="line">  Iterable&lt;DirectedEdge&gt; cycle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 总是计算当前队列中最小的边 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BellmanFordShortest</span><span class="params">(DirectedEdgeWeightedGraph g, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    edgeTo = <span class="keyword">new</span> <span class="title class_">DirectedEdge</span>[g.V()];</span><br><span class="line">    distTo = <span class="keyword">new</span> <span class="title class_">double</span>[g.V()];</span><br><span class="line">    onQ = <span class="keyword">new</span> <span class="title class_">boolean</span>[g.V()];</span><br><span class="line">    queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; g.V(); i++) &#123;</span><br><span class="line">      distTo[i] = Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">    queue.add(s);</span><br><span class="line">    onQ[s] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; !hasNegativeCycle()) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">      onQ[v] = <span class="literal">false</span>;</span><br><span class="line">      relax(g, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNegativeCycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cycle != <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relax</span><span class="params">(DirectedEdgeWeightedGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge directedEdge : g.adj(v)) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> directedEdge.to();</span><br><span class="line">      <span class="comment">/* 遍历当前顶点连接的所有点，然后计算如果现有的距离比目前存储的大的话，就开始替换 */</span></span><br><span class="line">      <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + directedEdge.weight()) &#123;</span><br><span class="line">        distTo[w] = distTo[v] + directedEdge.weight();</span><br><span class="line">        edgeTo[w] = directedEdge;</span><br><span class="line">        <span class="keyword">if</span> (!onQ[w]) &#123;</span><br><span class="line">          queue.add(w);</span><br><span class="line">          onQ[w] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cost++ % g.V() == <span class="number">0</span>) &#123;</span><br><span class="line">        findNegativeCycle();</span><br><span class="line">        <span class="keyword">if</span> (hasNegativeCycle()) <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findNegativeCycle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edgeTo.length;</span><br><span class="line">    <span class="type">DirectedEdgeWeightedGraph</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectedEdgeWeightedGraph</span>(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (edgeTo[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">        t.addEdge(edgeTo[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">DirectedEdgeWeightedGraphFinder</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectedEdgeWeightedGraphFinder</span>(t);</span><br><span class="line">    cycle = f.cycle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DirectedEdgeWeightedGraphFinder</span>&#123;</span><br><span class="line">    Stack&lt;DirectedEdge&gt; cycle;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] onStack;</span><br><span class="line">    DirectedEdgeWeightedGraphFinder(DirectedEdgeWeightedGraph G) &#123;</span><br><span class="line">      <span class="comment">// 直接通过dfs找出环</span></span><br><span class="line">      marked  = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">      onStack = <span class="keyword">new</span> <span class="title class_">boolean</span>[G.V()];</span><br><span class="line">      edgeTo  = <span class="keyword">new</span> <span class="title class_">DirectedEdge</span>[G.V()];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">        <span class="keyword">if</span> (!marked[v]) dfs(G, v);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(DirectedEdgeWeightedGraph G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">      onStack[v] = <span class="literal">true</span>;</span><br><span class="line">      marked[v] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (DirectedEdge e : G.adj(v)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> e.to();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cycle != <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">          edgeTo[w] = e;</span><br><span class="line">          dfs(G, w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onStack[w]) &#123;</span><br><span class="line">          cycle = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="type">DirectedEdge</span> <span class="variable">f</span> <span class="operator">=</span> e;</span><br><span class="line">          <span class="keyword">while</span> (f.from() != w) &#123;</span><br><span class="line">            cycle.push(f);</span><br><span class="line">            f = edgeTo[f.from()];</span><br><span class="line">          &#125;</span><br><span class="line">          cycle.push(f);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      onStack[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> <span class="title function_">distTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> distTo[v];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasPathTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> distTo[v] &lt; Double.POSITIVE_INFINITY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Iterable&lt;DirectedEdge&gt; <span class="title function_">pathTo</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasNegativeCycle())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;Negative cost cycle exists&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hasPathTo(v)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;DirectedEdge&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">DirectedEdge</span> <span class="variable">e</span> <span class="operator">=</span> edgeTo[v]; e != <span class="literal">null</span>; e = edgeTo[e.from()]) &#123;</span><br><span class="line">      path.push(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] lines = &#123;</span><br><span class="line">        <span class="string">&quot;4%5%0.35&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5%4%0.35&quot;</span>,</span><br><span class="line">        <span class="string">&quot;4%7%0.37&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5%7%0.28&quot;</span>,</span><br><span class="line">        <span class="string">&quot;7%5%0.28&quot;</span>,</span><br><span class="line">        <span class="string">&quot;5%1%0.32&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0%4%0.38&quot;</span>,</span><br><span class="line">        <span class="string">&quot;0%2%0.26&quot;</span>,</span><br><span class="line">        <span class="string">&quot;7%3%0.39&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1%3%0.29&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2%7%0.34&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6%2%-1.20&quot;</span>,</span><br><span class="line">        <span class="string">&quot;3%6%0.52&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6%0%-1.4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;6%4%-1.25&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">DirectedEdgeWeightedGraph</span> <span class="variable">ewg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectedEdgeWeightedGraph</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (String _line : lines) &#123;</span><br><span class="line">      String[] split = _line.split(<span class="string">&quot;%&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> split[<span class="number">0</span>], w = split[<span class="number">1</span>], weight = split[<span class="number">2</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">vi</span> <span class="operator">=</span> Integer.parseInt(v), vw = Integer.parseInt(w);</span><br><span class="line">      ewg.addEdge(<span class="keyword">new</span> <span class="title class_">DirectedEdge</span>(vi, vw, Double.parseDouble(weight)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BellmanFordShortest</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BellmanFordShortest</span>(ewg, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ewg.V(); i++) &#123;</span><br><span class="line">      Iterable&lt;DirectedEdge&gt; directedEdges = d.pathTo(i);</span><br><span class="line">      <span class="type">double</span> <span class="variable">edgeSumWeight</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">      <span class="keyword">for</span> (DirectedEdge directedEdge : directedEdges) &#123;</span><br><span class="line">        edgeSumWeight += directedEdge.weight();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;1 -&gt; &quot;</span> + i + <span class="string">&quot;: &quot;</span> + directedEdges + <span class="string">&quot;，sum=&quot;</span> + edgeSumWeight);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">0</span>: [DirectedEdge&#123;from=<span class="number">6</span>, to=<span class="number">0</span>, weight=-<span class="number">1.4</span>&#125;, DirectedEdge&#123;from=<span class="number">3</span>, to=<span class="number">6</span>, weight=<span class="number">0.52</span>&#125;, DirectedEdge&#123;from=<span class="number">1</span>, to=<span class="number">3</span>, weight=<span class="number">0.29</span>&#125;]，sum=-<span class="number">0.5899999999999999</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">1</span>: []，sum=<span class="number">0.0</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span>: [DirectedEdge&#123;from=<span class="number">6</span>, to=<span class="number">2</span>, weight=-<span class="number">1.2</span>&#125;, DirectedEdge&#123;from=<span class="number">3</span>, to=<span class="number">6</span>, weight=<span class="number">0.52</span>&#125;, DirectedEdge&#123;from=<span class="number">1</span>, to=<span class="number">3</span>, weight=<span class="number">0.29</span>&#125;]，sum=-<span class="number">0.38999999999999996</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">3</span>: [DirectedEdge&#123;from=<span class="number">1</span>, to=<span class="number">3</span>, weight=<span class="number">0.29</span>&#125;]，sum=<span class="number">0.29</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">4</span>: [DirectedEdge&#123;from=<span class="number">6</span>, to=<span class="number">4</span>, weight=-<span class="number">1.25</span>&#125;, DirectedEdge&#123;from=<span class="number">3</span>, to=<span class="number">6</span>, weight=<span class="number">0.52</span>&#125;, DirectedEdge&#123;from=<span class="number">1</span>, to=<span class="number">3</span>, weight=<span class="number">0.29</span>&#125;]，sum=-<span class="number">0.44</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">5</span>: [DirectedEdge&#123;from=<span class="number">4</span>, to=<span class="number">5</span>, weight=<span class="number">0.35</span>&#125;, DirectedEdge&#123;from=<span class="number">6</span>, to=<span class="number">4</span>, weight=-<span class="number">1.25</span>&#125;, DirectedEdge&#123;from=<span class="number">3</span>, to=<span class="number">6</span>, weight=<span class="number">0.52</span>&#125;, DirectedEdge&#123;from=<span class="number">1</span>, to=<span class="number">3</span>, weight=<span class="number">0.29</span>&#125;]，sum=-<span class="number">0.09000000000000002</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">6</span>: [DirectedEdge&#123;from=<span class="number">3</span>, to=<span class="number">6</span>, weight=<span class="number">0.52</span>&#125;, DirectedEdge&#123;from=<span class="number">1</span>, to=<span class="number">3</span>, weight=<span class="number">0.29</span>&#125;]，sum=<span class="number">0.81</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">7</span>: [DirectedEdge&#123;from=<span class="number">4</span>, to=<span class="number">7</span>, weight=<span class="number">0.37</span>&#125;, DirectedEdge&#123;from=<span class="number">6</span>, to=<span class="number">4</span>, weight=-<span class="number">1.25</span>&#125;, DirectedEdge&#123;from=<span class="number">3</span>, to=<span class="number">6</span>, weight=<span class="number">0.52</span>&#125;, DirectedEdge&#123;from=<span class="number">1</span>, to=<span class="number">3</span>, weight=<span class="number">0.29</span>&#125;]，sum=-<span class="number">0.07</span></span><br></pre></td></tr></table></figure>
<p>这个算法会在放松边的时候，出现负数权重环的情况下停止运行。效率肯定是没有上面那个高，但是支持 <code>负权重有向图</code> 的相关问题计算。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9B%BE/" rel="tag"># 图</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%9F%A5%E6%89%BE%E6%A0%91/" rel="prev" title="【编程基础】字典查找树">
                  <i class="fa fa-chevron-left"></i> 【编程基础】字典查找树
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/Computer/Network/1-Find-Computer-Network/" rel="next" title="初识计算机网络">
                  初识计算机网络 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidan</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">218k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:12</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"WeidanLi","repo":"blog-gittalk","client_id":"9e1bc39d00e3c90593cb","client_secret":"f6e987db19088f322e0923bb017b2a907c02bd5d","admin_user":"WeidanLi","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"ff74e5628750fd9c21b5e6bac4f08121"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
