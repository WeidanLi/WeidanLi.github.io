<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="codeva-18Edjlpyk5">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"weidanli.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1}}},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

  <meta name="description" content="字典查找其实做 Java 的应该都知道 Map 和 HashMap，这个类其实就是字典查找实现。他的前身是 Dictionary 以及 Hashtable。因为之前的类库，大部分方法都被加上 synchronized 标记，导致这些类库在运行的时候，效率都不高。所以后期都是使用 HashMap 这一类来进行操作。 不过现在我们要看的是 字典 是什么，我们看书的时候基本都有一个东西叫做 目录，这个东">
<meta property="og:type" content="article">
<meta property="og:title" content="【编程基础】字典查找树">
<meta property="og:url" content="http://weidanli.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%9F%A5%E6%89%BE%E6%A0%91/index.html">
<meta property="og:site_name" content="丹崽的技术博客">
<meta property="og:description" content="字典查找其实做 Java 的应该都知道 Map 和 HashMap，这个类其实就是字典查找实现。他的前身是 Dictionary 以及 Hashtable。因为之前的类库，大部分方法都被加上 synchronized 标记，导致这些类库在运行的时候，效率都不高。所以后期都是使用 HashMap 这一类来进行操作。 不过现在我们要看的是 字典 是什么，我们看书的时候基本都有一个东西叫做 目录，这个东">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152919.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152941.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110153004.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110153139.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110153206.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160356.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160617.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160641.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160703.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160722.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160755.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160819.gif">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160837.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160851.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160911.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160940.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160955.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161013.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161035.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161054.jpeg">
<meta property="article:published_time" content="2020-06-25T09:52:32.000Z">
<meta property="article:modified_time" content="2023-01-27T12:02:55.563Z">
<meta property="article:author" content="Weidan">
<meta property="article:tag" content="java">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152919.jpeg">


<link rel="canonical" href="http://weidanli.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%9F%A5%E6%89%BE%E6%A0%91/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"http://weidanli.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%9F%A5%E6%89%BE%E6%A0%91/","path":"数据结构/字典查找树/","title":"【编程基础】字典查找树"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>【编程基础】字典查找树 | 丹崽的技术博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">丹崽的技术博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">丹崽的计算机知识博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section">分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section">归档</a></li>
        <li class="menu-item menu-item-数据结构"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="section">数据结构</a></li>
        <li class="menu-item menu-item-spring源码"><a href="/spring-sources/" rel="section">Spring源码</a></li>
        <li class="menu-item menu-item-mysql底层"><a href="/mysql/" rel="section">MySQL底层</a></li>
        <li class="menu-item menu-item-tomcat源码"><a href="/tomcat-sources/" rel="section">Tomcat源码</a></li>
        <li class="menu-item menu-item-计算机网络"><a href="/network/" rel="section">计算机网络</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8%E6%9F%A5%E6%89%BE"><span class="nav-number">1.</span> <span class="nav-text">字典查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">2.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">3.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">二叉查找树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%882-3%E6%A0%91%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">平衡查找树（2-3树）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E7%9A%84%E8%8A%82%E7%82%B9%E6%98%AF%E4%B8%80%E4%B8%AA-2%E8%8A%82%E7%82%B9"><span class="nav-number">5.1.</span> <span class="nav-text">如果查找插入的节点是一个 2节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E7%9A%84%E8%8A%82%E7%82%B9%E6%98%AF%E4%B8%80%E4%B8%AA-3%E8%8A%82%E7%82%B9"><span class="nav-number">5.2.</span> <span class="nav-text">如果查找插入的节点是一个 3节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">6.</span> <span class="nav-text">红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0"><span class="nav-number">6.1.</span> <span class="nav-text">红黑树的增删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">6.2.</span> <span class="nav-text">红黑树的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">6.3.</span> <span class="nav-text">红黑树的删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%A7%80%E7%82%B9"><span class="nav-number">6.4.</span> <span class="nav-text">优秀点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-number">7.</span> <span class="nav-text">散列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HASH%E7%A2%B0%E6%92%9E%E6%8B%89%E9%93%BE%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">HASH碰撞拉链法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HASH%E7%A2%B0%E6%92%9E%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">HASH碰撞线性探测法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap%E8%A7%A3%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text">HashMap解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%B9%E9%87%8F%E5%92%8C%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90"><span class="nav-number">8.1.</span> <span class="nav-text">默认容量和平衡因子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E6%8B%89%E9%93%BE%E6%B3%95"><span class="nav-number">8.2.</span> <span class="nav-text">HashMap拉链法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E6%A0%91%E5%8C%96"><span class="nav-number">8.3.</span> <span class="nav-text">HashMap树化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E6%89%A9%E5%AE%B9"><span class="nav-number">8.4.</span> <span class="nav-text">HashMap扩容</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weidan</p>
  <div class="site-description" itemprop="description">计算机基础 计算机网络 Java Vue 前端 后端</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/WeidanLi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;WeidanLi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:toweidan@126.com" title="E-Mail → mailto:toweidan@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/WeidanLi" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%9F%A5%E6%89%BE%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【编程基础】字典查找树
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-25 17:52:32" itemprop="dateCreated datePublished" datetime="2020-06-25T17:52:32+08:00">2020-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-27 20:02:55" itemprop="dateModified" datetime="2023-01-27T20:02:55+08:00">2023-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="字典查找"><a href="#字典查找" class="headerlink" title="字典查找"></a>字典查找</h2><p>其实做 <code>Java</code> 的应该都知道 <code>Map</code> 和 <code>HashMap</code>，这个类其实就是字典查找实现。他的前身是 <code>Dictionary</code> 以及 <code>Hashtable</code>。因为之前的类库，大部分方法都被加上 <code>synchronized</code> 标记，导致这些类库在运行的时候，效率都不高。所以后期都是使用 <code>HashMap</code> 这一类来进行操作。 不过现在我们要看的是 <code>字典</code> 是什么，我们看书的时候基本都有一个东西叫做 <code>目录</code>，这个东西就可以用来查询哪个标题大概在哪一页开始，而我们程序所说的就是这个东西，一个类似于 <code>目录</code> 的 <code>Key-Value</code> 对应的结构，当我们为了实现一些需求的时候需要将一类数据作为 <code>Key</code>，另外一类数据作为 <code>Value</code> 存入从而实现计算的时候，就可以使用 <code>字典</code> 这种数据结构了。 而实现 <code>字典</code> 也有不同方式，我们还是慢慢的一步一步接近，目的就是为了设计一个高性能的字典。 那 <code>API</code> 我们可以定义类似于 <code>Map</code> 接口，然后使用不同的结构来实现我们的功能，首先我们先定义我想要的接口：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dictionary</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 存储键和值，键值均不允许为null.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key 键.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> val 值.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据键获取对应的值，如果不存在返回null.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  V <span class="title function_">get</span><span class="params">(K k)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除指定键的值.并返回被删除的值.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  V <span class="title function_">delete</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断一个键是否存在.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前字典是否为空.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回当前字典的长度.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最小的键.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  K <span class="title function_">min</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最大的键.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  K <span class="title function_">max</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 小于或者等于的最大的指定Key的键</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  K <span class="title function_">floor</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 大于或等于的最小的指定的Key键</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  K <span class="title function_">ceiling</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 小于指定Key键的数量.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">rank</span><span class="params">(K key)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查询第k个键.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  K <span class="title function_">select</span><span class="params">(<span class="type">int</span> k)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回所有键的迭代器.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Iterable&lt;K&gt; <span class="title function_">keys</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>那最简单的就是使用一个 <code>数组</code> 或者 <code>链表</code> 来做存储，然后我们需要的所有操作，都需要通过遍历这个存储来做。由于操作数量还是蛮多的，用 <code>链表</code> 可以很简单的操作，所以我们直接使用链表来做了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnorderedDictionary</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; <span class="keyword">implements</span> <span class="title class_">Dictionary</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node first;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 定义Node内部结构</span></span><br><span class="line"><span class="comment">   * 用来记录Key和Value</span></span><br><span class="line"><span class="comment">   * 顺带有个next指针指向下一条.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V val;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V val, Node next)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.key = key;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 尝试命中同样的Key</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">f</span> <span class="operator">=</span> first; f != <span class="literal">null</span>; f = f.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f.key.equals(key)) &#123;</span><br><span class="line">          f.val = val;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 没有命中，则将链表最后一个设置为新的Node</span></span><br><span class="line">      <span class="type">Node</span> <span class="variable">f</span> <span class="operator">=</span> first;</span><br><span class="line">      <span class="keyword">while</span> (f.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        f = f.next;</span><br><span class="line">      &#125;</span><br><span class="line">      f.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      first = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">f</span> <span class="operator">=</span> first; f != <span class="literal">null</span>; f = f.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (f.key.equals(k)) &#123;</span><br><span class="line">        <span class="keyword">return</span> f.val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Dictionary&lt;Integer, Integer&gt; unordered = <span class="keyword">new</span> <span class="title class_">UnorderedDictionary</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">      unordered.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始查找...&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> unordered.get(<span class="number">10_000</span> - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;查找到：&quot;</span> + val + <span class="string">&quot; 共用时&quot;</span> + (System.nanoTime() - start));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line">开始查找...</span><br><span class="line">查找到：<span class="number">999</span> 共用时<span class="number">143015</span></span><br></pre></td></tr></table></figure>
<p>OK，没有任何辅助的结构，单纯简单粗暴的进行循环遍历，<code>get(K k)</code> 每次都需要通过遍历整个链表，这种实现方式无疑效率是最低的，因为随着链表的长度增加，时间成本将会原来越长。这种好比 <code>选择排序</code> 一样，遍历每个元素与后面的元素依次遍历。这就可以通过证明，我们查找第一个元素需要比较 <code>1次</code>，查找第二个元素需要比较 <code>2次</code>，而如果我们元素刚好在最后一位的话就需要 <code>1 + 2 + 3 + ... + N = N / 2</code> 而 <code>put(K key, V val)</code> 更加离谱，每次加入都需要循环整个链表。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找比较简单，我们可以使用一个 <code>Key[]</code> 和 <code>Value[]</code> 来存储 <code>Key和Value</code>。然后先查询 <code>Key</code> 对应的下标，然后直接命中 <code>Value[indexOf(Key)]</code> 即可，查找 <code>Key</code> 的过程我们就可以使用 <code>二分查找</code> 的方法来查找。至于插入，我们需要根据顺序来进行整容，将原有的 <code>Key和Value数组</code> 进行整理再将新的值插入到对应的位置，查找的过程也是使用到了 <code>二分查找法</code>。 实现并不太难，不写了-,-</p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>那么，通过上面的实践，我们可以再进一步优化成树形结构（其实编程貌似万物都可用树-,-），首先我们先用简单的 <code>二叉查找树</code> 来做，<code>二叉查找</code> 具有以下的特点：</p>
<blockquote>
<ol>
<li> 所有节点的左节点的值都比当前节点小；</li>
<li> 所有节点的右节点的值都比当前节点大；</li>
<li> 左右子树也是二叉查找树；</li>
<li> 没有键值相等的节点。</li>
</ol>
</blockquote>
<p>一颗典型的 <code>二叉查找树</code>：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152919.jpeg"> </p>
<p>那么我们可以很简单的写出实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTDictionary</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; <span class="keyword">implements</span> <span class="title class_">Dictionary</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V val;</span><br><span class="line">    Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V val)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.key = key;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span> &#123;</span><br><span class="line">    root = put(root, key,val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node n, K key, V val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> key.compareTo(n.key);</span><br><span class="line">    <span class="keyword">if</span> (compare == <span class="number">0</span>) &#123;</span><br><span class="line">      n.val = val;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compare &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      n.right = put(n.right, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      n.left = put(n.left, key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(root, k);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> V <span class="title function_">get</span><span class="params">(Node n, K key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> key.compareTo(n.key);</span><br><span class="line">    <span class="keyword">if</span> (compare == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> n.val;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compare &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(n.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> get(n.left, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Dictionary&lt;Integer, Integer&gt; unordered = <span class="keyword">new</span> <span class="title class_">BSTDictionary</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1_000</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 因为目前我们在put的时候并没有对树进行整理</span></span><br><span class="line">      <span class="comment">// 所以防止构建的树形总是最差情况，加入随机数</span></span><br><span class="line">      unordered.put((<span class="type">int</span>) (i + <span class="number">100</span> * Math.random()), i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始查找...&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">val</span> <span class="operator">=</span> unordered.get(<span class="number">1_000</span> - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;查找到：&quot;</span> + val + <span class="string">&quot; 共用时&quot;</span> + (System.nanoTime() - start));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------</span></span><br><span class="line">开始查找...</span><br><span class="line">查找到：<span class="number">915</span> 共用时<span class="number">73567</span></span><br></pre></td></tr></table></figure>
<p>上面的代码是一个及其简单的实现，我们也加入了假设，假设每次插入的 <code>Key</code> 总是均匀分布的。不然这棵树就会变成这样的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110152941.jpeg"> </p>
<p>不仅仅插入的时候会导致这种情况，当我们调用 <code>del</code> 删除节点的时候，也可能会出现这种情况，所以怎么维护这棵树的最佳查找性能，就成了现在的话题了。接下来的结构基本都会围绕这个问题来展开。</p>
<h2 id="平衡查找树（2-3树）"><a href="#平衡查找树（2-3树）" class="headerlink" title="平衡查找树（2-3树）"></a>平衡查找树（2-3树）</h2><p>从上面的 <code>二叉查找树</code> 我们可以看到，即使随机的情况下树的性能还是不错的，但是如果我们顺序插入就会导致上面最后一个图中最坏的情况，当我们需要查询 <code>节点4</code> 的时候，我们一直在右树查找，这么看来性能已经达到了线性的程度了。那这样下去肯定是不行的（带去河边？） 所以有了 <code>平衡查找树</code>，又称为 <code>2-3树</code>，为啥，因为在上面 <code>二叉查找树</code> 中，节点都是 <code>2节点</code>，何为 <code>2</code>，因为每个节点只有2个子节点。那么我们现在插入一个概念就是 <code>3节点</code>，意思就是有些节点他有 <code>3个</code> 子节点。如图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110153004.jpeg"> </p>
<p>我们可以看到，在上面这棵树中，存在 <code>2</code> 个 <code>3节点</code>，<code>3节点</code> 左边的节点是比节点左边的值小的节点，中间则是介于 <code>3节点</code> 两个数值之间，右边就是比 <code>右边的数</code> 大的节点了。那么这种有什么好处，答案就是整容方便。那么怎么整容呢，那就出现两种情况了：</p>
<h3 id="如果查找插入的节点是一个-2节点"><a href="#如果查找插入的节点是一个-2节点" class="headerlink" title="如果查找插入的节点是一个 2节点"></a>如果查找插入的节点是一个 <code>2节点</code></h3><p>如果插入的节点是一个 <code>2节点</code>，那么操作显然要简单很多，我们只需要简单把原来 <code>2节点</code> 转换为 <code>3节点</code> 即可。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110153139.gif"></p>
<h3 id="如果查找插入的节点是一个-3节点"><a href="#如果查找插入的节点是一个-3节点" class="headerlink" title="如果查找插入的节点是一个 3节点"></a>如果查找插入的节点是一个 <code>3节点</code></h3><p>那如果我们需要插入的数是 <code>60</code>，就会碰到 <code>59-69</code> 这个节点，那能咋办，往上生长呗： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110153206.gif"></p>
<p> 那如果碰上父父父节点到根节点都是 <code>3节点</code> 的情况，树的高度就会增加 <code>1</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160356.gif"></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>直接进入红黑树，红黑树如果没有上面 <code>2-3树</code> 的理解的话，完全不知道是什么鬼东西，不过现在看来一切将会清晰： 首先我取上面动图一颗左子树来示例： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160617.jpeg"> 用红黑树表示：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160641.jpeg"> </p>
<p>然后再把红线拉平： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160703.jpeg"> </p>
<p>那么很显然，她就是一颗 <code>2-3树</code> 了，只不过通过连接线的颜色来表示他是 <code>2节点</code> 还是 <code>3节点</code>。 那么很显然为了编码方便，<code>红黑树</code> 加入一些定义：</p>
<ol>
<li> <code>红链接</code> 均为 <code>左链接</code>；</li>
<li> 没有任何一个节点同时和 <code>两个红链接</code> 相连；</li>
<li> 所有叶子都是黑色（叶子是NUIL节点）；</li>
<li> 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点；</li>
<li> 根节点是黑色。</li>
</ol>
<p>同样的，我们需要一个内部 <code>Node</code> 类来表示节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  K key;</span><br><span class="line">  V val;</span><br><span class="line">  Node left, right;</span><br><span class="line">  <span class="comment">// 如果父节点指向我自己的线是红色的</span></span><br><span class="line">  <span class="comment">// 则该值为true</span></span><br><span class="line">  <span class="type">boolean</span> isRed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树的增删"><a href="#红黑树的增删" class="headerlink" title="红黑树的增删"></a>红黑树的增删</h3><p>当我们对树进行插入操作或者删除操作的时候，在 <code>2-3树</code> 说到这棵树就需要通过变型，让树来达到平衡，那么 <code>红黑树</code> 同样也需要进行变型，而变型就是通过 <code>旋转</code> 来做的。 先来解释什么是旋转，旋转又分为 <code>左旋转</code> 和 <code>右旋转</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160722.jpeg"> 那么最后这棵子树就变成这个样子：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160755.jpeg"> </p>
<p>那右旋转基本和左旋一样，这个动图比较好画-,-： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160819.gif"></p>
<hr>
<p>什么时候需要旋转： 其实每次插入的时候，一般都需要旋转，而旋转的地方，就是<strong>我们插入的那一小部分树</strong>： 那我分别插入最小值、最大值和中间值来看这棵树：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160837.jpeg"></p>
<ul>
<li>  插入最小值</li>
</ul>
<p>那么我们现在要插入 <code>9</code>： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160851.jpeg"> </p>
<p>出现了两个红色的左连接，那么我们右旋转一次： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160911.jpeg"> </p>
<p>出现了 <code>10节点</code> 有两个红色链接，那么我们只需要将 <code>10节点</code> 和 <code>根节点</code> 转换颜色即可： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160940.jpeg"> </p>
<p>对应的转换颜色的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">changeColor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">  node.isRed = <span class="literal">true</span>;</span><br><span class="line">  node.left.isRed = <span class="literal">false</span>;</span><br><span class="line">  node.right.isRed = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那 <code>20节点</code> 和 <code>25节点</code> 之间应该是红色才对？没关系，如果我们插入的值是 <code>10 - 20</code> 之间的数值的时候，他不就平衡了咩~</p>
<ul>
<li>  插入中间值</li>
</ul>
<p>那先在刚好，在上一节我们说插入 <code>10 - 20</code> 之间的数值的时候就会平衡，那我们现在就来插入 <code>15</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110160955.jpeg"></p>
<ul>
<li>  插入最大值</li>
</ul>
<p>比方说插入 <code>101</code>：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161013.jpeg"> </p>
<p>出现了右红色链接，这时候需要对 <code>100节点</code> 进行一次左旋转： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161035.jpeg"></p>
<p> 即可达到稳定。 那现在我们就可以来编写 <code>put</code> 的代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RBTDictionary</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; <span class="keyword">implements</span> <span class="title class_">Dictionary</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    K key;</span><br><span class="line">    V val;</span><br><span class="line">    Node left, right;</span><br><span class="line">    <span class="type">boolean</span> isRed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V val, <span class="type">boolean</span> isRed)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.key = key;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">      <span class="built_in">this</span>.isRed = isRed;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 左旋转</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Node <span class="title function_">routateLeft</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先拿到右边的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line">    <span class="comment">// 把右节点的左节点连接到被旋转的父节点的右边；</span></span><br><span class="line">    node.right = right.left;</span><br><span class="line">    <span class="comment">// 然后需要将右边的节点替换成当前传递进来的父节点</span></span><br><span class="line">    right.left = node;</span><br><span class="line">    <span class="comment">// 保留之前父节点的颜色</span></span><br><span class="line">    right.isRed = node.isRed;</span><br><span class="line">    <span class="comment">// 把之前父节点的颜色设置为红色</span></span><br><span class="line">    node.isRed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 右旋转</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Node <span class="title function_">rotateRight</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先拿到左节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">    <span class="comment">// 把左节点的右边连接到被旋转的父节点的左边；</span></span><br><span class="line">    node.left = left.right;</span><br><span class="line">    <span class="comment">// 右边则是传递的父节点</span></span><br><span class="line">    left.right = node;</span><br><span class="line">    <span class="comment">// 左节点称为父节点了，需要保留原来的颜色</span></span><br><span class="line">    left.isRed = node.isRed;</span><br><span class="line">    <span class="comment">// 原来的节点变成右节点了，所以需要染色</span></span><br><span class="line">    node.isRed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 返回旋转之后的左节点</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">changeColor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    node.isRed = <span class="literal">true</span>;</span><br><span class="line">    node.left.isRed = <span class="literal">false</span>;</span><br><span class="line">    node.right.isRed = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.isRed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V val)</span> &#123;</span><br><span class="line">    root = put(root, key, val);</span><br><span class="line">    root.isRed = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node node, K key, V val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较大小，看是要在左边插入还是右边插入</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> key.compareTo(node.key);</span><br><span class="line">    <span class="keyword">if</span> (compare &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.left = put(node.left, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compare &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.right = put(node.right, key, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果出现红色右链接，左旋转</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left)) &#123;</span><br><span class="line">      node = routateLeft(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果连续出现两个左红链接，右旋转</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left)) &#123;</span><br><span class="line">      node = rotateRight(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右都是红色链接，需要将红色网上传递给父节点，当前链接均变成黑色</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right)) &#123;</span><br><span class="line">      changeColor(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(root, k);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> V <span class="title function_">get</span><span class="params">(Node n, K key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> key.compareTo(n.key);</span><br><span class="line">    <span class="keyword">if</span> (compare == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> n.val;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (compare &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(n.right, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> get(n.left, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Dictionary&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">RBTDictionary</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      dic.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树的查找"><a href="#红黑树的查找" class="headerlink" title="红黑树的查找"></a>红黑树的查找</h3><p>红黑树的查找过程上面代码已经体现，跟 <code>普通二叉查找树</code> 的算法一致。</p>
<h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>红黑树的删除，可能会使一个 <code>2节点</code> 的子节点是 <code>NULL</code>，我们为了避免这种事情的发生，需要对树进行调整，分为以下几种情况：</p>
<ol>
<li> 如果根节点不是 <code>2节点</code>，完成；</li>
<li> 如果当前节点的左节点是 <code>2节点</code> 而兄弟节点不是，则可以从 <code>兄弟节点</code> 借一个过来，然后再做删除处理；</li>
<li> 如果当前节点和兄弟节点都是 <code>2节点</code>，则需要从父节点中借出一个节点来辅助变成 <code>4节点</code> 然后再进行删除。</li>
</ol>
<h3 id="优秀点"><a href="#优秀点" class="headerlink" title="优秀点"></a>优秀点</h3><p>那么 <code>红黑树</code> 我们可以看到跟 <code>普通查找二叉树</code> 的查找算法是一致的，那他优秀在哪里。因为规定了 <code>红黑链接</code>，所以他在插入删除的时候，也需要进行特定操作，但是具体的性能基本上都是 <code>logN</code>。即使在最差的情况下，也可以将保持树形的平衡，并且需要移动的节点很少。</p>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表的说法相信用 <code>Java</code> 的多少有听说过 <code>HashMap</code> 的实现原理，那就是通过一个对象，通过 <code>jvm</code> 给定的 <code>hashCode</code> 进行一系列操作得出来一个数组的下标，那么这个 <code>Key对象</code> 就会被散落在对应的数组下标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// j8的HashMap的Hash算法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入的代码片段，通过长度跟hash值计算，得到下标</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">  tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>那么首先将 <code>hashCode</code> 向右移动 <code>16</code> 位，目的是打乱 <code>hashCode</code> 低位，然后再跟数组长度进行与操作，尽可能的散落均匀。 但是，无论再怎么均匀，总会出现 <code>hash碰撞</code> 的情况。那么就有以下两种方式来进行解决：</p>
<h3 id="HASH碰撞拉链法"><a href="#HASH碰撞拉链法" class="headerlink" title="HASH碰撞拉链法"></a>HASH碰撞拉链法</h3><p>我们假设，<code>node[]</code> 是用来存储对象的数组，那么如果我们插入的时候通过计算，得到的数组下标那个位置已经有对象存在了，那这个位置就会形成一个单向链表，即 <code>node.next = newObj</code>，这种就是拉链法，<code>HashMap</code> 在树形化之前也是采用这种方式来解决 <code>Hash碰撞</code> 的问题，那搜索的时候我们就需要拿到下标，然后一步一步 <code>next</code> 的去 <code>equals</code> 再取出对象的 <code>Key对象</code> 和 <code>Value值</code>。</p>
<h3 id="HASH碰撞线性探测法"><a href="#HASH碰撞线性探测法" class="headerlink" title="HASH碰撞线性探测法"></a>HASH碰撞线性探测法</h3><p>如果不使用链表来解决碰撞问题的话，那么可以使用数组探测的形式来做，如果插入一个值，这个值的 <code>hash</code> 过以后对应数组的位置上已经存在其他值了，那么将 <code>hash</code>后的 <code>数组下标</code> 自增1（遇到数组尾部折回去头部），然后再插入。查找的时候就需要先得到 <code>hash</code> 后的数组下标，然后使用比较 <code>equals</code> 接下去数组位去探测是否相同，相同则返回。 删除的时候会显得麻烦很多，因为我们在使用线性探测的时候，会使用 <code>null</code> 来标记查找结束，如果简单粗暴的设置为 <code>null</code>，则被删除后面的元素也会顺带着被删除，正确的做法则是：我删除了这个位置上的元素，那后面的相同 <code>hash</code> 的键值都需要被重新排位。</p>
<h2 id="HashMap解析"><a href="#HashMap解析" class="headerlink" title="HashMap解析"></a>HashMap解析</h2><p><code>HashMap</code> 的面试题如此之多，网络上的文章也很多时候我们只看一半，就我目前来说，就知道达到一定阈值的时候，<code>Hash散列表</code> 会被转换成 <code>红黑树</code>，但是怎么转的，我居然是简单的认为将整个 <code>Hash表</code> 都进行树化，目前看来，<strong>这是错误的看法哈</strong>，其实是 <code>Hash碰撞</code> 的时候，当这个碰撞位的链表达到阈值的时候，<strong>只有</strong>这个链表被转化为 <code>红黑树</code>。 也就是有时候，你的 <code>HashMap</code> 结构是这样的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161054.jpeg"> 不得不说，<code>jdk</code> 开发者的脑袋真的不是 <code>人做的</code> orz。</p>
<h3 id="默认容量和平衡因子"><a href="#默认容量和平衡因子" class="headerlink" title="默认容量和平衡因子"></a>默认容量和平衡因子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认的平衡因子</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">  <span class="comment">// 使用空构造器默认的初始化容量，必须是2的倍数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全参构造</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                         initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">      initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span>  Float.isNaN(loadFactor))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 会将需要使用的容量整容成2的倍数，为了散列的时候更加均匀</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供给构造器整形传递容量的方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n = n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n = n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n = n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n = n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个还算是简单点的，不过需要注意的就是，我们在初始化需要使用的容量的时候，就需要结合我们所需要的容量和计算因子来计算总共需要提供的容量，不然很快就会进入重新拷贝扩容的过程，不过日常我更喜欢使用这个，因为他会帮我算好刚刚好的容量，而且可读性更高：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">使用的时候：Maps.newHashMapWithExpectedSize(list.size());</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; HashMap&lt;K, V&gt; <span class="title function_">newHashMapWithExpectedSize</span><span class="params">(<span class="type">int</span> expectedSize)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity(expectedSize));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">(<span class="type">int</span> expectedSize)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (expectedSize &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    checkNonnegative(expectedSize, <span class="string">&quot;expectedSize&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> expectedSize + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (expectedSize &lt; Ints.MAX_POWER_OF_TWO) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) ((<span class="type">float</span>) expectedSize / <span class="number">0.75F</span> + <span class="number">1.0F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Integer.MAX_VALUE; <span class="comment">// any large value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap拉链法"><a href="#HashMap拉链法" class="headerlink" title="HashMap拉链法"></a>HashMap拉链法</h3><p>那么我们要实现 <code>Hash冲突</code>，也不是很难，首先我们准备一个类，然后重写 <code>hashCode()</code> 方法总是让他返回一个常亮即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABean</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ABean</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>  <span class="title function_">getClass</span><span class="params">()</span> != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">ABean</span> <span class="variable">aBean</span> <span class="operator">=</span> (ABean) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(s, aBean.s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;ABean, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">      map.put(<span class="keyword">new</span> <span class="title class_">ABean</span>(i + <span class="string">&quot;&quot;</span>), i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看 <code>put</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                 <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 我们使用的时候，new HashMap() 其实并没有初始化里面的属性</span></span><br><span class="line">    <span class="comment">// 所以我们在第一次put的时候，会进入这个分支，其实就是初始化</span></span><br><span class="line">    <span class="comment">// table[] 和 容量.</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span>  (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 拉链法，如果拿到的 table[] 对应下标的位置为null，直接就可以插入了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">      tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 进入这个分支就是开始解决冲突的问题：</span></span><br><span class="line">      Node&lt;K,V&gt; e; K k;</span><br><span class="line">      <span class="comment">// hash相同并且equals，说明是同个对象，重新把Value更新</span></span><br><span class="line">      <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">          ((k = p.key) == key  (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">      <span class="comment">// 树形的操作，稍后再看</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">          <span class="comment">// 如果当前 Node 的下一个是 null，插入到下一个</span></span><br><span class="line">          <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">            p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* TREEIFY_THRESHOLD = 8;也就是链表长度为8的时候，就会进行红黑树的转换 */</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">              treeifyBin(tab, hash);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果下一个 Node 不是 null，并且值相等，则更新这个 Node 的 Value 值</span></span><br><span class="line">          <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">              ((k = e.key) == key  (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          p = e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 上面查找后，均在此处更新</span></span><br><span class="line">      <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent  oldValue == <span class="literal">null</span>)</span><br><span class="line">          e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果有必要扩容，则重新扩容。</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">      resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap树化"><a href="#HashMap树化" class="headerlink" title="HashMap树化"></a>HashMap树化</h3><p>在上面的 <code>putVal</code> 方法中有个很重要的分支，就是 <code>if (binCount &gt;= TREEIFY_THRESHOLD - 1)</code> 这个分支，他表示当 <code>链表</code> 的长度大于 <code>8</code> 的时候，进入树化，不过表面说是树化，其实…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment">  * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment">  * 如果表的长度太小了，直接使用扩容方式处理.</span></span><br><span class="line"><span class="comment">  * 如果足够长了（64个，指的是数组的长度而不是我们put的个数），则将表进行树化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">// 如果 hash数组 的长度 &lt; 64，则直接扩容.</span></span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="literal">null</span>  (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">  <span class="comment">// 判断如果 Node 对应的下标 != null 的时候，开始进行整个数组的替换</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 开始循环对应的数组下标，将数组下标从原来的 HashMap$Node </span></span><br><span class="line">    <span class="comment">// 转换为 HashMap$TreeNode，也就是红黑树结构的节点表示.</span></span><br><span class="line">    <span class="comment">// 下面的操作实际上只是将原来的 HashMap$Node 的 Key和Value 值</span></span><br><span class="line">    <span class="comment">// 读取出来，然后连接每一个节点的前后节点，也就是 prev和next 指针</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 双向链表，也就是说，目前树化的时候还保留之前链表的顺序</span></span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">        hd = p;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 将原来的链表对象替换成当前的树节点对象</span></span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">      <span class="comment">// 开始链表节点内的树化</span></span><br><span class="line">      hd.treeify(tab);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个树化函数就都封装在 <code>HashMap$TreeNode</code> 的内部类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前节点的父级</span></span><br><span class="line">  TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">  <span class="comment">// 当前节点的左节点</span></span><br><span class="line">  TreeNode&lt;K,V&gt; left;</span><br><span class="line">  <span class="comment">// 右节点</span></span><br><span class="line">  TreeNode&lt;K,V&gt; right;</span><br><span class="line">  <span class="comment">// 前一个节点，也就是这里是个双向链表，父级还存在下一个的指针</span></span><br><span class="line">  TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">  <span class="comment">// 是否是红色节点</span></span><br><span class="line">  <span class="type">boolean</span> red;</span><br><span class="line">  <span class="comment">// next的值永远是null，有这个参数其实是为了能够实现父级的构造器</span></span><br><span class="line">  TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 两两循环，也就是第0个和第1个参与比较，取大小</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123;</span><br><span class="line">      next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">      <span class="comment">// 清除左右节点</span></span><br><span class="line">      x.left = x.right = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 先确定父节点是第一个</span></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        x.parent = <span class="literal">null</span>;</span><br><span class="line">        x.red = <span class="literal">false</span>;</span><br><span class="line">        root = x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从下标为1的Node开始，均走这个逻辑，意在比较大小</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash;</span><br><span class="line">        Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">          <span class="comment">// 由于我们改写了hashCode方法让其一直返回1，</span></span><br><span class="line">          <span class="comment">// 所以前两个if尝试比较我们自己手写的hashCode的</span></span><br><span class="line">          <span class="comment">// 时候总是不会进入</span></span><br><span class="line">          <span class="type">int</span> dir, ph;</span><br><span class="line">          <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key;</span><br><span class="line">          <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 然后尝试使用Comparable比较顺序，但是还是没有得到期望的比较</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    (kc = comparableClassFor(k)) == <span class="literal">null</span>) </span><br><span class="line">                   (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 开始放弃治疗，使用系统级别的hashCode来计算</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">          TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">          <span class="comment">// 开始按照红黑树的定义连接左右节点，这个循环也是按照左右子树来遍历</span></span><br><span class="line">          <span class="comment">// 由于上面的没有提供 Compareable接口 的类是根据系统的HashCode来做</span></span><br><span class="line">          <span class="comment">// 计算的，我现在修改 ABean 实现 Compareable接口，并且比较属性（修改为Integer）</span></span><br><span class="line">          <span class="comment">// 来做排序。</span></span><br><span class="line">          <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = xp;</span><br><span class="line">            <span class="comment">// 小于或者等于，连接左边</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">              xp.left = x;</span><br><span class="line">            <span class="comment">// 大于连接右边</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              xp.right = x;</span><br><span class="line">            <span class="comment">// 开始调整树的平衡</span></span><br><span class="line">            root = balanceInsertion(root, x);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tieBreakOrder</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>  b == <span class="literal">null</span> </span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 调用系统类计算原生的hashCode</span></span><br><span class="line">      d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">           -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                              TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// 每次进来就进行一次红色的染色，然后再做调整</span></span><br><span class="line">    x.red = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">      <span class="comment">// 只有一层，把这层的节点染成黑色，直接返回作为root节点</span></span><br><span class="line">      <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">        x.red = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果只有两层，就不做调整</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red  (xpp = xp.parent) == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">      <span class="comment">// 判断需要发生插入并且旋转的位置是发生在左子树还是右子树</span></span><br><span class="line">      <span class="comment">// 想要走进来也很简单，就是把我们的示例的递增换成递减就可以了</span></span><br><span class="line">      <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">          xppr.red = <span class="literal">false</span>;</span><br><span class="line">          xp.red = <span class="literal">false</span>;</span><br><span class="line">          xpp.red = <span class="literal">true</span>;</span><br><span class="line">          x = xpp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">            root = rotateLeft(root, x = xp);</span><br><span class="line">            xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xp.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">              xpp.red = <span class="literal">true</span>;</span><br><span class="line">              root = rotateRight(root, xpp);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 那我们是递增的，所以发生在右子树，会经常的走进这里来</span></span><br><span class="line">        <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;<span class="comment">// 情况一：发生了变色，也就是左右两个红色的连接往上浮一层</span></span><br><span class="line">          xppl.red = <span class="literal">false</span>;</span><br><span class="line">          xp.red = <span class="literal">false</span>;</span><br><span class="line">          xpp.red = <span class="literal">true</span>;</span><br><span class="line">          x = xpp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 情况二：判断要发生左旋转还是右旋转</span></span><br><span class="line">          <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">            root = rotateRight(root, x = xp);</span><br><span class="line">            xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">            xp.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">              xpp.red = <span class="literal">true</span>;</span><br><span class="line">              root = rotateLeft(root, xpp);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那这个情况的搜索或者是旋转跟上面简单的红黑树示例差不多，我也就不继续画图了。那我们现在要跳出去，也就是看看 <code>moveRootToFront(tab, root);</code> 做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; tab != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 查找目前root的Key值锁需要存在的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">    <span class="comment">// 可能为空，但只要不是跟之前的值一致，就需要进行替换</span></span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">      Node&lt;K,V&gt; rn;</span><br><span class="line">      tab[index] = root;</span><br><span class="line">      <span class="comment">// 把之前放在链表的第一个往后移动，并且把root节点放在链表的第一位</span></span><br><span class="line">      TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">      <span class="keyword">if</span> ((rn = root.next) != <span class="literal">null</span>)</span><br><span class="line">        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">      <span class="keyword">if</span> (rp != <span class="literal">null</span>)</span><br><span class="line">        rp.next = rn;</span><br><span class="line">      <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        first.prev = root;</span><br><span class="line">      root.next = first;</span><br><span class="line">      root.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">checkInvariants</span><span class="params">(root)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap扩容</h3><p><code>HashMap</code> 在扩容的时候，<code>jdk7</code> 和 <code>jdk8</code> 使用的方式是不一样的，<code>jdk7</code> 要好理解一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.7版本的HashMap：</span></span><br><span class="line"><span class="comment">// 我们在调用put(K key, V value)方法插入数据的时候，就会进入这个方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">// 重点关注这里，可以看到扩容的时候是2倍2倍的在扩容</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">    hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">    bucketIndex = indexFor(hash, table.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">  Entry[] oldTable = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">  <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">    threshold = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的Entry数组</span></span><br><span class="line">  Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">  <span class="comment">// 将旧的数组拷贝过去</span></span><br><span class="line">  transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">  table = newTable;</span><br><span class="line">  threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">  <span class="comment">// 遍历table数组的</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">    <span class="comment">// 遍历链表结构的节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">      Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">      <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">        e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">      <span class="comment">// 在这里链表的顺序发生了转换，也就是头部先插进去，然后尾部再把它顶出去(头插法)</span></span><br><span class="line">      <span class="comment">// 举个例子，比如当前链表是 0 -&gt; 1 -&gt; 2</span></span><br><span class="line">      <span class="comment">// 新的链表会变成 2 -&gt; 1 -&gt; 0</span></span><br><span class="line">      e.next = newTable[i];</span><br><span class="line">      newTable[i] = e;</span><br><span class="line">      e = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们再看看 <code>JDK8</code> 的版本实现，Emm，<code>orz</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">  <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 同样的还是扩容两倍，采用位移的方式来计算</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="comment">// 这上面是计算容量、threshold的，我们只要知道是2倍oldCap即可</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历断开所有oldTab的连接</span></span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          <span class="comment">// 红黑树的尝试分割，通过跟以前相似的方法遍历红黑节点，分割高低位存放</span></span><br><span class="line">          <span class="comment">// 如果分割后的节点个数小于6个，则还原原来的Node链表结构</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          <span class="comment">// 将原来的链表分割为两个链表分割</span></span><br><span class="line">          <span class="comment">// 一个高位，一个低位，</span></span><br><span class="line">          <span class="comment">// 分别声明两个值，head记录链表头部，tail记录尾部</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="comment">// 使用旧的容量进行hash计算，能够保证插入的顺序</span></span><br><span class="line">            <span class="comment">// 这里有个技巧，扩容是2倍的扩容，所以在计算的时候</span></span><br><span class="line">            <span class="comment">// 之前碰撞的hash值要么在原位置，要么在(oldIndex+oldCap)</span></span><br><span class="line">            <span class="comment">// 所以loHead的链表可以看成是保存原来索引的链表而hiHead是保存新数组的链表</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">          <span class="comment">// 直接赋值，loHead在低位索引的数组中，hiHead在高位的数组中</span></span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="prev" title="【编程基础】排序算法">
                  <i class="fa fa-chevron-left"></i> 【编程基础】排序算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E7%AE%97%E6%B3%95/" rel="next" title="图算法">
                  图算法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidan</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">218k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:12</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"liweidan-cn","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
