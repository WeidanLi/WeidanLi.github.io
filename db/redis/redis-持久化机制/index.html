<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          Redis 持久化机制 - 丹崽的技术博客
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 5.2.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>丹崽的技术博客</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <ul>
<li><a href="/">Home</a></li>
</ul>
<h1 id="计算机碎碎念"><a href="#计算机碎碎念" class="headerlink" title="计算机碎碎念"></a>计算机碎碎念</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li><a href="/Computer/Network/1-Find-Computer-Network/">生活中的网络</a></li>
<li><a href="/Computer/Network/2-TCP-IP-PROTOCOL/">TCP/IP之数据链路层</a></li>
<li><a href="/Computer/Network/3-IP/">TCP/IP之网络层IP协议</a></li>
<li><a href="/Computer/Network/4-TCP-UDP/">TCP/IP之传输层TCP/UDP协议</a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><code>redis</code> 数据库，可以直接用来当数据库使用，也可以当系统的缓存使用。但是 <code>redis</code> 大部分数据是存储在内存中的，当服务掉线重启，会造成数据的丢失。当然，<code>redis</code> 是有持久化线程的，我们可以利用这个持久化服务来做数据的持久化，这样当 <code>redis</code> 重启的时候，即可从硬盘重新读取数据，然后进行数据的恢复。 <code>redis</code> 的持久化方式有两种：</p>
<ol>
<li>RDB 方式</li>
<li>AOP方式<h2 id="RDB-方式"><a href="#RDB-方式" class="headerlink" title="RDB 方式"></a>RDB 方式</h2></li>
</ol>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p><code>redis</code> 的 <code>RDB</code> 持久化是通过快照完成的。当符合一定条件的时候，<code>redis</code> 可以将目前的数据生成一份副本存储在硬盘。 <code>redis</code> 执行快照的一句有下面几种：</p>
<ol>
<li>根据配置的规则</li>
<li>用户执行 <code>SAVE</code> 或 <code>BGSAVE</code> 命令</li>
<li>执行 <code>FLUSHALL</code> 命令</li>
<li>执行复制时</li>
</ol>
<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p><code>redis</code> 可以根据用户在配置文件中配置的规则进行定时，定量的持久化。在 <code>redis</code> 的 <code>conf</code> 文件夹中配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 # 表示900秒以内有一个或以上的简直更改时进行快照</span><br><span class="line">save 300 10 </span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<h3 id="执行-SAVE-或-BGSAVE-命令"><a href="#执行-SAVE-或-BGSAVE-命令" class="headerlink" title="执行 SAVE 或 BGSAVE 命令"></a>执行 SAVE 或 BGSAVE 命令</h3><p>执行 <code>SAVE</code> 时，<code>redis</code> 会阻塞所有客户端的请求，然后进行备份。这一过程可能造成 <code>redis</code> 长时间无响应，所以应该尽量避免。 执行 <code>BGSAVE</code> 时，<code>redis</code> 则异步的进行快照，客户端的请求依然可以进行处理。 执行 <code>BGSAVE</code> 时，<code>redis</code> 做了以下的操作：</p>
<ol>
<li>当执行 <code>BGSAVE</code> 的时候，<code>redis</code> 会使用 <code>Fork</code> 函数复制一份当前进程（父）的副本（子）</li>
<li>父进程继续接收客户端的请求，而子进程会将 <code>Fork</code> 的副本写入硬盘的临时文件</li>
<li>当子进程将所有数据写入临时文件时，开始替换旧的 <code>RDB</code> 文件</li>
</ol>
<blockquote>
<p>在进行 Fork 操作的时候，父子进程共享一份内存数据，当父进程需要修改某一片的数据的时候，操作系统会将这一份数据进行复制，保证子进程的读取。所以，Fork 函数执行的时候，RDB文件存储的是这一时刻的数据。 执行这一操作需要确保开启 Linux 系统允许应用程序申请超过可用内存的空间（物理空间和交换空间）。方法是在 .etc/sysctl.conf 加入 vm.overcommit_memory = 1 然后重启系统或执行 sysctl vm.overcommit_memory = 1使配置生效即可。</p>
</blockquote>
<h3 id="执行-FLUSHALL-命令"><a href="#执行-FLUSHALL-命令" class="headerlink" title="执行 FLUSHALL 命令"></a>执行 FLUSHALL 命令</h3><p>执行该命令时，数据库中的所有数据将会被清空，不论配置文件怎么配置，只要执行该命令，<code>redis</code> 就会执行一次快照操作。</p>
<h3 id="执行复制时"><a href="#执行复制时" class="headerlink" title="执行复制时"></a>执行复制时</h3><p>只要配置主从复制时，无论有没有配置规则，都会生成 <code>RDB</code> 文件的快照。用于多个实例之间进行数据的同步。</p>
<h2 id="AOF-方式"><a href="#AOF-方式" class="headerlink" title="AOF 方式"></a>AOF 方式</h2><p>当使用 <code>redis</code> 存储非临时数据时，一般需要开启 <code>AOF</code> 模式来减少每次 <code>redis</code> 的宕机造成的数据损失。<code>AOF</code> 会将 <code>redis</code> 执行的每一条命令都写入硬盘。当然这一过程肯定对性能造成一定影响，不过可以接受。</p>
<h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>默认 <code>redis</code> 是没有开启 <code>AOF</code> 模式的。可以通过配置文件来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>开启 <code>AOF</code> 持久化后将会保存每一条命令，可以通过下面配置来指定持久化文件的名字。 <code>appendfilename append.aof</code></p>
<h3 id="AOF-的实现"><a href="#AOF-的实现" class="headerlink" title="AOF 的实现"></a>AOF 的实现</h3><p><code>AOF</code> 会通过保存客户端发送的通讯协议进行保存，所以会导致 <code>AOF</code> 文件越来越大的问题，因为可能出现的情况是，一个键被设置了，后面又被删除了，这时候完全可以不进行记录这一个过程。那么可以通过配置文件来设置 <code>redis</code> 当 <code>AOF</code> 文件达到一定容量的时候进行 <code>AOF</code> 的优化重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100 # 当前 AOF 文件超过上一次的 AOF 文件的百分之多少时进行重写，如果无重写过则以启动时的文件大小为准</span><br><span class="line">auto-aof-min-size 64mb # 当 AOF 达到这个设置容量时触发重写</span><br></pre></td></tr></table></figure>

<p>除了可以让 <code>redis</code> 自动重写以外，还可以通过传输命令 <code>BGREWRITEAOF</code> 来触发 <code>redis</code> 的重写。</p>
<h3 id="同步硬盘数据"><a href="#同步硬盘数据" class="headerlink" title="同步硬盘数据"></a>同步硬盘数据</h3><p>虽然每次都会重写 <code>AOF</code> 文件，但是此时这个文件并没有真正的写入硬盘中，而是进入硬盘缓存，如果此时系统出现异常宕机，则会导致数据的丢失。系统默认情况下，30秒执行一次同步硬盘操作，但是一般开启 <code>AOF</code> 的应用都不能允许这个情况的出现，这就需要 <code>redis</code> 在写入 <code>AOF</code> 文件的时候，主动触发同步硬盘。我们可以通过以下设置来实现这个目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapendfsync everysec # 每秒执行一次同步操作，也是默认设置</span><br></pre></td></tr></table></figure>

<p>可选值：<code>always</code> <code>no</code> 前者是每次写入 <code>AOF</code> 都进行同步，后者则完全交由系统决定。</p>
<h2 id="持久化使用"><a href="#持久化使用" class="headerlink" title="持久化使用"></a>持久化使用</h2><p><code>redis</code> 允许同时开启两种模式，既保证数据安全又使得备份十分容易。重启 <code>redis</code> 后 <code>redis</code> 会使用 <code>AOF</code> 方式来回复数据，因为 <code>AOF</code> 可能丢失的数据更少。 </p>

</div>




<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="W"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>Weidan</div>
      <div>2019-04-06</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/db/">db</a> <a class="category-link" href="/categories/db/redis/">redis</a>

      <a class="tag-none-link" href="/tags/redis/" rel="tag">#redis</a> <a class="tag-none-link" href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/" rel="tag">#持久化</a> <a class="tag-none-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">#运维</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
