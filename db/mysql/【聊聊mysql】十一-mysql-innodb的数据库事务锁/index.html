<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?66f61662f62178eebb934fa943e5df84";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weidanli.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="一.InnoDB锁并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。MySQL 也一样，当两个 会话 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。">
<meta property="og:type" content="article">
<meta property="og:title" content="【聊聊MySQL】十一.MySQL-InnoDB的数据库事务锁">
<meta property="og:url" content="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81%E4%B8%80-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%94%81/index.html">
<meta property="og:site_name" content="丹崽的技术博客">
<meta property="og:description" content="一.InnoDB锁并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。MySQL 也一样，当两个 会话 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg">
<meta property="article:published_time" content="2020-04-01T01:24:47.000Z">
<meta property="article:modified_time" content="2020-11-12T08:03:23.418Z">
<meta property="article:author" content="Weidan">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg">


<link rel="canonical" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81%E4%B8%80-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%94%81/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【聊聊MySQL】十一.MySQL-InnoDB的数据库事务锁 | 丹崽的技术博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">丹崽的技术博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">丹崽的计算机知识博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-数据结构">

    <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="section">数据结构</a>

  </li>
        <li class="menu-item menu-item-spring源码">

    <a href="/spring-sources/" rel="section">Spring源码</a>

  </li>
        <li class="menu-item menu-item-mysql底层">

    <a href="/mysql/" rel="section">MySQL底层</a>

  </li>
        <li class="menu-item menu-item-tomcat源码">

    <a href="/tomcat-sources/" rel="section">Tomcat源码</a>

  </li>
        <li class="menu-item menu-item-计算机网络">

    <a href="/network/" rel="section">计算机网络</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-InnoDB%E9%94%81"><span class="nav-number">1.</span> <span class="nav-text">一.InnoDB锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%86%99%E5%86%99"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 写写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%AF%BB%E5%92%8C%E5%86%99"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 读和写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">二.锁的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 行级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 表级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%89%B9%E6%AE%8A%E7%9A%84%E9%94%81%E2%80%93AUTO-INC%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 特殊的锁–AUTO-INC锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E6%B7%B1%E5%85%A5%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">三.深入行级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Record-Locks"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Record Locks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-GAP%E9%94%81"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 GAP锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Next-Key-Locks%EF%BC%9A"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 Next-Key Locks：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Insert-Intention-Locks-%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 Insert Intention Locks 插入意向锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E9%9A%90%E5%BD%A2%E7%9A%84%E9%94%81"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 隐形的锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E9%94%81%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">四.锁结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%89%8B%E5%8A%A8%E5%88%86%E5%89%B2%E7%BA%BF"><span class="nav-number">5.</span> <span class="nav-text">五.手动分割线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-SELECT%E8%AF%AD%E5%8F%A5%E5%8A%A0%E9%94%81"><span class="nav-number">6.</span> <span class="nav-text">六.SELECT语句加锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E6%99%AE%E9%80%9A%E8%AF%BB"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 普通读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-xxxxx-%E5%88%86%E5%89%B2%E7%BA%BF%EF%BC%8C%E4%BB%A5%E4%B8%8B%E5%B1%9E%E4%BA%8E-READ-UNCOMMITTED-READ-COMMITTED-%E5%8A%A0%E9%94%81%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">6.xxxxx 分割线，以下属于 READ UNCOMMITTED&#x2F;READ COMMITTED 加锁方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E7%AD%89%E5%80%BC%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">6.3.</span> <span class="nav-text">6.2 等值锁定读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E8%8C%83%E5%9B%B4%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">6.4.</span> <span class="nav-text">6.3 范围锁定读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F%E8%AF%BB"><span class="nav-number">6.5.</span> <span class="nav-text">6.4 全表扫描读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-xxxxx-%E5%88%86%E5%89%B2%E7%BA%BF%EF%BC%8C%E4%BB%A5%E4%B8%8B%E5%B1%9E%E4%BA%8E-REPEATABLE-READ-%E5%8A%A0%E9%94%81%E6%96%B9%E5%BC%8F"><span class="nav-number">6.6.</span> <span class="nav-text">6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-%E7%AD%89%E5%80%BC%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">6.7.</span> <span class="nav-text">6.5 等值锁定读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-%E8%8C%83%E5%9B%B4%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">6.8.</span> <span class="nav-text">6.6 范围锁定读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F"><span class="nav-number">6.9.</span> <span class="nav-text">6.7 全表扫描</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-INSERT%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">7.</span> <span class="nav-text">七.INSERT的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E6%AD%BB%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">七.死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%99%AE%E9%80%9A%E8%B5%84%E6%BA%90%E9%94%81"><span class="nav-number">8.1.</span> <span class="nav-text">7.1 普通资源锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E6%8F%92%E5%85%A5GAP%E9%94%81"><span class="nav-number">8.2.</span> <span class="nav-text">7.2 插入GAP锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95%E9%94%81"><span class="nav-number">8.3.</span> <span class="nav-text">7.3 更新索引锁</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weidan</p>
  <div class="site-description" itemprop="description">计算机基础 计算机网络 Java Vue 前端 后端</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/WeidanLi" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81%E4%B8%80-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【聊聊MySQL】十一.MySQL-InnoDB的数据库事务锁
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-01 09:24:47" itemprop="dateCreated datePublished" datetime="2020-04-01T09:24:47+08:00">2020-04-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-12 16:03:23" itemprop="dateModified" datetime="2020-11-12T16:03:23+08:00">2020-11-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="一-InnoDB锁"><a href="#一-InnoDB锁" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<a id="more"></a>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写"><a href="#1-1-写写" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写"><a href="#1-2-读和写" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型"><a href="#二-锁的类型" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁"><a href="#2-1-行级锁" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁"><a href="#2-2-表级锁" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁"><a href="#2-3-特殊的锁–AUTO-INC锁" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁"><a href="#三-深入行级锁" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks"><a href="#3-1-Record-Locks" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁"><a href="#3-2-GAP锁" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks："><a href="#3-3-Next-Key-Locks：" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁"><a href="#3-4-Insert-Intention-Locks-插入意向锁" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁"><a href="#3-5-隐形的锁" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构"><a href="#四-锁结构" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线"><a href="#五-手动分割线" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁"><a href="#六-SELECT语句加锁" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读"><a href="#6-1-普通读" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读"><a href="#6-2-等值锁定读" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读"><a href="#6-3-范围锁定读" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读"><a href="#6-4-全表扫描读" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读"><a href="#6-5-等值锁定读" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读"><a href="#6-6-范围锁定读" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描"><a href="#6-7-全表扫描" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况"><a href="#七-INSERT的情况" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁"><a href="#七-死锁" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁"><a href="#7-1-普通资源锁" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁"><a href="#7-2-插入GAP锁" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁"><a href="#7-3-更新索引锁" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bmvcc/" rel="prev" title="【聊聊MySQL】十.MySQL-InnoDB的数据库事务的执行之MVCC">
                  <i class="fa fa-chevron-left"></i> 【聊聊MySQL】十.MySQL-InnoDB的数据库事务的执行之MVCC
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/java/Tomcat/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat/" rel="next" title="【Tomcat】一.初识Tomcat以及调试Tomcat">
                  【Tomcat】一.初识Tomcat以及调试Tomcat <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
