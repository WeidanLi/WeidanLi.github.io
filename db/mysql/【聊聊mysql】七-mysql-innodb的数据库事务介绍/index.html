<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          【聊聊MySQL】七.MySQL-InnoDB的数据库事务介绍 - 丹崽的技术博客
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 5.2.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>丹崽的技术博客</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <ul>
<li><a href="/">Home</a></li>
</ul>
<h1 id="计算机碎碎念"><a href="#计算机碎碎念" class="headerlink" title="计算机碎碎念"></a>计算机碎碎念</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li><a href="/Computer/Network/1-Find-Computer-Network/">生活中的网络</a></li>
<li><a href="/Computer/Network/2-TCP-IP-PROTOCOL/">TCP/IP之数据链路层</a></li>
<li><a href="/Computer/Network/3-IP/">TCP/IP之网络层IP协议</a></li>
<li><a href="/Computer/Network/4-TCP-UDP/">TCP/IP之传输层TCP/UDP协议</a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h2 id="一-数据库事务"><a href="#一-数据库事务" class="headerlink" title="一.数据库事务"></a>一.数据库事务</h2><p>刚开始接触编程，要写业务代码的时候我们知道。某个业务动作必须通过 <code>事务</code> 完成对数据库的修改。那么这个事务是什么，<code>InnoDB</code> 是怎样实现事务的要求的，就是接下来老夫想说的内容。</p>
<p>那么事务是怎样的，也就是说，我们在做业务操作的时候，最简单的比如用户下单：</p>
<ol>
<li>用户按下下单的按钮，开始请求后端进行创建订单；</li>
<li><code>Java</code> 开始着手创建订单的信息对象；</li>
<li>与此同时，产品的库存需要扣减比如 iPhone 的库存需要减掉 10 个；</li>
<li>插入订单 + 扣减库存，在 <code>MySQL</code> 中开始执行；</li>
</ol>
<p>结果：此时针对最后一步来看，我们要求两个操作的 <code>SQL</code> 操作必须一并成功，或者一并失败，而且要求数据库发生故障重启的时候数据还存在，而且数据是准确的。</p>
<p>上面这句话包含太多数据库事务的内容了，我们需要一个一个来说。</p>
<p>这个数据库事务的概念就是我们常说的 <code>ACID</code>。</p>
<h3 id="1-1-A-Atomicity-原子性"><a href="#1-1-A-Atomicity-原子性" class="headerlink" title="1.1 A-Atomicity-原子性"></a>1.1 A-Atomicity-原子性</h3><p>每个点我打算拆分上面的执行结果来说，何为 <code>原子性</code>，对应我那句话：<code>插入订单 + 扣减库存必须一并成功，或者一并失败</code>。原子性就是两个操作，插入订单和扣减库存，对应数据库操作是一个 <code>INSERT</code> 和一个 <code>UPDATE</code>，那么这两个语句要么同时都对我们的数据表成功的修改，如果其中有一个失败了，另外一个语句<strong>必须不执行</strong>，<strong>或者已经执行了，必须把修改的数据还原成修改前的数据</strong>。这就说创建订单和扣减库存是一个原子操作。我们的业务不可能允许创建了订单但是没有扣减库存，这时候后续的用户下单了就没有库存发货了，那程序就没什么意义，也不允许扣减了库存但是没有创建订单，要不然赚什么钱。</p>
<p>所以开启事务后，我们必须满足，在这个事务里面执行的语句要么一并成功，要么全部回滚。</p>
<h3 id="1-2-C-Consistency-一致性"><a href="#1-2-C-Consistency-一致性" class="headerlink" title="1.2 C-Consistency-一致性"></a>1.2 C-Consistency-一致性</h3><p>我们知道，我们的业务代码是现实生活的映射，所以在上面扣减库存的动作中，订单下了 15 个 iPhone，那库存就应该扣减 15 个，而不是其他任何数字，更不可能是一个负数。当然现在的编码生活中，留给数据库处理的事情越来越少，所以这个一致性在某种意义上需要我们程序去保证，数据库只能够帮助我们同时执行一个语句并保证他们的执行是原子性的。</p>
<h3 id="1-3-I-Isolation-隔离性"><a href="#1-3-I-Isolation-隔离性" class="headerlink" title="1.3 I-Isolation-隔离性"></a>1.3 I-Isolation-隔离性</h3><p>这个东西可能我们在程序中最注重的了。上面的例子已经不足以说明。那就拓展一下这个例子。</p>
<p>iPhone 总库存只有 <code>15</code> 台，<code>A用户</code> 和 <code>B用户</code> 同时下单 <code>10台</code>。</p>
<p>那么按照我们现实生活中的例子，就是两个用户看谁先排队在前面，就可以先买到 <code>10</code> 台 iPhone。</p>
<p>而程序则不是，他有可能就是这样子：</p>
<p>1160</p>
<p>OK，老板卖了 <code>20台</code> 还剩下 <code>5台</code> 可以卖！</p>
<p>所以，我们在处理这个问题的时候，思路又跟生活靠近，买同一个产品的客户，你们排队，这样上面的流程将会被撸成串行（即排队），而买一个 iPhone 和一个 小米，又可以使用上面的方式处理，即提高处理速度又不担心超卖的问题。</p>
<p>所以如果两个请求在操作同一条数据的时候，即库存这条数据，我们需要让这两个用户读取到的数据是具有隔离性质的，也就是 <code>A用户</code> 完成一系列原子性操作的时候，才可以让 <code>B用户</code> 来执行其他的操作。</p>
<h3 id="1-4-D-Durability-持久性"><a href="#1-4-D-Durability-持久性" class="headerlink" title="1.4 D-Durability-持久性"></a>1.4 D-Durability-持久性</h3><p>这个很好理解，我的业务进行后，数据状态被修改了，当系统关机或者因为其他原因导致突然暂停的时候，我的数据要恢复成宕机前的亚子。</p>
<h2 id="二-InnoDB事务状态"><a href="#二-InnoDB事务状态" class="headerlink" title="二.InnoDB事务状态"></a>二.InnoDB事务状态</h2><p><code>InnoDB</code> 将事务分为五个状态，分别是：<code>活动的</code>、<code>部分提交的</code>、<code>失败的</code>、<code>中止的</code>、<code>提交的</code>。</p>
<p>那这五个状态分别对应哪些事情，</p>
<p><code>活动的</code>：对应开启事务的时候，也就是 <code>START TRANSACTION;</code></p>
<p>此时，如果我们输入 <code>COMMIT</code>，那么该事务就是 <code>部分提交的</code>，为啥，因为在之前说过 <code>BufferPool</code> 的事情，就是说我们提交了修改，修改的还只是内存中的数据，还没有刷到硬盘，所以我们提交的时候就是 <code>部分提交的</code>。</p>
<p>那如果我们 <code>ROLLBACK</code> 呢，就是 <code>中止的</code> 的状态了，也就是回滚修改的时候。</p>
<p><code>失败的</code> 我们日常应该很少遇到，就是我们在事务处于 <code>活动的</code> 或者 <code>部分提交的</code> 状态，导致内存中的数据没有持久化到硬盘（注意是持久化，后面会说），那这个事务就是 <code>失败的</code>。</p>
<p><code>提交的</code> 数据已经完完全全被保存到硬盘中，就算重启或者宕机都不用害怕，就说这个事务是 <code>提交的</code>。</p>
<hr>
<h2 id="三-事务并发执行可能出现的问题"><a href="#三-事务并发执行可能出现的问题" class="headerlink" title="三.事务并发执行可能出现的问题"></a>三.事务并发执行可能出现的问题</h2><p>通常来说，我们的数据库不可能只有一条连接在执行业务。而一条连接就是一个会话（<code>Session</code>），所以下面遇到的问题基本是多个 <code>Session</code> 在同时操作数据库时可能会出现的问题。</p>
<p>那我依然使用上面下单扣库存的例子来说说这些问题：</p>
<h3 id="3-1-脏写（Dirty-Write）"><a href="#3-1-脏写（Dirty-Write）" class="headerlink" title="3.1 脏写（Dirty Write）"></a>3.1 脏写（<code>Dirty Write</code>）</h3><p>脏写基本是所有数据库都不允许的，但是为了完整还是说下。</p>
<p>脏写可以理解成两个用户同时下单一个产品时可能出现的问题：</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
<td align="center">其他操作</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>COMMIT;</code></td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center">由于其他操作失败 <code>ROLLBACK;</code></td>
</tr>
<tr>
<td align="center">此时，<code>A客户</code> 下单了 <code>10</code> 台 iPhone，并且顺利提交，但是 <code>B客户</code> 可能由于其他问题，比如是个黑号，下单失败，回滚了，那么导致 <code>A客户</code> 提交的库存只有 <code>10</code> 台 iPhone 这条修改也不见了，称为 <code>脏写</code>。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>那么怎么看，所有业务，基本都不可能容许这种错误的存在吧，所以下面聊隔离级别的时候，基本排除这个错误的发生。</p>
<h3 id="3-2-脏读（Dirty-Read）"><a href="#3-2-脏读（Dirty-Read）" class="headerlink" title="3.2 脏读（Dirty Read）"></a>3.2 脏读（<code>Dirty Read</code>）</h3><p>如果 <code>客户A</code> 读取到的数据是 <code>客户B</code> 未提交的数据，我们成为 <code>脏读</code>。乍一想扣库存的时候，好像挺好的，但是如果 <code>客户B</code> 回滚数据呢，那数据就完全混乱了呀：</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>10</code></td>
<td align="center">其他操作</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center">由于其他操作失败 <code>ROLLBACK;</code></td>
</tr>
</tbody></table>
<h3 id="3-3-不可重复读（Non-Repeatable-Read）"><a href="#3-3-不可重复读（Non-Repeatable-Read）" class="headerlink" title="3.3 不可重复读（Non-Repeatable Read）"></a>3.3 不可重复读（<code>Non-Repeatable Read</code>）</h3><p>指的是一个事务重复读取一个 <code>SQL</code> 时，因为其他事务提交了数据，导致在此次事务读取两次的数据不一样，成为 <code>不可重复读</code>。<br>| 执行步骤 |           Session_A_客户           |    Session_B客户     |<br>| :——: | :——————————–: | :——————: |<br>|    1     |        <code>START TRANSACTION;</code>        | <code>START TRANSACTION;</code> |<br>|    2     | <code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code> | — |<br>|    3     |        —        | <code>UPDATE prod_stock SET stock = 10</code> |<br>| 4 |     —       |  <code>COMMIT</code> |<br>| 5 | <code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>10</code> |  —|</p>
<h3 id="3-4-幻读（Phantom）"><a href="#3-4-幻读（Phantom）" class="headerlink" title="3.4 幻读（Phantom）"></a>3.4 幻读（<code>Phantom</code>）</h3><p>跟不可重复读有点相似，但是这个是由于另外的事务插入数据导致本事务相同条件读到的数据条目数不一样。</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code></td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">—</td>
<td align="center"><code>INSERT INTO prod_stock VALUES (XXX, 10)</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center"><code>COMMIT</code></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code> 和 <code>10</code></td>
<td align="center">—</td>
</tr>
</tbody></table>
<p><code>客户A</code> 准备下单在读取产品的库存数据，这时候 <code>客户B</code> 新增了一个其他类型的库存记录，<code>客户A</code> 重新查询的时候，被查出来了，所以就可以说这个事务产生了 <code>幻读</code>。</p>
<h2 id="三-InnDB事务隔离级别"><a href="#三-InnDB事务隔离级别" class="headerlink" title="三.InnDB事务隔离级别"></a>三.InnDB事务隔离级别</h2><p>那么 <code>SQL标准</code> 就规定了四种隔离机制，<code>InnoDB</code> 也同时对这几个隔离级别做了支持：</p>
<ol>
<li><code>READ UNCOMMITTED</code>：读未提交的</li>
<li><code>READ COMMITTED</code>：读已提交的</li>
<li><code>REPEATABLE READ</code>：可重复读</li>
<li><code>SERIALIZABLE</code>：串行化</li>
</ol>
<p>当然因为 <code>脏写</code> 产生的后果是 <code>所有业务都不允许发生</code> 的，所以并不在讨论范围之内，因为所有的级别都不允许发生 <code>脏写</code></p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>我们可以看到，<code>串行化</code> 是效果最好的，但是因为是 <code>串行化</code>（俗话说就是每个请求都要排队，等前面做好了再来做下一个），所以性能也是最低的。</p>
<p><code>MySQL_InnoDB</code> 的默认隔离机制是 <code>REPEATABLE READ</code>，也就是可重复读。</p>
<p>可重复读会出现幻读，但是 <code>InnoDB</code> 又把 <code>幻读</code> 的问题给解决了，所以可以说 <code>MySQL_InnoDB</code> 用了一些手段，将数据库事务的性能提高又不影响数据的准确性。</p>
<p>怎么解决的，简单的说在查询的时候判断当前事务开启时，会生成一个 <code>ReadView</code>，这个 <code>ReadView</code> 会记录当前事务的信息，然后在查询的时候，只需要判断查询到的数据的所有版本在当前 <code>ReadView</code> 中是否可见，如果可见就显示出来，不可见就隐藏掉。那么就相当于解决了 <code>REPEATABLE READ</code>：可重复读 这个级别的 <code>幻读</code> 问题。至于怎么比较的，现在还不是时候知道，因为需要先知道 <code>REDO</code> 和 <code>UNDO</code> 日志。</p>
<h2 id="四-完"><a href="#四-完" class="headerlink" title="四. 完"></a>四. 完</h2><p>OK，有了 <code>事务</code> 的一些相关内容以后，就可以来深入 <code>事务</code> 的执行原理了。</p>

</div>




<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="W"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>Weidan</div>
      <div>2020-03-11</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/db/">db</a> <a class="category-link" href="/categories/db/mysql/">mysql</a>

      <a class="tag-none-link" href="/tags/mysql/" rel="tag">#mysql</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
