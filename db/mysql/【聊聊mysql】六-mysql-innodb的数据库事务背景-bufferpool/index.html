<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weidanli.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。  一. BufferPool总览之前在 MySQL-InnoDB体系结构 中有说过，InnoDB 有一个一直在运行的后台线程在跑，目的简单的说就是 异步的同步内存中的数据到硬盘上去。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之">
<meta property="og:type" content="article">
<meta property="og:title" content="【聊聊MySQL】六.MySQL-InnoDB的数据库事务背景_BufferPool">
<meta property="og:url" content="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AD-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E8%83%8C%E6%99%AF-bufferpool/index.html">
<meta property="og:site_name" content="丹崽的技术博客">
<meta property="og:description" content="该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。  一. BufferPool总览之前在 MySQL-InnoDB体系结构 中有说过，InnoDB 有一个一直在运行的后台线程在跑，目的简单的说就是 异步的同步内存中的数据到硬盘上去。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg">
<meta property="article:published_time" content="2020-03-04T08:29:12.000Z">
<meta property="article:modified_time" content="2020-11-10T03:41:33.422Z">
<meta property="article:author" content="Weidan">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png">


<link rel="canonical" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AD-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E8%83%8C%E6%99%AF-bufferpool/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【聊聊MySQL】六.MySQL-InnoDB的数据库事务背景_BufferPool | 丹崽的技术博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">丹崽的技术博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">丹崽的计算机知识博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-BufferPool%E6%80%BB%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">一. BufferPool总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-BufferPool%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">二. BufferPool查询数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-BufferPool%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">三. BufferPool更改数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-BufferPool%E6%80%BB%E8%A7%88-1"><span class="nav-number">4.</span> <span class="nav-text">一. BufferPool总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-BufferPool%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-1"><span class="nav-number">5.</span> <span class="nav-text">二. BufferPool查询数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-BufferPool%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-1"><span class="nav-number">6.</span> <span class="nav-text">三. BufferPool更改数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-BufferPool%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90"><span class="nav-number">7.</span> <span class="nav-text">四. BufferPool内部组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-BufferPool%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%93%BE%E8%A1%A8"><span class="nav-number">7.1.</span> <span class="nav-text">4.1 BufferPool数据页链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-BufferPool-%E7%9A%84-free-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E9%93%BE%E8%A1%A8"><span class="nav-number">7.2.</span> <span class="nav-text">4.2 BufferPool 的 free 数据缓存链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-BufferPool-%E7%9A%84-LRU-%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%EF%BC%89"><span class="nav-number">7.3.</span> <span class="nav-text">4.3 BufferPool 的 LRU 管理（简单理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-LRU-%E6%B7%B1%E5%85%A5%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%EF%BC%89"><span class="nav-number">7.4.</span> <span class="nav-text">4.4 BufferPool 的 LRU 深入管理（数据分区）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-flush-%E9%93%BE%E8%A1%A8"><span class="nav-number">7.5.</span> <span class="nav-text">4.4 BufferPool 的 flush 链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AABufferPool%E5%AE%9E%E4%BE%8B"><span class="nav-number">8.</span> <span class="nav-text">五.配置多个BufferPool实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-BufferPool%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="nav-number">9.</span> <span class="nav-text">六.BufferPool状态监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E9%85%8D%E7%BD%AEBufferPool"><span class="nav-number">10.</span> <span class="nav-text">七. 配置BufferPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%80%BB%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE"><span class="nav-number">10.1.</span> <span class="nav-text">7.1 总大小配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E9%A2%84%E8%AF%BB%E9%85%8D%E7%BD%AE"><span class="nav-number">10.2.</span> <span class="nav-text">7.2 预读配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-LRU%E9%85%8D%E7%BD%AE"><span class="nav-number">10.3.</span> <span class="nav-text">7.3 LRU配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E5%AE%8C%E7%BB%93"><span class="nav-number">11.</span> <span class="nav-text">八.完结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-BufferPool%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90-1"><span class="nav-number">12.</span> <span class="nav-text">四. BufferPool内部组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-BufferPool%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%93%BE%E8%A1%A8-1"><span class="nav-number">12.1.</span> <span class="nav-text">4.1 BufferPool数据页链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-BufferPool%E6%80%BB%E8%A7%88-2"><span class="nav-number">13.</span> <span class="nav-text">一. BufferPool总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-BufferPool%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-2"><span class="nav-number">14.</span> <span class="nav-text">二. BufferPool查询数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-BufferPool%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-2"><span class="nav-number">15.</span> <span class="nav-text">三. BufferPool更改数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-BufferPool%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90-2"><span class="nav-number">16.</span> <span class="nav-text">四. BufferPool内部组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-BufferPool%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%93%BE%E8%A1%A8-2"><span class="nav-number">16.1.</span> <span class="nav-text">4.1 BufferPool数据页链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-BufferPool-%E7%9A%84-free-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E9%93%BE%E8%A1%A8-1"><span class="nav-number">16.2.</span> <span class="nav-text">4.2 BufferPool 的 free 数据缓存链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-BufferPool-%E7%9A%84-LRU-%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%EF%BC%89-1"><span class="nav-number">16.3.</span> <span class="nav-text">4.3 BufferPool 的 LRU 管理（简单理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-LRU-%E6%B7%B1%E5%85%A5%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%EF%BC%89-1"><span class="nav-number">16.4.</span> <span class="nav-text">4.4 BufferPool 的 LRU 深入管理（数据分区）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-flush-%E9%93%BE%E8%A1%A8-1"><span class="nav-number">16.5.</span> <span class="nav-text">4.4 BufferPool 的 flush 链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AABufferPool%E5%AE%9E%E4%BE%8B-1"><span class="nav-number">17.</span> <span class="nav-text">五.配置多个BufferPool实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-BufferPool%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7-1"><span class="nav-number">18.</span> <span class="nav-text">六.BufferPool状态监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E9%85%8D%E7%BD%AEBufferPool-1"><span class="nav-number">19.</span> <span class="nav-text">七. 配置BufferPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%80%BB%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE-1"><span class="nav-number">19.1.</span> <span class="nav-text">7.1 总大小配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E9%A2%84%E8%AF%BB%E9%85%8D%E7%BD%AE-1"><span class="nav-number">19.2.</span> <span class="nav-text">7.2 预读配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-LRU%E9%85%8D%E7%BD%AE-1"><span class="nav-number">19.3.</span> <span class="nav-text">7.3 LRU配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E5%AE%8C%E7%BB%93-1"><span class="nav-number">20.</span> <span class="nav-text">八.完结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-BufferPool%E6%80%BB%E8%A7%88-3"><span class="nav-number">21.</span> <span class="nav-text">一. BufferPool总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-BufferPool%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-3"><span class="nav-number">22.</span> <span class="nav-text">二. BufferPool查询数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-BufferPool%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-3"><span class="nav-number">23.</span> <span class="nav-text">三. BufferPool更改数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-BufferPool%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90-3"><span class="nav-number">24.</span> <span class="nav-text">四. BufferPool内部组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-BufferPool%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%93%BE%E8%A1%A8-3"><span class="nav-number">24.1.</span> <span class="nav-text">4.1 BufferPool数据页链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-BufferPool-%E7%9A%84-free-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E9%93%BE%E8%A1%A8-2"><span class="nav-number">24.2.</span> <span class="nav-text">4.2 BufferPool 的 free 数据缓存链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-BufferPool-%E7%9A%84-LRU-%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%EF%BC%89-2"><span class="nav-number">24.3.</span> <span class="nav-text">4.3 BufferPool 的 LRU 管理（简单理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-LRU-%E6%B7%B1%E5%85%A5%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%EF%BC%89-2"><span class="nav-number">24.4.</span> <span class="nav-text">4.4 BufferPool 的 LRU 深入管理（数据分区）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-flush-%E9%93%BE%E8%A1%A8-2"><span class="nav-number">24.5.</span> <span class="nav-text">4.4 BufferPool 的 flush 链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AABufferPool%E5%AE%9E%E4%BE%8B-2"><span class="nav-number">25.</span> <span class="nav-text">五.配置多个BufferPool实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-BufferPool%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7-2"><span class="nav-number">26.</span> <span class="nav-text">六.BufferPool状态监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E9%85%8D%E7%BD%AEBufferPool-2"><span class="nav-number">27.</span> <span class="nav-text">七. 配置BufferPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%80%BB%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE-2"><span class="nav-number">27.1.</span> <span class="nav-text">7.1 总大小配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E9%A2%84%E8%AF%BB%E9%85%8D%E7%BD%AE-2"><span class="nav-number">27.2.</span> <span class="nav-text">7.2 预读配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-LRU%E9%85%8D%E7%BD%AE-2"><span class="nav-number">27.3.</span> <span class="nav-text">7.3 LRU配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E5%AE%8C%E7%BB%93-2"><span class="nav-number">28.</span> <span class="nav-text">八.完结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-BufferPool%E6%80%BB%E8%A7%88-4"><span class="nav-number">29.</span> <span class="nav-text">一. BufferPool总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-BufferPool%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-4"><span class="nav-number">30.</span> <span class="nav-text">二. BufferPool查询数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-BufferPool%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-4"><span class="nav-number">31.</span> <span class="nav-text">三. BufferPool更改数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-BufferPool%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90-4"><span class="nav-number">32.</span> <span class="nav-text">四. BufferPool内部组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-BufferPool%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%93%BE%E8%A1%A8-4"><span class="nav-number">32.1.</span> <span class="nav-text">4.1 BufferPool数据页链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-BufferPool-%E7%9A%84-free-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E9%93%BE%E8%A1%A8-3"><span class="nav-number">32.2.</span> <span class="nav-text">4.2 BufferPool 的 free 数据缓存链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-BufferPool-%E7%9A%84-LRU-%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%EF%BC%89-3"><span class="nav-number">32.3.</span> <span class="nav-text">4.3 BufferPool 的 LRU 管理（简单理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-LRU-%E6%B7%B1%E5%85%A5%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%EF%BC%89-3"><span class="nav-number">32.4.</span> <span class="nav-text">4.4 BufferPool 的 LRU 深入管理（数据分区）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-flush-%E9%93%BE%E8%A1%A8-3"><span class="nav-number">32.5.</span> <span class="nav-text">4.4 BufferPool 的 flush 链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AABufferPool%E5%AE%9E%E4%BE%8B-3"><span class="nav-number">33.</span> <span class="nav-text">五.配置多个BufferPool实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-BufferPool%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7-3"><span class="nav-number">34.</span> <span class="nav-text">六.BufferPool状态监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E9%85%8D%E7%BD%AEBufferPool-3"><span class="nav-number">35.</span> <span class="nav-text">七. 配置BufferPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%80%BB%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE-3"><span class="nav-number">35.1.</span> <span class="nav-text">7.1 总大小配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E9%A2%84%E8%AF%BB%E9%85%8D%E7%BD%AE-3"><span class="nav-number">35.2.</span> <span class="nav-text">7.2 预读配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-LRU%E9%85%8D%E7%BD%AE-3"><span class="nav-number">35.3.</span> <span class="nav-text">7.3 LRU配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E5%AE%8C%E7%BB%93-3"><span class="nav-number">36.</span> <span class="nav-text">八.完结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-BufferPool-%E7%9A%84-free-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E9%93%BE%E8%A1%A8-4"><span class="nav-number">36.1.</span> <span class="nav-text">4.2 BufferPool 的 free 数据缓存链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-BufferPool%E6%80%BB%E8%A7%88-5"><span class="nav-number">37.</span> <span class="nav-text">一. BufferPool总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-BufferPool%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-5"><span class="nav-number">38.</span> <span class="nav-text">二. BufferPool查询数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-BufferPool%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-5"><span class="nav-number">39.</span> <span class="nav-text">三. BufferPool更改数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-BufferPool%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90-5"><span class="nav-number">40.</span> <span class="nav-text">四. BufferPool内部组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-BufferPool%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%93%BE%E8%A1%A8-5"><span class="nav-number">40.1.</span> <span class="nav-text">4.1 BufferPool数据页链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-BufferPool-%E7%9A%84-free-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E9%93%BE%E8%A1%A8-5"><span class="nav-number">40.2.</span> <span class="nav-text">4.2 BufferPool 的 free 数据缓存链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-BufferPool-%E7%9A%84-LRU-%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%EF%BC%89-4"><span class="nav-number">40.3.</span> <span class="nav-text">4.3 BufferPool 的 LRU 管理（简单理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-LRU-%E6%B7%B1%E5%85%A5%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%EF%BC%89-4"><span class="nav-number">40.4.</span> <span class="nav-text">4.4 BufferPool 的 LRU 深入管理（数据分区）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-flush-%E9%93%BE%E8%A1%A8-4"><span class="nav-number">40.5.</span> <span class="nav-text">4.4 BufferPool 的 flush 链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AABufferPool%E5%AE%9E%E4%BE%8B-4"><span class="nav-number">41.</span> <span class="nav-text">五.配置多个BufferPool实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-BufferPool%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7-4"><span class="nav-number">42.</span> <span class="nav-text">六.BufferPool状态监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E9%85%8D%E7%BD%AEBufferPool-4"><span class="nav-number">43.</span> <span class="nav-text">七. 配置BufferPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%80%BB%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE-4"><span class="nav-number">43.1.</span> <span class="nav-text">7.1 总大小配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E9%A2%84%E8%AF%BB%E9%85%8D%E7%BD%AE-4"><span class="nav-number">43.2.</span> <span class="nav-text">7.2 预读配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-LRU%E9%85%8D%E7%BD%AE-4"><span class="nav-number">43.3.</span> <span class="nav-text">7.3 LRU配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E5%AE%8C%E7%BB%93-4"><span class="nav-number">44.</span> <span class="nav-text">八.完结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-BufferPool-%E7%9A%84-LRU-%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%EF%BC%89-5"><span class="nav-number">44.1.</span> <span class="nav-text">4.3 BufferPool 的 LRU 管理（简单理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-LRU-%E6%B7%B1%E5%85%A5%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%EF%BC%89-5"><span class="nav-number">44.2.</span> <span class="nav-text">4.4 BufferPool 的 LRU 深入管理（数据分区）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-BufferPool%E6%80%BB%E8%A7%88-6"><span class="nav-number">45.</span> <span class="nav-text">一. BufferPool总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-BufferPool%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-6"><span class="nav-number">46.</span> <span class="nav-text">二. BufferPool查询数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-BufferPool%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%9C%E7%94%A8-6"><span class="nav-number">47.</span> <span class="nav-text">三. BufferPool更改数据的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-BufferPool%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90-6"><span class="nav-number">48.</span> <span class="nav-text">四. BufferPool内部组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-BufferPool%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%93%BE%E8%A1%A8-6"><span class="nav-number">48.1.</span> <span class="nav-text">4.1 BufferPool数据页链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-BufferPool-%E7%9A%84-free-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E9%93%BE%E8%A1%A8-6"><span class="nav-number">48.2.</span> <span class="nav-text">4.2 BufferPool 的 free 数据缓存链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-BufferPool-%E7%9A%84-LRU-%E7%AE%A1%E7%90%86%EF%BC%88%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%EF%BC%89-6"><span class="nav-number">48.3.</span> <span class="nav-text">4.3 BufferPool 的 LRU 管理（简单理解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-LRU-%E6%B7%B1%E5%85%A5%E7%AE%A1%E7%90%86%EF%BC%88%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%EF%BC%89-6"><span class="nav-number">48.4.</span> <span class="nav-text">4.4 BufferPool 的 LRU 深入管理（数据分区）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-flush-%E9%93%BE%E8%A1%A8-5"><span class="nav-number">48.5.</span> <span class="nav-text">4.4 BufferPool 的 flush 链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AABufferPool%E5%AE%9E%E4%BE%8B-5"><span class="nav-number">49.</span> <span class="nav-text">五.配置多个BufferPool实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-BufferPool%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7-5"><span class="nav-number">50.</span> <span class="nav-text">六.BufferPool状态监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E9%85%8D%E7%BD%AEBufferPool-5"><span class="nav-number">51.</span> <span class="nav-text">七. 配置BufferPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%80%BB%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE-5"><span class="nav-number">51.1.</span> <span class="nav-text">7.1 总大小配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E9%A2%84%E8%AF%BB%E9%85%8D%E7%BD%AE-5"><span class="nav-number">51.2.</span> <span class="nav-text">7.2 预读配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-LRU%E9%85%8D%E7%BD%AE-5"><span class="nav-number">51.3.</span> <span class="nav-text">7.3 LRU配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E5%AE%8C%E7%BB%93-5"><span class="nav-number">52.</span> <span class="nav-text">八.完结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-BufferPool-%E7%9A%84-flush-%E9%93%BE%E8%A1%A8-6"><span class="nav-number">52.1.</span> <span class="nav-text">4.4 BufferPool 的 flush 链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AABufferPool%E5%AE%9E%E4%BE%8B-6"><span class="nav-number">53.</span> <span class="nav-text">五.配置多个BufferPool实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-BufferPool%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7-6"><span class="nav-number">54.</span> <span class="nav-text">六.BufferPool状态监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E9%85%8D%E7%BD%AEBufferPool-6"><span class="nav-number">55.</span> <span class="nav-text">七. 配置BufferPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%80%BB%E5%A4%A7%E5%B0%8F%E9%85%8D%E7%BD%AE-6"><span class="nav-number">55.1.</span> <span class="nav-text">7.1 总大小配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E9%A2%84%E8%AF%BB%E9%85%8D%E7%BD%AE-6"><span class="nav-number">55.2.</span> <span class="nav-text">7.2 预读配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-LRU%E9%85%8D%E7%BD%AE-6"><span class="nav-number">55.3.</span> <span class="nav-text">7.3 LRU配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E5%AE%8C%E7%BB%93-6"><span class="nav-number">56.</span> <span class="nav-text">八.完结</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weidan</p>
  <div class="site-description" itemprop="description">计算机基础 计算机网络 Java Vue 前端 后端</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AD-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E8%83%8C%E6%99%AF-bufferpool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【聊聊MySQL】六.MySQL-InnoDB的数据库事务背景_BufferPool
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-04 16:29:12" itemprop="dateCreated datePublished" datetime="2020-03-04T16:29:12+08:00">2020-03-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 11:41:33" itemprop="dateModified" datetime="2020-11-10T11:41:33+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览"><a href="#一-BufferPool总览" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用"><a href="#二-BufferPool查询数据的作用" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用"><a href="#三-BufferPool更改数据的作用" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-1"><a href="#一-BufferPool总览-1" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-1"><a href="#二-BufferPool查询数据的作用-1" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-1"><a href="#三-BufferPool更改数据的作用-1" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成"><a href="#四-BufferPool内部组成" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表"><a href="#4-1-BufferPool数据页链表" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表"><a href="#4-2-BufferPool-的-free-数据缓存链表" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表"><a href="#4-4-BufferPool-的-flush-链表" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例"><a href="#五-配置多个BufferPool实例" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控"><a href="#六-BufferPool状态监控" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool"><a href="#七-配置BufferPool" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置"><a href="#7-1-总大小配置" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置"><a href="#7-2-预读配置" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置"><a href="#7-3-LRU配置" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结"><a href="#八-完结" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。 </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-1"><a href="#四-BufferPool内部组成-1" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-1"><a href="#4-1-BufferPool数据页链表-1" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-2"><a href="#一-BufferPool总览-2" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-2"><a href="#二-BufferPool查询数据的作用-2" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-2"><a href="#三-BufferPool更改数据的作用-2" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-2"><a href="#四-BufferPool内部组成-2" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-2"><a href="#4-1-BufferPool数据页链表-2" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-1"><a href="#4-2-BufferPool-的-free-数据缓存链表-1" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-1"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-1" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-1"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-1" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-1"><a href="#4-4-BufferPool-的-flush-链表-1" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-1"><a href="#五-配置多个BufferPool实例-1" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-1"><a href="#六-BufferPool状态监控-1" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-1"><a href="#七-配置BufferPool-1" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-1"><a href="#7-1-总大小配置-1" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-1"><a href="#7-2-预读配置-1" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-1"><a href="#7-3-LRU配置-1" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-1"><a href="#八-完结-1" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-3"><a href="#一-BufferPool总览-3" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-3"><a href="#二-BufferPool查询数据的作用-3" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-3"><a href="#三-BufferPool更改数据的作用-3" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-3"><a href="#四-BufferPool内部组成-3" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-3"><a href="#4-1-BufferPool数据页链表-3" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-2"><a href="#4-2-BufferPool-的-free-数据缓存链表-2" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-2"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-2" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-2"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-2" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-2"><a href="#4-4-BufferPool-的-flush-链表-2" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-2"><a href="#五-配置多个BufferPool实例-2" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-2"><a href="#六-BufferPool状态监控-2" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-2"><a href="#七-配置BufferPool-2" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-2"><a href="#7-1-总大小配置-2" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-2"><a href="#7-2-预读配置-2" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-2"><a href="#7-3-LRU配置-2" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-2"><a href="#八-完结-2" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-4"><a href="#一-BufferPool总览-4" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-4"><a href="#二-BufferPool查询数据的作用-4" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-4"><a href="#三-BufferPool更改数据的作用-4" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-4"><a href="#四-BufferPool内部组成-4" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-4"><a href="#4-1-BufferPool数据页链表-4" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-3"><a href="#4-2-BufferPool-的-free-数据缓存链表-3" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-3"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-3" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-3"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-3" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-3"><a href="#4-4-BufferPool-的-flush-链表-3" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-3"><a href="#五-配置多个BufferPool实例-3" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-3"><a href="#六-BufferPool状态监控-3" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-3"><a href="#七-配置BufferPool-3" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-3"><a href="#7-1-总大小配置-3" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-3"><a href="#7-2-预读配置-3" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-3"><a href="#7-3-LRU配置-3" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-3"><a href="#八-完结-3" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-4"><a href="#4-2-BufferPool-的-free-数据缓存链表-4" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-5"><a href="#一-BufferPool总览-5" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-5"><a href="#二-BufferPool查询数据的作用-5" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-5"><a href="#三-BufferPool更改数据的作用-5" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-5"><a href="#四-BufferPool内部组成-5" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-5"><a href="#4-1-BufferPool数据页链表-5" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-5"><a href="#4-2-BufferPool-的-free-数据缓存链表-5" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-4"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-4" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-4"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-4" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-4"><a href="#4-4-BufferPool-的-flush-链表-4" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-4"><a href="#五-配置多个BufferPool实例-4" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-4"><a href="#六-BufferPool状态监控-4" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-4"><a href="#七-配置BufferPool-4" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-4"><a href="#7-1-总大小配置-4" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-4"><a href="#7-2-预读配置-4" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-4"><a href="#7-3-LRU配置-4" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-4"><a href="#八-完结-4" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-5"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-5" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-5"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-5" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-6"><a href="#一-BufferPool总览-6" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-6"><a href="#二-BufferPool查询数据的作用-6" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-6"><a href="#三-BufferPool更改数据的作用-6" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-6"><a href="#四-BufferPool内部组成-6" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-6"><a href="#4-1-BufferPool数据页链表-6" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-6"><a href="#4-2-BufferPool-的-free-数据缓存链表-6" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-6"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-6" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-6"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-6" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-5"><a href="#4-4-BufferPool-的-flush-链表-5" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-5"><a href="#五-配置多个BufferPool实例-5" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-5"><a href="#六-BufferPool状态监控-5" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-5"><a href="#七-配置BufferPool-5" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-5"><a href="#7-1-总大小配置-5" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-5"><a href="#7-2-预读配置-5" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-5"><a href="#7-3-LRU配置-5" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-5"><a href="#八-完结-5" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-6"><a href="#4-4-BufferPool-的-flush-链表-6" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-6"><a href="#五-配置多个BufferPool实例-6" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-6"><a href="#六-BufferPool状态监控-6" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-6"><a href="#七-配置BufferPool-6" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-6"><a href="#7-1-总大小配置-6" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-6"><a href="#7-2-预读配置-6" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-6"><a href="#7-3-LRU配置-6" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-6"><a href="#八-完结-6" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%BA%94-mysql-%E5%AD%90%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B/" rel="prev" title="【聊聊MySQL】五.MySQL-子查询的过程">
                  <i class="fa fa-chevron-left"></i> 【聊聊MySQL】五.MySQL-子查询的过程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/uncategorized/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AB-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bredo-log/" rel="next" title="">
                   <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
