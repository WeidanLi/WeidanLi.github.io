<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weidanli.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="一.InnoDB存储引擎自从 InnoDB 被 Heikki Tuuri 发明出来以后，可以说安装 MySQL 肯定默认的引擎就是设置 InnoDB，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 InnoDB 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 MyISAM 来进行存储）。 InnoDB 相比其他的存储引擎，拥有以下几个特点：  支持完整 ACID 事">
<meta property="og:type" content="article">
<meta property="og:title" content="【聊聊MySQL】二. InnoDB体系结构">
<meta property="og:url" content="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%BA%8C-innodb%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="丹崽的技术博客">
<meta property="og:description" content="一.InnoDB存储引擎自从 InnoDB 被 Heikki Tuuri 发明出来以后，可以说安装 MySQL 肯定默认的引擎就是设置 InnoDB，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 InnoDB 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 MyISAM 来进行存储）。 InnoDB 相比其他的存储引擎，拥有以下几个特点：  支持完整 ACID 事">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113500.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113519.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113500.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113519.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113500.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113519.png">
<meta property="article:published_time" content="2019-09-05T08:09:51.000Z">
<meta property="article:modified_time" content="2020-11-12T08:03:23.479Z">
<meta property="article:author" content="Weidan">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="InnoDB">
<meta property="article:tag" content="B+">
<meta property="article:tag" content="MasterThread">
<meta property="article:tag" content="Redo">
<meta property="article:tag" content="Undo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg">


<link rel="canonical" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%BA%8C-innodb%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>【聊聊MySQL】二. InnoDB体系结构 | 丹崽的技术博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">丹崽的技术博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">丹崽的计算机知识博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.</span> <span class="nav-text">一.InnoDB存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">二.InnoDB体系架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-1"><span class="nav-number">3.</span> <span class="nav-text">一.InnoDB存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-1"><span class="nav-number">4.</span> <span class="nav-text">二.InnoDB体系架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">2.1 后台线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">2.2 内存使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E4%B8%80%E4%B8%AA%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">三. 一个一直在循环的主线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%AF%8F%E4%B8%80%E7%A7%92%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85"><span class="nav-number">5.1.</span> <span class="nav-text">3.1 每一秒做的事情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%AF%8F%E5%8D%81%E7%A7%92%E5%81%9A%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-number">5.2.</span> <span class="nav-text">3.2 每十秒做的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%90%8E%E5%8F%B0%E6%B4%BB%E5%8A%A8%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">3.3 后台活动线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-7Innodb%E7%9A%84%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.4.</span> <span class="nav-text">3.4 5.7Innodb的后台线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-Double-Write"><span class="nav-number">6.</span> <span class="nav-text">四. Double Write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">7.</span> <span class="nav-text">五. 自适应哈希索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-MySQL-InnoDB%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%A1%8C%E4%B8%BA%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">8.</span> <span class="nav-text">六. MySQL_InnoDB启动关闭行为的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-innodb-fast-shutdown"><span class="nav-number">8.1.</span> <span class="nav-text">6.1 innodb_fast_shutdown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-innodb-force-recovery"><span class="nav-number">8.2.</span> <span class="nav-text">6.2 innodb_force_recovery</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="nav-number">9.</span> <span class="nav-text">五.总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B-1"><span class="nav-number">9.1.</span> <span class="nav-text">2.1 后台线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8-1"><span class="nav-number">9.2.</span> <span class="nav-text">2.2 内存使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-2"><span class="nav-number">10.</span> <span class="nav-text">一.InnoDB存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-2"><span class="nav-number">11.</span> <span class="nav-text">二.InnoDB体系架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B-2"><span class="nav-number">11.1.</span> <span class="nav-text">2.1 后台线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8-2"><span class="nav-number">11.2.</span> <span class="nav-text">2.2 内存使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E4%B8%80%E4%B8%AA%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B-1"><span class="nav-number">12.</span> <span class="nav-text">三. 一个一直在循环的主线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%AF%8F%E4%B8%80%E7%A7%92%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85-1"><span class="nav-number">12.1.</span> <span class="nav-text">3.1 每一秒做的事情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%AF%8F%E5%8D%81%E7%A7%92%E5%81%9A%E7%9A%84%E4%BB%BB%E5%8A%A1-1"><span class="nav-number">12.2.</span> <span class="nav-text">3.2 每十秒做的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%90%8E%E5%8F%B0%E6%B4%BB%E5%8A%A8%E7%BA%BF%E7%A8%8B-1"><span class="nav-number">12.3.</span> <span class="nav-text">3.3 后台活动线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-7Innodb%E7%9A%84%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B-1"><span class="nav-number">12.4.</span> <span class="nav-text">3.4 5.7Innodb的后台线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-Double-Write-1"><span class="nav-number">13.</span> <span class="nav-text">四. Double Write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95-1"><span class="nav-number">14.</span> <span class="nav-text">五. 自适应哈希索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-MySQL-InnoDB%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%A1%8C%E4%B8%BA%E7%9A%84%E9%85%8D%E7%BD%AE-1"><span class="nav-number">15.</span> <span class="nav-text">六. MySQL_InnoDB启动关闭行为的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-innodb-fast-shutdown-1"><span class="nav-number">15.1.</span> <span class="nav-text">6.1 innodb_fast_shutdown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-innodb-force-recovery-1"><span class="nav-number">15.2.</span> <span class="nav-text">6.2 innodb_force_recovery</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93-1"><span class="nav-number">16.</span> <span class="nav-text">五.总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E4%B8%80%E4%B8%AA%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B-2"><span class="nav-number">17.</span> <span class="nav-text">三. 一个一直在循环的主线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%AF%8F%E4%B8%80%E7%A7%92%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85-2"><span class="nav-number">17.1.</span> <span class="nav-text">3.1 每一秒做的事情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%AF%8F%E5%8D%81%E7%A7%92%E5%81%9A%E7%9A%84%E4%BB%BB%E5%8A%A1-2"><span class="nav-number">17.2.</span> <span class="nav-text">3.2 每十秒做的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%90%8E%E5%8F%B0%E6%B4%BB%E5%8A%A8%E7%BA%BF%E7%A8%8B-2"><span class="nav-number">17.3.</span> <span class="nav-text">3.3 后台活动线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-7Innodb%E7%9A%84%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B-2"><span class="nav-number">17.4.</span> <span class="nav-text">3.4 5.7Innodb的后台线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-Double-Write-2"><span class="nav-number">18.</span> <span class="nav-text">四. Double Write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-3"><span class="nav-number">19.</span> <span class="nav-text">一.InnoDB存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-InnoDB%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-3"><span class="nav-number">20.</span> <span class="nav-text">二.InnoDB体系架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B-3"><span class="nav-number">20.1.</span> <span class="nav-text">2.1 后台线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8-3"><span class="nav-number">20.2.</span> <span class="nav-text">2.2 内存使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E4%B8%80%E4%B8%AA%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B-3"><span class="nav-number">21.</span> <span class="nav-text">三. 一个一直在循环的主线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%AF%8F%E4%B8%80%E7%A7%92%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85-3"><span class="nav-number">21.1.</span> <span class="nav-text">3.1 每一秒做的事情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%AF%8F%E5%8D%81%E7%A7%92%E5%81%9A%E7%9A%84%E4%BB%BB%E5%8A%A1-3"><span class="nav-number">21.2.</span> <span class="nav-text">3.2 每十秒做的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%90%8E%E5%8F%B0%E6%B4%BB%E5%8A%A8%E7%BA%BF%E7%A8%8B-3"><span class="nav-number">21.3.</span> <span class="nav-text">3.3 后台活动线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-7Innodb%E7%9A%84%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B-3"><span class="nav-number">21.4.</span> <span class="nav-text">3.4 5.7Innodb的后台线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-Double-Write-3"><span class="nav-number">22.</span> <span class="nav-text">四. Double Write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95-2"><span class="nav-number">23.</span> <span class="nav-text">五. 自适应哈希索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-MySQL-InnoDB%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%A1%8C%E4%B8%BA%E7%9A%84%E9%85%8D%E7%BD%AE-2"><span class="nav-number">24.</span> <span class="nav-text">六. MySQL_InnoDB启动关闭行为的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-innodb-fast-shutdown-2"><span class="nav-number">24.1.</span> <span class="nav-text">6.1 innodb_fast_shutdown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-innodb-force-recovery-2"><span class="nav-number">24.2.</span> <span class="nav-text">6.2 innodb_force_recovery</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93-2"><span class="nav-number">25.</span> <span class="nav-text">五.总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95-3"><span class="nav-number">26.</span> <span class="nav-text">五. 自适应哈希索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-MySQL-InnoDB%E5%90%AF%E5%8A%A8%E5%85%B3%E9%97%AD%E8%A1%8C%E4%B8%BA%E7%9A%84%E9%85%8D%E7%BD%AE-3"><span class="nav-number">27.</span> <span class="nav-text">六. MySQL_InnoDB启动关闭行为的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-innodb-fast-shutdown-3"><span class="nav-number">27.1.</span> <span class="nav-text">6.1 innodb_fast_shutdown</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-innodb-force-recovery-3"><span class="nav-number">27.2.</span> <span class="nav-text">6.2 innodb_force_recovery</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93-3"><span class="nav-number">28.</span> <span class="nav-text">五.总结</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weidan</p>
  <div class="site-description" itemprop="description">计算机基础 计算机网络 Java Vue 前端 后端</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%BA%8C-innodb%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【聊聊MySQL】二. InnoDB体系结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-05 16:09:51" itemprop="dateCreated datePublished" datetime="2019-09-05T16:09:51+08:00">2019-09-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-12 16:03:23" itemprop="dateModified" datetime="2020-11-12T16:03:23+08:00">2020-11-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="一-InnoDB存储引擎"><a href="#一-InnoDB存储引擎" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li>支持完整 <code>ACID</code> 事务；</li>
<li>行锁设计，可提高并发；</li>
<li>支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li>支持外键；</li>
<li>优秀的 <code>B+</code> 索引。<a id="more"></a>
<h2 id="二-InnoDB体系架构"><a href="#二-InnoDB体系架构" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2></li>
</ol>
<h2 id="一-InnoDB存储引擎-1"><a href="#一-InnoDB存储引擎-1" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li>支持完整 <code>ACID</code> 事务；</li>
<li>行锁设计，可提高并发；</li>
<li>支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li>支持外键；</li>
<li>优秀的 <code>B+</code> 索引。<!--more-->
<h2 id="二-InnoDB体系架构-1"><a href="#二-InnoDB体系架构-1" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg"> <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程"><a href="#2-1-后台线程" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li><code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li><code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li>…</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;99, Main thread ID&#x3D;123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存使用"><a href="#2-2-内存使用" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li>缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li>重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li>额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.64 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113500.png"></p>
<h2 id="三-一个一直在循环的主线程"><a href="#三-一个一直在循环的主线程" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情"><a href="#3-1-每一秒做的事情" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个来看看吧：</p>
<ol>
<li>刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li>合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li>刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务"><a href="#3-2-每十秒做的任务" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程"><a href="#3-3-后台活动线程" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程"><a href="#3-4-5-7Innodb的后台线程" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write"><a href="#四-Double-Write" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113519.png"></p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_dblwr%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 1865308</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 248718</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure>

<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引"><a href="#五-自适应哈希索引" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">691</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">112</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">307</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">481</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">463</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">281</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">410</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> <span class="keyword">hash</span> searches/s, <span class="number">42.04</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置"><a href="#六-MySQL-InnoDB启动关闭行为的配置" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown"><a href="#6-1-innodb-fast-shutdown" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery"><a href="#6-2-innodb-force-recovery" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。 <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程-1"><a href="#2-1-后台线程-1" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li><code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li><code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li>…</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;99, Main thread ID&#x3D;123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存使用-1"><a href="#2-2-内存使用-1" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li>缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li>重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li>额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.64 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 </p>
<h2 id="一-InnoDB存储引擎-2"><a href="#一-InnoDB存储引擎-2" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li>支持完整 <code>ACID</code> 事务；</li>
<li>行锁设计，可提高并发；</li>
<li>支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li>支持外键；</li>
<li>优秀的 <code>B+</code> 索引。<!--more-->
<h2 id="二-InnoDB体系架构-2"><a href="#二-InnoDB体系架构-2" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg"> <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程-2"><a href="#2-1-后台线程-2" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li><code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li><code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li>…</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;99, Main thread ID&#x3D;123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存使用-2"><a href="#2-2-内存使用-2" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li>缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li>重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li>额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.64 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113500.png"></p>
<h2 id="三-一个一直在循环的主线程-1"><a href="#三-一个一直在循环的主线程-1" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情-1"><a href="#3-1-每一秒做的事情-1" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个来看看吧：</p>
<ol>
<li>刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li>合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li>刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务-1"><a href="#3-2-每十秒做的任务-1" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程-1"><a href="#3-3-后台活动线程-1" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程-1"><a href="#3-4-5-7Innodb的后台线程-1" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write-1"><a href="#四-Double-Write-1" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113519.png"></p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_dblwr%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 1865308</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 248718</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure>

<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引-1"><a href="#五-自适应哈希索引-1" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">691</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">112</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">307</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">481</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">463</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">281</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">410</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> <span class="keyword">hash</span> searches/s, <span class="number">42.04</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置-1"><a href="#六-MySQL-InnoDB启动关闭行为的配置-1" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown-1"><a href="#6-1-innodb-fast-shutdown-1" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery-1"><a href="#6-2-innodb-force-recovery-1" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结-1"><a href="#五-总结-1" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。</p>
<h2 id="三-一个一直在循环的主线程-2"><a href="#三-一个一直在循环的主线程-2" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情-2"><a href="#3-1-每一秒做的事情-2" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个来看看吧：</p>
<ol>
<li>刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li>合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li>刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务-2"><a href="#3-2-每十秒做的任务-2" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程-2"><a href="#3-3-后台活动线程-2" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程-2"><a href="#3-4-5-7Innodb的后台线程-2" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write-2"><a href="#四-Double-Write-2" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 </p>
<h2 id="一-InnoDB存储引擎-3"><a href="#一-InnoDB存储引擎-3" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li>支持完整 <code>ACID</code> 事务；</li>
<li>行锁设计，可提高并发；</li>
<li>支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li>支持外键；</li>
<li>优秀的 <code>B+</code> 索引。<!--more-->
<h2 id="二-InnoDB体系架构-3"><a href="#二-InnoDB体系架构-3" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg"> <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程-3"><a href="#2-1-后台线程-3" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li><code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li><code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li>…</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;99, Main thread ID&#x3D;123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存使用-3"><a href="#2-2-内存使用-3" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li>缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li>重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li>额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.64 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113500.png"></p>
<h2 id="三-一个一直在循环的主线程-3"><a href="#三-一个一直在循环的主线程-3" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情-3"><a href="#3-1-每一秒做的事情-3" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个来看看吧：</p>
<ol>
<li>刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li>合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li>刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务-3"><a href="#3-2-每十秒做的任务-3" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程-3"><a href="#3-3-后台活动线程-3" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程-3"><a href="#3-4-5-7Innodb的后台线程-3" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write-3"><a href="#四-Double-Write-3" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113519.png"></p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_dblwr%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 1865308</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 248718</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure>

<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引-2"><a href="#五-自适应哈希索引-2" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">691</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">112</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">307</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">481</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">463</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">281</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">410</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> <span class="keyword">hash</span> searches/s, <span class="number">42.04</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置-2"><a href="#六-MySQL-InnoDB启动关闭行为的配置-2" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown-2"><a href="#6-1-innodb-fast-shutdown-2" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery-2"><a href="#6-2-innodb-force-recovery-2" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结-2"><a href="#五-总结-2" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。</p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_dblwr%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 1865308</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 248718</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure>

<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引-3"><a href="#五-自适应哈希索引-3" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">691</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">112</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">307</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">481</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">463</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">281</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">410</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> <span class="keyword">hash</span> searches/s, <span class="number">42.04</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置-3"><a href="#六-MySQL-InnoDB启动关闭行为的配置-3" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown-3"><a href="#6-1-innodb-fast-shutdown-3" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery-3"><a href="#6-2-innodb-force-recovery-3" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结-3"><a href="#五-总结-3" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mysql/" rel="tag"># mysql</a>
              <a href="/tags/InnoDB/" rel="tag"># InnoDB</a>
              <a href="/tags/B/" rel="tag"># B+</a>
              <a href="/tags/MasterThread/" rel="tag"># MasterThread</a>
              <a href="/tags/Redo/" rel="tag"># Redo</a>
              <a href="/tags/Undo/" rel="tag"># Undo</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%80-mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="prev" title="【聊聊MySQL】一. MySQL存储引擎">
                  <i class="fa fa-chevron-left"></i> 【聊聊MySQL】一. MySQL存储引擎
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%89-innodb%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/" rel="next" title="【聊聊MySQL】三.InnoDB的表结构和行记录结构">
                  【聊聊MySQL】三.InnoDB的表结构和行记录结构 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
