<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/favicon.png" />
    

    <title>
        
          【聊聊MySQL】二. InnoDB体系结构 - 丹崽的技术博客
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/css/book.css">

    
<script src="/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 5.2.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/">
    <img src="/favicon.png">
    <span>丹崽的技术博客</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <ul>
<li><a href="/">Home</a></li>
</ul>
<h1 id="计算机碎碎念"><a href="#计算机碎碎念" class="headerlink" title="计算机碎碎念"></a>计算机碎碎念</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul>
<li><a href="/Computer/Network/1-Find-Computer-Network/">生活中的网络</a></li>
<li><a href="/Computer/Network/2-TCP-IP-PROTOCOL/">TCP/IP之数据链路层</a></li>
<li><a href="/Computer/Network/3-IP/">TCP/IP之网络层IP协议</a></li>
<li><a href="/Computer/Network/4-TCP-UDP/">TCP/IP之传输层TCP/UDP协议</a></li>
</ul>

</div>


<script src="/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h2 id="一-InnoDB存储引擎"><a href="#一-InnoDB存储引擎" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li>支持完整 <code>ACID</code> 事务；</li>
<li>行锁设计，可提高并发；</li>
<li>支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li>支持外键；</li>
<li>优秀的 <code>B+</code> 索引。</li>
</ol>
<h2 id="二-InnoDB体系架构"><a href="#二-InnoDB体系架构" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2><p>334 <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程"><a href="#2-1-后台线程" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li><code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li><code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li>…</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;99, Main thread ID&#x3D;123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存使用"><a href="#2-2-内存使用" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li>缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li>重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li>额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.64 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 15934</p>
<h2 id="三-一个一直在循环的主线程"><a href="#三-一个一直在循环的主线程" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情"><a href="#3-1-每一秒做的事情" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个来看看吧：</p>
<ol>
<li>刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li>合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li>刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务"><a href="#3-2-每十秒做的任务" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程"><a href="#3-3-后台活动线程" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程"><a href="#3-4-5-7Innodb的后台线程" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write"><a href="#四-Double-Write" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 34961</p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_dblwr%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 1865308</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 248718</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure>

<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引"><a href="#五-自适应哈希索引" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">691</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">112</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">307</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">481</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">463</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">281</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">410</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> <span class="keyword">hash</span> searches/s, <span class="number">42.04</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置"><a href="#六-MySQL-InnoDB启动关闭行为的配置" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown"><a href="#6-1-innodb-fast-shutdown" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery"><a href="#6-2-innodb-force-recovery" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。</p>

</div>




<script src="/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="W"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>Weidan</div>
      <div>2019-09-05</div>
    </div>
  </div>

  
    <div class="divider"></div>

    <div class="link">
      <a class="category-link" href="/categories/db/">db</a> <a class="category-link" href="/categories/db/mysql/">mysql</a>

      <a class="tag-none-link" href="/tags/B/" rel="tag">#B+</a> <a class="tag-none-link" href="/tags/InnoDB/" rel="tag">#InnoDB</a> <a class="tag-none-link" href="/tags/MasterThread/" rel="tag">#MasterThread</a> <a class="tag-none-link" href="/tags/Redo/" rel="tag">#Redo</a> <a class="tag-none-link" href="/tags/Undo/" rel="tag">#Undo</a> <a class="tag-none-link" href="/tags/mysql/" rel="tag">#mysql</a>
    </div>
    
  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/js/book.js"></script>
