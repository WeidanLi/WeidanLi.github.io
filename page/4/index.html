<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weidanli.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
<meta property="og:type" content="website">
<meta property="og:title" content="丹崽的技术博客">
<meta property="og:url" content="http://weidanli.github.io/page/4/index.html">
<meta property="og:site_name" content="丹崽的技术博客">
<meta property="og:description" content="计算机基础 计算机网络 Java Vue 前端 后端">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Weidan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://weidanli.github.io/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>丹崽的技术博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">丹崽的技术博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">丹崽的计算机知识博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weidan</p>
  <div class="site-description" itemprop="description">计算机基础 计算机网络 Java Vue 前端 后端</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/frame/Spring%E6%BA%90%E7%A0%81/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84beanfactory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/frame/Spring%E6%BA%90%E7%A0%81/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84beanfactory/" class="post-title-link" itemprop="url">【Spring源码】第三步：从一个简单的BeanFactory开始</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-03 19:41:51" itemprop="dateCreated datePublished" datetime="2019-12-03T19:41:51+08:00">2019-12-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 14:49:03" itemprop="dateModified" datetime="2020-11-10T14:49:03+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/" itemprop="url" rel="index"><span itemprop="name">frame</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/Spring%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">Spring源码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简单的DEMO"><a href="#简单的DEMO" class="headerlink" title="简单的DEMO"></a>简单的DEMO</h2><p>看源码，不就是打断点，看断点代码，重复这个步骤。 然而要运行这个容器，我需要一个简单的例子： 一个简单的 <code>Bean</code>，只有一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的测试Bean.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weidan &lt;emailto&gt;toweidan@126.com&lt;/emailto&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;TestBean&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;WeidanLi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>主要通过构造函数来构造了 <code>Bean</code> 的值。 还有一个程序入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的IOC测试用例.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weidan &lt;emailto&gt;toweidan@126.com&lt;/emailto&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyXmlFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line">    TestBean bean = bf.getBean(TestBean.class);</span><br><span class="line">    Assert.hasLength(bean.getName(), <span class="string">&quot;没有获取到配置文件的配置信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了 <code>XmlBeanFactory</code>，一个简单的 <code>BeanFactory</code> 实例。这个类提供了最基础的 <code>IOC</code> 功能，少了消息通知，生命周期等等这些东西，在日常中都不用这个类，使用 <code>ApplicationContext</code>，他是增强很多功能的 <code>BeanFactory</code>，不过作为出入门的菜逼，我就是用 <code>XmlBeanFactory</code> 这个好了，也是很多 <code>Spring</code> 源码书籍推荐的入门类。 可以看进入的代码，简单的创建容器，指定配置文件，然后断言我在配置文件中注入的值。 可以先看看这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到这个类的作者是大名鼎鼎的 <code>Rod Johnson</code>，这是一个左脑用来拿计算机博士，右脑用来拿音乐博士的男人，简直就是我的光头偶像。后来创建了 <code>Spring</code> 项目以及维护的公司，所以说这个类其实已经很元老级别了。然后我现在的光标就在他的署名上闪动，想想还有点小激动。</p>
</blockquote>
<p>我们调用的构造函数传递一个 <code>Resource</code> 接口参数，这个参数我并不打算深究，因为他就是一个简单的工具接口（在 <code>spring-core</code> 模块中定义的），里面指定了配置文件从哪个流出来（所以我们不仅仅可以使用 <code>File</code> 流，只要是 <code>IO流</code> 都可以作为配置文件的来源。） 除开构造函数构造的参数，他还直接定义了一个 <code>XmlBeanDefinitionReader</code>，就是一个配置文件的读取器，用来读取、解析配置内容的。然而这个类，先放一边，只需要看他在哪里调用的注册就可以了，因为我现在的目的不是怎么解析 <code>xml</code> 文件，而是怎么注册 <code>Bean</code>。</p>
<h2 id="XmlBeanDefinitionReader解析ClassBean"><a href="#XmlBeanDefinitionReader解析ClassBean" class="headerlink" title="XmlBeanDefinitionReader解析ClassBean"></a>XmlBeanDefinitionReader解析ClassBean</h2><p>现在我们把 <code>debug</code> 指针进入这个 <code>XmlBeanDefinitionReader.loadBeanDefinitions(resource)</code> 里边去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用封装编码的对象 <code>EncodedResource</code> 继续调用了同名的重载函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">    <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">            <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粘了代码觉得挺长的，那么通过调用 <code>loadBeanDefinitions(EncodedResource encodedResource)</code> 开始进行当前 <code>BeanFactory</code> 进行检测，如果已经存在了同样的解析进程，则抛出异常，这个异常我先放着，应该大概意思就是重复注册了配置文件吧？因为我们知道 <code>applicationContext</code> 是可以导入其他配置的，如果同样的配置注册了两次那么以为着配置有问题，则抛出异常。我们可以试一下： 修改 <code>applicationContext.xml</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- import他自己 --&gt;</span><br><span class="line">    &lt;import resource&#x3D;&quot;applicationContext.xml&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;TestBean&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;WeidanLi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>运行： </p>
<h2 id="简单的DEMO-1"><a href="#简单的DEMO-1" class="headerlink" title="简单的DEMO"></a>简单的DEMO</h2><p>看源码，不就是打断点，看断点代码，重复这个步骤。 然而要运行这个容器，我需要一个简单的例子： 一个简单的 <code>Bean</code>，只有一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的测试Bean.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weidan &lt;emailto&gt;toweidan@126.com&lt;/emailto&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;TestBean&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;WeidanLi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>主要通过构造函数来构造了 <code>Bean</code> 的值。 还有一个程序入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的IOC测试用例.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weidan &lt;emailto&gt;toweidan@126.com&lt;/emailto&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyXmlFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line">    TestBean bean = bf.getBean(TestBean.class);</span><br><span class="line">    Assert.hasLength(bean.getName(), <span class="string">&quot;没有获取到配置文件的配置信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了 <code>XmlBeanFactory</code>，一个简单的 <code>BeanFactory</code> 实例。这个类提供了最基础的 <code>IOC</code> 功能，少了消息通知，生命周期等等这些东西，在日常中都不用这个类，使用 <code>ApplicationContext</code>，他是增强很多功能的 <code>BeanFactory</code>，不过作为出入门的菜逼，我就是用 <code>XmlBeanFactory</code> 这个好了，也是很多 <code>Spring</code> 源码书籍推荐的入门类。 可以看进入的代码，简单的创建容器，指定配置文件，然后断言我在配置文件中注入的值。 可以先看看这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到这个类的作者是大名鼎鼎的 <code>Rod Johnson</code>，这是一个左脑用来拿计算机博士，右脑用来拿音乐博士的男人，简直就是我的光头偶像。后来创建了 <code>Spring</code> 项目以及维护的公司，所以说这个类其实已经很元老级别了。然后我现在的光标就在他的署名上闪动，想想还有点小激动。</p>
</blockquote>
<p>我们调用的构造函数传递一个 <code>Resource</code> 接口参数，这个参数我并不打算深究，因为他就是一个简单的工具接口（在 <code>spring-core</code> 模块中定义的），里面指定了配置文件从哪个流出来（所以我们不仅仅可以使用 <code>File</code> 流，只要是 <code>IO流</code> 都可以作为配置文件的来源。） 除开构造函数构造的参数，他还直接定义了一个 <code>XmlBeanDefinitionReader</code>，就是一个配置文件的读取器，用来读取、解析配置内容的。然而这个类，先放一边，只需要看他在哪里调用的注册就可以了，因为我现在的目的不是怎么解析 <code>xml</code> 文件，而是怎么注册 <code>Bean</code>。</p>
<h2 id="XmlBeanDefinitionReader解析ClassBean-1"><a href="#XmlBeanDefinitionReader解析ClassBean-1" class="headerlink" title="XmlBeanDefinitionReader解析ClassBean"></a>XmlBeanDefinitionReader解析ClassBean</h2><p>现在我们把 <code>debug</code> 指针进入这个 <code>XmlBeanDefinitionReader.loadBeanDefinitions(resource)</code> 里边去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用封装编码的对象 <code>EncodedResource</code> 继续调用了同名的重载函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">    <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">            <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粘了代码觉得挺长的，那么通过调用 <code>loadBeanDefinitions(EncodedResource encodedResource)</code> 开始进行当前 <code>BeanFactory</code> 进行检测，如果已经存在了同样的解析进程，则抛出异常，这个异常我先放着，应该大概意思就是重复注册了配置文件吧？因为我们知道 <code>applicationContext</code> 是可以导入其他配置的，如果同样的配置注册了两次那么以为着配置有问题，则抛出异常。我们可以试一下： 修改 <code>applicationContext.xml</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- import他自己 --&gt;</span><br><span class="line">    &lt;import resource&#x3D;&quot;applicationContext.xml&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;TestBean&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;WeidanLi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>运行： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144719.png"> </p>
<p>果然，在第一次解析的时候，拿到了我的 <code>import</code> 节点，继续调用当前方法来注册的时候，因为文件是同一个，<code>Set&lt;EncodedResource&gt;.add()</code> 的时候添加失败了，抛出异常，直接解析失败。而 <code>Set</code> 这个实例是存储在当前线程的<code>ThreadLocal</code> 中的，防止重复读取配置文件。可以在这里看出来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;EncodedResource&gt; currentResources &#x3D; this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">if (currentResources &#x3D;&#x3D; null) &#123;</span><br><span class="line">    currentResources &#x3D; new HashSet&lt;&gt;(4);</span><br><span class="line">    this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进入一个 <code>try-catch</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步就是拆解上一步封装的 <code>EncodedResource</code> 拿到我们的文件资源，然后开始进入 <code>doLoadBeanDefinitions</code> 开始真正的读取。</p>
<blockquote>
<p>这其实是 <code>spring</code> 项目的一个编码风格，xxx() 函数一般做数据准备，包括验证，设置什么东西，然后doXxx() 才开始做真正的事情。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ... 省略一堆catch代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个方法很简单，就两句话，不过第一句读取可以跳过，无非就是 <code>文件流</code> 读成了熟悉的 <code>Document</code> 对象了。然后第二句话，没有 <code>do</code> 开头，说明又要进入准备：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">            <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是调用的时候需要的三个属性</span></span><br><span class="line"><span class="keyword">private</span> ProblemReporter problemReporter = <span class="keyword">new</span> FailFastProblemReporter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ReaderEventListener eventListener = <span class="keyword">new</span> EmptyReaderEventListener();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SourceExtractor sourceExtractor = <span class="keyword">new</span> NullSourceExtractor();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>准备了一个 <code>BeanDefinitionDocumentReader</code>，通过反射实例化了这个类，这个类作用就是记录了配置文件中，节点代表的含义，以及在解析过程中，遇到这些节点要干什么事情，比如遇到 <code>import</code> 要回来调用继续读取，遇到 <code>bean</code> 要实例化对象，并且注册到 <code>BeanFactory</code> 中。 而 <code>XmlReaderContext createReaderContext(Resource resource)</code> 构建一个对象 <code>XmlReaderContext</code>，应该说就是当前的上下文状态，包含了事件监听器、日志记录以及元信息提取器，然而在当前这个简单的 <code>BeanFactory</code> 中，这三个对象，都是很简单的实现（非空即NULL，<code>problemReporter</code> 则是一个记录器上下文，抛抛异常什么的）。 <code>XmlBeanDefinitionReader</code> 的任务基本上已经做完了，接下来就是交给解析器 <code>BeanDefinitionDocumentReader</code> 来做了。 接下来我们进入 <code>documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</code> 这句话，看看里面做了什么。</p>
<h2 id="BeanDefinitionDocumentReader读取配置文档"><a href="#BeanDefinitionDocumentReader读取配置文档" class="headerlink" title="BeanDefinitionDocumentReader读取配置文档"></a>BeanDefinitionDocumentReader读取配置文档</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">        doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">        delegate.initDefaults(root, parentDelegate);</span><br><span class="line">        <span class="keyword">return</span> delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">                <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">                <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，可以简单看到，<code>registerBeanDefinitions</code> 函数只是简单的设置了一下 <code>上一个类中的 xml 读取环境XmlReaderContext</code>，然后直接进入 <code>doRegisterBeanDefinitions</code> 开始解析。</p>
<blockquote>
<p>又见到这个 xxx() 和 doXxx() 的风格了。</p>
</blockquote>
<p>在 <code>doRegisterBeanDefinitions</code> 方法中，首先通过判断父类有没有 <code>BeanDefinitionParserDelegate</code> 解析器，如果没有，直接传递当前的 <code>XmlReaderContext上下文</code> <code>new</code> 一个新的解析器，先康康这个解析器是干嘛的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionParserDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEANS_NAMESPACE_URI = <span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MULTI_VALUE_ATTRIBUTE_DELIMITERS = <span class="string">&quot;,; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Value of a T/F attribute that represents true.</span></span><br><span class="line"><span class="comment">     * Anything else represents false. Case seNsItive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRUE_VALUE = <span class="string">&quot;true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FALSE_VALUE = <span class="string">&quot;false&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_VALUE = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTION_ELEMENT = <span class="string">&quot;description&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_NO_VALUE = <span class="string">&quot;no&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_BY_NAME_VALUE = <span class="string">&quot;byName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_BY_TYPE_VALUE = <span class="string">&quot;byType&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_CONSTRUCTOR_VALUE = <span class="string">&quot;constructor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_AUTODETECT_VALUE = <span class="string">&quot;autodetect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME_ATTRIBUTE = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_ELEMENT = <span class="string">&quot;bean&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String META_ELEMENT = <span class="string">&quot;meta&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID_ATTRIBUTE = <span class="string">&quot;id&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，直接下结论，这就是一个与我们配置文件节点、属性名字对应的解析器。 走到了中间的 <code>if</code> 代码，无非就是判断节点是否是根节点，以及有没有配置 <code>profile</code> 环境。如果有，是否跟当前配置想要的环境一致，如果不一致，跳过解析，一致就继续走到下面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">                <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">                <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过了 <code>profile</code> 判断后，就开始解析配置文件了。 先开始 <code>preProcessXml</code> ，然而，默认的实现是不做任何事情，这就预留给我们，可以在子类里边做一些事情。如果我们用了自定义的标签，可以实现这个方法来实现我们标签想要的功能。比如我们可以实现一个 <code>author</code> 的 <code>xml</code> 节点，然后在日志打印这个配置文件的作者（防止有 <code>bug</code> 找不到当事人祭天~） 哦对了，<code>postProcessXml</code> 也没有实现，跟 <code>preProcessXml</code> 一样留给使用者。 紧接着，开始 <code>parseBeanDefinitions</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，摄影师，把聚光灯投向 <code>BeanDefinitionParserDelegate</code> 类。</p>
<h2 id="BeanDefinitionParserDelegate解析BeanDefinition"><a href="#BeanDefinitionParserDelegate解析BeanDefinition" class="headerlink" title="BeanDefinitionParserDelegate解析BeanDefinition"></a>BeanDefinitionParserDelegate解析BeanDefinition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionParserDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略上面一堆的常量</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">        String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String beanName = id;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                                beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                        <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">                        <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">                        <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">                        String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                        <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                                !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                            aliases.add(beanClassName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    error(ex.getMessage(), ele);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我在配置文件什么都没有定义，所以直接来到了这句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkNameUniqueness</span><span class="params">(String beanName, List&lt;String&gt; aliases, Element beanElement)</span> </span>&#123;</span><br><span class="line">    String foundName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(beanName) &amp;&amp; <span class="keyword">this</span>.usedNames.contains(beanName)) &#123;</span><br><span class="line">        foundName = beanName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        foundName = CollectionUtils.findFirstMatch(<span class="keyword">this</span>.usedNames, aliases);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;Bean name &#x27;&quot;</span> + foundName + <span class="string">&quot;&#x27; is already used in this &lt;beans&gt; element&quot;</span>, beanElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.usedNames.add(beanName);</span><br><span class="line">    <span class="keyword">this</span>.usedNames.addAll(aliases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后他就通过一个集合（这个集合记录我配置里面定义的所有名字 <code>name属性</code>）来判断名字是否是唯一的。 然而我都没有定义，所以还是不必要关心，过。 接下来继续关心 <code>BeanDefinitionParserDelegate</code> 的解析过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    String parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">        parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (... ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先有一个 <code>parseState</code> 来记录解析的状态（<code>finally</code> 里面会弹出来，所以这个是个栈结构），获取到 <code>类名</code> 以及 <code>父类</code>，然后进入 <code>createBeanDefinition</code> 开始创建 <code>BeanDefinition</code>。</p>
<blockquote>
<p><code>BeanDefinition</code> 是一个将配置文件中的内容抽象到内存对象的数据结构（就是业务中常用的DTO）。</p>
</blockquote>
<p>再来看看 <code>createBeanDefinition</code> 中做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(<span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> String parentName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">            parentName, className, <span class="keyword">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinitionReaderUtils.createBeanDefinition: </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">    bd.setParentName(parentName);</span><br><span class="line">    <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bd.setBeanClassName(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个 <code>GenericBeanDefinition</code>，指定了 <code>Bean</code> 的 <code>Class</code> 对象。</p>
<blockquote>
<p>GenericBeanDefinition 就是我们定义的，我们可以自己使用的，普通 <code>Bean</code> 的数据结构。</p>
</blockquote>
<p>然后接下来所做的事情，就是把标签里边的属性给设置到当前这个 <code>GenericBeanDefinition</code> 中去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">代码片段：</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br></pre></td></tr></table></figure>

<p>由于我们使用的是构造器注入值的方式，所以可以简单看看 <code>parseConstructorArgElements(ele, bd);</code> 这一段，其他的解析，如果没有设置，都会直接无操作的跳过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">    String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">    String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Integer.parseInt(indexAttr);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="string">&quot;&#x27;index&#x27; cannot be lower than 0&quot;</span>, ele);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry(index));</span><br><span class="line">                    Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">                    ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">                        valueHolder.setType(typeAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                        valueHolder.setName(nameAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    valueHolder.setSource(extractSource(ele));</span><br><span class="line">                    <span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">                        error(<span class="string">&quot;Ambiguous constructor-arg entries for index &quot;</span> + index, ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">            error(<span class="string">&quot;Attribute &#x27;index&#x27; of tag &#x27;constructor-arg&#x27; must be an integer&quot;</span>, ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry());</span><br><span class="line">            Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">            ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">                valueHolder.setType(typeAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                valueHolder.setName(nameAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            valueHolder.setSource(extractSource(ele));</span><br><span class="line">            bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无非就是拿到我配置文件中配置的值，然后注入到 <code>GenericBeanDefinition</code> 中去，我不想解读了。。。😑 注册完，返回到我们上面的主流程中来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">  String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">    aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String beanName = id;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">    beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                   <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">  <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">            beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">          <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">          <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">          <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">          String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">          <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">              beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">              !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">            aliases.add(beanClassName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        error(ex.getMessage(), ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我没有定义名字，所以，<code>XmlReaderContext</code> 需要帮我生成一个名字，默认是 <code>TestBean#0</code>，添加到 <code>alias</code> 数组中，然后返回去。</p>
<h2 id="BeanDefinitionDocumentReader注册BeanDefinition"><a href="#BeanDefinitionDocumentReader注册BeanDefinition" class="headerlink" title="BeanDefinitionDocumentReader注册BeanDefinition"></a>BeanDefinitionDocumentReader注册BeanDefinition</h2><p><code>BeanDefinitionParserDelegate</code> 昨晚解析的工作并且产生 <code>BeanDefinition</code> 返回回去了，接下来，生成实例的任务又回到了 <code>BeanDefinitionDocumentReader</code> 的头上。 先回忆一下刚刚到哪一步了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">  <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">  <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">  <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">  <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">  <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">  BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">  <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">      <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                       <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element ele = (Element) node;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">          parseDefaultElement(ele, delegate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          delegate.parseCustomElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">    importBeanDefinitionResource(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">    processAliasRegistration(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">    processBeanDefinition(ele, delegate);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">    <span class="comment">// recurse</span></span><br><span class="line">    doRegisterBeanDefinitions(ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<span class="comment">// ← 刚刚来到这一步</span></span><br><span class="line">  <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来 <code>bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder)</code> 里面做的事情是用户自定义标签要做的事情，所以可以先不看。直接过，接下来就是将 <code>BeanDefinition</code> 放入当前的容器中了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanDefinitionRegistry</code> 从哪里来的，他其实就是刚开始进入的时候，传递了 <code>this</code> 实现将当前的 <code>BeanFactory</code> 放进去的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new XmlBeanFactory with the given resource,</span></span><br><span class="line"><span class="comment">     * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new XmlBeanFactory with the given input stream,</span></span><br><span class="line"><span class="comment">     * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentBeanFactory parent bean factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以此时，<code>registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())</code> 这句话就是注册 <code>BeanDefinition</code> 的关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                        existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="function"><span class="keyword">null</span>  <span class="title">containsSingleton</span><span class="params">(beanName)</span>) </span>&#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有点长，仔细看了一下，验证和和真正注册都写在这里面，有点反之前 <code>xxx</code> 和 <code>doXxx</code> 的约定啊。总感觉是某个老鼠屎（比较大颗的那种，因为比我牛逼）写的。我来裁减掉日志记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<span class="comment">// ←直接来到这里</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="function"><span class="keyword">null</span>  <span class="title">containsSingleton</span><span class="params">(beanName)</span>) </span>&#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通篇很长，然而我现在的情况就是直接去到代码中我指示的地方，这两个就很好说了，到了 <code>removeManualSingletonName</code> 这一句则是移除当前已经存在的单例的名字。</p>
<h2 id="完成注册"><a href="#完成注册" class="headerlink" title="完成注册"></a>完成注册</h2><p>通篇讲完，我发现他并没有实例化我要的 <code>Bean</code>，然后在 <code>getBean</code> 的方法里面我发现我需要的时候他才开始创建真正的对象。</p>
<h2 id="getBean初始化"><a href="#getBean初始化" class="headerlink" title="getBean初始化"></a>getBean初始化</h2><p>我的测试用例第二句话是 <code>TestBean bean = bf.getBean(TestBean.class);</code>，就是这个时候拿到对应的对象的。</p>
<blockquote>
<p>那 lazy-init 有什么用呢… 可能其他容器用到了吧。</p>
</blockquote>
<p>现在我们进入 <code>getBean</code> 来看看了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBean(requiredType, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) resolved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用了重载的方法，然后重载方法也比较简单，就是通过 <code>resolveBean</code> 拿到我的对象然后返回。那重点应该是 <code>resolveBean</code> 这个方法了。 <code>ResolvableType.forRawClass(requiredType)</code> 只是包装了一层对象，包含了我指定的 <code>Class</code> 其他没什么了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> namedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanFactory parent = getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AutowireCapableBeanFactory) parent).resolveNamedBean(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ResolvableType requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    String[] candidateNames = getBeanNamesForType(requiredType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        List&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!containsBeanDefinition(beanName)  getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">                autowireCandidates.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!autowireCandidates.isEmpty()) &#123;</span><br><span class="line">            candidateNames = StringUtils.toStringArray(autowireCandidates);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">        String beanName = candidateNames[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; candidates = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object beanInstance = getBean(beanName);</span><br><span class="line">                candidates.put(beanName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                candidates.put(beanName, getType(beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());</span><br><span class="line">        <span class="keyword">if</span> (candidateName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (candidateName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object beanInstance = candidates.get(candidateName);</span><br><span class="line">            <span class="keyword">if</span> (beanInstance == <span class="keyword">null</span>  beanInstance <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                beanInstance = getBean(candidateName, requiredType.toClass(), args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(candidateName, (T) beanInstance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nonUniqueAsNull) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单参数的 <code>resolveNamedBean</code> 调用了重载的 <code>resolveNamedBean</code> 方法，下面的代码是如果没有找到，继续从父级容器寻找，然而我们都没有父级容器而且可以直接就拿到实例，所以下面的代码基本可以不看。 首先，他通过 <code>String[] candidateNames = getBeanNamesForType(requiredType)</code> 拿到了容器中帮我生成的默认名字。然而由于只有一个名字，所以她走了这段代码：<code>return new NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</code>，首先通过 <code>getBean(beanName, requiredType.toClass(), args)</code> 拿到实例。但是这个方法已经进入到了父类 <code>AbstractBeanFactory</code> 中，所以父类应该是做了实例化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">              <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">      <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">        String nameToLookup = originalBeanName(name);</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">              nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">          <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">        markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            registerDependentBean(dep, beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create bean instance.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">              <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">              <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">          <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">          Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">finally</span> &#123;</span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">          bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          String scopeName = mbd.getScope();</span><br><span class="line">          <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">          <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">              beforePrototypeCreation(beanName);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">              ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doGetBean</code> 方法还是很长，所以我感觉我还是需要裁减掉一些东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">  Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">    <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">    <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> convertedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">            ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在 <code>doGetBean</code> 代码就只做几件事情了：</p>
<ol>
<li>尝试获取正在创建的单例，如果没有，创建、放入容器、返回；</li>
<li>检查是否有循环以来，类似于 A 依赖 B，B 依赖 A 的操作；</li>
<li>转换为我们制定的类（有接口的情况下）；</li>
</ol>
<h2 id="创建Bean对象"><a href="#创建Bean对象" class="headerlink" title="创建Bean对象"></a>创建Bean对象</h2><p>所以我们现在需要看的是这个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">                ...</span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 在子类的 AbstractAutowireCapableBeanFactory 实现</span></span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------&gt; AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException  ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而，我们注册的是 <code>GenericBeanDefinition</code> 来到这里被转换成 <code>RootBeanDefinition</code>，进去看了注释发现，他说 <code>GenericBeanDefinition</code> 拥有高级的功能。所以这里的转换应该是为了兼容老版本的吧。 因为我们在配置文件定义的类，是可以通过其他方法来覆盖他原来拥有的方法的（但其实我还是不明白这么做的含义是什么，一般日常都是直接修改的吧，唯一能想到的就是临时拓展功能），所以在这里需要准备一下覆盖的配置：<code>mbdToUse.prepareMethodOverrides();</code> 接下来，来到了 <code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>，看注释的意思是可以注入 <code>AOP</code> 然后获取到了一个代理增强的实例，但是由于目前我还没设置 <code>AOP</code>，姑且先跳过不管吧。毕竟他也是直接返回一个 <code>null</code> 值。 下一步就是 <code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code> 了，这一步有点复杂….不过慢慢来吧。</p>
<hr>
<p>我们来看看 <code>doCreateBean(beanName, mbdToUse, args)</code> 做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦<del>~</del>，出现了一个 <code>BeanWrapper</code> 的创建了。</p>
<blockquote>
<p><code>BeanWrapper</code> 与 <code>BeanDefinition</code> 的道理差不多，<code>BeanDefinition</code> 记录着配置信息，那 <code>BeanWrapper</code> 也一样记录着创建的信息了。 忽然间感觉好像很少需要用到配置记录这类东西？</p>
</blockquote>
<p>然后来到了这两个 <code>if</code> 里边：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">  instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实第一个 <code>if</code> 就没什么作用了，是用于给 <code>FactoryBean</code> 的，直接移除，但是移除返回的是 <code>null</code>，所以顺利的进入了第二个 <code>if</code> 语句。我现在贴出 <code>createBeanInstance</code> 的代码出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  调用了这个方法</span></span><br><span class="line"><span class="comment">    @Nullable</span></span><br><span class="line"><span class="comment">    protected Class&lt;?&gt; resolveBeanClass(final RootBeanDefinition mbd, String beanName, final Class&lt;?&gt;... typesToMatch)</span></span><br><span class="line"><span class="comment">            throws CannotLoadBeanClassException &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            if (mbd.hasBeanClass()) &#123;</span></span><br><span class="line"><span class="comment">                return mbd.getBeanClass();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ----------------- 先不看 Start ----------------- */</span></span><br><span class="line">        <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">        <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ----------------- 先不看 END ----------------- */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">        <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    resolved = <span class="keyword">true</span>;</span><br><span class="line">                    autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">            <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">                <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (ctors != <span class="keyword">null</span>  mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR </span><br><span class="line">                mbd.hasConstructorArgumentValues()  !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">        ctors = mbd.getPreferredConstructors();</span><br><span class="line">        <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">        <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么当前的 <code>BeanDefinition</code> 已经记录了我们使用的，也就是 <code>TestBean.class</code>，所以直接返回这个 <code>Class</code> 实例即可。然后继续接下来的动作，因为已经支持了 <code>j8</code> 的 <code>Lambda</code> 函数（<code>j8</code> ？~），所以此处可以编写函数进行创建，先不看，过。 然而我在 <code>getBean</code> 的时候并没有传递参数，只是传递了一个 <code>Class</code>，所以此处所有的 <code>args</code> 都是 <code>Null</code>。 那 <code>Spring</code> 该怎么办呢？我也没有提供 <code>factoryMethod</code> 也没有指定 <code>构造方法</code>， 他只能从配置文件来获取了。 所以设置了 <code>resolved</code> 为 <code>true</code>（<code>resolved</code> 意思是解决，我想这里可以当成自己解决的意思吧）</p>
<h2 id="查找对应的构造器"><a href="#查找对应的构造器" class="headerlink" title="查找对应的构造器"></a>查找对应的构造器</h2><p>接下来 <code>Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</code> 用于获取 <code>Bean</code> 创建的后处理器，看看是否有做什么后备操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(<span class="meta">@Nullable</span> Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">            <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">                    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ctors;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然而我没有给，直接给 <code>null</code> 返回出来了。 接下来 <code>mbd.hasConstructorArgumentValues()</code> 返回 <code>true</code>，因为我提供了构造器的值，所以使用 <code>return autowireConstructor(beanName, mbd, ctors, args);</code> 这个函数进行创建并返回。 <code>autowireConstructor</code> 只有一句话，就是 <code>new</code> 一个构造器构建器进行注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] ctors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this</code> 是当前的 <code>BeanFactory</code>，然后我们可以直接进入 <code>autowireConstructor</code> 构造器注入方式的函数了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line">    <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; constructorToUse = <span class="keyword">null</span>;</span><br><span class="line">    ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line">    Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsToUse = explicitArgs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">                <span class="comment">// Found a cached constructor...</span></span><br><span class="line">                argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">                <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>  argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">        Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">                        beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line">                        <span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">            Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">                    mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">                    mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">                &#125;</span><br><span class="line">                bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">                <span class="keyword">return</span> bw;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to resolve the constructor.</span></span><br><span class="line">        <span class="keyword">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> </span><br><span class="line">                mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">        ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minNrOfArgs;</span><br><span class="line">        <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minNrOfArgs = explicitArgs.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">            resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AutowireUtils.sortConstructors(candidates);</span><br><span class="line">        <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> parameterCount = candidate.getParameterCount();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; argsToUse != <span class="keyword">null</span> &amp;&amp; argsToUse.length &gt; parameterCount) &#123;</span><br><span class="line">                <span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span><br><span class="line">                <span class="comment">// do not look any further, there are only less greedy constructors left.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parameterCount &lt; minNrOfArgs) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ArgumentsHolder argsHolder;</span><br><span class="line">            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);</span><br><span class="line">                    <span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">                        <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">                            getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Ignoring constructor [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Swallow and try next constructor.</span></span><br><span class="line">                    <span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        causes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    causes.add(ex);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line">                <span class="keyword">if</span> (parameterCount != explicitArgs.length) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">                    argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">            <span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line">            <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">                constructorToUse = candidate;</span><br><span class="line">                argsHolderToUse = argsHolder;</span><br><span class="line">                argsToUse = argsHolder.arguments;</span><br><span class="line">                minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">                ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                    ambiguousConstructors.add(constructorToUse);</span><br><span class="line">                &#125;</span><br><span class="line">                ambiguousConstructors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line">                <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Could not resolve matching constructor &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Ambiguous constructor matches found in bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">                    ambiguousConstructors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Assert.state(argsToUse != <span class="keyword">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line">    bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line">    <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这函数的长度还是挺恶心人的。。。 首先，在 <code>BeanFactory</code> 里边记录些东西并进行初始化 <code>BeanWrapImpl</code>，我就先不看了，我现在目标是进入初始化的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">  beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br></pre></td></tr></table></figure>

<p>这句话是个三元表达式，<code>nonPublicAccessAllowed</code> 默认是 <code>true</code>，所以走 <code>beanClass.getDeclaredConstructors()</code>，这个是 <code>jdk</code> <code>Class</code> 的方法，获取到所有声明的构造函数，不出意外的话是两个。 接下来就是判断拿哪个构造器了，第一个 <code>if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues())</code> 显然不是，因为我有两个构造函数。所以又可以跳过一大段无聊的代码~然而因为传递的 <code>args</code> 是 <code>Null</code> 所以开始拿到配置文件中构造器参数的长度：<code>minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</code>。 接下来就是找到哪个构造器来匹配了，采用 <code>for</code> 所有构造器，比对长度的方式来做：<code>for (Constructor&lt;?&gt; candidate : candidates) &#123;</code> 如果不符合条件的就 <code>Continue</code>，接下来获取名字，不出意外的话，是为了能够写日志hhhh？下面还有使用到这个参数，接着看下去。 先是记录了使用的配置文件的值，使用的构造器，然后 <code>argsHolderToUse.storeCache(mbd, constructorToUse);</code> 保存到缓存中以便后面使用（是不是有点没必要的）。</p>
<h2 id="开始初始化对象"><a href="#开始初始化对象" class="headerlink" title="开始初始化对象"></a>开始初始化对象</h2><p>然后调用 <code>instantiate</code> 进行真正的对象初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">instantiate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt; constructorToUse, Object[] argsToUse)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  InstantiationStrategy strategy = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy();</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">     strategy.instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse),</span><br><span class="line">     <span class="keyword">this</span>.beanFactory.getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> strategy.instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">    <span class="string">&quot;Bean instantiation via constructor failed&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有系统安全管理器，所以使用 <code>SimpleInstantiationStrategy.instantiate</code> 开始初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">// use own privileged to change accessibility (when security is on)</span></span><br><span class="line">   AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args); <span class="comment">// 直接进入这里</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanUtils</code> 就是封装 <code>jdk</code> 反射调用构造器构造对象的方法了。 好了一层一层的返回去，最后回到了这里 <code>AbstractBeanFactory</code> 里边刚刚路过的 <code>Lambda</code> 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">      <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">      <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">      destroySingleton(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册刚刚创建的Bean到BeanFactory中"><a href="#注册刚刚创建的Bean到BeanFactory中" class="headerlink" title="注册刚刚创建的Bean到BeanFactory中"></a>注册刚刚创建的Bean到BeanFactory中</h2><p>拿到了 <code>sharedInstance</code> 之前呢，其实 <code>AbstractBeanFactory</code> 是调用父级 <code>DefaultSingletonBeanRegistry</code> 的 <code>getSingleton</code> 先从容器中查找，没有的话再调用了我们刚刚看的一堆创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName); <span class="comment">// 因为第一次取没有找到所以进入创建流程</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                            <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                beforeSingletonCreation(beanName); <span class="comment">// 开始通知</span></span><br><span class="line">                <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    newSingleton = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                    <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                            ex.addRelatedCause(suppressedException);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    afterSingletonCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    addSingleton(beanName, singletonObject); <span class="comment">// 然后做了记录</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此一个真正创建 <code>Bean</code> 的流程就完成了。 我们接下来看 <code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</code> 这句话，这句话说是 <code>get</code> 但是内部其实就是验证 <code>Bean</code> 是否创建完整，是否返回的是 <code>Null对象</code> 或者 <code>工厂对象</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">  <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">  <span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">  <span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">  <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  省略下面代码因为上面已经直接返回回去了，下面其实就是说拿到了 FactoryBean 的话，调用创建真正的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个返回一路前进，就出来到我们自己写的 <code>TestBean bean = bf.getBean(TestBean.class);</code></p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>我用类图来说说看法： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144826.png"> 代码的分割还有意思：</p>
<ol>
<li>定义基础的 <code>BeanFactory</code> 能干嘛（能拿能顺序能父子容器的 <code>BeanFactory</code>）；</li>
<li>定义了 <code>Registry</code> 能干嘛（无非就是容器的增删查改）；</li>
<li>初步实现了第 <code>2</code> 点的功能；</li>
<li>上面功能都有了，接下来要自动装配了，自动化的 <code>BeanFactory</code>；</li>
<li>能自动组装了，还要可以配置，定义根据配置做上面动作的增删查改；</li>
<li>然后就是一个完整的 <code>BeanFactory</code> 类：<code>XmlBeanFactory</code>。</li>
</ol>
<h2 id="小看法"><a href="#小看法" class="headerlink" title="小看法"></a>小看法</h2><p>第一次写 <code>Spring</code> 相关的源码文章，写的可能不是很好，已经跟随断点慢慢一步一步的走过来了。其实读完有那么一瞬间我感觉，针对一个函数做一个小事情的做法，<code>Spring</code> 貌似并没有做到？不过后面仔细思考了一下，因为我看源码的时候会忽略掉函数权限的问题，所以其实接口暴露的方法能够拿到正确的值才是关键。 不得不说，<code>XmlBeanFactory</code> 这个类走得有点复杂，但是我看后面的 <code>Context</code> 已经没有使用上面所说的所有类了。这个类现在的责任应该就是当成学习来供读者感受的吧。 </p>
<p>果然，在第一次解析的时候，拿到了我的 <code>import</code> 节点，继续调用当前方法来注册的时候，因为文件是同一个，<code>Set&lt;EncodedResource&gt;.add()</code> 的时候添加失败了，抛出异常，直接解析失败。而 <code>Set</code> 这个实例是存储在当前线程的<code>ThreadLocal</code> 中的，防止重复读取配置文件。可以在这里看出来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;EncodedResource&gt; currentResources &#x3D; this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">if (currentResources &#x3D;&#x3D; null) &#123;</span><br><span class="line">    currentResources &#x3D; new HashSet&lt;&gt;(4);</span><br><span class="line">    this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进入一个 <code>try-catch</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步就是拆解上一步封装的 <code>EncodedResource</code> 拿到我们的文件资源，然后开始进入 <code>doLoadBeanDefinitions</code> 开始真正的读取。</p>
<blockquote>
<p>这其实是 <code>spring</code> 项目的一个编码风格，xxx() 函数一般做数据准备，包括验证，设置什么东西，然后doXxx() 才开始做真正的事情。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ... 省略一堆catch代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个方法很简单，就两句话，不过第一句读取可以跳过，无非就是 <code>文件流</code> 读成了熟悉的 <code>Document</code> 对象了。然后第二句话，没有 <code>do</code> 开头，说明又要进入准备：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">            <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是调用的时候需要的三个属性</span></span><br><span class="line"><span class="keyword">private</span> ProblemReporter problemReporter = <span class="keyword">new</span> FailFastProblemReporter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ReaderEventListener eventListener = <span class="keyword">new</span> EmptyReaderEventListener();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SourceExtractor sourceExtractor = <span class="keyword">new</span> NullSourceExtractor();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>准备了一个 <code>BeanDefinitionDocumentReader</code>，通过反射实例化了这个类，这个类作用就是记录了配置文件中，节点代表的含义，以及在解析过程中，遇到这些节点要干什么事情，比如遇到 <code>import</code> 要回来调用继续读取，遇到 <code>bean</code> 要实例化对象，并且注册到 <code>BeanFactory</code> 中。 而 <code>XmlReaderContext createReaderContext(Resource resource)</code> 构建一个对象 <code>XmlReaderContext</code>，应该说就是当前的上下文状态，包含了事件监听器、日志记录以及元信息提取器，然而在当前这个简单的 <code>BeanFactory</code> 中，这三个对象，都是很简单的实现（非空即NULL，<code>problemReporter</code> 则是一个记录器上下文，抛抛异常什么的）。 <code>XmlBeanDefinitionReader</code> 的任务基本上已经做完了，接下来就是交给解析器 <code>BeanDefinitionDocumentReader</code> 来做了。 接下来我们进入 <code>documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</code> 这句话，看看里面做了什么。</p>
<h2 id="BeanDefinitionDocumentReader读取配置文档-1"><a href="#BeanDefinitionDocumentReader读取配置文档-1" class="headerlink" title="BeanDefinitionDocumentReader读取配置文档"></a>BeanDefinitionDocumentReader读取配置文档</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">        doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">        delegate.initDefaults(root, parentDelegate);</span><br><span class="line">        <span class="keyword">return</span> delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">                <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">                <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，可以简单看到，<code>registerBeanDefinitions</code> 函数只是简单的设置了一下 <code>上一个类中的 xml 读取环境XmlReaderContext</code>，然后直接进入 <code>doRegisterBeanDefinitions</code> 开始解析。</p>
<blockquote>
<p>又见到这个 xxx() 和 doXxx() 的风格了。</p>
</blockquote>
<p>在 <code>doRegisterBeanDefinitions</code> 方法中，首先通过判断父类有没有 <code>BeanDefinitionParserDelegate</code> 解析器，如果没有，直接传递当前的 <code>XmlReaderContext上下文</code> <code>new</code> 一个新的解析器，先康康这个解析器是干嘛的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionParserDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEANS_NAMESPACE_URI = <span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MULTI_VALUE_ATTRIBUTE_DELIMITERS = <span class="string">&quot;,; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Value of a T/F attribute that represents true.</span></span><br><span class="line"><span class="comment">     * Anything else represents false. Case seNsItive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRUE_VALUE = <span class="string">&quot;true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FALSE_VALUE = <span class="string">&quot;false&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_VALUE = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTION_ELEMENT = <span class="string">&quot;description&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_NO_VALUE = <span class="string">&quot;no&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_BY_NAME_VALUE = <span class="string">&quot;byName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_BY_TYPE_VALUE = <span class="string">&quot;byType&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_CONSTRUCTOR_VALUE = <span class="string">&quot;constructor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_AUTODETECT_VALUE = <span class="string">&quot;autodetect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME_ATTRIBUTE = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_ELEMENT = <span class="string">&quot;bean&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String META_ELEMENT = <span class="string">&quot;meta&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID_ATTRIBUTE = <span class="string">&quot;id&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，直接下结论，这就是一个与我们配置文件节点、属性名字对应的解析器。 走到了中间的 <code>if</code> 代码，无非就是判断节点是否是根节点，以及有没有配置 <code>profile</code> 环境。如果有，是否跟当前配置想要的环境一致，如果不一致，跳过解析，一致就继续走到下面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">                <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">                <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过了 <code>profile</code> 判断后，就开始解析配置文件了。 先开始 <code>preProcessXml</code> ，然而，默认的实现是不做任何事情，这就预留给我们，可以在子类里边做一些事情。如果我们用了自定义的标签，可以实现这个方法来实现我们标签想要的功能。比如我们可以实现一个 <code>author</code> 的 <code>xml</code> 节点，然后在日志打印这个配置文件的作者（防止有 <code>bug</code> 找不到当事人祭天~） 哦对了，<code>postProcessXml</code> 也没有实现，跟 <code>preProcessXml</code> 一样留给使用者。 紧接着，开始 <code>parseBeanDefinitions</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，摄影师，把聚光灯投向 <code>BeanDefinitionParserDelegate</code> 类。</p>
<h2 id="BeanDefinitionParserDelegate解析BeanDefinition-1"><a href="#BeanDefinitionParserDelegate解析BeanDefinition-1" class="headerlink" title="BeanDefinitionParserDelegate解析BeanDefinition"></a>BeanDefinitionParserDelegate解析BeanDefinition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionParserDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略上面一堆的常量</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">        String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String beanName = id;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                                beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                        <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">                        <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">                        <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">                        String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                        <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                                !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                            aliases.add(beanClassName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    error(ex.getMessage(), ele);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我在配置文件什么都没有定义，所以直接来到了这句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkNameUniqueness</span><span class="params">(String beanName, List&lt;String&gt; aliases, Element beanElement)</span> </span>&#123;</span><br><span class="line">    String foundName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(beanName) &amp;&amp; <span class="keyword">this</span>.usedNames.contains(beanName)) &#123;</span><br><span class="line">        foundName = beanName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        foundName = CollectionUtils.findFirstMatch(<span class="keyword">this</span>.usedNames, aliases);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;Bean name &#x27;&quot;</span> + foundName + <span class="string">&quot;&#x27; is already used in this &lt;beans&gt; element&quot;</span>, beanElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.usedNames.add(beanName);</span><br><span class="line">    <span class="keyword">this</span>.usedNames.addAll(aliases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后他就通过一个集合（这个集合记录我配置里面定义的所有名字 <code>name属性</code>）来判断名字是否是唯一的。 然而我都没有定义，所以还是不必要关心，过。 接下来继续关心 <code>BeanDefinitionParserDelegate</code> 的解析过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    String parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">        parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (... ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先有一个 <code>parseState</code> 来记录解析的状态（<code>finally</code> 里面会弹出来，所以这个是个栈结构），获取到 <code>类名</code> 以及 <code>父类</code>，然后进入 <code>createBeanDefinition</code> 开始创建 <code>BeanDefinition</code>。</p>
<blockquote>
<p><code>BeanDefinition</code> 是一个将配置文件中的内容抽象到内存对象的数据结构（就是业务中常用的DTO）。</p>
</blockquote>
<p>再来看看 <code>createBeanDefinition</code> 中做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(<span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> String parentName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">            parentName, className, <span class="keyword">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinitionReaderUtils.createBeanDefinition: </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">    bd.setParentName(parentName);</span><br><span class="line">    <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bd.setBeanClassName(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个 <code>GenericBeanDefinition</code>，指定了 <code>Bean</code> 的 <code>Class</code> 对象。</p>
<blockquote>
<p>GenericBeanDefinition 就是我们定义的，我们可以自己使用的，普通 <code>Bean</code> 的数据结构。</p>
</blockquote>
<p>然后接下来所做的事情，就是把标签里边的属性给设置到当前这个 <code>GenericBeanDefinition</code> 中去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">代码片段：</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br></pre></td></tr></table></figure>

<p>由于我们使用的是构造器注入值的方式，所以可以简单看看 <code>parseConstructorArgElements(ele, bd);</code> 这一段，其他的解析，如果没有设置，都会直接无操作的跳过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">    String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">    String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Integer.parseInt(indexAttr);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="string">&quot;&#x27;index&#x27; cannot be lower than 0&quot;</span>, ele);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry(index));</span><br><span class="line">                    Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">                    ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">                        valueHolder.setType(typeAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                        valueHolder.setName(nameAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    valueHolder.setSource(extractSource(ele));</span><br><span class="line">                    <span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">                        error(<span class="string">&quot;Ambiguous constructor-arg entries for index &quot;</span> + index, ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">            error(<span class="string">&quot;Attribute &#x27;index&#x27; of tag &#x27;constructor-arg&#x27; must be an integer&quot;</span>, ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry());</span><br><span class="line">            Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">            ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">                valueHolder.setType(typeAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                valueHolder.setName(nameAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            valueHolder.setSource(extractSource(ele));</span><br><span class="line">            bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无非就是拿到我配置文件中配置的值，然后注入到 <code>GenericBeanDefinition</code> 中去，我不想解读了。。。😑 注册完，返回到我们上面的主流程中来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">  String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">    aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String beanName = id;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">    beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                   <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">  <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">            beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">          <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">          <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">          <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">          String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">          <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">              beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">              !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">            aliases.add(beanClassName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        error(ex.getMessage(), ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我没有定义名字，所以，<code>XmlReaderContext</code> 需要帮我生成一个名字，默认是 <code>TestBean#0</code>，添加到 <code>alias</code> 数组中，然后返回去。</p>
<h2 id="BeanDefinitionDocumentReader注册BeanDefinition-1"><a href="#BeanDefinitionDocumentReader注册BeanDefinition-1" class="headerlink" title="BeanDefinitionDocumentReader注册BeanDefinition"></a>BeanDefinitionDocumentReader注册BeanDefinition</h2><p><code>BeanDefinitionParserDelegate</code> 昨晚解析的工作并且产生 <code>BeanDefinition</code> 返回回去了，接下来，生成实例的任务又回到了 <code>BeanDefinitionDocumentReader</code> 的头上。 先回忆一下刚刚到哪一步了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">  <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">  <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">  <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">  <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">  <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">  BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">  <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">      <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                       <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element ele = (Element) node;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">          parseDefaultElement(ele, delegate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          delegate.parseCustomElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">    importBeanDefinitionResource(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">    processAliasRegistration(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">    processBeanDefinition(ele, delegate);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">    <span class="comment">// recurse</span></span><br><span class="line">    doRegisterBeanDefinitions(ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<span class="comment">// ← 刚刚来到这一步</span></span><br><span class="line">  <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来 <code>bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder)</code> 里面做的事情是用户自定义标签要做的事情，所以可以先不看。直接过，接下来就是将 <code>BeanDefinition</code> 放入当前的容器中了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanDefinitionRegistry</code> 从哪里来的，他其实就是刚开始进入的时候，传递了 <code>this</code> 实现将当前的 <code>BeanFactory</code> 放进去的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new XmlBeanFactory with the given resource,</span></span><br><span class="line"><span class="comment">     * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new XmlBeanFactory with the given input stream,</span></span><br><span class="line"><span class="comment">     * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentBeanFactory parent bean factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以此时，<code>registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())</code> 这句话就是注册 <code>BeanDefinition</code> 的关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                        existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="function"><span class="keyword">null</span>  <span class="title">containsSingleton</span><span class="params">(beanName)</span>) </span>&#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有点长，仔细看了一下，验证和和真正注册都写在这里面，有点反之前 <code>xxx</code> 和 <code>doXxx</code> 的约定啊。总感觉是某个老鼠屎（比较大颗的那种，因为比我牛逼）写的。我来裁减掉日志记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<span class="comment">// ←直接来到这里</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="function"><span class="keyword">null</span>  <span class="title">containsSingleton</span><span class="params">(beanName)</span>) </span>&#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通篇很长，然而我现在的情况就是直接去到代码中我指示的地方，这两个就很好说了，到了 <code>removeManualSingletonName</code> 这一句则是移除当前已经存在的单例的名字。</p>
<h2 id="完成注册-1"><a href="#完成注册-1" class="headerlink" title="完成注册"></a>完成注册</h2><p>通篇讲完，我发现他并没有实例化我要的 <code>Bean</code>，然后在 <code>getBean</code> 的方法里面我发现我需要的时候他才开始创建真正的对象。</p>
<h2 id="getBean初始化-1"><a href="#getBean初始化-1" class="headerlink" title="getBean初始化"></a>getBean初始化</h2><p>我的测试用例第二句话是 <code>TestBean bean = bf.getBean(TestBean.class);</code>，就是这个时候拿到对应的对象的。</p>
<blockquote>
<p>那 lazy-init 有什么用呢… 可能其他容器用到了吧。</p>
</blockquote>
<p>现在我们进入 <code>getBean</code> 来看看了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBean(requiredType, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) resolved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用了重载的方法，然后重载方法也比较简单，就是通过 <code>resolveBean</code> 拿到我的对象然后返回。那重点应该是 <code>resolveBean</code> 这个方法了。 <code>ResolvableType.forRawClass(requiredType)</code> 只是包装了一层对象，包含了我指定的 <code>Class</code> 其他没什么了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> namedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanFactory parent = getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AutowireCapableBeanFactory) parent).resolveNamedBean(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ResolvableType requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    String[] candidateNames = getBeanNamesForType(requiredType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        List&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!containsBeanDefinition(beanName)  getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">                autowireCandidates.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!autowireCandidates.isEmpty()) &#123;</span><br><span class="line">            candidateNames = StringUtils.toStringArray(autowireCandidates);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">        String beanName = candidateNames[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; candidates = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object beanInstance = getBean(beanName);</span><br><span class="line">                candidates.put(beanName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                candidates.put(beanName, getType(beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());</span><br><span class="line">        <span class="keyword">if</span> (candidateName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (candidateName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object beanInstance = candidates.get(candidateName);</span><br><span class="line">            <span class="keyword">if</span> (beanInstance == <span class="keyword">null</span>  beanInstance <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                beanInstance = getBean(candidateName, requiredType.toClass(), args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(candidateName, (T) beanInstance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nonUniqueAsNull) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单参数的 <code>resolveNamedBean</code> 调用了重载的 <code>resolveNamedBean</code> 方法，下面的代码是如果没有找到，继续从父级容器寻找，然而我们都没有父级容器而且可以直接就拿到实例，所以下面的代码基本可以不看。 首先，他通过 <code>String[] candidateNames = getBeanNamesForType(requiredType)</code> 拿到了容器中帮我生成的默认名字。然而由于只有一个名字，所以她走了这段代码：<code>return new NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</code>，首先通过 <code>getBean(beanName, requiredType.toClass(), args)</code> 拿到实例。但是这个方法已经进入到了父类 <code>AbstractBeanFactory</code> 中，所以父类应该是做了实例化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">              <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">      <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">        String nameToLookup = originalBeanName(name);</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">              nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">          <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">        markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            registerDependentBean(dep, beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create bean instance.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">              <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">              <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">          <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">          Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">finally</span> &#123;</span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">          bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          String scopeName = mbd.getScope();</span><br><span class="line">          <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">          <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">              beforePrototypeCreation(beanName);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">              ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doGetBean</code> 方法还是很长，所以我感觉我还是需要裁减掉一些东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">  Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">    <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">    <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> convertedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">            ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在 <code>doGetBean</code> 代码就只做几件事情了：</p>
<ol>
<li>尝试获取正在创建的单例，如果没有，创建、放入容器、返回；</li>
<li>检查是否有循环以来，类似于 A 依赖 B，B 依赖 A 的操作；</li>
<li>转换为我们制定的类（有接口的情况下）；</li>
</ol>
<h2 id="创建Bean对象-1"><a href="#创建Bean对象-1" class="headerlink" title="创建Bean对象"></a>创建Bean对象</h2><p>所以我们现在需要看的是这个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">                ...</span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 在子类的 AbstractAutowireCapableBeanFactory 实现</span></span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------&gt; AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException  ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而，我们注册的是 <code>GenericBeanDefinition</code> 来到这里被转换成 <code>RootBeanDefinition</code>，进去看了注释发现，他说 <code>GenericBeanDefinition</code> 拥有高级的功能。所以这里的转换应该是为了兼容老版本的吧。 因为我们在配置文件定义的类，是可以通过其他方法来覆盖他原来拥有的方法的（但其实我还是不明白这么做的含义是什么，一般日常都是直接修改的吧，唯一能想到的就是临时拓展功能），所以在这里需要准备一下覆盖的配置：<code>mbdToUse.prepareMethodOverrides();</code> 接下来，来到了 <code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>，看注释的意思是可以注入 <code>AOP</code> 然后获取到了一个代理增强的实例，但是由于目前我还没设置 <code>AOP</code>，姑且先跳过不管吧。毕竟他也是直接返回一个 <code>null</code> 值。 下一步就是 <code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code> 了，这一步有点复杂….不过慢慢来吧。</p>
<hr>
<p>我们来看看 <code>doCreateBean(beanName, mbdToUse, args)</code> 做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦<del>~</del>，出现了一个 <code>BeanWrapper</code> 的创建了。</p>
<blockquote>
<p><code>BeanWrapper</code> 与 <code>BeanDefinition</code> 的道理差不多，<code>BeanDefinition</code> 记录着配置信息，那 <code>BeanWrapper</code> 也一样记录着创建的信息了。 忽然间感觉好像很少需要用到配置记录这类东西？</p>
</blockquote>
<p>然后来到了这两个 <code>if</code> 里边：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">  instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实第一个 <code>if</code> 就没什么作用了，是用于给 <code>FactoryBean</code> 的，直接移除，但是移除返回的是 <code>null</code>，所以顺利的进入了第二个 <code>if</code> 语句。我现在贴出 <code>createBeanInstance</code> 的代码出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  调用了这个方法</span></span><br><span class="line"><span class="comment">    @Nullable</span></span><br><span class="line"><span class="comment">    protected Class&lt;?&gt; resolveBeanClass(final RootBeanDefinition mbd, String beanName, final Class&lt;?&gt;... typesToMatch)</span></span><br><span class="line"><span class="comment">            throws CannotLoadBeanClassException &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            if (mbd.hasBeanClass()) &#123;</span></span><br><span class="line"><span class="comment">                return mbd.getBeanClass();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ----------------- 先不看 Start ----------------- */</span></span><br><span class="line">        <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">        <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ----------------- 先不看 END ----------------- */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">        <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    resolved = <span class="keyword">true</span>;</span><br><span class="line">                    autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">            <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">                <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (ctors != <span class="keyword">null</span>  mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR </span><br><span class="line">                mbd.hasConstructorArgumentValues()  !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">        ctors = mbd.getPreferredConstructors();</span><br><span class="line">        <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">        <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么当前的 <code>BeanDefinition</code> 已经记录了我们使用的，也就是 <code>TestBean.class</code>，所以直接返回这个 <code>Class</code> 实例即可。然后继续接下来的动作，因为已经支持了 <code>j8</code> 的 <code>Lambda</code> 函数（<code>j8</code> ？~），所以此处可以编写函数进行创建，先不看，过。 然而我在 <code>getBean</code> 的时候并没有传递参数，只是传递了一个 <code>Class</code>，所以此处所有的 <code>args</code> 都是 <code>Null</code>。 那 <code>Spring</code> 该怎么办呢？我也没有提供 <code>factoryMethod</code> 也没有指定 <code>构造方法</code>， 他只能从配置文件来获取了。 所以设置了 <code>resolved</code> 为 <code>true</code>（<code>resolved</code> 意思是解决，我想这里可以当成自己解决的意思吧）</p>
<h2 id="查找对应的构造器-1"><a href="#查找对应的构造器-1" class="headerlink" title="查找对应的构造器"></a>查找对应的构造器</h2><p>接下来 <code>Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</code> 用于获取 <code>Bean</code> 创建的后处理器，看看是否有做什么后备操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(<span class="meta">@Nullable</span> Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">            <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">                    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ctors;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然而我没有给，直接给 <code>null</code> 返回出来了。 接下来 <code>mbd.hasConstructorArgumentValues()</code> 返回 <code>true</code>，因为我提供了构造器的值，所以使用 <code>return autowireConstructor(beanName, mbd, ctors, args);</code> 这个函数进行创建并返回。 <code>autowireConstructor</code> 只有一句话，就是 <code>new</code> 一个构造器构建器进行注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] ctors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this</code> 是当前的 <code>BeanFactory</code>，然后我们可以直接进入 <code>autowireConstructor</code> 构造器注入方式的函数了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line">    <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; constructorToUse = <span class="keyword">null</span>;</span><br><span class="line">    ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line">    Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsToUse = explicitArgs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">                <span class="comment">// Found a cached constructor...</span></span><br><span class="line">                argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">                <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>  argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">        Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">                        beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line">                        <span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">            Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">                    mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">                    mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">                &#125;</span><br><span class="line">                bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">                <span class="keyword">return</span> bw;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to resolve the constructor.</span></span><br><span class="line">        <span class="keyword">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> </span><br><span class="line">                mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">        ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minNrOfArgs;</span><br><span class="line">        <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minNrOfArgs = explicitArgs.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">            resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AutowireUtils.sortConstructors(candidates);</span><br><span class="line">        <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> parameterCount = candidate.getParameterCount();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; argsToUse != <span class="keyword">null</span> &amp;&amp; argsToUse.length &gt; parameterCount) &#123;</span><br><span class="line">                <span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span><br><span class="line">                <span class="comment">// do not look any further, there are only less greedy constructors left.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parameterCount &lt; minNrOfArgs) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ArgumentsHolder argsHolder;</span><br><span class="line">            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);</span><br><span class="line">                    <span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">                        <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">                            getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Ignoring constructor [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Swallow and try next constructor.</span></span><br><span class="line">                    <span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        causes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    causes.add(ex);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line">                <span class="keyword">if</span> (parameterCount != explicitArgs.length) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">                    argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">            <span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line">            <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">                constructorToUse = candidate;</span><br><span class="line">                argsHolderToUse = argsHolder;</span><br><span class="line">                argsToUse = argsHolder.arguments;</span><br><span class="line">                minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">                ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                    ambiguousConstructors.add(constructorToUse);</span><br><span class="line">                &#125;</span><br><span class="line">                ambiguousConstructors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line">                <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Could not resolve matching constructor &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Ambiguous constructor matches found in bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">                    ambiguousConstructors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Assert.state(argsToUse != <span class="keyword">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line">    bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line">    <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这函数的长度还是挺恶心人的。。。 首先，在 <code>BeanFactory</code> 里边记录些东西并进行初始化 <code>BeanWrapImpl</code>，我就先不看了，我现在目标是进入初始化的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">  beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br></pre></td></tr></table></figure>

<p>这句话是个三元表达式，<code>nonPublicAccessAllowed</code> 默认是 <code>true</code>，所以走 <code>beanClass.getDeclaredConstructors()</code>，这个是 <code>jdk</code> <code>Class</code> 的方法，获取到所有声明的构造函数，不出意外的话是两个。 接下来就是判断拿哪个构造器了，第一个 <code>if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues())</code> 显然不是，因为我有两个构造函数。所以又可以跳过一大段无聊的代码~然而因为传递的 <code>args</code> 是 <code>Null</code> 所以开始拿到配置文件中构造器参数的长度：<code>minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</code>。 接下来就是找到哪个构造器来匹配了，采用 <code>for</code> 所有构造器，比对长度的方式来做：<code>for (Constructor&lt;?&gt; candidate : candidates) &#123;</code> 如果不符合条件的就 <code>Continue</code>，接下来获取名字，不出意外的话，是为了能够写日志hhhh？下面还有使用到这个参数，接着看下去。 先是记录了使用的配置文件的值，使用的构造器，然后 <code>argsHolderToUse.storeCache(mbd, constructorToUse);</code> 保存到缓存中以便后面使用（是不是有点没必要的）。</p>
<h2 id="开始初始化对象-1"><a href="#开始初始化对象-1" class="headerlink" title="开始初始化对象"></a>开始初始化对象</h2><p>然后调用 <code>instantiate</code> 进行真正的对象初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">instantiate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt; constructorToUse, Object[] argsToUse)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  InstantiationStrategy strategy = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy();</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">     strategy.instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse),</span><br><span class="line">     <span class="keyword">this</span>.beanFactory.getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> strategy.instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">    <span class="string">&quot;Bean instantiation via constructor failed&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有系统安全管理器，所以使用 <code>SimpleInstantiationStrategy.instantiate</code> 开始初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">// use own privileged to change accessibility (when security is on)</span></span><br><span class="line">   AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args); <span class="comment">// 直接进入这里</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanUtils</code> 就是封装 <code>jdk</code> 反射调用构造器构造对象的方法了。 好了一层一层的返回去，最后回到了这里 <code>AbstractBeanFactory</code> 里边刚刚路过的 <code>Lambda</code> 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">      <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">      <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">      destroySingleton(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册刚刚创建的Bean到BeanFactory中-1"><a href="#注册刚刚创建的Bean到BeanFactory中-1" class="headerlink" title="注册刚刚创建的Bean到BeanFactory中"></a>注册刚刚创建的Bean到BeanFactory中</h2><p>拿到了 <code>sharedInstance</code> 之前呢，其实 <code>AbstractBeanFactory</code> 是调用父级 <code>DefaultSingletonBeanRegistry</code> 的 <code>getSingleton</code> 先从容器中查找，没有的话再调用了我们刚刚看的一堆创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName); <span class="comment">// 因为第一次取没有找到所以进入创建流程</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                            <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                beforeSingletonCreation(beanName); <span class="comment">// 开始通知</span></span><br><span class="line">                <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    newSingleton = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                    <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                            ex.addRelatedCause(suppressedException);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    afterSingletonCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    addSingleton(beanName, singletonObject); <span class="comment">// 然后做了记录</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此一个真正创建 <code>Bean</code> 的流程就完成了。 我们接下来看 <code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</code> 这句话，这句话说是 <code>get</code> 但是内部其实就是验证 <code>Bean</code> 是否创建完整，是否返回的是 <code>Null对象</code> 或者 <code>工厂对象</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">  <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">  <span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">  <span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">  <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  省略下面代码因为上面已经直接返回回去了，下面其实就是说拿到了 FactoryBean 的话，调用创建真正的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个返回一路前进，就出来到我们自己写的 <code>TestBean bean = bf.getBean(TestBean.class);</code></p>
<h2 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h2><p>我用类图来说说看法： </p>
<h2 id="简单的DEMO-2"><a href="#简单的DEMO-2" class="headerlink" title="简单的DEMO"></a>简单的DEMO</h2><p>看源码，不就是打断点，看断点代码，重复这个步骤。 然而要运行这个容器，我需要一个简单的例子： 一个简单的 <code>Bean</code>，只有一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的测试Bean.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weidan &lt;emailto&gt;toweidan@126.com&lt;/emailto&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;TestBean&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;WeidanLi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>主要通过构造函数来构造了 <code>Bean</code> 的值。 还有一个程序入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.XmlBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的IOC测试用例.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> weidan &lt;emailto&gt;toweidan@126.com&lt;/emailto&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyXmlFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BeanFactory bf = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;applicationContext.xml&quot;</span>));</span><br><span class="line">    TestBean bean = bf.getBean(TestBean.class);</span><br><span class="line">    Assert.hasLength(bean.getName(), <span class="string">&quot;没有获取到配置文件的配置信息&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了 <code>XmlBeanFactory</code>，一个简单的 <code>BeanFactory</code> 实例。这个类提供了最基础的 <code>IOC</code> 功能，少了消息通知，生命周期等等这些东西，在日常中都不用这个类，使用 <code>ApplicationContext</code>，他是增强很多功能的 <code>BeanFactory</code>，不过作为出入门的菜逼，我就是用 <code>XmlBeanFactory</code> 这个好了，也是很多 <code>Spring</code> 源码书籍推荐的入门类。 可以看进入的代码，简单的创建容器，指定配置文件，然后断言我在配置文件中注入的值。 可以先看看这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到这个类的作者是大名鼎鼎的 <code>Rod Johnson</code>，这是一个左脑用来拿计算机博士，右脑用来拿音乐博士的男人，简直就是我的光头偶像。后来创建了 <code>Spring</code> 项目以及维护的公司，所以说这个类其实已经很元老级别了。然后我现在的光标就在他的署名上闪动，想想还有点小激动。</p>
</blockquote>
<p>我们调用的构造函数传递一个 <code>Resource</code> 接口参数，这个参数我并不打算深究，因为他就是一个简单的工具接口（在 <code>spring-core</code> 模块中定义的），里面指定了配置文件从哪个流出来（所以我们不仅仅可以使用 <code>File</code> 流，只要是 <code>IO流</code> 都可以作为配置文件的来源。） 除开构造函数构造的参数，他还直接定义了一个 <code>XmlBeanDefinitionReader</code>，就是一个配置文件的读取器，用来读取、解析配置内容的。然而这个类，先放一边，只需要看他在哪里调用的注册就可以了，因为我现在的目的不是怎么解析 <code>xml</code> 文件，而是怎么注册 <code>Bean</code>。</p>
<h2 id="XmlBeanDefinitionReader解析ClassBean-2"><a href="#XmlBeanDefinitionReader解析ClassBean-2" class="headerlink" title="XmlBeanDefinitionReader解析ClassBean"></a>XmlBeanDefinitionReader解析ClassBean</h2><p>现在我们把 <code>debug</code> 指针进入这个 <code>XmlBeanDefinitionReader.loadBeanDefinitions(resource)</code> 里边去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用封装编码的对象 <code>EncodedResource</code> 继续调用了同名的重载函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">    <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">            <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粘了代码觉得挺长的，那么通过调用 <code>loadBeanDefinitions(EncodedResource encodedResource)</code> 开始进行当前 <code>BeanFactory</code> 进行检测，如果已经存在了同样的解析进程，则抛出异常，这个异常我先放着，应该大概意思就是重复注册了配置文件吧？因为我们知道 <code>applicationContext</code> 是可以导入其他配置的，如果同样的配置注册了两次那么以为着配置有问题，则抛出异常。我们可以试一下： 修改 <code>applicationContext.xml</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- import他自己 --&gt;</span><br><span class="line">    &lt;import resource&#x3D;&quot;applicationContext.xml&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;TestBean&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;WeidanLi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>运行： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144719.png"> </p>
<p>果然，在第一次解析的时候，拿到了我的 <code>import</code> 节点，继续调用当前方法来注册的时候，因为文件是同一个，<code>Set&lt;EncodedResource&gt;.add()</code> 的时候添加失败了，抛出异常，直接解析失败。而 <code>Set</code> 这个实例是存储在当前线程的<code>ThreadLocal</code> 中的，防止重复读取配置文件。可以在这里看出来设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;EncodedResource&gt; currentResources &#x3D; this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">if (currentResources &#x3D;&#x3D; null) &#123;</span><br><span class="line">    currentResources &#x3D; new HashSet&lt;&gt;(4);</span><br><span class="line">    this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来进入一个 <code>try-catch</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">        <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    currentResources.remove(encodedResource);</span><br><span class="line">    <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步就是拆解上一步封装的 <code>EncodedResource</code> 拿到我们的文件资源，然后开始进入 <code>doLoadBeanDefinitions</code> 开始真正的读取。</p>
<blockquote>
<p>这其实是 <code>spring</code> 项目的一个编码风格，xxx() 函数一般做数据准备，包括验证，设置什么东西，然后doXxx() 才开始做真正的事情。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ... 省略一堆catch代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个方法很简单，就两句话，不过第一句读取可以跳过，无非就是 <code>文件流</code> 读成了熟悉的 <code>Document</code> 对象了。然后第二句话，没有 <code>do</code> 开头，说明又要进入准备：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</span><br><span class="line">            <span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是调用的时候需要的三个属性</span></span><br><span class="line"><span class="keyword">private</span> ProblemReporter problemReporter = <span class="keyword">new</span> FailFastProblemReporter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ReaderEventListener eventListener = <span class="keyword">new</span> EmptyReaderEventListener();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SourceExtractor sourceExtractor = <span class="keyword">new</span> NullSourceExtractor();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>准备了一个 <code>BeanDefinitionDocumentReader</code>，通过反射实例化了这个类，这个类作用就是记录了配置文件中，节点代表的含义，以及在解析过程中，遇到这些节点要干什么事情，比如遇到 <code>import</code> 要回来调用继续读取，遇到 <code>bean</code> 要实例化对象，并且注册到 <code>BeanFactory</code> 中。 而 <code>XmlReaderContext createReaderContext(Resource resource)</code> 构建一个对象 <code>XmlReaderContext</code>，应该说就是当前的上下文状态，包含了事件监听器、日志记录以及元信息提取器，然而在当前这个简单的 <code>BeanFactory</code> 中，这三个对象，都是很简单的实现（非空即NULL，<code>problemReporter</code> 则是一个记录器上下文，抛抛异常什么的）。 <code>XmlBeanDefinitionReader</code> 的任务基本上已经做完了，接下来就是交给解析器 <code>BeanDefinitionDocumentReader</code> 来做了。 接下来我们进入 <code>documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</code> 这句话，看看里面做了什么。</p>
<h2 id="BeanDefinitionDocumentReader读取配置文档-2"><a href="#BeanDefinitionDocumentReader读取配置文档-2" class="headerlink" title="BeanDefinitionDocumentReader读取配置文档"></a>BeanDefinitionDocumentReader读取配置文档</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">        doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            XmlReaderContext readerContext, Element root, <span class="meta">@Nullable</span> BeanDefinitionParserDelegate parentDelegate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionParserDelegate delegate = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">        delegate.initDefaults(root, parentDelegate);</span><br><span class="line">        <span class="keyword">return</span> delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">                <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">                <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，可以简单看到，<code>registerBeanDefinitions</code> 函数只是简单的设置了一下 <code>上一个类中的 xml 读取环境XmlReaderContext</code>，然后直接进入 <code>doRegisterBeanDefinitions</code> 开始解析。</p>
<blockquote>
<p>又见到这个 xxx() 和 doXxx() 的风格了。</p>
</blockquote>
<p>在 <code>doRegisterBeanDefinitions</code> 方法中，首先通过判断父类有没有 <code>BeanDefinitionParserDelegate</code> 解析器，如果没有，直接传递当前的 <code>XmlReaderContext上下文</code> <code>new</code> 一个新的解析器，先康康这个解析器是干嘛的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionParserDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEANS_NAMESPACE_URI = <span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MULTI_VALUE_ATTRIBUTE_DELIMITERS = <span class="string">&quot;,; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Value of a T/F attribute that represents true.</span></span><br><span class="line"><span class="comment">     * Anything else represents false. Case seNsItive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRUE_VALUE = <span class="string">&quot;true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FALSE_VALUE = <span class="string">&quot;false&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_VALUE = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DESCRIPTION_ELEMENT = <span class="string">&quot;description&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_NO_VALUE = <span class="string">&quot;no&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_BY_NAME_VALUE = <span class="string">&quot;byName&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_BY_TYPE_VALUE = <span class="string">&quot;byType&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_CONSTRUCTOR_VALUE = <span class="string">&quot;constructor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTOWIRE_AUTODETECT_VALUE = <span class="string">&quot;autodetect&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME_ATTRIBUTE = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_ELEMENT = <span class="string">&quot;bean&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String META_ELEMENT = <span class="string">&quot;meta&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID_ATTRIBUTE = <span class="string">&quot;id&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，直接下结论，这就是一个与我们配置文件节点、属性名字对应的解析器。 走到了中间的 <code>if</code> 代码，无非就是判断节点是否是根节点，以及有没有配置 <code>profile</code> 环境。如果有，是否跟当前配置想要的环境一致，如果不一致，跳过解析，一致就继续走到下面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  <span class="comment">// for Environment.acceptsProfiles(String...)</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">                <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">                <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                                <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessXml</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过了 <code>profile</code> 判断后，就开始解析配置文件了。 先开始 <code>preProcessXml</code> ，然而，默认的实现是不做任何事情，这就预留给我们，可以在子类里边做一些事情。如果我们用了自定义的标签，可以实现这个方法来实现我们标签想要的功能。比如我们可以实现一个 <code>author</code> 的 <code>xml</code> 节点，然后在日志打印这个配置文件的作者（防止有 <code>bug</code> 找不到当事人祭天~） 哦对了，<code>postProcessXml</code> 也没有实现，跟 <code>preProcessXml</code> 一样留给使用者。 紧接着，开始 <code>parseBeanDefinitions</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the given bean element, parsing the bean definition</span></span><br><span class="line"><span class="comment"> * and registering it with the registry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，摄影师，把聚光灯投向 <code>BeanDefinitionParserDelegate</code> 类。</p>
<h2 id="BeanDefinitionParserDelegate解析BeanDefinition-2"><a href="#BeanDefinitionParserDelegate解析BeanDefinition-2" class="headerlink" title="BeanDefinitionParserDelegate解析BeanDefinition"></a>BeanDefinitionParserDelegate解析BeanDefinition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionParserDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略上面一堆的常量</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">        String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String beanName = id;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                                beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                        <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">                        <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">                        <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">                        String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                        <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                                !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                            aliases.add(beanClassName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    error(ex.getMessage(), ele);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我在配置文件什么都没有定义，所以直接来到了这句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkNameUniqueness</span><span class="params">(String beanName, List&lt;String&gt; aliases, Element beanElement)</span> </span>&#123;</span><br><span class="line">    String foundName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(beanName) &amp;&amp; <span class="keyword">this</span>.usedNames.contains(beanName)) &#123;</span><br><span class="line">        foundName = beanName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        foundName = CollectionUtils.findFirstMatch(<span class="keyword">this</span>.usedNames, aliases);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;Bean name &#x27;&quot;</span> + foundName + <span class="string">&quot;&#x27; is already used in this &lt;beans&gt; element&quot;</span>, beanElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.usedNames.add(beanName);</span><br><span class="line">    <span class="keyword">this</span>.usedNames.addAll(aliases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后他就通过一个集合（这个集合记录我配置里面定义的所有名字 <code>name属性</code>）来判断名字是否是唯一的。 然而我都没有定义，所以还是不必要关心，过。 接下来继续关心 <code>BeanDefinitionParserDelegate</code> 的解析过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    String parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">        parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (... ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先有一个 <code>parseState</code> 来记录解析的状态（<code>finally</code> 里面会弹出来，所以这个是个栈结构），获取到 <code>类名</code> 以及 <code>父类</code>，然后进入 <code>createBeanDefinition</code> 开始创建 <code>BeanDefinition</code>。</p>
<blockquote>
<p><code>BeanDefinition</code> 是一个将配置文件中的内容抽象到内存对象的数据结构（就是业务中常用的DTO）。</p>
</blockquote>
<p>再来看看 <code>createBeanDefinition</code> 中做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(<span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> String parentName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">            parentName, className, <span class="keyword">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinitionReaderUtils.createBeanDefinition: </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">    bd.setParentName(parentName);</span><br><span class="line">    <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bd.setBeanClassName(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个 <code>GenericBeanDefinition</code>，指定了 <code>Bean</code> 的 <code>Class</code> 对象。</p>
<blockquote>
<p>GenericBeanDefinition 就是我们定义的，我们可以自己使用的，普通 <code>Bean</code> 的数据结构。</p>
</blockquote>
<p>然后接下来所做的事情，就是把标签里边的属性给设置到当前这个 <code>GenericBeanDefinition</code> 中去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">代码片段：</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br></pre></td></tr></table></figure>

<p>由于我们使用的是构造器注入值的方式，所以可以简单看看 <code>parseConstructorArgElements(ele, bd);</code> 这一段，其他的解析，如果没有设置，都会直接无操作的跳过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseConstructorArgElement</span><span class="params">(Element ele, BeanDefinition bd)</span> </span>&#123;</span><br><span class="line">    String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);</span><br><span class="line">    String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(indexAttr)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Integer.parseInt(indexAttr);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="string">&quot;&#x27;index&#x27; cannot be lower than 0&quot;</span>, ele);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry(index));</span><br><span class="line">                    Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">                    ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">                        valueHolder.setType(typeAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                        valueHolder.setName(nameAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    valueHolder.setSource(extractSource(ele));</span><br><span class="line">                    <span class="keyword">if</span> (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123;</span><br><span class="line">                        error(<span class="string">&quot;Ambiguous constructor-arg entries for index &quot;</span> + index, ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">            error(<span class="string">&quot;Attribute &#x27;index&#x27; of tag &#x27;constructor-arg&#x27; must be an integer&quot;</span>, ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> ConstructorArgumentEntry());</span><br><span class="line">            Object value = parsePropertyValue(ele, bd, <span class="keyword">null</span>);</span><br><span class="line">            ConstructorArgumentValues.ValueHolder valueHolder = <span class="keyword">new</span> ConstructorArgumentValues.ValueHolder(value);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(typeAttr)) &#123;</span><br><span class="line">                valueHolder.setType(typeAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                valueHolder.setName(nameAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            valueHolder.setSource(extractSource(ele));</span><br><span class="line">            bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无非就是拿到我配置文件中配置的值，然后注入到 <code>GenericBeanDefinition</code> 中去，我不想解读了。。。😑 注册完，返回到我们上面的主流程中来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">  String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">    String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">    aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String beanName = id;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">    beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">                   <span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">    checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">  <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">          beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">            beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">          <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">          <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">          <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">          String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">          <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">              beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">              !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">            aliases.add(beanClassName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        error(ex.getMessage(), ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我没有定义名字，所以，<code>XmlReaderContext</code> 需要帮我生成一个名字，默认是 <code>TestBean#0</code>，添加到 <code>alias</code> 数组中，然后返回去。</p>
<h2 id="BeanDefinitionDocumentReader注册BeanDefinition-2"><a href="#BeanDefinitionDocumentReader注册BeanDefinition-2" class="headerlink" title="BeanDefinitionDocumentReader注册BeanDefinition"></a>BeanDefinitionDocumentReader注册BeanDefinition</h2><p><code>BeanDefinitionParserDelegate</code> 昨晚解析的工作并且产生 <code>BeanDefinition</code> 返回回去了，接下来，生成实例的任务又回到了 <code>BeanDefinitionDocumentReader</code> 的头上。 先回忆一下刚刚到哪一步了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">  <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">  <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">  <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">  <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">  <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">  BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">  <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">        profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">      <span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">                       <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">      Node node = nl.item(i);</span><br><span class="line">      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element ele = (Element) node;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">          parseDefaultElement(ele, delegate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          delegate.parseCustomElement(ele);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    delegate.parseCustomElement(root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">    importBeanDefinitionResource(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">    processAliasRegistration(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">    processBeanDefinition(ele, delegate);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">    <span class="comment">// recurse</span></span><br><span class="line">    doRegisterBeanDefinitions(ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);<span class="comment">// ← 刚刚来到这一步</span></span><br><span class="line">  <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">                               bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来 <code>bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder)</code> 里面做的事情是用户自定义标签要做的事情，所以可以先不看。直接过，接下来就是将 <code>BeanDefinition</code> 放入当前的容器中了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanDefinitionRegistry</code> 从哪里来的，他其实就是刚开始进入的时候，传递了 <code>this</code> 实现将当前的 <code>BeanFactory</code> 放进去的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new XmlBeanFactory with the given resource,</span></span><br><span class="line"><span class="comment">     * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new XmlBeanFactory with the given input stream,</span></span><br><span class="line"><span class="comment">     * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentBeanFactory parent bean factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以此时，<code>registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())</code> 这句话就是注册 <code>BeanDefinition</code> 的关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Overriding user-defined bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a framework-generated bean definition: replacing [&quot;</span> +</span><br><span class="line">                        existingDefinition + <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; with an equivalent definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                        <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="function"><span class="keyword">null</span>  <span class="title">containsSingleton</span><span class="params">(beanName)</span>) </span>&#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有点长，仔细看了一下，验证和和真正注册都写在这里面，有点反之前 <code>xxx</code> 和 <code>doXxx</code> 的约定啊。总感觉是某个老鼠屎（比较大颗的那种，因为比我牛逼）写的。我来裁减掉日志记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">&quot;Bean name must not be empty&quot;</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">&quot;BeanDefinition must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Validation of bean definition failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<span class="comment">// ←直接来到这里</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="function"><span class="keyword">null</span>  <span class="title">containsSingleton</span><span class="params">(beanName)</span>) </span>&#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通篇很长，然而我现在的情况就是直接去到代码中我指示的地方，这两个就很好说了，到了 <code>removeManualSingletonName</code> 这一句则是移除当前已经存在的单例的名字。</p>
<h2 id="完成注册-2"><a href="#完成注册-2" class="headerlink" title="完成注册"></a>完成注册</h2><p>通篇讲完，我发现他并没有实例化我要的 <code>Bean</code>，然后在 <code>getBean</code> 的方法里面我发现我需要的时候他才开始创建真正的对象。</p>
<h2 id="getBean初始化-2"><a href="#getBean初始化-2" class="headerlink" title="getBean初始化"></a>getBean初始化</h2><p>我的测试用例第二句话是 <code>TestBean bean = bf.getBean(TestBean.class);</code>，就是这个时候拿到对应的对象的。</p>
<blockquote>
<p>那 lazy-init 有什么用呢… 可能其他容器用到了吧。</p>
</blockquote>
<p>现在我们进入 <code>getBean</code> 来看看了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getBean(requiredType, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (resolved == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) resolved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用了重载的方法，然后重载方法也比较简单，就是通过 <code>resolveBean</code> 拿到我的对象然后返回。那重点应该是 <code>resolveBean</code> 这个方法了。 <code>ResolvableType.forRawClass(requiredType)</code> 只是包装了一层对象，包含了我指定的 <code>Class</code> 其他没什么了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    NamedBeanHolder&lt;T&gt; namedBean = resolveNamedBean(ResolvableType.forRawClass(requiredType), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (namedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> namedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanFactory parent = getParentBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((AutowireCapableBeanFactory) parent).resolveNamedBean(requiredType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(requiredType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ResolvableType requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> nonUniqueAsNull)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(requiredType, <span class="string">&quot;Required type must not be null&quot;</span>);</span><br><span class="line">    String[] candidateNames = getBeanNamesForType(requiredType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        List&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!containsBeanDefinition(beanName)  getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">                autowireCandidates.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!autowireCandidates.isEmpty()) &#123;</span><br><span class="line">            candidateNames = StringUtils.toStringArray(autowireCandidates);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (candidateNames.length == <span class="number">1</span>) &#123;</span><br><span class="line">        String beanName = candidateNames[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (candidateNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; candidates = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(candidateNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (containsSingleton(beanName) &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object beanInstance = getBean(beanName);</span><br><span class="line">                candidates.put(beanName, (beanInstance <span class="keyword">instanceof</span> NullBean ? <span class="keyword">null</span> : beanInstance));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                candidates.put(beanName, getType(beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());</span><br><span class="line">        <span class="keyword">if</span> (candidateName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (candidateName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object beanInstance = candidates.get(candidateName);</span><br><span class="line">            <span class="keyword">if</span> (beanInstance == <span class="keyword">null</span>  beanInstance <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                beanInstance = getBean(candidateName, requiredType.toClass(), args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NamedBeanHolder&lt;&gt;(candidateName, (T) beanInstance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nonUniqueAsNull) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.keySet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单参数的 <code>resolveNamedBean</code> 调用了重载的 <code>resolveNamedBean</code> 方法，下面的代码是如果没有找到，继续从父级容器寻找，然而我们都没有父级容器而且可以直接就拿到实例，所以下面的代码基本可以不看。 首先，他通过 <code>String[] candidateNames = getBeanNamesForType(requiredType)</code> 拿到了容器中帮我生成的默认名字。然而由于只有一个名字，所以她走了这段代码：<code>return new NamedBeanHolder&lt;&gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));</code>，首先通过 <code>getBean(beanName, requiredType.toClass(), args)</code> 拿到实例。但是这个方法已经进入到了父类 <code>AbstractBeanFactory</code> 中，所以父类应该是做了实例化操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">              <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">      <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">        String nameToLookup = originalBeanName(name);</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">          <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">              nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">          <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">        markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">        String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">        <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            registerDependentBean(dep, beanName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create bean instance.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">              <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">              <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">          <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">          Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">finally</span> &#123;</span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">          bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          String scopeName = mbd.getScope();</span><br><span class="line">          <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">          <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">              beforePrototypeCreation(beanName);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">finally</span> &#123;</span><br><span class="line">                afterPrototypeCreation(beanName);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> convertedBean;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">          logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">              ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>doGetBean</code> 方法还是很长，所以我感觉我还是需要裁减掉一些东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">  Object bean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">  Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">    <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">    <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">      markBeanAsCreated(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">  <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> convertedBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">            ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在 <code>doGetBean</code> 代码就只做几件事情了：</p>
<ol>
<li>尝试获取正在创建的单例，如果没有，创建、放入容器、返回；</li>
<li>检查是否有循环以来，类似于 A 依赖 B，B 依赖 A 的操作；</li>
<li>转换为我们制定的类（有接口的情况下）；</li>
</ol>
<h2 id="创建Bean对象-2"><a href="#创建Bean对象-2" class="headerlink" title="创建Bean对象"></a>创建Bean对象</h2><p>所以我们现在需要看的是这个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">                ...</span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">          sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 在子类的 AbstractAutowireCapableBeanFactory 实现</span></span><br><span class="line">              <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">              destroySingleton(beanName);</span><br><span class="line">              <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------&gt; AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException  ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然而，我们注册的是 <code>GenericBeanDefinition</code> 来到这里被转换成 <code>RootBeanDefinition</code>，进去看了注释发现，他说 <code>GenericBeanDefinition</code> 拥有高级的功能。所以这里的转换应该是为了兼容老版本的吧。 因为我们在配置文件定义的类，是可以通过其他方法来覆盖他原来拥有的方法的（但其实我还是不明白这么做的含义是什么，一般日常都是直接修改的吧，唯一能想到的就是临时拓展功能），所以在这里需要准备一下覆盖的配置：<code>mbdToUse.prepareMethodOverrides();</code> 接下来，来到了 <code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>，看注释的意思是可以注入 <code>AOP</code> 然后获取到了一个代理增强的实例，但是由于目前我还没设置 <code>AOP</code>，姑且先跳过不管吧。毕竟他也是直接返回一个 <code>null</code> 值。 下一步就是 <code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code> 了，这一步有点复杂….不过慢慢来吧。</p>
<hr>
<p>我们来看看 <code>doCreateBean(beanName, mbdToUse, args)</code> 做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦<del>~</del>，出现了一个 <code>BeanWrapper</code> 的创建了。</p>
<blockquote>
<p><code>BeanWrapper</code> 与 <code>BeanDefinition</code> 的道理差不多，<code>BeanDefinition</code> 记录着配置信息，那 <code>BeanWrapper</code> 也一样记录着创建的信息了。 忽然间感觉好像很少需要用到配置记录这类东西？</p>
</blockquote>
<p>然后来到了这两个 <code>if</code> 里边：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">  instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实第一个 <code>if</code> 就没什么作用了，是用于给 <code>FactoryBean</code> 的，直接移除，但是移除返回的是 <code>null</code>，所以顺利的进入了第二个 <code>if</code> 语句。我现在贴出 <code>createBeanInstance</code> 的代码出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  调用了这个方法</span></span><br><span class="line"><span class="comment">    @Nullable</span></span><br><span class="line"><span class="comment">    protected Class&lt;?&gt; resolveBeanClass(final RootBeanDefinition mbd, String beanName, final Class&lt;?&gt;... typesToMatch)</span></span><br><span class="line"><span class="comment">            throws CannotLoadBeanClassException &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            if (mbd.hasBeanClass()) &#123;</span></span><br><span class="line"><span class="comment">                return mbd.getBeanClass();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ----------------- 先不看 Start ----------------- */</span></span><br><span class="line">        <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">        <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ----------------- 先不看 END ----------------- */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">        <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    resolved = <span class="keyword">true</span>;</span><br><span class="line">                    autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">            <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">                <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (ctors != <span class="keyword">null</span>  mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR </span><br><span class="line">                mbd.hasConstructorArgumentValues()  !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">        ctors = mbd.getPreferredConstructors();</span><br><span class="line">        <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">        <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么当前的 <code>BeanDefinition</code> 已经记录了我们使用的，也就是 <code>TestBean.class</code>，所以直接返回这个 <code>Class</code> 实例即可。然后继续接下来的动作，因为已经支持了 <code>j8</code> 的 <code>Lambda</code> 函数（<code>j8</code> ？~），所以此处可以编写函数进行创建，先不看，过。 然而我在 <code>getBean</code> 的时候并没有传递参数，只是传递了一个 <code>Class</code>，所以此处所有的 <code>args</code> 都是 <code>Null</code>。 那 <code>Spring</code> 该怎么办呢？我也没有提供 <code>factoryMethod</code> 也没有指定 <code>构造方法</code>， 他只能从配置文件来获取了。 所以设置了 <code>resolved</code> 为 <code>true</code>（<code>resolved</code> 意思是解决，我想这里可以当成自己解决的意思吧）</p>
<h2 id="查找对应的构造器-2"><a href="#查找对应的构造器-2" class="headerlink" title="查找对应的构造器"></a>查找对应的构造器</h2><p>接下来 <code>Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</code> 用于获取 <code>Bean</code> 创建的后处理器，看看是否有做什么后备操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(<span class="meta">@Nullable</span> Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">            <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">                    <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ctors;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然而我没有给，直接给 <code>null</code> 返回出来了。 接下来 <code>mbd.hasConstructorArgumentValues()</code> 返回 <code>true</code>，因为我提供了构造器的值，所以使用 <code>return autowireConstructor(beanName, mbd, ctors, args);</code> 这个函数进行创建并返回。 <code>autowireConstructor</code> 只有一句话，就是 <code>new</code> 一个构造器构建器进行注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] ctors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this</code> 是当前的 <code>BeanFactory</code>，然后我们可以直接进入 <code>autowireConstructor</code> 构造器注入方式的函数了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(String beanName, RootBeanDefinition mbd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Constructor&lt;?&gt;[] chosenCtors, <span class="meta">@Nullable</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line">    <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; constructorToUse = <span class="keyword">null</span>;</span><br><span class="line">    ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line">    Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsToUse = explicitArgs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">                <span class="comment">// Found a cached constructor...</span></span><br><span class="line">                argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">                <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>  argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Take specified constructors, if any.</span></span><br><span class="line">        Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">                        beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Resolution of declared constructors on bean Class [&quot;</span> + beanClass.getName() +</span><br><span class="line">                        <span class="string">&quot;] from ClassLoader [&quot;</span> + beanClass.getClassLoader() + <span class="string">&quot;] failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (candidates.length == <span class="number">1</span> &amp;&amp; explicitArgs == <span class="keyword">null</span> &amp;&amp; !mbd.hasConstructorArgumentValues()) &#123;</span><br><span class="line">            Constructor&lt;?&gt; uniqueCandidate = candidates[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (uniqueCandidate.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;</span><br><span class="line">                    mbd.constructorArgumentsResolved = <span class="keyword">true</span>;</span><br><span class="line">                    mbd.resolvedConstructorArguments = EMPTY_ARGS;</span><br><span class="line">                &#125;</span><br><span class="line">                bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));</span><br><span class="line">                <span class="keyword">return</span> bw;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to resolve the constructor.</span></span><br><span class="line">        <span class="keyword">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> </span><br><span class="line">                mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">        ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minNrOfArgs;</span><br><span class="line">        <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minNrOfArgs = explicitArgs.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">            resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AutowireUtils.sortConstructors(candidates);</span><br><span class="line">        <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> parameterCount = candidate.getParameterCount();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; argsToUse != <span class="keyword">null</span> &amp;&amp; argsToUse.length &gt; parameterCount) &#123;</span><br><span class="line">                <span class="comment">// Already found greedy constructor that can be satisfied -&gt;</span></span><br><span class="line">                <span class="comment">// do not look any further, there are only less greedy constructors left.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parameterCount &lt; minNrOfArgs) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ArgumentsHolder argsHolder;</span><br><span class="line">            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);</span><br><span class="line">                    <span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">                        <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,</span><br><span class="line">                            getUserDeclaredConstructor(candidate), autowiring, candidates.length == <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(<span class="string">&quot;Ignoring constructor [&quot;</span> + candidate + <span class="string">&quot;] of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Swallow and try next constructor.</span></span><br><span class="line">                    <span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        causes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    causes.add(ex);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Explicit arguments given -&gt; arguments length must match exactly.</span></span><br><span class="line">                <span class="keyword">if</span> (parameterCount != explicitArgs.length) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">                    argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">            <span class="comment">// Choose this constructor if it represents the closest match.</span></span><br><span class="line">            <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">                constructorToUse = candidate;</span><br><span class="line">                argsHolderToUse = argsHolder;</span><br><span class="line">                argsToUse = argsHolder.arguments;</span><br><span class="line">                minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">                ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                    ambiguousConstructors.add(constructorToUse);</span><br><span class="line">                &#125;</span><br><span class="line">                ambiguousConstructors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line">                <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Could not resolve matching constructor &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">&quot;Ambiguous constructor matches found in bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot;</span> +</span><br><span class="line">                    ambiguousConstructors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Assert.state(argsToUse != <span class="keyword">null</span>, <span class="string">&quot;Unresolved constructor arguments&quot;</span>);</span><br><span class="line">    bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br><span class="line">    <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这函数的长度还是挺恶心人的。。。 首先，在 <code>BeanFactory</code> 里边记录些东西并进行初始化 <code>BeanWrapImpl</code>，我就先不看了，我现在目标是进入初始化的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">candidates = (mbd.isNonPublicAccessAllowed() ?</span><br><span class="line">  beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br></pre></td></tr></table></figure>

<p>这句话是个三元表达式，<code>nonPublicAccessAllowed</code> 默认是 <code>true</code>，所以走 <code>beanClass.getDeclaredConstructors()</code>，这个是 <code>jdk</code> <code>Class</code> 的方法，获取到所有声明的构造函数，不出意外的话是两个。 接下来就是判断拿哪个构造器了，第一个 <code>if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues())</code> 显然不是，因为我有两个构造函数。所以又可以跳过一大段无聊的代码~然而因为传递的 <code>args</code> 是 <code>Null</code> 所以开始拿到配置文件中构造器参数的长度：<code>minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</code>。 接下来就是找到哪个构造器来匹配了，采用 <code>for</code> 所有构造器，比对长度的方式来做：<code>for (Constructor&lt;?&gt; candidate : candidates) &#123;</code> 如果不符合条件的就 <code>Continue</code>，接下来获取名字，不出意外的话，是为了能够写日志hhhh？下面还有使用到这个参数，接着看下去。 先是记录了使用的配置文件的值，使用的构造器，然后 <code>argsHolderToUse.storeCache(mbd, constructorToUse);</code> 保存到缓存中以便后面使用（是不是有点没必要的）。</p>
<h2 id="开始初始化对象-2"><a href="#开始初始化对象-2" class="headerlink" title="开始初始化对象"></a>开始初始化对象</h2><p>然后调用 <code>instantiate</code> 进行真正的对象初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">instantiate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt; constructorToUse, Object[] argsToUse)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  InstantiationStrategy strategy = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy();</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">     strategy.instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse),</span><br><span class="line">     <span class="keyword">this</span>.beanFactory.getAccessControlContext());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> strategy.instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">    <span class="string">&quot;Bean instantiation via constructor failed&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有系统安全管理器，所以使用 <code>SimpleInstantiationStrategy.instantiate</code> 开始初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">// use own privileged to change accessibility (when security is on)</span></span><br><span class="line">   AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">    ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args); <span class="comment">// 直接进入这里</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BeanUtils</code> 就是封装 <code>jdk</code> 反射调用构造器构造对象的方法了。 好了一层一层的返回去，最后回到了这里 <code>AbstractBeanFactory</code> 里边刚刚路过的 <code>Lambda</code> 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">  sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">      <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">      <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">      destroySingleton(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册刚刚创建的Bean到BeanFactory中-2"><a href="#注册刚刚创建的Bean到BeanFactory中-2" class="headerlink" title="注册刚刚创建的Bean到BeanFactory中"></a>注册刚刚创建的Bean到BeanFactory中</h2><p>拿到了 <code>sharedInstance</code> 之前呢，其实 <code>AbstractBeanFactory</code> 是调用父级 <code>DefaultSingletonBeanRegistry</code> 的 <code>getSingleton</code> 先从容器中查找，没有的话再调用了我们刚刚看的一堆创建过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName); <span class="comment">// 因为第一次取没有找到所以进入创建流程</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                            <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                beforeSingletonCreation(beanName); <span class="comment">// 开始通知</span></span><br><span class="line">                <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    newSingleton = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                    <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                            ex.addRelatedCause(suppressedException);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    afterSingletonCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    addSingleton(beanName, singletonObject); <span class="comment">// 然后做了记录</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> singletonObject;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至此一个真正创建 <code>Bean</code> 的流程就完成了。 我们接下来看 <code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</code> 这句话，这句话说是 <code>get</code> 但是内部其实就是验证 <code>Bean</code> 是否创建完整，是否返回的是 <code>Null对象</code> 或者 <code>工厂对象</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">  <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">  <span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">  <span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">  <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  省略下面代码因为上面已经直接返回回去了，下面其实就是说拿到了 FactoryBean 的话，调用创建真正的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个返回一路前进，就出来到我们自己写的 <code>TestBean bean = bf.getBean(TestBean.class);</code></p>
<h2 id="总结一下-2"><a href="#总结一下-2" class="headerlink" title="总结一下"></a>总结一下</h2><p>我用类图来说说看法： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144826.png"> 代码的分割还有意思：</p>
<ol>
<li>定义基础的 <code>BeanFactory</code> 能干嘛（能拿能顺序能父子容器的 <code>BeanFactory</code>）；</li>
<li>定义了 <code>Registry</code> 能干嘛（无非就是容器的增删查改）；</li>
<li>初步实现了第 <code>2</code> 点的功能；</li>
<li>上面功能都有了，接下来要自动装配了，自动化的 <code>BeanFactory</code>；</li>
<li>能自动组装了，还要可以配置，定义根据配置做上面动作的增删查改；</li>
<li>然后就是一个完整的 <code>BeanFactory</code> 类：<code>XmlBeanFactory</code>。</li>
</ol>
<h2 id="小看法-1"><a href="#小看法-1" class="headerlink" title="小看法"></a>小看法</h2><p>第一次写 <code>Spring</code> 相关的源码文章，写的可能不是很好，已经跟随断点慢慢一步一步的走过来了。其实读完有那么一瞬间我感觉，针对一个函数做一个小事情的做法，<code>Spring</code> 貌似并没有做到？不过后面仔细思考了一下，因为我看源码的时候会忽略掉函数权限的问题，所以其实接口暴露的方法能够拿到正确的值才是关键。 不得不说，<code>XmlBeanFactory</code> 这个类走得有点复杂，但是我看后面的 <code>Context</code> 已经没有使用上面所说的所有类了。这个类现在的责任应该就是当成学习来供读者感受的吧。 代码的分割还有意思：</p>
<ol>
<li>定义基础的 <code>BeanFactory</code> 能干嘛（能拿能顺序能父子容器的 <code>BeanFactory</code>）；</li>
<li>定义了 <code>Registry</code> 能干嘛（无非就是容器的增删查改）；</li>
<li>初步实现了第 <code>2</code> 点的功能；</li>
<li>上面功能都有了，接下来要自动装配了，自动化的 <code>BeanFactory</code>；</li>
<li>能自动组装了，还要可以配置，定义根据配置做上面动作的增删查改；</li>
<li>然后就是一个完整的 <code>BeanFactory</code> 类：<code>XmlBeanFactory</code>。</li>
</ol>
<h2 id="小看法-2"><a href="#小看法-2" class="headerlink" title="小看法"></a>小看法</h2><p>第一次写 <code>Spring</code> 相关的源码文章，写的可能不是很好，已经跟随断点慢慢一步一步的走过来了。其实读完有那么一瞬间我感觉，针对一个函数做一个小事情的做法，<code>Spring</code> 貌似并没有做到？不过后面仔细思考了一下，因为我看源码的时候会忽略掉函数权限的问题，所以其实接口暴露的方法能够拿到正确的值才是关键。 不得不说，<code>XmlBeanFactory</code> 这个类走得有点复杂，但是我看后面的 <code>Context</code> 已经没有使用上面所说的所有类了。这个类现在的责任应该就是当成学习来供读者感受的吧。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/frame/Spring%E6%BA%90%E7%A0%81/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%BA%86%E8%A7%A3spring%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/frame/Spring%E6%BA%90%E7%A0%81/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%BA%86%E8%A7%A3spring%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">【Spring源码】第二步：了解Spring的项目架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-03 19:37:22" itemprop="dateCreated datePublished" datetime="2019-12-03T19:37:22+08:00">2019-12-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 14:43:53" itemprop="dateModified" datetime="2020-11-10T14:43:53+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/" itemprop="url" rel="index"><span itemprop="name">frame</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/Spring%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">Spring源码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Spring项目模块"><a href="#Spring项目模块" class="headerlink" title="Spring项目模块"></a>Spring项目模块</h2><p>下了源码一看，我去（我其实没有那么惊讶毕竟功能强大，多也正常），<code>Spring</code> 居然有这么多的模块划分，但是这些模块都是做什么的，可能我们平常观察项目集成的时候，能够感受一些东西出来。比如：<code>spring-web</code> 是 <code>SpringMVC</code> 的内容。所以在日常中，把 <code>SpringMVC</code> 当成一个独立框架是一个很有问题的说法，他其实也就是 <code>Spring</code> 家族中的一个小模块而已。除了这个模块比较常见，我们还使用了 <code>AOP</code> <code>Transction</code> 这些模块，因为很多时候，在框架的集成中，已经依赖好了这些中间对接模块，但是他其实存在于每一个基本的 <code>web</code> 项目中。 我一直很喜欢 <code>Spring</code> 提供的说明书：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/index.html">说明书链接</a> 这个说明书开头就已经把所有模块，做什么事情的都总结好了，需要用到哪个模块的说明，进入对应的链接就好了： </p>
<h2 id="Spring项目模块-1"><a href="#Spring项目模块-1" class="headerlink" title="Spring项目模块"></a>Spring项目模块</h2><p>下了源码一看，我去（我其实没有那么惊讶毕竟功能强大，多也正常），<code>Spring</code> 居然有这么多的模块划分，但是这些模块都是做什么的，可能我们平常观察项目集成的时候，能够感受一些东西出来。比如：<code>spring-web</code> 是 <code>SpringMVC</code> 的内容。所以在日常中，把 <code>SpringMVC</code> 当成一个独立框架是一个很有问题的说法，他其实也就是 <code>Spring</code> 家族中的一个小模块而已。除了这个模块比较常见，我们还使用了 <code>AOP</code> <code>Transction</code> 这些模块，因为很多时候，在框架的集成中，已经依赖好了这些中间对接模块，但是他其实存在于每一个基本的 <code>web</code> 项目中。 我一直很喜欢 <code>Spring</code> 提供的说明书：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/index.html">说明书链接</a> 这个说明书开头就已经把所有模块，做什么事情的都总结好了，需要用到哪个模块的说明，进入对应的链接就好了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144307.png" alt="image-20191202151902551"></p>
<p> 简单说说：</p>
<ol>
<li>总览：介绍 <code>Spring</code> 的背景故事；</li>
<li><code>Core核心模块</code>：<code>Spring</code> 的核心是什么，就是 <code>容器+AOP</code>。一切的事情都是基于这两个模块而来，现有容器，容器装着我们定义的 <code>Bean</code> 配置，然后再是 <code>AOP</code>，<code>AOP</code> 可以增强很多额外的功能，比如 <code>spring-cache</code> 缓存。然而这里的介绍还包含了事件通知、资源管理、<code>i18n</code>、数据校验、数据绑定以及类型转变；</li>
<li><code>Testing测试模块</code>：我们公司倒是很少写测试用例，然而这个模块包含了一系列的测试模块，包括 <code>Mock数据</code>、测试的Spring上下文、<code>SpringMVC</code> 的测试等等；</li>
<li><code>DataAccess数据访问模块</code>：包含了数据库事务，<code>Dao层</code> 的支持，也就是常见的 <code>MyBatis</code> 整合 <code>Spring</code> 需要用到的一些接口，还有 <code>jdbcTemplate</code>；</li>
<li><code>WebServlet 和 WebReactive</code>：包含有新版才有的 <code>WebFlux</code> 模块还有他的客户端，我们常见的 <code>SpringMVC</code>，<code>WebSocket</code>；</li>
<li><code>Integration集成模块</code>：这个模块可能用的不是很多？有远程调用过时的 <code>JMS</code> 技术，<code>Email</code>，任务，调度以及缓存模块；</li>
<li><code>Language</code> 就不用说啦，支持的编程语言。</li>
</ol>
<h2 id="spring-core项目"><a href="#spring-core项目" class="headerlink" title="spring-core项目"></a>spring-core项目</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144320.png"></p>
<p> 有点报错，但是不影响运行呀~ 为啥这个模块要在这里说，因为这个模块是最基础的一个，基本 <code>Spring</code> 所有的子模块都以来这个项目，那么他有什么用，因为他是一个工具人工具模块，比如这个 <code>StringUtils</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144343.png"> </p>
<p>还有个点，他的 <code>utils</code> 都是抽象类的（防止实例化），提供静态方法使用。在日常业务搬砖中，也可以直接使用这些工具类，节省了很多依赖包。 好了，可以开始进入源码的阶段了，这篇稍稍短点，但是那时候知道文档地址的时候简直如获珍宝，一切我们所需要的东西都可以在这里找到。</p>
<p> 简单说说：</p>
<ol>
<li>总览：介绍 <code>Spring</code> 的背景故事；</li>
<li><code>Core核心模块</code>：<code>Spring</code> 的核心是什么，就是 <code>容器+AOP</code>。一切的事情都是基于这两个模块而来，现有容器，容器装着我们定义的 <code>Bean</code> 配置，然后再是 <code>AOP</code>，<code>AOP</code> 可以增强很多额外的功能，比如 <code>spring-cache</code> 缓存。然而这里的介绍还包含了事件通知、资源管理、<code>i18n</code>、数据校验、数据绑定以及类型转变；</li>
<li><code>Testing测试模块</code>：我们公司倒是很少写测试用例，然而这个模块包含了一系列的测试模块，包括 <code>Mock数据</code>、测试的Spring上下文、<code>SpringMVC</code> 的测试等等；</li>
<li><code>DataAccess数据访问模块</code>：包含了数据库事务，<code>Dao层</code> 的支持，也就是常见的 <code>MyBatis</code> 整合 <code>Spring</code> 需要用到的一些接口，还有 <code>jdbcTemplate</code>；</li>
<li><code>WebServlet 和 WebReactive</code>：包含有新版才有的 <code>WebFlux</code> 模块还有他的客户端，我们常见的 <code>SpringMVC</code>，<code>WebSocket</code>；</li>
<li><code>Integration集成模块</code>：这个模块可能用的不是很多？有远程调用过时的 <code>JMS</code> 技术，<code>Email</code>，任务，调度以及缓存模块；</li>
<li><code>Language</code> 就不用说啦，支持的编程语言。</li>
</ol>
<h2 id="spring-core项目-1"><a href="#spring-core项目-1" class="headerlink" title="spring-core项目"></a>spring-core项目</h2><h2 id="Spring项目模块-2"><a href="#Spring项目模块-2" class="headerlink" title="Spring项目模块"></a>Spring项目模块</h2><p>下了源码一看，我去（我其实没有那么惊讶毕竟功能强大，多也正常），<code>Spring</code> 居然有这么多的模块划分，但是这些模块都是做什么的，可能我们平常观察项目集成的时候，能够感受一些东西出来。比如：<code>spring-web</code> 是 <code>SpringMVC</code> 的内容。所以在日常中，把 <code>SpringMVC</code> 当成一个独立框架是一个很有问题的说法，他其实也就是 <code>Spring</code> 家族中的一个小模块而已。除了这个模块比较常见，我们还使用了 <code>AOP</code> <code>Transction</code> 这些模块，因为很多时候，在框架的集成中，已经依赖好了这些中间对接模块，但是他其实存在于每一个基本的 <code>web</code> 项目中。 我一直很喜欢 <code>Spring</code> 提供的说明书：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/index.html">说明书链接</a> 这个说明书开头就已经把所有模块，做什么事情的都总结好了，需要用到哪个模块的说明，进入对应的链接就好了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144307.png" alt="image-20191202151902551"></p>
<p> 简单说说：</p>
<ol>
<li>总览：介绍 <code>Spring</code> 的背景故事；</li>
<li><code>Core核心模块</code>：<code>Spring</code> 的核心是什么，就是 <code>容器+AOP</code>。一切的事情都是基于这两个模块而来，现有容器，容器装着我们定义的 <code>Bean</code> 配置，然后再是 <code>AOP</code>，<code>AOP</code> 可以增强很多额外的功能，比如 <code>spring-cache</code> 缓存。然而这里的介绍还包含了事件通知、资源管理、<code>i18n</code>、数据校验、数据绑定以及类型转变；</li>
<li><code>Testing测试模块</code>：我们公司倒是很少写测试用例，然而这个模块包含了一系列的测试模块，包括 <code>Mock数据</code>、测试的Spring上下文、<code>SpringMVC</code> 的测试等等；</li>
<li><code>DataAccess数据访问模块</code>：包含了数据库事务，<code>Dao层</code> 的支持，也就是常见的 <code>MyBatis</code> 整合 <code>Spring</code> 需要用到的一些接口，还有 <code>jdbcTemplate</code>；</li>
<li><code>WebServlet 和 WebReactive</code>：包含有新版才有的 <code>WebFlux</code> 模块还有他的客户端，我们常见的 <code>SpringMVC</code>，<code>WebSocket</code>；</li>
<li><code>Integration集成模块</code>：这个模块可能用的不是很多？有远程调用过时的 <code>JMS</code> 技术，<code>Email</code>，任务，调度以及缓存模块；</li>
<li><code>Language</code> 就不用说啦，支持的编程语言。</li>
</ol>
<h2 id="spring-core项目-2"><a href="#spring-core项目-2" class="headerlink" title="spring-core项目"></a>spring-core项目</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144320.png"></p>
<p> 有点报错，但是不影响运行呀~ 为啥这个模块要在这里说，因为这个模块是最基础的一个，基本 <code>Spring</code> 所有的子模块都以来这个项目，那么他有什么用，因为他是一个工具人工具模块，比如这个 <code>StringUtils</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144343.png"> </p>
<p>还有个点，他的 <code>utils</code> 都是抽象类的（防止实例化），提供静态方法使用。在日常业务搬砖中，也可以直接使用这些工具类，节省了很多依赖包。 好了，可以开始进入源码的阶段了，这篇稍稍短点，但是那时候知道文档地址的时候简直如获珍宝，一切我们所需要的东西都可以在这里找到。</p>
<p> 有点报错，但是不影响运行呀~ 为啥这个模块要在这里说，因为这个模块是最基础的一个，基本 <code>Spring</code> 所有的子模块都以来这个项目，那么他有什么用，因为他是一个工具人工具模块，比如这个 <code>StringUtils</code>： </p>
<h2 id="Spring项目模块-3"><a href="#Spring项目模块-3" class="headerlink" title="Spring项目模块"></a>Spring项目模块</h2><p>下了源码一看，我去（我其实没有那么惊讶毕竟功能强大，多也正常），<code>Spring</code> 居然有这么多的模块划分，但是这些模块都是做什么的，可能我们平常观察项目集成的时候，能够感受一些东西出来。比如：<code>spring-web</code> 是 <code>SpringMVC</code> 的内容。所以在日常中，把 <code>SpringMVC</code> 当成一个独立框架是一个很有问题的说法，他其实也就是 <code>Spring</code> 家族中的一个小模块而已。除了这个模块比较常见，我们还使用了 <code>AOP</code> <code>Transction</code> 这些模块，因为很多时候，在框架的集成中，已经依赖好了这些中间对接模块，但是他其实存在于每一个基本的 <code>web</code> 项目中。 我一直很喜欢 <code>Spring</code> 提供的说明书：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/index.html">说明书链接</a> 这个说明书开头就已经把所有模块，做什么事情的都总结好了，需要用到哪个模块的说明，进入对应的链接就好了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144307.png" alt="image-20191202151902551"></p>
<p> 简单说说：</p>
<ol>
<li>总览：介绍 <code>Spring</code> 的背景故事；</li>
<li><code>Core核心模块</code>：<code>Spring</code> 的核心是什么，就是 <code>容器+AOP</code>。一切的事情都是基于这两个模块而来，现有容器，容器装着我们定义的 <code>Bean</code> 配置，然后再是 <code>AOP</code>，<code>AOP</code> 可以增强很多额外的功能，比如 <code>spring-cache</code> 缓存。然而这里的介绍还包含了事件通知、资源管理、<code>i18n</code>、数据校验、数据绑定以及类型转变；</li>
<li><code>Testing测试模块</code>：我们公司倒是很少写测试用例，然而这个模块包含了一系列的测试模块，包括 <code>Mock数据</code>、测试的Spring上下文、<code>SpringMVC</code> 的测试等等；</li>
<li><code>DataAccess数据访问模块</code>：包含了数据库事务，<code>Dao层</code> 的支持，也就是常见的 <code>MyBatis</code> 整合 <code>Spring</code> 需要用到的一些接口，还有 <code>jdbcTemplate</code>；</li>
<li><code>WebServlet 和 WebReactive</code>：包含有新版才有的 <code>WebFlux</code> 模块还有他的客户端，我们常见的 <code>SpringMVC</code>，<code>WebSocket</code>；</li>
<li><code>Integration集成模块</code>：这个模块可能用的不是很多？有远程调用过时的 <code>JMS</code> 技术，<code>Email</code>，任务，调度以及缓存模块；</li>
<li><code>Language</code> 就不用说啦，支持的编程语言。</li>
</ol>
<h2 id="spring-core项目-3"><a href="#spring-core项目-3" class="headerlink" title="spring-core项目"></a>spring-core项目</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144320.png"></p>
<p> 有点报错，但是不影响运行呀~ 为啥这个模块要在这里说，因为这个模块是最基础的一个，基本 <code>Spring</code> 所有的子模块都以来这个项目，那么他有什么用，因为他是一个工具人工具模块，比如这个 <code>StringUtils</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144343.png"> </p>
<p>还有个点，他的 <code>utils</code> 都是抽象类的（防止实例化），提供静态方法使用。在日常业务搬砖中，也可以直接使用这些工具类，节省了很多依赖包。 好了，可以开始进入源码的阶段了，这篇稍稍短点，但是那时候知道文档地址的时候简直如获珍宝，一切我们所需要的东西都可以在这里找到。 </p>
<p>还有个点，他的 <code>utils</code> 都是抽象类的（防止实例化），提供静态方法使用。在日常业务搬砖中，也可以直接使用这些工具类，节省了很多依赖包。 好了，可以开始进入源码的阶段了，这篇稍稍短点，但是那时候知道文档地址的时候简直如获珍宝，一切我们所需要的东西都可以在这里找到。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/frame/Spring%E6%BA%90%E7%A0%81/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E5%BC%80%E5%A7%8B%E8%AF%BB%E6%BA%90%E7%A0%81-%E5%9F%BA%E4%BA%8Eidea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/frame/Spring%E6%BA%90%E7%A0%81/%E3%80%90spring%E6%BA%90%E7%A0%81%E3%80%91%E5%BC%80%E5%A7%8B%E8%AF%BB%E6%BA%90%E7%A0%81-%E5%9F%BA%E4%BA%8Eidea/" class="post-title-link" itemprop="url">【Spring源码】第一步：开始读源码--基于idea</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-03 19:34:07" itemprop="dateCreated datePublished" datetime="2019-12-03T19:34:07+08:00">2019-12-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 14:46:38" itemprop="dateModified" datetime="2020-11-10T14:46:38+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/" itemprop="url" rel="index"><span itemprop="name">frame</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/Spring%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">Spring源码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>心心想念很久读 <code>Spring</code> 源码，但是一直没有坚持下去。也看了一些别人怎么读源码的教程，然而有一天忽然在上班的公交上来了灵感，最方便的工具就在我手上啊！ 对，就是那个叫 <code>idea</code> 的编码工具！</p>
<h2 id="看类层次图"><a href="#看类层次图" class="headerlink" title="看类层次图"></a>看类层次图</h2><p>有两种方式，一种是直接生成 <code>UML</code> 图： 在想要看的类上面，右键选择这里（当然建议记住这里的快捷键），就可以出现 <code>idea</code> 绘制好的 <code>UML</code> 图：<br>心心想念很久读 <code>Spring</code> 源码，但是一直没有坚持下去。也看了一些别人怎么读源码的教程，然而有一天忽然在上班的公交上来了灵感，最方便的工具就在我手上啊！ 对，就是那个叫 <code>idea</code> 的编码工具！</p>
<h2 id="看类层次图-1"><a href="#看类层次图-1" class="headerlink" title="看类层次图"></a>看类层次图</h2><p>有两种方式，一种是直接生成 <code>UML</code> 图： 在想要看的类上面，右键选择这里（当然建议记住这里的快捷键），就可以出现 <code>idea</code> 绘制好的 <code>UML</code> 图： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144402.png"> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144409.png" alt="image-20191202144945669"> </p>
<p>然后，如果想看其中某个节点的源码，比如 <code>MessageSource</code> 那么只要鼠标选中这个节点，然后按 <code>F4</code> 即可进入类源码： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144432.png" alt="image-20191202145300345"> </p>
<p>好，这是第一种方法，我也比较喜欢这种方式。那么第二种方法是让 <code>idea</code> 出现树形的结构，然后可以直接看层次，但是我感觉单纯的树形并不能很好的表达 <code>继承</code> 和 <code>实现</code>，不过还是说一下吧： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144447.png"> </p>
<p>就是这个，<code>osx</code> 系统使用的是 <code>^ + H</code>，可以看看自己电脑是哪个快捷键，方便快速调用出来。</p>
<h2 id="运行轨迹图"><a href="#运行轨迹图" class="headerlink" title="运行轨迹图"></a>运行轨迹图</h2><p>这个问题尼玛就是困扰我没有去读源码的动力，但是，在 <code>Debug</code> 窗口，他就是提供了，悔恨自己没早点发现！！！ 很多时候，我们在源码打了断点，但是因为跳来跳去，然后后面忘了，忘了在哪个地方进来了，然后就稀里糊涂的出去了。 然而其实在这里，是记录了 <code>Debug</code> 走过的函数的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144516.png"> </p>
<p>只要用鼠标点击函数名字，就可以去到这个函数所在的代码块，特么太香了！！！</p>
<h2 id="导入Spring源码"><a href="#导入Spring源码" class="headerlink" title="导入Spring源码"></a>导入Spring源码</h2><p>其实这一步在源码下的 <code>import-into-idea.md</code> 文件已经有提及到了，不过还是简单说说吧： 下载完源码，先不要急着导入 <code>idea</code>，而是在代码所在的目录中运行这个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>

<p>我估计是这个项目会先安装一些代码所需要的依赖工程（这些工程就在源码里边），让 <code>idea</code> 打开的时候不至于扫描的时候报错。 然后再导入源码到 <code>idea</code> 中，这时候大概的十多分钟的索引+下依赖，就可以试着运行 <code>Spring</code> 提供的测试用例来简单的测试环境。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144610.png"> </p>
<p>通过了大概就是这样吧，绿色的小沟子√。 </p>
<p>然后，如果想看其中某个节点的源码，比如 <code>MessageSource</code> 那么只要鼠标选中这个节点，然后按 <code>F4</code> 即可进入类源码： </p>
<p>心心想念很久读 <code>Spring</code> 源码，但是一直没有坚持下去。也看了一些别人怎么读源码的教程，然而有一天忽然在上班的公交上来了灵感，最方便的工具就在我手上啊！ 对，就是那个叫 <code>idea</code> 的编码工具！</p>
<h2 id="看类层次图-2"><a href="#看类层次图-2" class="headerlink" title="看类层次图"></a>看类层次图</h2><p>有两种方式，一种是直接生成 <code>UML</code> 图： 在想要看的类上面，右键选择这里（当然建议记住这里的快捷键），就可以出现 <code>idea</code> 绘制好的 <code>UML</code> 图： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144402.png"> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144409.png" alt="image-20191202144945669"> </p>
<p>然后，如果想看其中某个节点的源码，比如 <code>MessageSource</code> 那么只要鼠标选中这个节点，然后按 <code>F4</code> 即可进入类源码： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144432.png" alt="image-20191202145300345"> </p>
<p>好，这是第一种方法，我也比较喜欢这种方式。那么第二种方法是让 <code>idea</code> 出现树形的结构，然后可以直接看层次，但是我感觉单纯的树形并不能很好的表达 <code>继承</code> 和 <code>实现</code>，不过还是说一下吧： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144447.png"> </p>
<p>就是这个，<code>osx</code> 系统使用的是 <code>^ + H</code>，可以看看自己电脑是哪个快捷键，方便快速调用出来。</p>
<h2 id="运行轨迹图-1"><a href="#运行轨迹图-1" class="headerlink" title="运行轨迹图"></a>运行轨迹图</h2><p>这个问题尼玛就是困扰我没有去读源码的动力，但是，在 <code>Debug</code> 窗口，他就是提供了，悔恨自己没早点发现！！！ 很多时候，我们在源码打了断点，但是因为跳来跳去，然后后面忘了，忘了在哪个地方进来了，然后就稀里糊涂的出去了。 然而其实在这里，是记录了 <code>Debug</code> 走过的函数的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144516.png"> </p>
<p>只要用鼠标点击函数名字，就可以去到这个函数所在的代码块，特么太香了！！！</p>
<h2 id="导入Spring源码-1"><a href="#导入Spring源码-1" class="headerlink" title="导入Spring源码"></a>导入Spring源码</h2><p>其实这一步在源码下的 <code>import-into-idea.md</code> 文件已经有提及到了，不过还是简单说说吧： 下载完源码，先不要急着导入 <code>idea</code>，而是在代码所在的目录中运行这个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>

<p>我估计是这个项目会先安装一些代码所需要的依赖工程（这些工程就在源码里边），让 <code>idea</code> 打开的时候不至于扫描的时候报错。 然后再导入源码到 <code>idea</code> 中，这时候大概的十多分钟的索引+下依赖，就可以试着运行 <code>Spring</code> 提供的测试用例来简单的测试环境。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144610.png"> </p>
<p>通过了大概就是这样吧，绿色的小沟子√。 </p>
<p>好，这是第一种方法，我也比较喜欢这种方式。那么第二种方法是让 <code>idea</code> 出现树形的结构，然后可以直接看层次，但是我感觉单纯的树形并不能很好的表达 <code>继承</code> 和 <code>实现</code>，不过还是说一下吧： </p>
<p>心心想念很久读 <code>Spring</code> 源码，但是一直没有坚持下去。也看了一些别人怎么读源码的教程，然而有一天忽然在上班的公交上来了灵感，最方便的工具就在我手上啊！ 对，就是那个叫 <code>idea</code> 的编码工具！</p>
<h2 id="看类层次图-3"><a href="#看类层次图-3" class="headerlink" title="看类层次图"></a>看类层次图</h2><p>有两种方式，一种是直接生成 <code>UML</code> 图： 在想要看的类上面，右键选择这里（当然建议记住这里的快捷键），就可以出现 <code>idea</code> 绘制好的 <code>UML</code> 图： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144402.png"> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144409.png" alt="image-20191202144945669"> </p>
<p>然后，如果想看其中某个节点的源码，比如 <code>MessageSource</code> 那么只要鼠标选中这个节点，然后按 <code>F4</code> 即可进入类源码： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144432.png" alt="image-20191202145300345"> </p>
<p>好，这是第一种方法，我也比较喜欢这种方式。那么第二种方法是让 <code>idea</code> 出现树形的结构，然后可以直接看层次，但是我感觉单纯的树形并不能很好的表达 <code>继承</code> 和 <code>实现</code>，不过还是说一下吧： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144447.png"> </p>
<p>就是这个，<code>osx</code> 系统使用的是 <code>^ + H</code>，可以看看自己电脑是哪个快捷键，方便快速调用出来。</p>
<h2 id="运行轨迹图-2"><a href="#运行轨迹图-2" class="headerlink" title="运行轨迹图"></a>运行轨迹图</h2><p>这个问题尼玛就是困扰我没有去读源码的动力，但是，在 <code>Debug</code> 窗口，他就是提供了，悔恨自己没早点发现！！！ 很多时候，我们在源码打了断点，但是因为跳来跳去，然后后面忘了，忘了在哪个地方进来了，然后就稀里糊涂的出去了。 然而其实在这里，是记录了 <code>Debug</code> 走过的函数的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144516.png"> </p>
<p>只要用鼠标点击函数名字，就可以去到这个函数所在的代码块，特么太香了！！！</p>
<h2 id="导入Spring源码-2"><a href="#导入Spring源码-2" class="headerlink" title="导入Spring源码"></a>导入Spring源码</h2><p>其实这一步在源码下的 <code>import-into-idea.md</code> 文件已经有提及到了，不过还是简单说说吧： 下载完源码，先不要急着导入 <code>idea</code>，而是在代码所在的目录中运行这个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>

<p>我估计是这个项目会先安装一些代码所需要的依赖工程（这些工程就在源码里边），让 <code>idea</code> 打开的时候不至于扫描的时候报错。 然后再导入源码到 <code>idea</code> 中，这时候大概的十多分钟的索引+下依赖，就可以试着运行 <code>Spring</code> 提供的测试用例来简单的测试环境。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144610.png"> </p>
<p>通过了大概就是这样吧，绿色的小沟子√。 </p>
<p>就是这个，<code>osx</code> 系统使用的是 <code>^ + H</code>，可以看看自己电脑是哪个快捷键，方便快速调用出来。</p>
<h2 id="运行轨迹图-3"><a href="#运行轨迹图-3" class="headerlink" title="运行轨迹图"></a>运行轨迹图</h2><p>这个问题尼玛就是困扰我没有去读源码的动力，但是，在 <code>Debug</code> 窗口，他就是提供了，悔恨自己没早点发现！！！ 很多时候，我们在源码打了断点，但是因为跳来跳去，然后后面忘了，忘了在哪个地方进来了，然后就稀里糊涂的出去了。 然而其实在这里，是记录了 <code>Debug</code> 走过的函数的： </p>
<p>心心想念很久读 <code>Spring</code> 源码，但是一直没有坚持下去。也看了一些别人怎么读源码的教程，然而有一天忽然在上班的公交上来了灵感，最方便的工具就在我手上啊！ 对，就是那个叫 <code>idea</code> 的编码工具！</p>
<h2 id="看类层次图-4"><a href="#看类层次图-4" class="headerlink" title="看类层次图"></a>看类层次图</h2><p>有两种方式，一种是直接生成 <code>UML</code> 图： 在想要看的类上面，右键选择这里（当然建议记住这里的快捷键），就可以出现 <code>idea</code> 绘制好的 <code>UML</code> 图： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144402.png"> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144409.png" alt="image-20191202144945669"> </p>
<p>然后，如果想看其中某个节点的源码，比如 <code>MessageSource</code> 那么只要鼠标选中这个节点，然后按 <code>F4</code> 即可进入类源码： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144432.png" alt="image-20191202145300345"> </p>
<p>好，这是第一种方法，我也比较喜欢这种方式。那么第二种方法是让 <code>idea</code> 出现树形的结构，然后可以直接看层次，但是我感觉单纯的树形并不能很好的表达 <code>继承</code> 和 <code>实现</code>，不过还是说一下吧： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144447.png"> </p>
<p>就是这个，<code>osx</code> 系统使用的是 <code>^ + H</code>，可以看看自己电脑是哪个快捷键，方便快速调用出来。</p>
<h2 id="运行轨迹图-4"><a href="#运行轨迹图-4" class="headerlink" title="运行轨迹图"></a>运行轨迹图</h2><p>这个问题尼玛就是困扰我没有去读源码的动力，但是，在 <code>Debug</code> 窗口，他就是提供了，悔恨自己没早点发现！！！ 很多时候，我们在源码打了断点，但是因为跳来跳去，然后后面忘了，忘了在哪个地方进来了，然后就稀里糊涂的出去了。 然而其实在这里，是记录了 <code>Debug</code> 走过的函数的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144516.png"> </p>
<p>只要用鼠标点击函数名字，就可以去到这个函数所在的代码块，特么太香了！！！</p>
<h2 id="导入Spring源码-3"><a href="#导入Spring源码-3" class="headerlink" title="导入Spring源码"></a>导入Spring源码</h2><p>其实这一步在源码下的 <code>import-into-idea.md</code> 文件已经有提及到了，不过还是简单说说吧： 下载完源码，先不要急着导入 <code>idea</code>，而是在代码所在的目录中运行这个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>

<p>我估计是这个项目会先安装一些代码所需要的依赖工程（这些工程就在源码里边），让 <code>idea</code> 打开的时候不至于扫描的时候报错。 然后再导入源码到 <code>idea</code> 中，这时候大概的十多分钟的索引+下依赖，就可以试着运行 <code>Spring</code> 提供的测试用例来简单的测试环境。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144610.png"> </p>
<p>通过了大概就是这样吧，绿色的小沟子√。 </p>
<p>只要用鼠标点击函数名字，就可以去到这个函数所在的代码块，特么太香了！！！</p>
<h2 id="导入Spring源码-4"><a href="#导入Spring源码-4" class="headerlink" title="导入Spring源码"></a>导入Spring源码</h2><p>其实这一步在源码下的 <code>import-into-idea.md</code> 文件已经有提及到了，不过还是简单说说吧： 下载完源码，先不要急着导入 <code>idea</code>，而是在代码所在的目录中运行这个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>

<p>我估计是这个项目会先安装一些代码所需要的依赖工程（这些工程就在源码里边），让 <code>idea</code> 打开的时候不至于扫描的时候报错。 然后再导入源码到 <code>idea</code> 中，这时候大概的十多分钟的索引+下依赖，就可以试着运行 <code>Spring</code> 提供的测试用例来简单的测试环境。</p>
<p>心心想念很久读 <code>Spring</code> 源码，但是一直没有坚持下去。也看了一些别人怎么读源码的教程，然而有一天忽然在上班的公交上来了灵感，最方便的工具就在我手上啊！ 对，就是那个叫 <code>idea</code> 的编码工具！</p>
<h2 id="看类层次图-5"><a href="#看类层次图-5" class="headerlink" title="看类层次图"></a>看类层次图</h2><p>有两种方式，一种是直接生成 <code>UML</code> 图： 在想要看的类上面，右键选择这里（当然建议记住这里的快捷键），就可以出现 <code>idea</code> 绘制好的 <code>UML</code> 图： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144402.png"> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144409.png" alt="image-20191202144945669"> </p>
<p>然后，如果想看其中某个节点的源码，比如 <code>MessageSource</code> 那么只要鼠标选中这个节点，然后按 <code>F4</code> 即可进入类源码： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144432.png" alt="image-20191202145300345"> </p>
<p>好，这是第一种方法，我也比较喜欢这种方式。那么第二种方法是让 <code>idea</code> 出现树形的结构，然后可以直接看层次，但是我感觉单纯的树形并不能很好的表达 <code>继承</code> 和 <code>实现</code>，不过还是说一下吧： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144447.png"> </p>
<p>就是这个，<code>osx</code> 系统使用的是 <code>^ + H</code>，可以看看自己电脑是哪个快捷键，方便快速调用出来。</p>
<h2 id="运行轨迹图-5"><a href="#运行轨迹图-5" class="headerlink" title="运行轨迹图"></a>运行轨迹图</h2><p>这个问题尼玛就是困扰我没有去读源码的动力，但是，在 <code>Debug</code> 窗口，他就是提供了，悔恨自己没早点发现！！！ 很多时候，我们在源码打了断点，但是因为跳来跳去，然后后面忘了，忘了在哪个地方进来了，然后就稀里糊涂的出去了。 然而其实在这里，是记录了 <code>Debug</code> 走过的函数的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144516.png"> </p>
<p>只要用鼠标点击函数名字，就可以去到这个函数所在的代码块，特么太香了！！！</p>
<h2 id="导入Spring源码-5"><a href="#导入Spring源码-5" class="headerlink" title="导入Spring源码"></a>导入Spring源码</h2><p>其实这一步在源码下的 <code>import-into-idea.md</code> 文件已经有提及到了，不过还是简单说说吧： 下载完源码，先不要急着导入 <code>idea</code>，而是在代码所在的目录中运行这个命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :spring-oxm:compileTestJava</span><br></pre></td></tr></table></figure>

<p>我估计是这个项目会先安装一些代码所需要的依赖工程（这些工程就在源码里边），让 <code>idea</code> 打开的时候不至于扫描的时候报错。 然后再导入源码到 <code>idea</code> 中，这时候大概的十多分钟的索引+下依赖，就可以试着运行 <code>Spring</code> 提供的测试用例来简单的测试环境。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144610.png"> </p>
<p>通过了大概就是这样吧，绿色的小沟子√。 </p>
<p>通过了大概就是这样吧，绿色的小沟子√。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%89-innodb%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%89-innodb%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%E5%92%8C%E8%A1%8C%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">【聊聊MySQL】三.InnoDB的表结构和行记录结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-02 13:57:17" itemprop="dateCreated datePublished" datetime="2019-12-02T13:57:17+08:00">2019-12-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 11:45:15" itemprop="dateModified" datetime="2020-11-10T11:45:15+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-InnoDB的表和数据"><a href="#一-InnoDB的表和数据" class="headerlink" title="一.InnoDB的表和数据"></a>一.InnoDB的表和数据</h2><p><code>InnoDB</code> 是怎样存储数据的，表是大概怎样的一种格式，表中的数据行又是怎样的一种格式。如果想要大概知道 <code>B+</code> 索引的执行过程，这块基本是跳不过去的。当然关于 <code>表</code> 和 <code>数据行</code> 的东西特别多，没办法涵盖所有，所以我只能将我学的，大概知道的重要部分取出来说一说。</p>
<p>这里先大概说下后面才说的 <code>索引</code> 问题，<code>B+索引</code> 其实利用了表中的 <code>行记录头</code>（可以想象是 <code>HTTP</code> 请求的请求头），然后进行数据结构组织实现快速检索的一种结构。所以不用说啦，<code>行记录头</code> 一些必要的属性，基本要知道的，也可以优化数据库的占用空间。</p>
<p><code>Innodb</code> 存储引擎表在创建的时候，如果没有显示定义主键（<code>Primary Key</code>），则会通过以下的规则创建主键：</p>
<ol>
<li>如果表中有非空的唯一索引，则该列为主键；</li>
<li>如果 <code>1</code> 不满足，则在你看不见的地方（行头）创建一个 <code>6</code> 字节大小的指针。</li>
</ol>
<p>我先从宏观的表空间进入，到段、区，到页，到行，那么这样看完行的时候，可以直接感受下一篇讲索引使用的行中的信息，也算是有一定的逻辑顺序吧。</p>
<p>他们的大致关系是：</p>
<h2 id="一-InnoDB的表和数据-1"><a href="#一-InnoDB的表和数据-1" class="headerlink" title="一.InnoDB的表和数据"></a>一.InnoDB的表和数据</h2><p><code>InnoDB</code> 是怎样存储数据的，表是大概怎样的一种格式，表中的数据行又是怎样的一种格式。如果想要大概知道 <code>B+</code> 索引的执行过程，这块基本是跳不过去的。当然关于 <code>表</code> 和 <code>数据行</code> 的东西特别多，没办法涵盖所有，所以我只能将我学的，大概知道的重要部分取出来说一说。</p>
<p>这里先大概说下后面才说的 <code>索引</code> 问题，<code>B+索引</code> 其实利用了表中的 <code>行记录头</code>（可以想象是 <code>HTTP</code> 请求的请求头），然后进行数据结构组织实现快速检索的一种结构。所以不用说啦，<code>行记录头</code> 一些必要的属性，基本要知道的，也可以优化数据库的占用空间。</p>
<p><code>Innodb</code> 存储引擎表在创建的时候，如果没有显示定义主键（<code>Primary Key</code>），则会通过以下的规则创建主键：</p>
<ol>
<li>如果表中有非空的唯一索引，则该列为主键；</li>
<li>如果 <code>1</code> 不满足，则在你看不见的地方（行头）创建一个 <code>6</code> 字节大小的指针。</li>
</ol>
<p>我先从宏观的表空间进入，到段、区，到页，到行，那么这样看完行的时候，可以直接感受下一篇讲索引使用的行中的信息，也算是有一定的逻辑顺序吧。</p>
<p>他们的大致关系是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h2 id="二-表空间"><a href="#二-表空间" class="headerlink" title="二.表空间"></a>二.表空间</h2><h3 id="2-1-表的物理存储"><a href="#2-1-表的物理存储" class="headerlink" title="2.1 表的物理存储"></a>2.1 表的物理存储</h3><p><strong>数据、表、数据库文件</strong></p>
<p>至于要找到表结构的文件，我们至少需要先知道数据文件存在哪个地方，所以我们可以直接通过 <code>SQL</code> 语句进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;datadir&#39;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>OK，结果返回，我们的数据存储在 <code>/var/lib/mysql/</code> 中，所以我们现在进去瞅一瞅是什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql       20 9月  23 00:00 demo</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>为了能够继续说下去，我需要建立一些数据库以及表来做演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database innodb_study;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; use innodb_study;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table table_file_user (id int, name varchar(10));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>好了，创建了一个 <code>innodb_study</code> 的数据库以及一个 <code>table_file_user</code> 的表，现在我们重新来看看数据文件里面多了些什么东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:44 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 10月  9 22:44 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:42 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql       74 10月  9 22:44 innodb_study # 多了这个数据库文件夹</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>好了进去 <code>innodb_study</code> 瞅瞅有哪些东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# ll</span><br><span class="line">总用量 112</span><br><span class="line">-rw-r-----. 1 mysql mysql    65 10月  9 22:43 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql  8586 10月  9 22:44 table_file_user.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 98304 10月  9 22:44 table_file_user.ibd</span><br></pre></td></tr></table></figure>

<ol>
<li><code>db.opt</code> 猜一下，应该是数据库的设定，比如字符集啊，使用的存储引擎啊等等；</li>
<li><code>table_file_user.frm</code> 则是我创建的用户表的结构文件了；</li>
<li><code>table_file_user.ibd</code> 是 <code>InnoDB</code> 存储引擎的数据库文件；</li>
</ol>
<p>首先我们先来看看 <code>db.opt</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# cat db.opt</span><br><span class="line">default-character-set&#x3D;latin1</span><br><span class="line">default-collation&#x3D;latin1_swedish_ci</span><br></pre></td></tr></table></figure>

<p>可以看到，我刚刚在创建这个数据库的时候，一切用的是默认的，所以默认的字符集以及排序规则都是 <code>latin1</code> 相关的。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/latin1/1183590?fr=aladdin">latin1百科</a></p>
<p><code>table_file_user.frm</code> 则无法直接使用 <code>cat</code> 进行查看，需要通过  <a target="_blank" rel="noopener" href="https://pdf.us/2019/01/10/2620.html">MySQL管理工具集 MySQL Utilities</a> 的方式进行查看，不过在这里我就不演示了。</p>
<p><code>table_file_user.ibd</code> 则就是数据库文件了，存储的是数据库数据，后面再说。</p>
<p><strong>表空间设置参数</strong></p>
<p>针对 <code>table_file_user.ibd</code> 有个参数需要提一下 <code>innodb_file_per_table</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;innodb_file_per_table&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>什么意思咧，就是每个表的数据都存储在独立的表空间，<code>5.7</code> 以前默认是 <code>off</code> 的，后面的版本就默认开启了。如果是 <code>off</code> 的话，所有表的数据都会记录在一个文件里面。但是即使开启了独立表空间的参数，也只是记录表的数据、索引、插入缓冲等信息，其他的回滚日志还是会存储在公共的空间中的。</p>
<p><strong>定义表空间文件大小位置</strong></p>
<p>可以通过定义 <code>my.cnf</code> 中的配置，来定义存储的表空间文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path &#x3D; &#x2F;db&#x2F;ibdata1:2000M;&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>

<p>我们可以这样定义由两个文件组成表空间，后面的文件容量大小限定表示文件限制大小，而 <code>ibdata2</code> 增长到 <code>2000M</code> 的时候还可以自动增长。</p>
<h3 id="2-1-表的逻辑存储"><a href="#2-1-表的逻辑存储" class="headerlink" title="2.1 表的逻辑存储"></a>2.1 表的逻辑存储</h3><p>接下来简单说下上图中，表空间的下级几个东西：</p>
<p><strong>段</strong></p>
<p>表空间由很多个段组成，段又有数据段、索引段、回滚段等等。因为 <code>InnoDB</code> 存储数据本质上就是利用索引树进行存储的，所以数据段即是 <code>B+树</code> 的<code>叶节点</code>，而索引段即为<code>非叶子节点</code>。</p>
<p><strong>区</strong></p>
<p>每个区由 <code>64个页</code> 组成，每页大小 <code>16KB</code>，因此每个区是 <code>1MB</code>。针对需要插入大数据段的操作，<code>InnoDB</code> 每次至多申请 <code>4个区</code>。</p>
<p>我们启用 <code>innodb_file_per_table</code> 参数的时候，创建表的时候即段的开始，<code>InnoDB</code> 先使用 <code>32个页</code> 的碎片页来存放数据，当这些数据存储完了才会申请上面说的 <code>64个页</code>。</p>
<p>具体其他创建的时候怎么创建的细节，因为对我们使用数据库的时候帮助不是很大，这里就不再阐述（可以参考《MySQL技术内幕：InnoDB存储引擎》的 <code>4.2.3</code> 小节）</p>
<p><strong>页</strong></p>
<p>页太重要了，请允许我现在马上提取到大标题来讲！</p>
<p><strong>行</strong></p>
<p>行和页一样，太重要了，现在也一样马上提取到大标题来讲！</p>
<h2 id="三-InnoDB的数据页"><a href="#三-InnoDB的数据页" class="headerlink" title="三. InnoDB的数据页"></a>三. InnoDB的数据页</h2><p>页是 <code>MySQL InnoDB</code> 与服务器硬盘打交道的单位，当我们需要查询数据的时候，数据库每次至少加载 <code>一个页</code> 的数据到内存进行查找，而在前面说的刷新脏数据的时候，每次至少刷新 <code>一个页</code> 的数据，而页在 <code>区</code> 中说的，是 <code>16KB</code>。所以交互不会太小导致频繁 <code>IO</code> 也不会因为太大导致读取太慢。</p>
<p>页不仅有数据页，所有的页包含有：</p>
<ol>
<li>数据页（<code>B-tree Node</code>）；</li>
<li>Undo页（<code>Undo Log Page</code>）；</li>
<li>系统页（<code>System Page</code>）；</li>
<li>事务数据页（<code>Transaction system Page</code>）；</li>
<li>插入缓冲位图页（<code>Insert Buffer Bitmap</code>）；</li>
<li>插入缓冲空闲列表页（<code>Insert Buffer Free List</code>）；</li>
<li>未压缩的二进制大对象页（<code>Uncompress BLOB Page</code>）；</li>
<li>压缩的二进制大对象页（<code>Compressed BLOB Page</code>）。</li>
</ol>
<blockquote>
<p>第四节数据页的结构和第五节数据行的结构应该是并行了解，也就是两者共同构成搜索数据的基础，阅读建议是数据页格式先有个大概的概念，然后数据行，再两个并起来聊聊数据查询的内部原理.</p>
</blockquote>
<h2 id="四-数据页的结构"><a href="#四-数据页的结构" class="headerlink" title="四. 数据页的结构"></a>四. 数据页的结构</h2><p>这是一个页的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191120152749956"></p>
<p>OK，现在我们知道了，<code>InnoDB 数据页</code> 一共由 <code>7</code> 个部分组成。其中 <code>User Records 数据行</code> 存储的是我们用户的数据，他会按照 <code>Table</code> 指定的 <code>Row Format 行格式</code> 的规定进行存储。然而当一个页没有数据页格式的时候，是不存在 <code>User Records</code> 空间的，也就是说 <code>Free Space</code> 将会占领图中 <code>User Records</code> 那部分的空间。</p>
<p>好了，我们先摊开来每部分，大致的说一下是什么功能：</p>
<h3 id="4-1-FileHeader-文件头信息"><a href="#4-1-FileHeader-文件头信息" class="headerlink" title="4.1 FileHeader 文件头信息"></a>4.1 FileHeader 文件头信息</h3><p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
<p>在页头信息里面有个 <code>FILE_PAGE_TYPE</code>，它主要有以下几种类型：</p>
<ol>
<li><code>FILE_PAGE_INDEX</code> ：<code>B+树</code> 叶节点</li>
<li><code>FILE_PAGE_UNDO_LOG</code> ：<code>Undo Log</code> 页</li>
<li><code>FILE_PAGE_INODE</code> ：索引节点</li>
<li><code>FILE_PAGE_IBUF_FREE_LIST</code> ：<code>Insert Buffer</code> 空闲列表</li>
<li><code>FILE_PAGE_TYPE_ALLOCATED</code> ：最新分配的页</li>
<li><code>FILE_PAGE_BITMAP</code> ：<code>Insert Buffer</code> 位图</li>
<li><code>FILE_PAGE_SYS</code> ：系统页</li>
<li><code>FILE_PAGE_TRX_SYS</code> ：事务系统数据</li>
<li><code>FILE_PAGE_FSP_HDR</code> ：File Space Header</li>
<li><code>FILE_PAGE_XDES</code> ：拓展描述页</li>
<li><code>FILE_PAGE_BLOB</code> ：<code>BLOB</code> 页</li>
</ol>
<h3 id="4-2-PageHeader-页头信息"><a href="#4-2-PageHeader-页头信息" class="headerlink" title="4.2 PageHeader 页头信息"></a>4.2 PageHeader 页头信息</h3><p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
<h3 id="4-3-Infimum-和-Supremum-最值记录"><a href="#4-3-Infimum-和-Supremum-最值记录" class="headerlink" title="4.3 Infimum 和 Supremum 最值记录"></a>4.3 Infimum 和 Supremum 最值记录</h3><p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
<h3 id="4-4-User-Records-用户记录-和-Free-Space-空闲空间"><a href="#4-4-User-Records-用户记录-和-Free-Space-空闲空间" class="headerlink" title="4.4 User Records 用户记录 和 Free Space 空闲空间"></a>4.4 User Records 用户记录 和 Free Space 空闲空间</h3><p>这两个放在一起说是有原因的，因为一个空的页，是没有 <code>User Records</code> 的，全部都是 <code>Free Space</code>。慢慢的插入数据的时候，<code>User Records</code> 慢慢增大，<code>Free Space</code> 慢慢减小，直到这个页塞满了数据，就开启下一页。</p>
<p>想了想，弄个动图演示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h3 id="4-5-Page-Director-页目录"><a href="#4-5-Page-Director-页目录" class="headerlink" title="4.5 Page Director 页目录"></a>4.5 Page Director 页目录</h3><p>页目录 <code>Page Director</code> 存储了很多槽，用来存储最大最小记录的槽，<code>InnoDB</code> 就是通过这些槽来提高查询的速度的，下面会详细说。</p>
<h3 id="4-6-File-Trailer-页尾部"><a href="#4-6-File-Trailer-页尾部" class="headerlink" title="4.6 File Trailer 页尾部"></a>4.6 File Trailer 页尾部</h3><p>校验页数据用的地方，这个页有两个部分：</p>
<ol>
<li>页的校验和</li>
</ol>
<p>与 <code>FileHeader</code> 中的 <code>FILE_PAGE_SPACE_OR_CHKSUM</code> 值相对应，因为 <code>FileHeader</code> 在页的头部，被首先写入硬盘，当写入硬盘的过程中发现错误导致页不完整的时候，头部和尾部的值就会出现不相同的情况，这时候就需要根据日志来重新做这个页。</p>
<ol start="2">
<li>被最后修改时对应的日志序列位置（LSN）</li>
</ol>
<p>也是用来做校验的，后面会说到。</p>
<h2 id="五-数据行"><a href="#五-数据行" class="headerlink" title="五. 数据行"></a>五. 数据行</h2><p>我们知道了，一个数据页是 <code>16kb</code> 的大小，而数据页中有一个很重要的部分就是 <code>User Record</code> 区域就是用来存放我们的数据的地方。我们所插入的数据，<code>InnoDB</code> 会根据规则，转变成一定的 <code>行格式</code> 插入到数据页中去，行格式除了存储我们生产的数据以外，还存储着一些额外的信息，用于加快<strong>查数据</strong>的速度（当然删和改也都以来着查，新增也会以来查来确定主要的位置，所以查是一个数据库中至关重要的功能）。</p>
<p><code>MySQL</code> 发展到现在，已经有好几种 <code>数据行</code> 的格式了，分别有：<code>Compact</code> <code>Redundant</code> <code>Dynamic</code> 和 <code>Compressed</code>。</p>
<p><code>Redundant</code> 是为了解决与之前版本的兼容性问题而存在的，剩下的 <code>Dynamic</code> 和 <code>Compressed</code> 本质上是 <code>Compact</code> 格式，只不过在处理溢出页的时候不同，只要说了 <code>Compact</code> 就相当于说了三种，至于什么是溢出页，在下面会详细说到。</p>
<p>首先来看看 <code>Compact</code> 的数据行包含了什么鬼：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121094525787"></p>
<h3 id="5-1-额外信息"><a href="#5-1-额外信息" class="headerlink" title="5.1 额外信息"></a>5.1 额外信息</h3><p>这部分是 <code>InnoDB</code> 为了方便快速查找统计而新加进去的一些记录行额外信息，主要用来标记可变长字段的长度（比如 <code>varchar</code> 占用多长）、哪些定义可为 <code>NULL</code> 的列在这条记录中出现了 <code>NULL</code> 以及一部分有用的记录头信息。</p>
<p>接下来一个一个来看这些有什么作用，为了防止标题太多层级我直接使用跟这里一样的标题。</p>
<h3 id="5-1-1-可变长字段的长度列表"><a href="#5-1-1-可变长字段的长度列表" class="headerlink" title="5.1.1 可变长字段的长度列表"></a>5.1.1 可变长字段的长度列表</h3><p>在 <code>Compact</code> 中，把表定义的可变长字段，在当前数据行中所占用的实际长度，按照 <strong>逆序</strong> 存储他们当前的长度。</p>
<p>怎么说呢，举个例子来做吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_db(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  addr <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  sex <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>这个表包含一个主键、一个不为空的 <code>name</code>，一个可为空的 <code>addr</code>，还有一个不可变长可为空的 <code>sex</code>。字符集是 <code>ascii</code>（就是包含简单字母的那个），以及指定行格式是 <code>Compact</code>。</p>
<p>然后我插入 <code>5</code> 个数据来玩玩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_db (<span class="keyword">id</span>, <span class="keyword">name</span>, addr, sex)</span><br><span class="line">	<span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;goudan&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">	(<span class="number">2</span>, <span class="string">&#x27;gousheng&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>, <span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">	(<span class="number">3</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">	(<span class="number">4</span>, <span class="string">&#x27;adan&#x27;</span>, <span class="string">&#x27;tianhe&#x27;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM user_db;</span></span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">| id | name     | addr      | sex  |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">|  1 | goudan   | NULL      | b    |</span><br><span class="line">|  2 | gousheng | guangzhou | g    |</span><br><span class="line">|  3 | xiaoming | NULL      | NULL |</span><br><span class="line">|  4 | adan     | tianhe    | NULL |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>好，终于搞定 <code>demo</code> 数据。</p>
<p>我们回到可变长字段的长度列表来看，就拿 <code>id = 2</code> 的数据来看吧：</p>
<p>因为在这个表中 <code>name</code> <code>addr</code> 都是可变长字段，<code>name</code> 的长度是 <code>8</code>，<code>addr</code> 的长度是 <code>9</code> 他们通过十六进制表示分别是：<code>0×08</code> <code>0×09</code> ，然后，可变长字段存储是逆序的，所有，存储在可变长字段列表里面的数据就是 <code>0908</code></p>
<p>这里有两个地方需要注意的是</p>
<ol>
<li>如果这个可变长的列，他的真实值是 <code>NULL</code>，则他不会被记录在此列表中，也就是说在 <code>id = 3</code> 的记录中，可变长字段的长度列表只需要记录 <code>name</code> 列的长度即可；</li>
<li>这个长度列表可能需要 <code>1字节</code> 也可能因为记录不下，而开辟了 <code>2字节</code> 的长度来记录，怎么说呢：</li>
</ol>
<p>我们知道 <code>1字节</code> 数的二进制是 <code>8</code> 位，然后，第一位像 <code>Protobuf</code> 一样用来记录后面还有没有位数，所以真实使用存储长度的是后 <code>7</code> 位。而 <code>7</code> 位最大能表示多大长度呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121105157176"></p>
<p>所以，如果这个长度他需要记录 <strong>小于等于</strong> <code>127</code> 的长度的时候，使用 <code>1字节</code>，而如果记录的值 <strong>大于</strong> <code>127</code> 的时候则使用 <code>2字节</code>。<code>8位</code> 的第一位用来标记，我后面还有没有 <code>1字节</code> 来一起记录长度，如果是 <code>0</code> 则表示我当前字节已经记录完所有的了，如果是 <code>1</code> 则表示我后面的 <code>1字节</code> 也是用来记录长度的。而如果长度，他 <code>1字节 = 255</code> 可以存储完毕，则使用 <code>1字节</code>。</p>
<p>那怎么大概计算字段占用多少字节的长度呢：</p>
<p>因为上面的 <code>user_db</code> 使用的是 <code>ascii</code> 来做记录的，让我们用臭名远扬的 <code>utf-8</code> 来说，我们知道，<code>MySQL</code> 中的 <code>utf-8</code> 是个假的，他其实只使用了 <code>3字节</code> 一个字符的方法来存储。</p>
<p>我们假设这个表只有一个列(varchar(MAXLEN))，那如果字符串的最大字节占用长度 = <code>MAXLEN * 3</code>，则如果最大占用字节 <strong>小于等于</strong> <code>255</code> 的时候，使用一个字节来存储，如果他大于 <code>255</code> 则根据他是否 <strong>小于等于</strong> <code>127</code> 也就是 <code>127 / 3 = 42</code> 个字符来看，如果小于等于127，则使用 <code>1字节</code>，否则使用 <code>2字节</code>。好累，弄个伪代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 占用的最大字节数，LocalCharsetLeng是当前字符集的最大字节长度 */</span></span><br><span class="line"><span class="keyword">let</span> maxByteLeng = LocalCharsetLeng * MAXLEN;</span><br><span class="line"><span class="comment">/** 可变长字段列表的长度 */</span></span><br><span class="line"><span class="keyword">let</span> lengthOfVariableColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (maxByteLeng &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">  lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/** 她当前数据行存储的长度 */</span></span><br><span class="line">  <span class="keyword">let</span> lengthOfData = ...</span><br><span class="line">  <span class="keyword">let</span> byteLengthOfData = LocalCharsetLeng * lengthOfData;</span><br><span class="line">  <span class="keyword">if</span> (byteLengthOfData &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-NULL值列表"><a href="#5-1-2-NULL值列表" class="headerlink" title="5.1.2 NULL值列表"></a>5.1.2 NULL值列表</h3><p><code>NULL值列表</code> 也是按照列中可以为NULL的列逆序来排放的，直接上图更清晰：</p>
<p>我们加入要看 <code>id = 3</code> 的数据，他的 <code>addr</code> 和 <code>sex</code> 都为 <code>NULL</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121151849940"></p>
<p>所以从最后一位开始，对应列中第一个可以为 <code>NULL</code> 的列（被 <code>NOT NULL</code> 修饰的列），如果是 <code>NULL</code> 则为 <code>1</code> 否则为 <code>0</code>。</p>
<p>所以，<code>NULL</code> 值并不会占用存储空间。</p>
<h3 id="5-1-3-记录头信息"><a href="#5-1-3-记录头信息" class="headerlink" title="5.1.3 记录头信息"></a>5.1.3 记录头信息</h3><p>这个可就很重要，因为他是构成索引搜索条件的基础。</p>
<p>记录头有以下这些头部信息，共占用 <code>40字节</code> 不同的字节数作用都不相同：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>占位符1</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>占位符2</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>delete_flag</td>
<td>1</td>
<td>标记记录是否被删除（也就是我们开发常说的逻辑删除）</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000普通记录 001B+树节点指针 010Infimum<br/>011Supremum 1xx保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>页中玉东道下一条记录需要的偏移量</td>
</tr>
</tbody></table>
<p>OK一起说完真实记录再来看看怎么搜索数据的吧</p>
<h3 id="5-2-真实数据"><a href="#5-2-真实数据" class="headerlink" title="5.2 真实数据"></a>5.2 真实数据</h3><p>真实数据的存储，都是存储有效的数据，即如果某个值没有数据，则不做存储。那他怎么知道谁是有的谁是没的，这就需要结合上面可变长字段列表、NULL值列表以及下一条记录的偏移量来确定了。</p>
<p>其实真实数据中，<code>InnoDB</code> 还会在真实数据的头部增加两个列：<code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> 分别是事务的指针以及回滚的指针（用于重做？）。如果当前的表没有定义主键的话，那么 <code>InnoDB</code> 还会真实数据的头部增加 <code>ROW_ID</code> 这个隐藏列来作为主键（为啥一定要主键？后面索引会说说的）</p>
<p>所以记录应该是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114503.png"></p>
<h3 id="5-3-溢出页"><a href="#5-3-溢出页" class="headerlink" title="5.3 溢出页"></a>5.3 溢出页</h3><p>针对 <code>VARCHAR</code> 定义的数据列最多能存储多少个数据？一个记录最大能存储 <code>65535</code> 个字节的数据，但是并不是真的可以存储，因为在上面看来，还需要记录变长字段以及 <code>NULL值列表</code>，如果被 <code>NOT NULL</code> 修饰，则还可以节省 <code>1字节</code>，所以假设我这个表只有一个列的情况下分为下面两种情况：</p>
<ol>
<li>被 <code>NOT NULL</code> 修饰，存储 <code>65533</code> 个字节；</li>
<li>没有修饰，存储 <code>65532</code> 个字节。</li>
</ol>
<p>那如果存储的数据超出一个页 <code>16kb</code> 的定义怎么办，那就需要额外的溢出页来存储数据了。</p>
<p>但是 <code>Compact</code> 格式的数据有点纠结，如果占用的字节数小于 <code>768</code> 字节的时候，存储在本页，如果超出了，则该页依然会记录前 <code>768字节</code> 的数据，然后再使用 <code>20字节</code> 来存储溢出页的地址以及字节数大小。</p>
<p>而 <code>MySQL 5.7</code> 使用的 <code>InnoDB Plugin</code> 默认的格式 <code>Dynamic</code> 以及新增的 <code>Compress</code> 格式则不同，他们只在当前记录这里记录溢出页的位置，将所有的数据都放在溢出页里面，而 <code>Compress</code> 还会将溢出页进行压缩处理，减少存储空间。</p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>主要了解了表的逻辑存储、数据页、数据行的格式。不过不用太担心没记住，后面我都会重复这里的内容来说接下来的所有事情的，毕竟这里面的一堆属性都是为后面 <code>MySQL</code> 的功能做铺垫。</p>
<h2 id="二-表空间-1"><a href="#二-表空间-1" class="headerlink" title="二.表空间"></a>二.表空间</h2><h3 id="2-1-表的物理存储-1"><a href="#2-1-表的物理存储-1" class="headerlink" title="2.1 表的物理存储"></a>2.1 表的物理存储</h3><p><strong>数据、表、数据库文件</strong></p>
<p>至于要找到表结构的文件，我们至少需要先知道数据文件存在哪个地方，所以我们可以直接通过 <code>SQL</code> 语句进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;datadir&#39;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>OK，结果返回，我们的数据存储在 <code>/var/lib/mysql/</code> 中，所以我们现在进去瞅一瞅是什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql       20 9月  23 00:00 demo</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>为了能够继续说下去，我需要建立一些数据库以及表来做演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database innodb_study;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; use innodb_study;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table table_file_user (id int, name varchar(10));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>好了，创建了一个 <code>innodb_study</code> 的数据库以及一个 <code>table_file_user</code> 的表，现在我们重新来看看数据文件里面多了些什么东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:44 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 10月  9 22:44 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:42 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql       74 10月  9 22:44 innodb_study # 多了这个数据库文件夹</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>好了进去 <code>innodb_study</code> 瞅瞅有哪些东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# ll</span><br><span class="line">总用量 112</span><br><span class="line">-rw-r-----. 1 mysql mysql    65 10月  9 22:43 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql  8586 10月  9 22:44 table_file_user.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 98304 10月  9 22:44 table_file_user.ibd</span><br></pre></td></tr></table></figure>

<ol>
<li><code>db.opt</code> 猜一下，应该是数据库的设定，比如字符集啊，使用的存储引擎啊等等；</li>
<li><code>table_file_user.frm</code> 则是我创建的用户表的结构文件了；</li>
<li><code>table_file_user.ibd</code> 是 <code>InnoDB</code> 存储引擎的数据库文件；</li>
</ol>
<p>首先我们先来看看 <code>db.opt</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# cat db.opt</span><br><span class="line">default-character-set&#x3D;latin1</span><br><span class="line">default-collation&#x3D;latin1_swedish_ci</span><br></pre></td></tr></table></figure>

<p>可以看到，我刚刚在创建这个数据库的时候，一切用的是默认的，所以默认的字符集以及排序规则都是 <code>latin1</code> 相关的。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/latin1/1183590?fr=aladdin">latin1百科</a></p>
<p><code>table_file_user.frm</code> 则无法直接使用 <code>cat</code> 进行查看，需要通过  <a target="_blank" rel="noopener" href="https://pdf.us/2019/01/10/2620.html">MySQL管理工具集 MySQL Utilities</a> 的方式进行查看，不过在这里我就不演示了。</p>
<p><code>table_file_user.ibd</code> 则就是数据库文件了，存储的是数据库数据，后面再说。</p>
<p><strong>表空间设置参数</strong></p>
<p>针对 <code>table_file_user.ibd</code> 有个参数需要提一下 <code>innodb_file_per_table</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;innodb_file_per_table&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>什么意思咧，就是每个表的数据都存储在独立的表空间，<code>5.7</code> 以前默认是 <code>off</code> 的，后面的版本就默认开启了。如果是 <code>off</code> 的话，所有表的数据都会记录在一个文件里面。但是即使开启了独立表空间的参数，也只是记录表的数据、索引、插入缓冲等信息，其他的回滚日志还是会存储在公共的空间中的。</p>
<p><strong>定义表空间文件大小位置</strong></p>
<p>可以通过定义 <code>my.cnf</code> 中的配置，来定义存储的表空间文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path &#x3D; &#x2F;db&#x2F;ibdata1:2000M;&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>

<p>我们可以这样定义由两个文件组成表空间，后面的文件容量大小限定表示文件限制大小，而 <code>ibdata2</code> 增长到 <code>2000M</code> 的时候还可以自动增长。</p>
<h3 id="2-1-表的逻辑存储-1"><a href="#2-1-表的逻辑存储-1" class="headerlink" title="2.1 表的逻辑存储"></a>2.1 表的逻辑存储</h3><p>接下来简单说下上图中，表空间的下级几个东西：</p>
<p><strong>段</strong></p>
<p>表空间由很多个段组成，段又有数据段、索引段、回滚段等等。因为 <code>InnoDB</code> 存储数据本质上就是利用索引树进行存储的，所以数据段即是 <code>B+树</code> 的<code>叶节点</code>，而索引段即为<code>非叶子节点</code>。</p>
<p><strong>区</strong></p>
<p>每个区由 <code>64个页</code> 组成，每页大小 <code>16KB</code>，因此每个区是 <code>1MB</code>。针对需要插入大数据段的操作，<code>InnoDB</code> 每次至多申请 <code>4个区</code>。</p>
<p>我们启用 <code>innodb_file_per_table</code> 参数的时候，创建表的时候即段的开始，<code>InnoDB</code> 先使用 <code>32个页</code> 的碎片页来存放数据，当这些数据存储完了才会申请上面说的 <code>64个页</code>。</p>
<p>具体其他创建的时候怎么创建的细节，因为对我们使用数据库的时候帮助不是很大，这里就不再阐述（可以参考《MySQL技术内幕：InnoDB存储引擎》的 <code>4.2.3</code> 小节）</p>
<p><strong>页</strong></p>
<p>页太重要了，请允许我现在马上提取到大标题来讲！</p>
<p><strong>行</strong></p>
<p>行和页一样，太重要了，现在也一样马上提取到大标题来讲！</p>
<h2 id="三-InnoDB的数据页-1"><a href="#三-InnoDB的数据页-1" class="headerlink" title="三. InnoDB的数据页"></a>三. InnoDB的数据页</h2><p>页是 <code>MySQL InnoDB</code> 与服务器硬盘打交道的单位，当我们需要查询数据的时候，数据库每次至少加载 <code>一个页</code> 的数据到内存进行查找，而在前面说的刷新脏数据的时候，每次至少刷新 <code>一个页</code> 的数据，而页在 <code>区</code> 中说的，是 <code>16KB</code>。所以交互不会太小导致频繁 <code>IO</code> 也不会因为太大导致读取太慢。</p>
<p>页不仅有数据页，所有的页包含有：</p>
<ol>
<li>数据页（<code>B-tree Node</code>）；</li>
<li>Undo页（<code>Undo Log Page</code>）；</li>
<li>系统页（<code>System Page</code>）；</li>
<li>事务数据页（<code>Transaction system Page</code>）；</li>
<li>插入缓冲位图页（<code>Insert Buffer Bitmap</code>）；</li>
<li>插入缓冲空闲列表页（<code>Insert Buffer Free List</code>）；</li>
<li>未压缩的二进制大对象页（<code>Uncompress BLOB Page</code>）；</li>
<li>压缩的二进制大对象页（<code>Compressed BLOB Page</code>）。</li>
</ol>
<blockquote>
<p>第四节数据页的结构和第五节数据行的结构应该是并行了解，也就是两者共同构成搜索数据的基础，阅读建议是数据页格式先有个大概的概念，然后数据行，再两个并起来聊聊数据查询的内部原理.</p>
</blockquote>
<h2 id="四-数据页的结构-1"><a href="#四-数据页的结构-1" class="headerlink" title="四. 数据页的结构"></a>四. 数据页的结构</h2><p>这是一个页的结构：</p>
<h2 id="一-InnoDB的表和数据-2"><a href="#一-InnoDB的表和数据-2" class="headerlink" title="一.InnoDB的表和数据"></a>一.InnoDB的表和数据</h2><p><code>InnoDB</code> 是怎样存储数据的，表是大概怎样的一种格式，表中的数据行又是怎样的一种格式。如果想要大概知道 <code>B+</code> 索引的执行过程，这块基本是跳不过去的。当然关于 <code>表</code> 和 <code>数据行</code> 的东西特别多，没办法涵盖所有，所以我只能将我学的，大概知道的重要部分取出来说一说。</p>
<p>这里先大概说下后面才说的 <code>索引</code> 问题，<code>B+索引</code> 其实利用了表中的 <code>行记录头</code>（可以想象是 <code>HTTP</code> 请求的请求头），然后进行数据结构组织实现快速检索的一种结构。所以不用说啦，<code>行记录头</code> 一些必要的属性，基本要知道的，也可以优化数据库的占用空间。</p>
<p><code>Innodb</code> 存储引擎表在创建的时候，如果没有显示定义主键（<code>Primary Key</code>），则会通过以下的规则创建主键：</p>
<ol>
<li>如果表中有非空的唯一索引，则该列为主键；</li>
<li>如果 <code>1</code> 不满足，则在你看不见的地方（行头）创建一个 <code>6</code> 字节大小的指针。</li>
</ol>
<p>我先从宏观的表空间进入，到段、区，到页，到行，那么这样看完行的时候，可以直接感受下一篇讲索引使用的行中的信息，也算是有一定的逻辑顺序吧。</p>
<p>他们的大致关系是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h2 id="二-表空间-2"><a href="#二-表空间-2" class="headerlink" title="二.表空间"></a>二.表空间</h2><h3 id="2-1-表的物理存储-2"><a href="#2-1-表的物理存储-2" class="headerlink" title="2.1 表的物理存储"></a>2.1 表的物理存储</h3><p><strong>数据、表、数据库文件</strong></p>
<p>至于要找到表结构的文件，我们至少需要先知道数据文件存在哪个地方，所以我们可以直接通过 <code>SQL</code> 语句进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;datadir&#39;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>OK，结果返回，我们的数据存储在 <code>/var/lib/mysql/</code> 中，所以我们现在进去瞅一瞅是什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql       20 9月  23 00:00 demo</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>为了能够继续说下去，我需要建立一些数据库以及表来做演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database innodb_study;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; use innodb_study;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table table_file_user (id int, name varchar(10));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>好了，创建了一个 <code>innodb_study</code> 的数据库以及一个 <code>table_file_user</code> 的表，现在我们重新来看看数据文件里面多了些什么东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:44 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 10月  9 22:44 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:42 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql       74 10月  9 22:44 innodb_study # 多了这个数据库文件夹</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>好了进去 <code>innodb_study</code> 瞅瞅有哪些东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# ll</span><br><span class="line">总用量 112</span><br><span class="line">-rw-r-----. 1 mysql mysql    65 10月  9 22:43 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql  8586 10月  9 22:44 table_file_user.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 98304 10月  9 22:44 table_file_user.ibd</span><br></pre></td></tr></table></figure>

<ol>
<li><code>db.opt</code> 猜一下，应该是数据库的设定，比如字符集啊，使用的存储引擎啊等等；</li>
<li><code>table_file_user.frm</code> 则是我创建的用户表的结构文件了；</li>
<li><code>table_file_user.ibd</code> 是 <code>InnoDB</code> 存储引擎的数据库文件；</li>
</ol>
<p>首先我们先来看看 <code>db.opt</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# cat db.opt</span><br><span class="line">default-character-set&#x3D;latin1</span><br><span class="line">default-collation&#x3D;latin1_swedish_ci</span><br></pre></td></tr></table></figure>

<p>可以看到，我刚刚在创建这个数据库的时候，一切用的是默认的，所以默认的字符集以及排序规则都是 <code>latin1</code> 相关的。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/latin1/1183590?fr=aladdin">latin1百科</a></p>
<p><code>table_file_user.frm</code> 则无法直接使用 <code>cat</code> 进行查看，需要通过  <a target="_blank" rel="noopener" href="https://pdf.us/2019/01/10/2620.html">MySQL管理工具集 MySQL Utilities</a> 的方式进行查看，不过在这里我就不演示了。</p>
<p><code>table_file_user.ibd</code> 则就是数据库文件了，存储的是数据库数据，后面再说。</p>
<p><strong>表空间设置参数</strong></p>
<p>针对 <code>table_file_user.ibd</code> 有个参数需要提一下 <code>innodb_file_per_table</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;innodb_file_per_table&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>什么意思咧，就是每个表的数据都存储在独立的表空间，<code>5.7</code> 以前默认是 <code>off</code> 的，后面的版本就默认开启了。如果是 <code>off</code> 的话，所有表的数据都会记录在一个文件里面。但是即使开启了独立表空间的参数，也只是记录表的数据、索引、插入缓冲等信息，其他的回滚日志还是会存储在公共的空间中的。</p>
<p><strong>定义表空间文件大小位置</strong></p>
<p>可以通过定义 <code>my.cnf</code> 中的配置，来定义存储的表空间文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path &#x3D; &#x2F;db&#x2F;ibdata1:2000M;&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>

<p>我们可以这样定义由两个文件组成表空间，后面的文件容量大小限定表示文件限制大小，而 <code>ibdata2</code> 增长到 <code>2000M</code> 的时候还可以自动增长。</p>
<h3 id="2-1-表的逻辑存储-2"><a href="#2-1-表的逻辑存储-2" class="headerlink" title="2.1 表的逻辑存储"></a>2.1 表的逻辑存储</h3><p>接下来简单说下上图中，表空间的下级几个东西：</p>
<p><strong>段</strong></p>
<p>表空间由很多个段组成，段又有数据段、索引段、回滚段等等。因为 <code>InnoDB</code> 存储数据本质上就是利用索引树进行存储的，所以数据段即是 <code>B+树</code> 的<code>叶节点</code>，而索引段即为<code>非叶子节点</code>。</p>
<p><strong>区</strong></p>
<p>每个区由 <code>64个页</code> 组成，每页大小 <code>16KB</code>，因此每个区是 <code>1MB</code>。针对需要插入大数据段的操作，<code>InnoDB</code> 每次至多申请 <code>4个区</code>。</p>
<p>我们启用 <code>innodb_file_per_table</code> 参数的时候，创建表的时候即段的开始，<code>InnoDB</code> 先使用 <code>32个页</code> 的碎片页来存放数据，当这些数据存储完了才会申请上面说的 <code>64个页</code>。</p>
<p>具体其他创建的时候怎么创建的细节，因为对我们使用数据库的时候帮助不是很大，这里就不再阐述（可以参考《MySQL技术内幕：InnoDB存储引擎》的 <code>4.2.3</code> 小节）</p>
<p><strong>页</strong></p>
<p>页太重要了，请允许我现在马上提取到大标题来讲！</p>
<p><strong>行</strong></p>
<p>行和页一样，太重要了，现在也一样马上提取到大标题来讲！</p>
<h2 id="三-InnoDB的数据页-2"><a href="#三-InnoDB的数据页-2" class="headerlink" title="三. InnoDB的数据页"></a>三. InnoDB的数据页</h2><p>页是 <code>MySQL InnoDB</code> 与服务器硬盘打交道的单位，当我们需要查询数据的时候，数据库每次至少加载 <code>一个页</code> 的数据到内存进行查找，而在前面说的刷新脏数据的时候，每次至少刷新 <code>一个页</code> 的数据，而页在 <code>区</code> 中说的，是 <code>16KB</code>。所以交互不会太小导致频繁 <code>IO</code> 也不会因为太大导致读取太慢。</p>
<p>页不仅有数据页，所有的页包含有：</p>
<ol>
<li>数据页（<code>B-tree Node</code>）；</li>
<li>Undo页（<code>Undo Log Page</code>）；</li>
<li>系统页（<code>System Page</code>）；</li>
<li>事务数据页（<code>Transaction system Page</code>）；</li>
<li>插入缓冲位图页（<code>Insert Buffer Bitmap</code>）；</li>
<li>插入缓冲空闲列表页（<code>Insert Buffer Free List</code>）；</li>
<li>未压缩的二进制大对象页（<code>Uncompress BLOB Page</code>）；</li>
<li>压缩的二进制大对象页（<code>Compressed BLOB Page</code>）。</li>
</ol>
<blockquote>
<p>第四节数据页的结构和第五节数据行的结构应该是并行了解，也就是两者共同构成搜索数据的基础，阅读建议是数据页格式先有个大概的概念，然后数据行，再两个并起来聊聊数据查询的内部原理.</p>
</blockquote>
<h2 id="四-数据页的结构-2"><a href="#四-数据页的结构-2" class="headerlink" title="四. 数据页的结构"></a>四. 数据页的结构</h2><p>这是一个页的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191120152749956"></p>
<p>OK，现在我们知道了，<code>InnoDB 数据页</code> 一共由 <code>7</code> 个部分组成。其中 <code>User Records 数据行</code> 存储的是我们用户的数据，他会按照 <code>Table</code> 指定的 <code>Row Format 行格式</code> 的规定进行存储。然而当一个页没有数据页格式的时候，是不存在 <code>User Records</code> 空间的，也就是说 <code>Free Space</code> 将会占领图中 <code>User Records</code> 那部分的空间。</p>
<p>好了，我们先摊开来每部分，大致的说一下是什么功能：</p>
<h3 id="4-1-FileHeader-文件头信息-1"><a href="#4-1-FileHeader-文件头信息-1" class="headerlink" title="4.1 FileHeader 文件头信息"></a>4.1 FileHeader 文件头信息</h3><p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
<p>在页头信息里面有个 <code>FILE_PAGE_TYPE</code>，它主要有以下几种类型：</p>
<ol>
<li><code>FILE_PAGE_INDEX</code> ：<code>B+树</code> 叶节点</li>
<li><code>FILE_PAGE_UNDO_LOG</code> ：<code>Undo Log</code> 页</li>
<li><code>FILE_PAGE_INODE</code> ：索引节点</li>
<li><code>FILE_PAGE_IBUF_FREE_LIST</code> ：<code>Insert Buffer</code> 空闲列表</li>
<li><code>FILE_PAGE_TYPE_ALLOCATED</code> ：最新分配的页</li>
<li><code>FILE_PAGE_BITMAP</code> ：<code>Insert Buffer</code> 位图</li>
<li><code>FILE_PAGE_SYS</code> ：系统页</li>
<li><code>FILE_PAGE_TRX_SYS</code> ：事务系统数据</li>
<li><code>FILE_PAGE_FSP_HDR</code> ：File Space Header</li>
<li><code>FILE_PAGE_XDES</code> ：拓展描述页</li>
<li><code>FILE_PAGE_BLOB</code> ：<code>BLOB</code> 页</li>
</ol>
<h3 id="4-2-PageHeader-页头信息-1"><a href="#4-2-PageHeader-页头信息-1" class="headerlink" title="4.2 PageHeader 页头信息"></a>4.2 PageHeader 页头信息</h3><p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
<h3 id="4-3-Infimum-和-Supremum-最值记录-1"><a href="#4-3-Infimum-和-Supremum-最值记录-1" class="headerlink" title="4.3 Infimum 和 Supremum 最值记录"></a>4.3 Infimum 和 Supremum 最值记录</h3><p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
<h3 id="4-4-User-Records-用户记录-和-Free-Space-空闲空间-1"><a href="#4-4-User-Records-用户记录-和-Free-Space-空闲空间-1" class="headerlink" title="4.4 User Records 用户记录 和 Free Space 空闲空间"></a>4.4 User Records 用户记录 和 Free Space 空闲空间</h3><p>这两个放在一起说是有原因的，因为一个空的页，是没有 <code>User Records</code> 的，全部都是 <code>Free Space</code>。慢慢的插入数据的时候，<code>User Records</code> 慢慢增大，<code>Free Space</code> 慢慢减小，直到这个页塞满了数据，就开启下一页。</p>
<p>想了想，弄个动图演示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h3 id="4-5-Page-Director-页目录-1"><a href="#4-5-Page-Director-页目录-1" class="headerlink" title="4.5 Page Director 页目录"></a>4.5 Page Director 页目录</h3><p>页目录 <code>Page Director</code> 存储了很多槽，用来存储最大最小记录的槽，<code>InnoDB</code> 就是通过这些槽来提高查询的速度的，下面会详细说。</p>
<h3 id="4-6-File-Trailer-页尾部-1"><a href="#4-6-File-Trailer-页尾部-1" class="headerlink" title="4.6 File Trailer 页尾部"></a>4.6 File Trailer 页尾部</h3><p>校验页数据用的地方，这个页有两个部分：</p>
<ol>
<li>页的校验和</li>
</ol>
<p>与 <code>FileHeader</code> 中的 <code>FILE_PAGE_SPACE_OR_CHKSUM</code> 值相对应，因为 <code>FileHeader</code> 在页的头部，被首先写入硬盘，当写入硬盘的过程中发现错误导致页不完整的时候，头部和尾部的值就会出现不相同的情况，这时候就需要根据日志来重新做这个页。</p>
<ol start="2">
<li>被最后修改时对应的日志序列位置（LSN）</li>
</ol>
<p>也是用来做校验的，后面会说到。</p>
<h2 id="五-数据行-1"><a href="#五-数据行-1" class="headerlink" title="五. 数据行"></a>五. 数据行</h2><p>我们知道了，一个数据页是 <code>16kb</code> 的大小，而数据页中有一个很重要的部分就是 <code>User Record</code> 区域就是用来存放我们的数据的地方。我们所插入的数据，<code>InnoDB</code> 会根据规则，转变成一定的 <code>行格式</code> 插入到数据页中去，行格式除了存储我们生产的数据以外，还存储着一些额外的信息，用于加快<strong>查数据</strong>的速度（当然删和改也都以来着查，新增也会以来查来确定主要的位置，所以查是一个数据库中至关重要的功能）。</p>
<p><code>MySQL</code> 发展到现在，已经有好几种 <code>数据行</code> 的格式了，分别有：<code>Compact</code> <code>Redundant</code> <code>Dynamic</code> 和 <code>Compressed</code>。</p>
<p><code>Redundant</code> 是为了解决与之前版本的兼容性问题而存在的，剩下的 <code>Dynamic</code> 和 <code>Compressed</code> 本质上是 <code>Compact</code> 格式，只不过在处理溢出页的时候不同，只要说了 <code>Compact</code> 就相当于说了三种，至于什么是溢出页，在下面会详细说到。</p>
<p>首先来看看 <code>Compact</code> 的数据行包含了什么鬼：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121094525787"></p>
<h3 id="5-1-额外信息-1"><a href="#5-1-额外信息-1" class="headerlink" title="5.1 额外信息"></a>5.1 额外信息</h3><p>这部分是 <code>InnoDB</code> 为了方便快速查找统计而新加进去的一些记录行额外信息，主要用来标记可变长字段的长度（比如 <code>varchar</code> 占用多长）、哪些定义可为 <code>NULL</code> 的列在这条记录中出现了 <code>NULL</code> 以及一部分有用的记录头信息。</p>
<p>接下来一个一个来看这些有什么作用，为了防止标题太多层级我直接使用跟这里一样的标题。</p>
<h3 id="5-1-1-可变长字段的长度列表-1"><a href="#5-1-1-可变长字段的长度列表-1" class="headerlink" title="5.1.1 可变长字段的长度列表"></a>5.1.1 可变长字段的长度列表</h3><p>在 <code>Compact</code> 中，把表定义的可变长字段，在当前数据行中所占用的实际长度，按照 <strong>逆序</strong> 存储他们当前的长度。</p>
<p>怎么说呢，举个例子来做吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_db(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  addr <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  sex <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>这个表包含一个主键、一个不为空的 <code>name</code>，一个可为空的 <code>addr</code>，还有一个不可变长可为空的 <code>sex</code>。字符集是 <code>ascii</code>（就是包含简单字母的那个），以及指定行格式是 <code>Compact</code>。</p>
<p>然后我插入 <code>5</code> 个数据来玩玩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_db (<span class="keyword">id</span>, <span class="keyword">name</span>, addr, sex)</span><br><span class="line">	<span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;goudan&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">	(<span class="number">2</span>, <span class="string">&#x27;gousheng&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>, <span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">	(<span class="number">3</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">	(<span class="number">4</span>, <span class="string">&#x27;adan&#x27;</span>, <span class="string">&#x27;tianhe&#x27;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM user_db;</span></span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">| id | name     | addr      | sex  |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">|  1 | goudan   | NULL      | b    |</span><br><span class="line">|  2 | gousheng | guangzhou | g    |</span><br><span class="line">|  3 | xiaoming | NULL      | NULL |</span><br><span class="line">|  4 | adan     | tianhe    | NULL |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>好，终于搞定 <code>demo</code> 数据。</p>
<p>我们回到可变长字段的长度列表来看，就拿 <code>id = 2</code> 的数据来看吧：</p>
<p>因为在这个表中 <code>name</code> <code>addr</code> 都是可变长字段，<code>name</code> 的长度是 <code>8</code>，<code>addr</code> 的长度是 <code>9</code> 他们通过十六进制表示分别是：<code>0×08</code> <code>0×09</code> ，然后，可变长字段存储是逆序的，所有，存储在可变长字段列表里面的数据就是 <code>0908</code></p>
<p>这里有两个地方需要注意的是</p>
<ol>
<li>如果这个可变长的列，他的真实值是 <code>NULL</code>，则他不会被记录在此列表中，也就是说在 <code>id = 3</code> 的记录中，可变长字段的长度列表只需要记录 <code>name</code> 列的长度即可；</li>
<li>这个长度列表可能需要 <code>1字节</code> 也可能因为记录不下，而开辟了 <code>2字节</code> 的长度来记录，怎么说呢：</li>
</ol>
<p>我们知道 <code>1字节</code> 数的二进制是 <code>8</code> 位，然后，第一位像 <code>Protobuf</code> 一样用来记录后面还有没有位数，所以真实使用存储长度的是后 <code>7</code> 位。而 <code>7</code> 位最大能表示多大长度呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121105157176"></p>
<p>所以，如果这个长度他需要记录 <strong>小于等于</strong> <code>127</code> 的长度的时候，使用 <code>1字节</code>，而如果记录的值 <strong>大于</strong> <code>127</code> 的时候则使用 <code>2字节</code>。<code>8位</code> 的第一位用来标记，我后面还有没有 <code>1字节</code> 来一起记录长度，如果是 <code>0</code> 则表示我当前字节已经记录完所有的了，如果是 <code>1</code> 则表示我后面的 <code>1字节</code> 也是用来记录长度的。而如果长度，他 <code>1字节 = 255</code> 可以存储完毕，则使用 <code>1字节</code>。</p>
<p>那怎么大概计算字段占用多少字节的长度呢：</p>
<p>因为上面的 <code>user_db</code> 使用的是 <code>ascii</code> 来做记录的，让我们用臭名远扬的 <code>utf-8</code> 来说，我们知道，<code>MySQL</code> 中的 <code>utf-8</code> 是个假的，他其实只使用了 <code>3字节</code> 一个字符的方法来存储。</p>
<p>我们假设这个表只有一个列(varchar(MAXLEN))，那如果字符串的最大字节占用长度 = <code>MAXLEN * 3</code>，则如果最大占用字节 <strong>小于等于</strong> <code>255</code> 的时候，使用一个字节来存储，如果他大于 <code>255</code> 则根据他是否 <strong>小于等于</strong> <code>127</code> 也就是 <code>127 / 3 = 42</code> 个字符来看，如果小于等于127，则使用 <code>1字节</code>，否则使用 <code>2字节</code>。好累，弄个伪代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 占用的最大字节数，LocalCharsetLeng是当前字符集的最大字节长度 */</span></span><br><span class="line"><span class="keyword">let</span> maxByteLeng = LocalCharsetLeng * MAXLEN;</span><br><span class="line"><span class="comment">/** 可变长字段列表的长度 */</span></span><br><span class="line"><span class="keyword">let</span> lengthOfVariableColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (maxByteLeng &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">  lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/** 她当前数据行存储的长度 */</span></span><br><span class="line">  <span class="keyword">let</span> lengthOfData = ...</span><br><span class="line">  <span class="keyword">let</span> byteLengthOfData = LocalCharsetLeng * lengthOfData;</span><br><span class="line">  <span class="keyword">if</span> (byteLengthOfData &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-NULL值列表-1"><a href="#5-1-2-NULL值列表-1" class="headerlink" title="5.1.2 NULL值列表"></a>5.1.2 NULL值列表</h3><p><code>NULL值列表</code> 也是按照列中可以为NULL的列逆序来排放的，直接上图更清晰：</p>
<p>我们加入要看 <code>id = 3</code> 的数据，他的 <code>addr</code> 和 <code>sex</code> 都为 <code>NULL</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121151849940"></p>
<p>所以从最后一位开始，对应列中第一个可以为 <code>NULL</code> 的列（被 <code>NOT NULL</code> 修饰的列），如果是 <code>NULL</code> 则为 <code>1</code> 否则为 <code>0</code>。</p>
<p>所以，<code>NULL</code> 值并不会占用存储空间。</p>
<h3 id="5-1-3-记录头信息-1"><a href="#5-1-3-记录头信息-1" class="headerlink" title="5.1.3 记录头信息"></a>5.1.3 记录头信息</h3><p>这个可就很重要，因为他是构成索引搜索条件的基础。</p>
<p>记录头有以下这些头部信息，共占用 <code>40字节</code> 不同的字节数作用都不相同：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>占位符1</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>占位符2</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>delete_flag</td>
<td>1</td>
<td>标记记录是否被删除（也就是我们开发常说的逻辑删除）</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000普通记录 001B+树节点指针 010Infimum<br/>011Supremum 1xx保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>页中玉东道下一条记录需要的偏移量</td>
</tr>
</tbody></table>
<p>OK一起说完真实记录再来看看怎么搜索数据的吧</p>
<h3 id="5-2-真实数据-1"><a href="#5-2-真实数据-1" class="headerlink" title="5.2 真实数据"></a>5.2 真实数据</h3><p>真实数据的存储，都是存储有效的数据，即如果某个值没有数据，则不做存储。那他怎么知道谁是有的谁是没的，这就需要结合上面可变长字段列表、NULL值列表以及下一条记录的偏移量来确定了。</p>
<p>其实真实数据中，<code>InnoDB</code> 还会在真实数据的头部增加两个列：<code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> 分别是事务的指针以及回滚的指针（用于重做？）。如果当前的表没有定义主键的话，那么 <code>InnoDB</code> 还会真实数据的头部增加 <code>ROW_ID</code> 这个隐藏列来作为主键（为啥一定要主键？后面索引会说说的）</p>
<p>所以记录应该是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114503.png"></p>
<h3 id="5-3-溢出页-1"><a href="#5-3-溢出页-1" class="headerlink" title="5.3 溢出页"></a>5.3 溢出页</h3><p>针对 <code>VARCHAR</code> 定义的数据列最多能存储多少个数据？一个记录最大能存储 <code>65535</code> 个字节的数据，但是并不是真的可以存储，因为在上面看来，还需要记录变长字段以及 <code>NULL值列表</code>，如果被 <code>NOT NULL</code> 修饰，则还可以节省 <code>1字节</code>，所以假设我这个表只有一个列的情况下分为下面两种情况：</p>
<ol>
<li>被 <code>NOT NULL</code> 修饰，存储 <code>65533</code> 个字节；</li>
<li>没有修饰，存储 <code>65532</code> 个字节。</li>
</ol>
<p>那如果存储的数据超出一个页 <code>16kb</code> 的定义怎么办，那就需要额外的溢出页来存储数据了。</p>
<p>但是 <code>Compact</code> 格式的数据有点纠结，如果占用的字节数小于 <code>768</code> 字节的时候，存储在本页，如果超出了，则该页依然会记录前 <code>768字节</code> 的数据，然后再使用 <code>20字节</code> 来存储溢出页的地址以及字节数大小。</p>
<p>而 <code>MySQL 5.7</code> 使用的 <code>InnoDB Plugin</code> 默认的格式 <code>Dynamic</code> 以及新增的 <code>Compress</code> 格式则不同，他们只在当前记录这里记录溢出页的位置，将所有的数据都放在溢出页里面，而 <code>Compress</code> 还会将溢出页进行压缩处理，减少存储空间。</p>
<h2 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h2><p>主要了解了表的逻辑存储、数据页、数据行的格式。不过不用太担心没记住，后面我都会重复这里的内容来说接下来的所有事情的，毕竟这里面的一堆属性都是为后面 <code>MySQL</code> 的功能做铺垫。</p>
<p>OK，现在我们知道了，<code>InnoDB 数据页</code> 一共由 <code>7</code> 个部分组成。其中 <code>User Records 数据行</code> 存储的是我们用户的数据，他会按照 <code>Table</code> 指定的 <code>Row Format 行格式</code> 的规定进行存储。然而当一个页没有数据页格式的时候，是不存在 <code>User Records</code> 空间的，也就是说 <code>Free Space</code> 将会占领图中 <code>User Records</code> 那部分的空间。</p>
<p>好了，我们先摊开来每部分，大致的说一下是什么功能：</p>
<h3 id="4-1-FileHeader-文件头信息-2"><a href="#4-1-FileHeader-文件头信息-2" class="headerlink" title="4.1 FileHeader 文件头信息"></a>4.1 FileHeader 文件头信息</h3><p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
<p>在页头信息里面有个 <code>FILE_PAGE_TYPE</code>，它主要有以下几种类型：</p>
<ol>
<li><code>FILE_PAGE_INDEX</code> ：<code>B+树</code> 叶节点</li>
<li><code>FILE_PAGE_UNDO_LOG</code> ：<code>Undo Log</code> 页</li>
<li><code>FILE_PAGE_INODE</code> ：索引节点</li>
<li><code>FILE_PAGE_IBUF_FREE_LIST</code> ：<code>Insert Buffer</code> 空闲列表</li>
<li><code>FILE_PAGE_TYPE_ALLOCATED</code> ：最新分配的页</li>
<li><code>FILE_PAGE_BITMAP</code> ：<code>Insert Buffer</code> 位图</li>
<li><code>FILE_PAGE_SYS</code> ：系统页</li>
<li><code>FILE_PAGE_TRX_SYS</code> ：事务系统数据</li>
<li><code>FILE_PAGE_FSP_HDR</code> ：File Space Header</li>
<li><code>FILE_PAGE_XDES</code> ：拓展描述页</li>
<li><code>FILE_PAGE_BLOB</code> ：<code>BLOB</code> 页</li>
</ol>
<h3 id="4-2-PageHeader-页头信息-2"><a href="#4-2-PageHeader-页头信息-2" class="headerlink" title="4.2 PageHeader 页头信息"></a>4.2 PageHeader 页头信息</h3><p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
<h3 id="4-3-Infimum-和-Supremum-最值记录-2"><a href="#4-3-Infimum-和-Supremum-最值记录-2" class="headerlink" title="4.3 Infimum 和 Supremum 最值记录"></a>4.3 Infimum 和 Supremum 最值记录</h3><p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
<h3 id="4-4-User-Records-用户记录-和-Free-Space-空闲空间-2"><a href="#4-4-User-Records-用户记录-和-Free-Space-空闲空间-2" class="headerlink" title="4.4 User Records 用户记录 和 Free Space 空闲空间"></a>4.4 User Records 用户记录 和 Free Space 空闲空间</h3><p>这两个放在一起说是有原因的，因为一个空的页，是没有 <code>User Records</code> 的，全部都是 <code>Free Space</code>。慢慢的插入数据的时候，<code>User Records</code> 慢慢增大，<code>Free Space</code> 慢慢减小，直到这个页塞满了数据，就开启下一页。</p>
<p>想了想，弄个动图演示一下：</p>
<h2 id="一-InnoDB的表和数据-3"><a href="#一-InnoDB的表和数据-3" class="headerlink" title="一.InnoDB的表和数据"></a>一.InnoDB的表和数据</h2><p><code>InnoDB</code> 是怎样存储数据的，表是大概怎样的一种格式，表中的数据行又是怎样的一种格式。如果想要大概知道 <code>B+</code> 索引的执行过程，这块基本是跳不过去的。当然关于 <code>表</code> 和 <code>数据行</code> 的东西特别多，没办法涵盖所有，所以我只能将我学的，大概知道的重要部分取出来说一说。</p>
<p>这里先大概说下后面才说的 <code>索引</code> 问题，<code>B+索引</code> 其实利用了表中的 <code>行记录头</code>（可以想象是 <code>HTTP</code> 请求的请求头），然后进行数据结构组织实现快速检索的一种结构。所以不用说啦，<code>行记录头</code> 一些必要的属性，基本要知道的，也可以优化数据库的占用空间。</p>
<p><code>Innodb</code> 存储引擎表在创建的时候，如果没有显示定义主键（<code>Primary Key</code>），则会通过以下的规则创建主键：</p>
<ol>
<li>如果表中有非空的唯一索引，则该列为主键；</li>
<li>如果 <code>1</code> 不满足，则在你看不见的地方（行头）创建一个 <code>6</code> 字节大小的指针。</li>
</ol>
<p>我先从宏观的表空间进入，到段、区，到页，到行，那么这样看完行的时候，可以直接感受下一篇讲索引使用的行中的信息，也算是有一定的逻辑顺序吧。</p>
<p>他们的大致关系是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h2 id="二-表空间-3"><a href="#二-表空间-3" class="headerlink" title="二.表空间"></a>二.表空间</h2><h3 id="2-1-表的物理存储-3"><a href="#2-1-表的物理存储-3" class="headerlink" title="2.1 表的物理存储"></a>2.1 表的物理存储</h3><p><strong>数据、表、数据库文件</strong></p>
<p>至于要找到表结构的文件，我们至少需要先知道数据文件存在哪个地方，所以我们可以直接通过 <code>SQL</code> 语句进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;datadir&#39;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>OK，结果返回，我们的数据存储在 <code>/var/lib/mysql/</code> 中，所以我们现在进去瞅一瞅是什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql       20 9月  23 00:00 demo</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>为了能够继续说下去，我需要建立一些数据库以及表来做演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database innodb_study;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; use innodb_study;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table table_file_user (id int, name varchar(10));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>好了，创建了一个 <code>innodb_study</code> 的数据库以及一个 <code>table_file_user</code> 的表，现在我们重新来看看数据文件里面多了些什么东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:44 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 10月  9 22:44 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:42 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql       74 10月  9 22:44 innodb_study # 多了这个数据库文件夹</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>好了进去 <code>innodb_study</code> 瞅瞅有哪些东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# ll</span><br><span class="line">总用量 112</span><br><span class="line">-rw-r-----. 1 mysql mysql    65 10月  9 22:43 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql  8586 10月  9 22:44 table_file_user.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 98304 10月  9 22:44 table_file_user.ibd</span><br></pre></td></tr></table></figure>

<ol>
<li><code>db.opt</code> 猜一下，应该是数据库的设定，比如字符集啊，使用的存储引擎啊等等；</li>
<li><code>table_file_user.frm</code> 则是我创建的用户表的结构文件了；</li>
<li><code>table_file_user.ibd</code> 是 <code>InnoDB</code> 存储引擎的数据库文件；</li>
</ol>
<p>首先我们先来看看 <code>db.opt</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# cat db.opt</span><br><span class="line">default-character-set&#x3D;latin1</span><br><span class="line">default-collation&#x3D;latin1_swedish_ci</span><br></pre></td></tr></table></figure>

<p>可以看到，我刚刚在创建这个数据库的时候，一切用的是默认的，所以默认的字符集以及排序规则都是 <code>latin1</code> 相关的。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/latin1/1183590?fr=aladdin">latin1百科</a></p>
<p><code>table_file_user.frm</code> 则无法直接使用 <code>cat</code> 进行查看，需要通过  <a target="_blank" rel="noopener" href="https://pdf.us/2019/01/10/2620.html">MySQL管理工具集 MySQL Utilities</a> 的方式进行查看，不过在这里我就不演示了。</p>
<p><code>table_file_user.ibd</code> 则就是数据库文件了，存储的是数据库数据，后面再说。</p>
<p><strong>表空间设置参数</strong></p>
<p>针对 <code>table_file_user.ibd</code> 有个参数需要提一下 <code>innodb_file_per_table</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;innodb_file_per_table&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>什么意思咧，就是每个表的数据都存储在独立的表空间，<code>5.7</code> 以前默认是 <code>off</code> 的，后面的版本就默认开启了。如果是 <code>off</code> 的话，所有表的数据都会记录在一个文件里面。但是即使开启了独立表空间的参数，也只是记录表的数据、索引、插入缓冲等信息，其他的回滚日志还是会存储在公共的空间中的。</p>
<p><strong>定义表空间文件大小位置</strong></p>
<p>可以通过定义 <code>my.cnf</code> 中的配置，来定义存储的表空间文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path &#x3D; &#x2F;db&#x2F;ibdata1:2000M;&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>

<p>我们可以这样定义由两个文件组成表空间，后面的文件容量大小限定表示文件限制大小，而 <code>ibdata2</code> 增长到 <code>2000M</code> 的时候还可以自动增长。</p>
<h3 id="2-1-表的逻辑存储-3"><a href="#2-1-表的逻辑存储-3" class="headerlink" title="2.1 表的逻辑存储"></a>2.1 表的逻辑存储</h3><p>接下来简单说下上图中，表空间的下级几个东西：</p>
<p><strong>段</strong></p>
<p>表空间由很多个段组成，段又有数据段、索引段、回滚段等等。因为 <code>InnoDB</code> 存储数据本质上就是利用索引树进行存储的，所以数据段即是 <code>B+树</code> 的<code>叶节点</code>，而索引段即为<code>非叶子节点</code>。</p>
<p><strong>区</strong></p>
<p>每个区由 <code>64个页</code> 组成，每页大小 <code>16KB</code>，因此每个区是 <code>1MB</code>。针对需要插入大数据段的操作，<code>InnoDB</code> 每次至多申请 <code>4个区</code>。</p>
<p>我们启用 <code>innodb_file_per_table</code> 参数的时候，创建表的时候即段的开始，<code>InnoDB</code> 先使用 <code>32个页</code> 的碎片页来存放数据，当这些数据存储完了才会申请上面说的 <code>64个页</code>。</p>
<p>具体其他创建的时候怎么创建的细节，因为对我们使用数据库的时候帮助不是很大，这里就不再阐述（可以参考《MySQL技术内幕：InnoDB存储引擎》的 <code>4.2.3</code> 小节）</p>
<p><strong>页</strong></p>
<p>页太重要了，请允许我现在马上提取到大标题来讲！</p>
<p><strong>行</strong></p>
<p>行和页一样，太重要了，现在也一样马上提取到大标题来讲！</p>
<h2 id="三-InnoDB的数据页-3"><a href="#三-InnoDB的数据页-3" class="headerlink" title="三. InnoDB的数据页"></a>三. InnoDB的数据页</h2><p>页是 <code>MySQL InnoDB</code> 与服务器硬盘打交道的单位，当我们需要查询数据的时候，数据库每次至少加载 <code>一个页</code> 的数据到内存进行查找，而在前面说的刷新脏数据的时候，每次至少刷新 <code>一个页</code> 的数据，而页在 <code>区</code> 中说的，是 <code>16KB</code>。所以交互不会太小导致频繁 <code>IO</code> 也不会因为太大导致读取太慢。</p>
<p>页不仅有数据页，所有的页包含有：</p>
<ol>
<li>数据页（<code>B-tree Node</code>）；</li>
<li>Undo页（<code>Undo Log Page</code>）；</li>
<li>系统页（<code>System Page</code>）；</li>
<li>事务数据页（<code>Transaction system Page</code>）；</li>
<li>插入缓冲位图页（<code>Insert Buffer Bitmap</code>）；</li>
<li>插入缓冲空闲列表页（<code>Insert Buffer Free List</code>）；</li>
<li>未压缩的二进制大对象页（<code>Uncompress BLOB Page</code>）；</li>
<li>压缩的二进制大对象页（<code>Compressed BLOB Page</code>）。</li>
</ol>
<blockquote>
<p>第四节数据页的结构和第五节数据行的结构应该是并行了解，也就是两者共同构成搜索数据的基础，阅读建议是数据页格式先有个大概的概念，然后数据行，再两个并起来聊聊数据查询的内部原理.</p>
</blockquote>
<h2 id="四-数据页的结构-3"><a href="#四-数据页的结构-3" class="headerlink" title="四. 数据页的结构"></a>四. 数据页的结构</h2><p>这是一个页的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191120152749956"></p>
<p>OK，现在我们知道了，<code>InnoDB 数据页</code> 一共由 <code>7</code> 个部分组成。其中 <code>User Records 数据行</code> 存储的是我们用户的数据，他会按照 <code>Table</code> 指定的 <code>Row Format 行格式</code> 的规定进行存储。然而当一个页没有数据页格式的时候，是不存在 <code>User Records</code> 空间的，也就是说 <code>Free Space</code> 将会占领图中 <code>User Records</code> 那部分的空间。</p>
<p>好了，我们先摊开来每部分，大致的说一下是什么功能：</p>
<h3 id="4-1-FileHeader-文件头信息-3"><a href="#4-1-FileHeader-文件头信息-3" class="headerlink" title="4.1 FileHeader 文件头信息"></a>4.1 FileHeader 文件头信息</h3><p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
<p>在页头信息里面有个 <code>FILE_PAGE_TYPE</code>，它主要有以下几种类型：</p>
<ol>
<li><code>FILE_PAGE_INDEX</code> ：<code>B+树</code> 叶节点</li>
<li><code>FILE_PAGE_UNDO_LOG</code> ：<code>Undo Log</code> 页</li>
<li><code>FILE_PAGE_INODE</code> ：索引节点</li>
<li><code>FILE_PAGE_IBUF_FREE_LIST</code> ：<code>Insert Buffer</code> 空闲列表</li>
<li><code>FILE_PAGE_TYPE_ALLOCATED</code> ：最新分配的页</li>
<li><code>FILE_PAGE_BITMAP</code> ：<code>Insert Buffer</code> 位图</li>
<li><code>FILE_PAGE_SYS</code> ：系统页</li>
<li><code>FILE_PAGE_TRX_SYS</code> ：事务系统数据</li>
<li><code>FILE_PAGE_FSP_HDR</code> ：File Space Header</li>
<li><code>FILE_PAGE_XDES</code> ：拓展描述页</li>
<li><code>FILE_PAGE_BLOB</code> ：<code>BLOB</code> 页</li>
</ol>
<h3 id="4-2-PageHeader-页头信息-3"><a href="#4-2-PageHeader-页头信息-3" class="headerlink" title="4.2 PageHeader 页头信息"></a>4.2 PageHeader 页头信息</h3><p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
<h3 id="4-3-Infimum-和-Supremum-最值记录-3"><a href="#4-3-Infimum-和-Supremum-最值记录-3" class="headerlink" title="4.3 Infimum 和 Supremum 最值记录"></a>4.3 Infimum 和 Supremum 最值记录</h3><p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
<h3 id="4-4-User-Records-用户记录-和-Free-Space-空闲空间-3"><a href="#4-4-User-Records-用户记录-和-Free-Space-空闲空间-3" class="headerlink" title="4.4 User Records 用户记录 和 Free Space 空闲空间"></a>4.4 User Records 用户记录 和 Free Space 空闲空间</h3><p>这两个放在一起说是有原因的，因为一个空的页，是没有 <code>User Records</code> 的，全部都是 <code>Free Space</code>。慢慢的插入数据的时候，<code>User Records</code> 慢慢增大，<code>Free Space</code> 慢慢减小，直到这个页塞满了数据，就开启下一页。</p>
<p>想了想，弄个动图演示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h3 id="4-5-Page-Director-页目录-2"><a href="#4-5-Page-Director-页目录-2" class="headerlink" title="4.5 Page Director 页目录"></a>4.5 Page Director 页目录</h3><p>页目录 <code>Page Director</code> 存储了很多槽，用来存储最大最小记录的槽，<code>InnoDB</code> 就是通过这些槽来提高查询的速度的，下面会详细说。</p>
<h3 id="4-6-File-Trailer-页尾部-2"><a href="#4-6-File-Trailer-页尾部-2" class="headerlink" title="4.6 File Trailer 页尾部"></a>4.6 File Trailer 页尾部</h3><p>校验页数据用的地方，这个页有两个部分：</p>
<ol>
<li>页的校验和</li>
</ol>
<p>与 <code>FileHeader</code> 中的 <code>FILE_PAGE_SPACE_OR_CHKSUM</code> 值相对应，因为 <code>FileHeader</code> 在页的头部，被首先写入硬盘，当写入硬盘的过程中发现错误导致页不完整的时候，头部和尾部的值就会出现不相同的情况，这时候就需要根据日志来重新做这个页。</p>
<ol start="2">
<li>被最后修改时对应的日志序列位置（LSN）</li>
</ol>
<p>也是用来做校验的，后面会说到。</p>
<h2 id="五-数据行-2"><a href="#五-数据行-2" class="headerlink" title="五. 数据行"></a>五. 数据行</h2><p>我们知道了，一个数据页是 <code>16kb</code> 的大小，而数据页中有一个很重要的部分就是 <code>User Record</code> 区域就是用来存放我们的数据的地方。我们所插入的数据，<code>InnoDB</code> 会根据规则，转变成一定的 <code>行格式</code> 插入到数据页中去，行格式除了存储我们生产的数据以外，还存储着一些额外的信息，用于加快<strong>查数据</strong>的速度（当然删和改也都以来着查，新增也会以来查来确定主要的位置，所以查是一个数据库中至关重要的功能）。</p>
<p><code>MySQL</code> 发展到现在，已经有好几种 <code>数据行</code> 的格式了，分别有：<code>Compact</code> <code>Redundant</code> <code>Dynamic</code> 和 <code>Compressed</code>。</p>
<p><code>Redundant</code> 是为了解决与之前版本的兼容性问题而存在的，剩下的 <code>Dynamic</code> 和 <code>Compressed</code> 本质上是 <code>Compact</code> 格式，只不过在处理溢出页的时候不同，只要说了 <code>Compact</code> 就相当于说了三种，至于什么是溢出页，在下面会详细说到。</p>
<p>首先来看看 <code>Compact</code> 的数据行包含了什么鬼：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121094525787"></p>
<h3 id="5-1-额外信息-2"><a href="#5-1-额外信息-2" class="headerlink" title="5.1 额外信息"></a>5.1 额外信息</h3><p>这部分是 <code>InnoDB</code> 为了方便快速查找统计而新加进去的一些记录行额外信息，主要用来标记可变长字段的长度（比如 <code>varchar</code> 占用多长）、哪些定义可为 <code>NULL</code> 的列在这条记录中出现了 <code>NULL</code> 以及一部分有用的记录头信息。</p>
<p>接下来一个一个来看这些有什么作用，为了防止标题太多层级我直接使用跟这里一样的标题。</p>
<h3 id="5-1-1-可变长字段的长度列表-2"><a href="#5-1-1-可变长字段的长度列表-2" class="headerlink" title="5.1.1 可变长字段的长度列表"></a>5.1.1 可变长字段的长度列表</h3><p>在 <code>Compact</code> 中，把表定义的可变长字段，在当前数据行中所占用的实际长度，按照 <strong>逆序</strong> 存储他们当前的长度。</p>
<p>怎么说呢，举个例子来做吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_db(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  addr <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  sex <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>这个表包含一个主键、一个不为空的 <code>name</code>，一个可为空的 <code>addr</code>，还有一个不可变长可为空的 <code>sex</code>。字符集是 <code>ascii</code>（就是包含简单字母的那个），以及指定行格式是 <code>Compact</code>。</p>
<p>然后我插入 <code>5</code> 个数据来玩玩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_db (<span class="keyword">id</span>, <span class="keyword">name</span>, addr, sex)</span><br><span class="line">	<span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;goudan&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">	(<span class="number">2</span>, <span class="string">&#x27;gousheng&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>, <span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">	(<span class="number">3</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">	(<span class="number">4</span>, <span class="string">&#x27;adan&#x27;</span>, <span class="string">&#x27;tianhe&#x27;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM user_db;</span></span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">| id | name     | addr      | sex  |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">|  1 | goudan   | NULL      | b    |</span><br><span class="line">|  2 | gousheng | guangzhou | g    |</span><br><span class="line">|  3 | xiaoming | NULL      | NULL |</span><br><span class="line">|  4 | adan     | tianhe    | NULL |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>好，终于搞定 <code>demo</code> 数据。</p>
<p>我们回到可变长字段的长度列表来看，就拿 <code>id = 2</code> 的数据来看吧：</p>
<p>因为在这个表中 <code>name</code> <code>addr</code> 都是可变长字段，<code>name</code> 的长度是 <code>8</code>，<code>addr</code> 的长度是 <code>9</code> 他们通过十六进制表示分别是：<code>0×08</code> <code>0×09</code> ，然后，可变长字段存储是逆序的，所有，存储在可变长字段列表里面的数据就是 <code>0908</code></p>
<p>这里有两个地方需要注意的是</p>
<ol>
<li>如果这个可变长的列，他的真实值是 <code>NULL</code>，则他不会被记录在此列表中，也就是说在 <code>id = 3</code> 的记录中，可变长字段的长度列表只需要记录 <code>name</code> 列的长度即可；</li>
<li>这个长度列表可能需要 <code>1字节</code> 也可能因为记录不下，而开辟了 <code>2字节</code> 的长度来记录，怎么说呢：</li>
</ol>
<p>我们知道 <code>1字节</code> 数的二进制是 <code>8</code> 位，然后，第一位像 <code>Protobuf</code> 一样用来记录后面还有没有位数，所以真实使用存储长度的是后 <code>7</code> 位。而 <code>7</code> 位最大能表示多大长度呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121105157176"></p>
<p>所以，如果这个长度他需要记录 <strong>小于等于</strong> <code>127</code> 的长度的时候，使用 <code>1字节</code>，而如果记录的值 <strong>大于</strong> <code>127</code> 的时候则使用 <code>2字节</code>。<code>8位</code> 的第一位用来标记，我后面还有没有 <code>1字节</code> 来一起记录长度，如果是 <code>0</code> 则表示我当前字节已经记录完所有的了，如果是 <code>1</code> 则表示我后面的 <code>1字节</code> 也是用来记录长度的。而如果长度，他 <code>1字节 = 255</code> 可以存储完毕，则使用 <code>1字节</code>。</p>
<p>那怎么大概计算字段占用多少字节的长度呢：</p>
<p>因为上面的 <code>user_db</code> 使用的是 <code>ascii</code> 来做记录的，让我们用臭名远扬的 <code>utf-8</code> 来说，我们知道，<code>MySQL</code> 中的 <code>utf-8</code> 是个假的，他其实只使用了 <code>3字节</code> 一个字符的方法来存储。</p>
<p>我们假设这个表只有一个列(varchar(MAXLEN))，那如果字符串的最大字节占用长度 = <code>MAXLEN * 3</code>，则如果最大占用字节 <strong>小于等于</strong> <code>255</code> 的时候，使用一个字节来存储，如果他大于 <code>255</code> 则根据他是否 <strong>小于等于</strong> <code>127</code> 也就是 <code>127 / 3 = 42</code> 个字符来看，如果小于等于127，则使用 <code>1字节</code>，否则使用 <code>2字节</code>。好累，弄个伪代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 占用的最大字节数，LocalCharsetLeng是当前字符集的最大字节长度 */</span></span><br><span class="line"><span class="keyword">let</span> maxByteLeng = LocalCharsetLeng * MAXLEN;</span><br><span class="line"><span class="comment">/** 可变长字段列表的长度 */</span></span><br><span class="line"><span class="keyword">let</span> lengthOfVariableColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (maxByteLeng &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">  lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/** 她当前数据行存储的长度 */</span></span><br><span class="line">  <span class="keyword">let</span> lengthOfData = ...</span><br><span class="line">  <span class="keyword">let</span> byteLengthOfData = LocalCharsetLeng * lengthOfData;</span><br><span class="line">  <span class="keyword">if</span> (byteLengthOfData &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-NULL值列表-2"><a href="#5-1-2-NULL值列表-2" class="headerlink" title="5.1.2 NULL值列表"></a>5.1.2 NULL值列表</h3><p><code>NULL值列表</code> 也是按照列中可以为NULL的列逆序来排放的，直接上图更清晰：</p>
<p>我们加入要看 <code>id = 3</code> 的数据，他的 <code>addr</code> 和 <code>sex</code> 都为 <code>NULL</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121151849940"></p>
<p>所以从最后一位开始，对应列中第一个可以为 <code>NULL</code> 的列（被 <code>NOT NULL</code> 修饰的列），如果是 <code>NULL</code> 则为 <code>1</code> 否则为 <code>0</code>。</p>
<p>所以，<code>NULL</code> 值并不会占用存储空间。</p>
<h3 id="5-1-3-记录头信息-2"><a href="#5-1-3-记录头信息-2" class="headerlink" title="5.1.3 记录头信息"></a>5.1.3 记录头信息</h3><p>这个可就很重要，因为他是构成索引搜索条件的基础。</p>
<p>记录头有以下这些头部信息，共占用 <code>40字节</code> 不同的字节数作用都不相同：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>占位符1</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>占位符2</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>delete_flag</td>
<td>1</td>
<td>标记记录是否被删除（也就是我们开发常说的逻辑删除）</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000普通记录 001B+树节点指针 010Infimum<br/>011Supremum 1xx保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>页中玉东道下一条记录需要的偏移量</td>
</tr>
</tbody></table>
<p>OK一起说完真实记录再来看看怎么搜索数据的吧</p>
<h3 id="5-2-真实数据-2"><a href="#5-2-真实数据-2" class="headerlink" title="5.2 真实数据"></a>5.2 真实数据</h3><p>真实数据的存储，都是存储有效的数据，即如果某个值没有数据，则不做存储。那他怎么知道谁是有的谁是没的，这就需要结合上面可变长字段列表、NULL值列表以及下一条记录的偏移量来确定了。</p>
<p>其实真实数据中，<code>InnoDB</code> 还会在真实数据的头部增加两个列：<code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> 分别是事务的指针以及回滚的指针（用于重做？）。如果当前的表没有定义主键的话，那么 <code>InnoDB</code> 还会真实数据的头部增加 <code>ROW_ID</code> 这个隐藏列来作为主键（为啥一定要主键？后面索引会说说的）</p>
<p>所以记录应该是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114503.png"></p>
<h3 id="5-3-溢出页-2"><a href="#5-3-溢出页-2" class="headerlink" title="5.3 溢出页"></a>5.3 溢出页</h3><p>针对 <code>VARCHAR</code> 定义的数据列最多能存储多少个数据？一个记录最大能存储 <code>65535</code> 个字节的数据，但是并不是真的可以存储，因为在上面看来，还需要记录变长字段以及 <code>NULL值列表</code>，如果被 <code>NOT NULL</code> 修饰，则还可以节省 <code>1字节</code>，所以假设我这个表只有一个列的情况下分为下面两种情况：</p>
<ol>
<li>被 <code>NOT NULL</code> 修饰，存储 <code>65533</code> 个字节；</li>
<li>没有修饰，存储 <code>65532</code> 个字节。</li>
</ol>
<p>那如果存储的数据超出一个页 <code>16kb</code> 的定义怎么办，那就需要额外的溢出页来存储数据了。</p>
<p>但是 <code>Compact</code> 格式的数据有点纠结，如果占用的字节数小于 <code>768</code> 字节的时候，存储在本页，如果超出了，则该页依然会记录前 <code>768字节</code> 的数据，然后再使用 <code>20字节</code> 来存储溢出页的地址以及字节数大小。</p>
<p>而 <code>MySQL 5.7</code> 使用的 <code>InnoDB Plugin</code> 默认的格式 <code>Dynamic</code> 以及新增的 <code>Compress</code> 格式则不同，他们只在当前记录这里记录溢出页的位置，将所有的数据都放在溢出页里面，而 <code>Compress</code> 还会将溢出页进行压缩处理，减少存储空间。</p>
<h2 id="总结一下-2"><a href="#总结一下-2" class="headerlink" title="总结一下"></a>总结一下</h2><p>主要了解了表的逻辑存储、数据页、数据行的格式。不过不用太担心没记住，后面我都会重复这里的内容来说接下来的所有事情的，毕竟这里面的一堆属性都是为后面 <code>MySQL</code> 的功能做铺垫。</p>
<h3 id="4-5-Page-Director-页目录-3"><a href="#4-5-Page-Director-页目录-3" class="headerlink" title="4.5 Page Director 页目录"></a>4.5 Page Director 页目录</h3><p>页目录 <code>Page Director</code> 存储了很多槽，用来存储最大最小记录的槽，<code>InnoDB</code> 就是通过这些槽来提高查询的速度的，下面会详细说。</p>
<h3 id="4-6-File-Trailer-页尾部-3"><a href="#4-6-File-Trailer-页尾部-3" class="headerlink" title="4.6 File Trailer 页尾部"></a>4.6 File Trailer 页尾部</h3><p>校验页数据用的地方，这个页有两个部分：</p>
<ol>
<li>页的校验和</li>
</ol>
<p>与 <code>FileHeader</code> 中的 <code>FILE_PAGE_SPACE_OR_CHKSUM</code> 值相对应，因为 <code>FileHeader</code> 在页的头部，被首先写入硬盘，当写入硬盘的过程中发现错误导致页不完整的时候，头部和尾部的值就会出现不相同的情况，这时候就需要根据日志来重新做这个页。</p>
<ol start="2">
<li>被最后修改时对应的日志序列位置（LSN）</li>
</ol>
<p>也是用来做校验的，后面会说到。</p>
<h2 id="五-数据行-3"><a href="#五-数据行-3" class="headerlink" title="五. 数据行"></a>五. 数据行</h2><p>我们知道了，一个数据页是 <code>16kb</code> 的大小，而数据页中有一个很重要的部分就是 <code>User Record</code> 区域就是用来存放我们的数据的地方。我们所插入的数据，<code>InnoDB</code> 会根据规则，转变成一定的 <code>行格式</code> 插入到数据页中去，行格式除了存储我们生产的数据以外，还存储着一些额外的信息，用于加快<strong>查数据</strong>的速度（当然删和改也都以来着查，新增也会以来查来确定主要的位置，所以查是一个数据库中至关重要的功能）。</p>
<p><code>MySQL</code> 发展到现在，已经有好几种 <code>数据行</code> 的格式了，分别有：<code>Compact</code> <code>Redundant</code> <code>Dynamic</code> 和 <code>Compressed</code>。</p>
<p><code>Redundant</code> 是为了解决与之前版本的兼容性问题而存在的，剩下的 <code>Dynamic</code> 和 <code>Compressed</code> 本质上是 <code>Compact</code> 格式，只不过在处理溢出页的时候不同，只要说了 <code>Compact</code> 就相当于说了三种，至于什么是溢出页，在下面会详细说到。</p>
<p>首先来看看 <code>Compact</code> 的数据行包含了什么鬼：</p>
<h2 id="一-InnoDB的表和数据-4"><a href="#一-InnoDB的表和数据-4" class="headerlink" title="一.InnoDB的表和数据"></a>一.InnoDB的表和数据</h2><p><code>InnoDB</code> 是怎样存储数据的，表是大概怎样的一种格式，表中的数据行又是怎样的一种格式。如果想要大概知道 <code>B+</code> 索引的执行过程，这块基本是跳不过去的。当然关于 <code>表</code> 和 <code>数据行</code> 的东西特别多，没办法涵盖所有，所以我只能将我学的，大概知道的重要部分取出来说一说。</p>
<p>这里先大概说下后面才说的 <code>索引</code> 问题，<code>B+索引</code> 其实利用了表中的 <code>行记录头</code>（可以想象是 <code>HTTP</code> 请求的请求头），然后进行数据结构组织实现快速检索的一种结构。所以不用说啦，<code>行记录头</code> 一些必要的属性，基本要知道的，也可以优化数据库的占用空间。</p>
<p><code>Innodb</code> 存储引擎表在创建的时候，如果没有显示定义主键（<code>Primary Key</code>），则会通过以下的规则创建主键：</p>
<ol>
<li>如果表中有非空的唯一索引，则该列为主键；</li>
<li>如果 <code>1</code> 不满足，则在你看不见的地方（行头）创建一个 <code>6</code> 字节大小的指针。</li>
</ol>
<p>我先从宏观的表空间进入，到段、区，到页，到行，那么这样看完行的时候，可以直接感受下一篇讲索引使用的行中的信息，也算是有一定的逻辑顺序吧。</p>
<p>他们的大致关系是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h2 id="二-表空间-4"><a href="#二-表空间-4" class="headerlink" title="二.表空间"></a>二.表空间</h2><h3 id="2-1-表的物理存储-4"><a href="#2-1-表的物理存储-4" class="headerlink" title="2.1 表的物理存储"></a>2.1 表的物理存储</h3><p><strong>数据、表、数据库文件</strong></p>
<p>至于要找到表结构的文件，我们至少需要先知道数据文件存在哪个地方，所以我们可以直接通过 <code>SQL</code> 语句进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;datadir&#39;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>OK，结果返回，我们的数据存储在 <code>/var/lib/mysql/</code> 中，所以我们现在进去瞅一瞅是什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql       20 9月  23 00:00 demo</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>为了能够继续说下去，我需要建立一些数据库以及表来做演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database innodb_study;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; use innodb_study;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table table_file_user (id int, name varchar(10));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>好了，创建了一个 <code>innodb_study</code> 的数据库以及一个 <code>table_file_user</code> 的表，现在我们重新来看看数据文件里面多了些什么东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:44 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 10月  9 22:44 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:42 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql       74 10月  9 22:44 innodb_study # 多了这个数据库文件夹</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>好了进去 <code>innodb_study</code> 瞅瞅有哪些东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# ll</span><br><span class="line">总用量 112</span><br><span class="line">-rw-r-----. 1 mysql mysql    65 10月  9 22:43 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql  8586 10月  9 22:44 table_file_user.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 98304 10月  9 22:44 table_file_user.ibd</span><br></pre></td></tr></table></figure>

<ol>
<li><code>db.opt</code> 猜一下，应该是数据库的设定，比如字符集啊，使用的存储引擎啊等等；</li>
<li><code>table_file_user.frm</code> 则是我创建的用户表的结构文件了；</li>
<li><code>table_file_user.ibd</code> 是 <code>InnoDB</code> 存储引擎的数据库文件；</li>
</ol>
<p>首先我们先来看看 <code>db.opt</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# cat db.opt</span><br><span class="line">default-character-set&#x3D;latin1</span><br><span class="line">default-collation&#x3D;latin1_swedish_ci</span><br></pre></td></tr></table></figure>

<p>可以看到，我刚刚在创建这个数据库的时候，一切用的是默认的，所以默认的字符集以及排序规则都是 <code>latin1</code> 相关的。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/latin1/1183590?fr=aladdin">latin1百科</a></p>
<p><code>table_file_user.frm</code> 则无法直接使用 <code>cat</code> 进行查看，需要通过  <a target="_blank" rel="noopener" href="https://pdf.us/2019/01/10/2620.html">MySQL管理工具集 MySQL Utilities</a> 的方式进行查看，不过在这里我就不演示了。</p>
<p><code>table_file_user.ibd</code> 则就是数据库文件了，存储的是数据库数据，后面再说。</p>
<p><strong>表空间设置参数</strong></p>
<p>针对 <code>table_file_user.ibd</code> 有个参数需要提一下 <code>innodb_file_per_table</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;innodb_file_per_table&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>什么意思咧，就是每个表的数据都存储在独立的表空间，<code>5.7</code> 以前默认是 <code>off</code> 的，后面的版本就默认开启了。如果是 <code>off</code> 的话，所有表的数据都会记录在一个文件里面。但是即使开启了独立表空间的参数，也只是记录表的数据、索引、插入缓冲等信息，其他的回滚日志还是会存储在公共的空间中的。</p>
<p><strong>定义表空间文件大小位置</strong></p>
<p>可以通过定义 <code>my.cnf</code> 中的配置，来定义存储的表空间文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path &#x3D; &#x2F;db&#x2F;ibdata1:2000M;&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>

<p>我们可以这样定义由两个文件组成表空间，后面的文件容量大小限定表示文件限制大小，而 <code>ibdata2</code> 增长到 <code>2000M</code> 的时候还可以自动增长。</p>
<h3 id="2-1-表的逻辑存储-4"><a href="#2-1-表的逻辑存储-4" class="headerlink" title="2.1 表的逻辑存储"></a>2.1 表的逻辑存储</h3><p>接下来简单说下上图中，表空间的下级几个东西：</p>
<p><strong>段</strong></p>
<p>表空间由很多个段组成，段又有数据段、索引段、回滚段等等。因为 <code>InnoDB</code> 存储数据本质上就是利用索引树进行存储的，所以数据段即是 <code>B+树</code> 的<code>叶节点</code>，而索引段即为<code>非叶子节点</code>。</p>
<p><strong>区</strong></p>
<p>每个区由 <code>64个页</code> 组成，每页大小 <code>16KB</code>，因此每个区是 <code>1MB</code>。针对需要插入大数据段的操作，<code>InnoDB</code> 每次至多申请 <code>4个区</code>。</p>
<p>我们启用 <code>innodb_file_per_table</code> 参数的时候，创建表的时候即段的开始，<code>InnoDB</code> 先使用 <code>32个页</code> 的碎片页来存放数据，当这些数据存储完了才会申请上面说的 <code>64个页</code>。</p>
<p>具体其他创建的时候怎么创建的细节，因为对我们使用数据库的时候帮助不是很大，这里就不再阐述（可以参考《MySQL技术内幕：InnoDB存储引擎》的 <code>4.2.3</code> 小节）</p>
<p><strong>页</strong></p>
<p>页太重要了，请允许我现在马上提取到大标题来讲！</p>
<p><strong>行</strong></p>
<p>行和页一样，太重要了，现在也一样马上提取到大标题来讲！</p>
<h2 id="三-InnoDB的数据页-4"><a href="#三-InnoDB的数据页-4" class="headerlink" title="三. InnoDB的数据页"></a>三. InnoDB的数据页</h2><p>页是 <code>MySQL InnoDB</code> 与服务器硬盘打交道的单位，当我们需要查询数据的时候，数据库每次至少加载 <code>一个页</code> 的数据到内存进行查找，而在前面说的刷新脏数据的时候，每次至少刷新 <code>一个页</code> 的数据，而页在 <code>区</code> 中说的，是 <code>16KB</code>。所以交互不会太小导致频繁 <code>IO</code> 也不会因为太大导致读取太慢。</p>
<p>页不仅有数据页，所有的页包含有：</p>
<ol>
<li>数据页（<code>B-tree Node</code>）；</li>
<li>Undo页（<code>Undo Log Page</code>）；</li>
<li>系统页（<code>System Page</code>）；</li>
<li>事务数据页（<code>Transaction system Page</code>）；</li>
<li>插入缓冲位图页（<code>Insert Buffer Bitmap</code>）；</li>
<li>插入缓冲空闲列表页（<code>Insert Buffer Free List</code>）；</li>
<li>未压缩的二进制大对象页（<code>Uncompress BLOB Page</code>）；</li>
<li>压缩的二进制大对象页（<code>Compressed BLOB Page</code>）。</li>
</ol>
<blockquote>
<p>第四节数据页的结构和第五节数据行的结构应该是并行了解，也就是两者共同构成搜索数据的基础，阅读建议是数据页格式先有个大概的概念，然后数据行，再两个并起来聊聊数据查询的内部原理.</p>
</blockquote>
<h2 id="四-数据页的结构-4"><a href="#四-数据页的结构-4" class="headerlink" title="四. 数据页的结构"></a>四. 数据页的结构</h2><p>这是一个页的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191120152749956"></p>
<p>OK，现在我们知道了，<code>InnoDB 数据页</code> 一共由 <code>7</code> 个部分组成。其中 <code>User Records 数据行</code> 存储的是我们用户的数据，他会按照 <code>Table</code> 指定的 <code>Row Format 行格式</code> 的规定进行存储。然而当一个页没有数据页格式的时候，是不存在 <code>User Records</code> 空间的，也就是说 <code>Free Space</code> 将会占领图中 <code>User Records</code> 那部分的空间。</p>
<p>好了，我们先摊开来每部分，大致的说一下是什么功能：</p>
<h3 id="4-1-FileHeader-文件头信息-4"><a href="#4-1-FileHeader-文件头信息-4" class="headerlink" title="4.1 FileHeader 文件头信息"></a>4.1 FileHeader 文件头信息</h3><p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
<p>在页头信息里面有个 <code>FILE_PAGE_TYPE</code>，它主要有以下几种类型：</p>
<ol>
<li><code>FILE_PAGE_INDEX</code> ：<code>B+树</code> 叶节点</li>
<li><code>FILE_PAGE_UNDO_LOG</code> ：<code>Undo Log</code> 页</li>
<li><code>FILE_PAGE_INODE</code> ：索引节点</li>
<li><code>FILE_PAGE_IBUF_FREE_LIST</code> ：<code>Insert Buffer</code> 空闲列表</li>
<li><code>FILE_PAGE_TYPE_ALLOCATED</code> ：最新分配的页</li>
<li><code>FILE_PAGE_BITMAP</code> ：<code>Insert Buffer</code> 位图</li>
<li><code>FILE_PAGE_SYS</code> ：系统页</li>
<li><code>FILE_PAGE_TRX_SYS</code> ：事务系统数据</li>
<li><code>FILE_PAGE_FSP_HDR</code> ：File Space Header</li>
<li><code>FILE_PAGE_XDES</code> ：拓展描述页</li>
<li><code>FILE_PAGE_BLOB</code> ：<code>BLOB</code> 页</li>
</ol>
<h3 id="4-2-PageHeader-页头信息-4"><a href="#4-2-PageHeader-页头信息-4" class="headerlink" title="4.2 PageHeader 页头信息"></a>4.2 PageHeader 页头信息</h3><p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
<h3 id="4-3-Infimum-和-Supremum-最值记录-4"><a href="#4-3-Infimum-和-Supremum-最值记录-4" class="headerlink" title="4.3 Infimum 和 Supremum 最值记录"></a>4.3 Infimum 和 Supremum 最值记录</h3><p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
<h3 id="4-4-User-Records-用户记录-和-Free-Space-空闲空间-4"><a href="#4-4-User-Records-用户记录-和-Free-Space-空闲空间-4" class="headerlink" title="4.4 User Records 用户记录 和 Free Space 空闲空间"></a>4.4 User Records 用户记录 和 Free Space 空闲空间</h3><p>这两个放在一起说是有原因的，因为一个空的页，是没有 <code>User Records</code> 的，全部都是 <code>Free Space</code>。慢慢的插入数据的时候，<code>User Records</code> 慢慢增大，<code>Free Space</code> 慢慢减小，直到这个页塞满了数据，就开启下一页。</p>
<p>想了想，弄个动图演示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h3 id="4-5-Page-Director-页目录-4"><a href="#4-5-Page-Director-页目录-4" class="headerlink" title="4.5 Page Director 页目录"></a>4.5 Page Director 页目录</h3><p>页目录 <code>Page Director</code> 存储了很多槽，用来存储最大最小记录的槽，<code>InnoDB</code> 就是通过这些槽来提高查询的速度的，下面会详细说。</p>
<h3 id="4-6-File-Trailer-页尾部-4"><a href="#4-6-File-Trailer-页尾部-4" class="headerlink" title="4.6 File Trailer 页尾部"></a>4.6 File Trailer 页尾部</h3><p>校验页数据用的地方，这个页有两个部分：</p>
<ol>
<li>页的校验和</li>
</ol>
<p>与 <code>FileHeader</code> 中的 <code>FILE_PAGE_SPACE_OR_CHKSUM</code> 值相对应，因为 <code>FileHeader</code> 在页的头部，被首先写入硬盘，当写入硬盘的过程中发现错误导致页不完整的时候，头部和尾部的值就会出现不相同的情况，这时候就需要根据日志来重新做这个页。</p>
<ol start="2">
<li>被最后修改时对应的日志序列位置（LSN）</li>
</ol>
<p>也是用来做校验的，后面会说到。</p>
<h2 id="五-数据行-4"><a href="#五-数据行-4" class="headerlink" title="五. 数据行"></a>五. 数据行</h2><p>我们知道了，一个数据页是 <code>16kb</code> 的大小，而数据页中有一个很重要的部分就是 <code>User Record</code> 区域就是用来存放我们的数据的地方。我们所插入的数据，<code>InnoDB</code> 会根据规则，转变成一定的 <code>行格式</code> 插入到数据页中去，行格式除了存储我们生产的数据以外，还存储着一些额外的信息，用于加快<strong>查数据</strong>的速度（当然删和改也都以来着查，新增也会以来查来确定主要的位置，所以查是一个数据库中至关重要的功能）。</p>
<p><code>MySQL</code> 发展到现在，已经有好几种 <code>数据行</code> 的格式了，分别有：<code>Compact</code> <code>Redundant</code> <code>Dynamic</code> 和 <code>Compressed</code>。</p>
<p><code>Redundant</code> 是为了解决与之前版本的兼容性问题而存在的，剩下的 <code>Dynamic</code> 和 <code>Compressed</code> 本质上是 <code>Compact</code> 格式，只不过在处理溢出页的时候不同，只要说了 <code>Compact</code> 就相当于说了三种，至于什么是溢出页，在下面会详细说到。</p>
<p>首先来看看 <code>Compact</code> 的数据行包含了什么鬼：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121094525787"></p>
<h3 id="5-1-额外信息-3"><a href="#5-1-额外信息-3" class="headerlink" title="5.1 额外信息"></a>5.1 额外信息</h3><p>这部分是 <code>InnoDB</code> 为了方便快速查找统计而新加进去的一些记录行额外信息，主要用来标记可变长字段的长度（比如 <code>varchar</code> 占用多长）、哪些定义可为 <code>NULL</code> 的列在这条记录中出现了 <code>NULL</code> 以及一部分有用的记录头信息。</p>
<p>接下来一个一个来看这些有什么作用，为了防止标题太多层级我直接使用跟这里一样的标题。</p>
<h3 id="5-1-1-可变长字段的长度列表-3"><a href="#5-1-1-可变长字段的长度列表-3" class="headerlink" title="5.1.1 可变长字段的长度列表"></a>5.1.1 可变长字段的长度列表</h3><p>在 <code>Compact</code> 中，把表定义的可变长字段，在当前数据行中所占用的实际长度，按照 <strong>逆序</strong> 存储他们当前的长度。</p>
<p>怎么说呢，举个例子来做吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_db(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  addr <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  sex <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>这个表包含一个主键、一个不为空的 <code>name</code>，一个可为空的 <code>addr</code>，还有一个不可变长可为空的 <code>sex</code>。字符集是 <code>ascii</code>（就是包含简单字母的那个），以及指定行格式是 <code>Compact</code>。</p>
<p>然后我插入 <code>5</code> 个数据来玩玩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_db (<span class="keyword">id</span>, <span class="keyword">name</span>, addr, sex)</span><br><span class="line">	<span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;goudan&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">	(<span class="number">2</span>, <span class="string">&#x27;gousheng&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>, <span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">	(<span class="number">3</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">	(<span class="number">4</span>, <span class="string">&#x27;adan&#x27;</span>, <span class="string">&#x27;tianhe&#x27;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM user_db;</span></span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">| id | name     | addr      | sex  |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">|  1 | goudan   | NULL      | b    |</span><br><span class="line">|  2 | gousheng | guangzhou | g    |</span><br><span class="line">|  3 | xiaoming | NULL      | NULL |</span><br><span class="line">|  4 | adan     | tianhe    | NULL |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>好，终于搞定 <code>demo</code> 数据。</p>
<p>我们回到可变长字段的长度列表来看，就拿 <code>id = 2</code> 的数据来看吧：</p>
<p>因为在这个表中 <code>name</code> <code>addr</code> 都是可变长字段，<code>name</code> 的长度是 <code>8</code>，<code>addr</code> 的长度是 <code>9</code> 他们通过十六进制表示分别是：<code>0×08</code> <code>0×09</code> ，然后，可变长字段存储是逆序的，所有，存储在可变长字段列表里面的数据就是 <code>0908</code></p>
<p>这里有两个地方需要注意的是</p>
<ol>
<li>如果这个可变长的列，他的真实值是 <code>NULL</code>，则他不会被记录在此列表中，也就是说在 <code>id = 3</code> 的记录中，可变长字段的长度列表只需要记录 <code>name</code> 列的长度即可；</li>
<li>这个长度列表可能需要 <code>1字节</code> 也可能因为记录不下，而开辟了 <code>2字节</code> 的长度来记录，怎么说呢：</li>
</ol>
<p>我们知道 <code>1字节</code> 数的二进制是 <code>8</code> 位，然后，第一位像 <code>Protobuf</code> 一样用来记录后面还有没有位数，所以真实使用存储长度的是后 <code>7</code> 位。而 <code>7</code> 位最大能表示多大长度呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121105157176"></p>
<p>所以，如果这个长度他需要记录 <strong>小于等于</strong> <code>127</code> 的长度的时候，使用 <code>1字节</code>，而如果记录的值 <strong>大于</strong> <code>127</code> 的时候则使用 <code>2字节</code>。<code>8位</code> 的第一位用来标记，我后面还有没有 <code>1字节</code> 来一起记录长度，如果是 <code>0</code> 则表示我当前字节已经记录完所有的了，如果是 <code>1</code> 则表示我后面的 <code>1字节</code> 也是用来记录长度的。而如果长度，他 <code>1字节 = 255</code> 可以存储完毕，则使用 <code>1字节</code>。</p>
<p>那怎么大概计算字段占用多少字节的长度呢：</p>
<p>因为上面的 <code>user_db</code> 使用的是 <code>ascii</code> 来做记录的，让我们用臭名远扬的 <code>utf-8</code> 来说，我们知道，<code>MySQL</code> 中的 <code>utf-8</code> 是个假的，他其实只使用了 <code>3字节</code> 一个字符的方法来存储。</p>
<p>我们假设这个表只有一个列(varchar(MAXLEN))，那如果字符串的最大字节占用长度 = <code>MAXLEN * 3</code>，则如果最大占用字节 <strong>小于等于</strong> <code>255</code> 的时候，使用一个字节来存储，如果他大于 <code>255</code> 则根据他是否 <strong>小于等于</strong> <code>127</code> 也就是 <code>127 / 3 = 42</code> 个字符来看，如果小于等于127，则使用 <code>1字节</code>，否则使用 <code>2字节</code>。好累，弄个伪代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 占用的最大字节数，LocalCharsetLeng是当前字符集的最大字节长度 */</span></span><br><span class="line"><span class="keyword">let</span> maxByteLeng = LocalCharsetLeng * MAXLEN;</span><br><span class="line"><span class="comment">/** 可变长字段列表的长度 */</span></span><br><span class="line"><span class="keyword">let</span> lengthOfVariableColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (maxByteLeng &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">  lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/** 她当前数据行存储的长度 */</span></span><br><span class="line">  <span class="keyword">let</span> lengthOfData = ...</span><br><span class="line">  <span class="keyword">let</span> byteLengthOfData = LocalCharsetLeng * lengthOfData;</span><br><span class="line">  <span class="keyword">if</span> (byteLengthOfData &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-NULL值列表-3"><a href="#5-1-2-NULL值列表-3" class="headerlink" title="5.1.2 NULL值列表"></a>5.1.2 NULL值列表</h3><p><code>NULL值列表</code> 也是按照列中可以为NULL的列逆序来排放的，直接上图更清晰：</p>
<p>我们加入要看 <code>id = 3</code> 的数据，他的 <code>addr</code> 和 <code>sex</code> 都为 <code>NULL</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121151849940"></p>
<p>所以从最后一位开始，对应列中第一个可以为 <code>NULL</code> 的列（被 <code>NOT NULL</code> 修饰的列），如果是 <code>NULL</code> 则为 <code>1</code> 否则为 <code>0</code>。</p>
<p>所以，<code>NULL</code> 值并不会占用存储空间。</p>
<h3 id="5-1-3-记录头信息-3"><a href="#5-1-3-记录头信息-3" class="headerlink" title="5.1.3 记录头信息"></a>5.1.3 记录头信息</h3><p>这个可就很重要，因为他是构成索引搜索条件的基础。</p>
<p>记录头有以下这些头部信息，共占用 <code>40字节</code> 不同的字节数作用都不相同：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>占位符1</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>占位符2</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>delete_flag</td>
<td>1</td>
<td>标记记录是否被删除（也就是我们开发常说的逻辑删除）</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000普通记录 001B+树节点指针 010Infimum<br/>011Supremum 1xx保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>页中玉东道下一条记录需要的偏移量</td>
</tr>
</tbody></table>
<p>OK一起说完真实记录再来看看怎么搜索数据的吧</p>
<h3 id="5-2-真实数据-3"><a href="#5-2-真实数据-3" class="headerlink" title="5.2 真实数据"></a>5.2 真实数据</h3><p>真实数据的存储，都是存储有效的数据，即如果某个值没有数据，则不做存储。那他怎么知道谁是有的谁是没的，这就需要结合上面可变长字段列表、NULL值列表以及下一条记录的偏移量来确定了。</p>
<p>其实真实数据中，<code>InnoDB</code> 还会在真实数据的头部增加两个列：<code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> 分别是事务的指针以及回滚的指针（用于重做？）。如果当前的表没有定义主键的话，那么 <code>InnoDB</code> 还会真实数据的头部增加 <code>ROW_ID</code> 这个隐藏列来作为主键（为啥一定要主键？后面索引会说说的）</p>
<p>所以记录应该是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114503.png"></p>
<h3 id="5-3-溢出页-3"><a href="#5-3-溢出页-3" class="headerlink" title="5.3 溢出页"></a>5.3 溢出页</h3><p>针对 <code>VARCHAR</code> 定义的数据列最多能存储多少个数据？一个记录最大能存储 <code>65535</code> 个字节的数据，但是并不是真的可以存储，因为在上面看来，还需要记录变长字段以及 <code>NULL值列表</code>，如果被 <code>NOT NULL</code> 修饰，则还可以节省 <code>1字节</code>，所以假设我这个表只有一个列的情况下分为下面两种情况：</p>
<ol>
<li>被 <code>NOT NULL</code> 修饰，存储 <code>65533</code> 个字节；</li>
<li>没有修饰，存储 <code>65532</code> 个字节。</li>
</ol>
<p>那如果存储的数据超出一个页 <code>16kb</code> 的定义怎么办，那就需要额外的溢出页来存储数据了。</p>
<p>但是 <code>Compact</code> 格式的数据有点纠结，如果占用的字节数小于 <code>768</code> 字节的时候，存储在本页，如果超出了，则该页依然会记录前 <code>768字节</code> 的数据，然后再使用 <code>20字节</code> 来存储溢出页的地址以及字节数大小。</p>
<p>而 <code>MySQL 5.7</code> 使用的 <code>InnoDB Plugin</code> 默认的格式 <code>Dynamic</code> 以及新增的 <code>Compress</code> 格式则不同，他们只在当前记录这里记录溢出页的位置，将所有的数据都放在溢出页里面，而 <code>Compress</code> 还会将溢出页进行压缩处理，减少存储空间。</p>
<h2 id="总结一下-3"><a href="#总结一下-3" class="headerlink" title="总结一下"></a>总结一下</h2><p>主要了解了表的逻辑存储、数据页、数据行的格式。不过不用太担心没记住，后面我都会重复这里的内容来说接下来的所有事情的，毕竟这里面的一堆属性都是为后面 <code>MySQL</code> 的功能做铺垫。</p>
<h3 id="5-1-额外信息-4"><a href="#5-1-额外信息-4" class="headerlink" title="5.1 额外信息"></a>5.1 额外信息</h3><p>这部分是 <code>InnoDB</code> 为了方便快速查找统计而新加进去的一些记录行额外信息，主要用来标记可变长字段的长度（比如 <code>varchar</code> 占用多长）、哪些定义可为 <code>NULL</code> 的列在这条记录中出现了 <code>NULL</code> 以及一部分有用的记录头信息。</p>
<p>接下来一个一个来看这些有什么作用，为了防止标题太多层级我直接使用跟这里一样的标题。</p>
<h3 id="5-1-1-可变长字段的长度列表-4"><a href="#5-1-1-可变长字段的长度列表-4" class="headerlink" title="5.1.1 可变长字段的长度列表"></a>5.1.1 可变长字段的长度列表</h3><p>在 <code>Compact</code> 中，把表定义的可变长字段，在当前数据行中所占用的实际长度，按照 <strong>逆序</strong> 存储他们当前的长度。</p>
<p>怎么说呢，举个例子来做吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_db(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  addr <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  sex <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>这个表包含一个主键、一个不为空的 <code>name</code>，一个可为空的 <code>addr</code>，还有一个不可变长可为空的 <code>sex</code>。字符集是 <code>ascii</code>（就是包含简单字母的那个），以及指定行格式是 <code>Compact</code>。</p>
<p>然后我插入 <code>5</code> 个数据来玩玩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_db (<span class="keyword">id</span>, <span class="keyword">name</span>, addr, sex)</span><br><span class="line">	<span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;goudan&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">	(<span class="number">2</span>, <span class="string">&#x27;gousheng&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>, <span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">	(<span class="number">3</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">	(<span class="number">4</span>, <span class="string">&#x27;adan&#x27;</span>, <span class="string">&#x27;tianhe&#x27;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM user_db;</span></span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">| id | name     | addr      | sex  |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">|  1 | goudan   | NULL      | b    |</span><br><span class="line">|  2 | gousheng | guangzhou | g    |</span><br><span class="line">|  3 | xiaoming | NULL      | NULL |</span><br><span class="line">|  4 | adan     | tianhe    | NULL |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>好，终于搞定 <code>demo</code> 数据。</p>
<p>我们回到可变长字段的长度列表来看，就拿 <code>id = 2</code> 的数据来看吧：</p>
<p>因为在这个表中 <code>name</code> <code>addr</code> 都是可变长字段，<code>name</code> 的长度是 <code>8</code>，<code>addr</code> 的长度是 <code>9</code> 他们通过十六进制表示分别是：<code>0×08</code> <code>0×09</code> ，然后，可变长字段存储是逆序的，所有，存储在可变长字段列表里面的数据就是 <code>0908</code></p>
<p>这里有两个地方需要注意的是</p>
<ol>
<li>如果这个可变长的列，他的真实值是 <code>NULL</code>，则他不会被记录在此列表中，也就是说在 <code>id = 3</code> 的记录中，可变长字段的长度列表只需要记录 <code>name</code> 列的长度即可；</li>
<li>这个长度列表可能需要 <code>1字节</code> 也可能因为记录不下，而开辟了 <code>2字节</code> 的长度来记录，怎么说呢：</li>
</ol>
<p>我们知道 <code>1字节</code> 数的二进制是 <code>8</code> 位，然后，第一位像 <code>Protobuf</code> 一样用来记录后面还有没有位数，所以真实使用存储长度的是后 <code>7</code> 位。而 <code>7</code> 位最大能表示多大长度呢：</p>
<h2 id="一-InnoDB的表和数据-5"><a href="#一-InnoDB的表和数据-5" class="headerlink" title="一.InnoDB的表和数据"></a>一.InnoDB的表和数据</h2><p><code>InnoDB</code> 是怎样存储数据的，表是大概怎样的一种格式，表中的数据行又是怎样的一种格式。如果想要大概知道 <code>B+</code> 索引的执行过程，这块基本是跳不过去的。当然关于 <code>表</code> 和 <code>数据行</code> 的东西特别多，没办法涵盖所有，所以我只能将我学的，大概知道的重要部分取出来说一说。</p>
<p>这里先大概说下后面才说的 <code>索引</code> 问题，<code>B+索引</code> 其实利用了表中的 <code>行记录头</code>（可以想象是 <code>HTTP</code> 请求的请求头），然后进行数据结构组织实现快速检索的一种结构。所以不用说啦，<code>行记录头</code> 一些必要的属性，基本要知道的，也可以优化数据库的占用空间。</p>
<p><code>Innodb</code> 存储引擎表在创建的时候，如果没有显示定义主键（<code>Primary Key</code>），则会通过以下的规则创建主键：</p>
<ol>
<li>如果表中有非空的唯一索引，则该列为主键；</li>
<li>如果 <code>1</code> 不满足，则在你看不见的地方（行头）创建一个 <code>6</code> 字节大小的指针。</li>
</ol>
<p>我先从宏观的表空间进入，到段、区，到页，到行，那么这样看完行的时候，可以直接感受下一篇讲索引使用的行中的信息，也算是有一定的逻辑顺序吧。</p>
<p>他们的大致关系是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h2 id="二-表空间-5"><a href="#二-表空间-5" class="headerlink" title="二.表空间"></a>二.表空间</h2><h3 id="2-1-表的物理存储-5"><a href="#2-1-表的物理存储-5" class="headerlink" title="2.1 表的物理存储"></a>2.1 表的物理存储</h3><p><strong>数据、表、数据库文件</strong></p>
<p>至于要找到表结构的文件，我们至少需要先知道数据文件存在哪个地方，所以我们可以直接通过 <code>SQL</code> 语句进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;datadir&#39;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>OK，结果返回，我们的数据存储在 <code>/var/lib/mysql/</code> 中，所以我们现在进去瞅一瞅是什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql       20 9月  23 00:00 demo</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>为了能够继续说下去，我需要建立一些数据库以及表来做演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database innodb_study;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; use innodb_study;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table table_file_user (id int, name varchar(10));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>好了，创建了一个 <code>innodb_study</code> 的数据库以及一个 <code>table_file_user</code> 的表，现在我们重新来看看数据文件里面多了些什么东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:44 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 10月  9 22:44 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:42 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql       74 10月  9 22:44 innodb_study # 多了这个数据库文件夹</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>好了进去 <code>innodb_study</code> 瞅瞅有哪些东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# ll</span><br><span class="line">总用量 112</span><br><span class="line">-rw-r-----. 1 mysql mysql    65 10月  9 22:43 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql  8586 10月  9 22:44 table_file_user.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 98304 10月  9 22:44 table_file_user.ibd</span><br></pre></td></tr></table></figure>

<ol>
<li><code>db.opt</code> 猜一下，应该是数据库的设定，比如字符集啊，使用的存储引擎啊等等；</li>
<li><code>table_file_user.frm</code> 则是我创建的用户表的结构文件了；</li>
<li><code>table_file_user.ibd</code> 是 <code>InnoDB</code> 存储引擎的数据库文件；</li>
</ol>
<p>首先我们先来看看 <code>db.opt</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# cat db.opt</span><br><span class="line">default-character-set&#x3D;latin1</span><br><span class="line">default-collation&#x3D;latin1_swedish_ci</span><br></pre></td></tr></table></figure>

<p>可以看到，我刚刚在创建这个数据库的时候，一切用的是默认的，所以默认的字符集以及排序规则都是 <code>latin1</code> 相关的。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/latin1/1183590?fr=aladdin">latin1百科</a></p>
<p><code>table_file_user.frm</code> 则无法直接使用 <code>cat</code> 进行查看，需要通过  <a target="_blank" rel="noopener" href="https://pdf.us/2019/01/10/2620.html">MySQL管理工具集 MySQL Utilities</a> 的方式进行查看，不过在这里我就不演示了。</p>
<p><code>table_file_user.ibd</code> 则就是数据库文件了，存储的是数据库数据，后面再说。</p>
<p><strong>表空间设置参数</strong></p>
<p>针对 <code>table_file_user.ibd</code> 有个参数需要提一下 <code>innodb_file_per_table</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;innodb_file_per_table&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>什么意思咧，就是每个表的数据都存储在独立的表空间，<code>5.7</code> 以前默认是 <code>off</code> 的，后面的版本就默认开启了。如果是 <code>off</code> 的话，所有表的数据都会记录在一个文件里面。但是即使开启了独立表空间的参数，也只是记录表的数据、索引、插入缓冲等信息，其他的回滚日志还是会存储在公共的空间中的。</p>
<p><strong>定义表空间文件大小位置</strong></p>
<p>可以通过定义 <code>my.cnf</code> 中的配置，来定义存储的表空间文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path &#x3D; &#x2F;db&#x2F;ibdata1:2000M;&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>

<p>我们可以这样定义由两个文件组成表空间，后面的文件容量大小限定表示文件限制大小，而 <code>ibdata2</code> 增长到 <code>2000M</code> 的时候还可以自动增长。</p>
<h3 id="2-1-表的逻辑存储-5"><a href="#2-1-表的逻辑存储-5" class="headerlink" title="2.1 表的逻辑存储"></a>2.1 表的逻辑存储</h3><p>接下来简单说下上图中，表空间的下级几个东西：</p>
<p><strong>段</strong></p>
<p>表空间由很多个段组成，段又有数据段、索引段、回滚段等等。因为 <code>InnoDB</code> 存储数据本质上就是利用索引树进行存储的，所以数据段即是 <code>B+树</code> 的<code>叶节点</code>，而索引段即为<code>非叶子节点</code>。</p>
<p><strong>区</strong></p>
<p>每个区由 <code>64个页</code> 组成，每页大小 <code>16KB</code>，因此每个区是 <code>1MB</code>。针对需要插入大数据段的操作，<code>InnoDB</code> 每次至多申请 <code>4个区</code>。</p>
<p>我们启用 <code>innodb_file_per_table</code> 参数的时候，创建表的时候即段的开始，<code>InnoDB</code> 先使用 <code>32个页</code> 的碎片页来存放数据，当这些数据存储完了才会申请上面说的 <code>64个页</code>。</p>
<p>具体其他创建的时候怎么创建的细节，因为对我们使用数据库的时候帮助不是很大，这里就不再阐述（可以参考《MySQL技术内幕：InnoDB存储引擎》的 <code>4.2.3</code> 小节）</p>
<p><strong>页</strong></p>
<p>页太重要了，请允许我现在马上提取到大标题来讲！</p>
<p><strong>行</strong></p>
<p>行和页一样，太重要了，现在也一样马上提取到大标题来讲！</p>
<h2 id="三-InnoDB的数据页-5"><a href="#三-InnoDB的数据页-5" class="headerlink" title="三. InnoDB的数据页"></a>三. InnoDB的数据页</h2><p>页是 <code>MySQL InnoDB</code> 与服务器硬盘打交道的单位，当我们需要查询数据的时候，数据库每次至少加载 <code>一个页</code> 的数据到内存进行查找，而在前面说的刷新脏数据的时候，每次至少刷新 <code>一个页</code> 的数据，而页在 <code>区</code> 中说的，是 <code>16KB</code>。所以交互不会太小导致频繁 <code>IO</code> 也不会因为太大导致读取太慢。</p>
<p>页不仅有数据页，所有的页包含有：</p>
<ol>
<li>数据页（<code>B-tree Node</code>）；</li>
<li>Undo页（<code>Undo Log Page</code>）；</li>
<li>系统页（<code>System Page</code>）；</li>
<li>事务数据页（<code>Transaction system Page</code>）；</li>
<li>插入缓冲位图页（<code>Insert Buffer Bitmap</code>）；</li>
<li>插入缓冲空闲列表页（<code>Insert Buffer Free List</code>）；</li>
<li>未压缩的二进制大对象页（<code>Uncompress BLOB Page</code>）；</li>
<li>压缩的二进制大对象页（<code>Compressed BLOB Page</code>）。</li>
</ol>
<blockquote>
<p>第四节数据页的结构和第五节数据行的结构应该是并行了解，也就是两者共同构成搜索数据的基础，阅读建议是数据页格式先有个大概的概念，然后数据行，再两个并起来聊聊数据查询的内部原理.</p>
</blockquote>
<h2 id="四-数据页的结构-5"><a href="#四-数据页的结构-5" class="headerlink" title="四. 数据页的结构"></a>四. 数据页的结构</h2><p>这是一个页的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191120152749956"></p>
<p>OK，现在我们知道了，<code>InnoDB 数据页</code> 一共由 <code>7</code> 个部分组成。其中 <code>User Records 数据行</code> 存储的是我们用户的数据，他会按照 <code>Table</code> 指定的 <code>Row Format 行格式</code> 的规定进行存储。然而当一个页没有数据页格式的时候，是不存在 <code>User Records</code> 空间的，也就是说 <code>Free Space</code> 将会占领图中 <code>User Records</code> 那部分的空间。</p>
<p>好了，我们先摊开来每部分，大致的说一下是什么功能：</p>
<h3 id="4-1-FileHeader-文件头信息-5"><a href="#4-1-FileHeader-文件头信息-5" class="headerlink" title="4.1 FileHeader 文件头信息"></a>4.1 FileHeader 文件头信息</h3><p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
<p>在页头信息里面有个 <code>FILE_PAGE_TYPE</code>，它主要有以下几种类型：</p>
<ol>
<li><code>FILE_PAGE_INDEX</code> ：<code>B+树</code> 叶节点</li>
<li><code>FILE_PAGE_UNDO_LOG</code> ：<code>Undo Log</code> 页</li>
<li><code>FILE_PAGE_INODE</code> ：索引节点</li>
<li><code>FILE_PAGE_IBUF_FREE_LIST</code> ：<code>Insert Buffer</code> 空闲列表</li>
<li><code>FILE_PAGE_TYPE_ALLOCATED</code> ：最新分配的页</li>
<li><code>FILE_PAGE_BITMAP</code> ：<code>Insert Buffer</code> 位图</li>
<li><code>FILE_PAGE_SYS</code> ：系统页</li>
<li><code>FILE_PAGE_TRX_SYS</code> ：事务系统数据</li>
<li><code>FILE_PAGE_FSP_HDR</code> ：File Space Header</li>
<li><code>FILE_PAGE_XDES</code> ：拓展描述页</li>
<li><code>FILE_PAGE_BLOB</code> ：<code>BLOB</code> 页</li>
</ol>
<h3 id="4-2-PageHeader-页头信息-5"><a href="#4-2-PageHeader-页头信息-5" class="headerlink" title="4.2 PageHeader 页头信息"></a>4.2 PageHeader 页头信息</h3><p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
<h3 id="4-3-Infimum-和-Supremum-最值记录-5"><a href="#4-3-Infimum-和-Supremum-最值记录-5" class="headerlink" title="4.3 Infimum 和 Supremum 最值记录"></a>4.3 Infimum 和 Supremum 最值记录</h3><p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
<h3 id="4-4-User-Records-用户记录-和-Free-Space-空闲空间-5"><a href="#4-4-User-Records-用户记录-和-Free-Space-空闲空间-5" class="headerlink" title="4.4 User Records 用户记录 和 Free Space 空闲空间"></a>4.4 User Records 用户记录 和 Free Space 空闲空间</h3><p>这两个放在一起说是有原因的，因为一个空的页，是没有 <code>User Records</code> 的，全部都是 <code>Free Space</code>。慢慢的插入数据的时候，<code>User Records</code> 慢慢增大，<code>Free Space</code> 慢慢减小，直到这个页塞满了数据，就开启下一页。</p>
<p>想了想，弄个动图演示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h3 id="4-5-Page-Director-页目录-5"><a href="#4-5-Page-Director-页目录-5" class="headerlink" title="4.5 Page Director 页目录"></a>4.5 Page Director 页目录</h3><p>页目录 <code>Page Director</code> 存储了很多槽，用来存储最大最小记录的槽，<code>InnoDB</code> 就是通过这些槽来提高查询的速度的，下面会详细说。</p>
<h3 id="4-6-File-Trailer-页尾部-5"><a href="#4-6-File-Trailer-页尾部-5" class="headerlink" title="4.6 File Trailer 页尾部"></a>4.6 File Trailer 页尾部</h3><p>校验页数据用的地方，这个页有两个部分：</p>
<ol>
<li>页的校验和</li>
</ol>
<p>与 <code>FileHeader</code> 中的 <code>FILE_PAGE_SPACE_OR_CHKSUM</code> 值相对应，因为 <code>FileHeader</code> 在页的头部，被首先写入硬盘，当写入硬盘的过程中发现错误导致页不完整的时候，头部和尾部的值就会出现不相同的情况，这时候就需要根据日志来重新做这个页。</p>
<ol start="2">
<li>被最后修改时对应的日志序列位置（LSN）</li>
</ol>
<p>也是用来做校验的，后面会说到。</p>
<h2 id="五-数据行-5"><a href="#五-数据行-5" class="headerlink" title="五. 数据行"></a>五. 数据行</h2><p>我们知道了，一个数据页是 <code>16kb</code> 的大小，而数据页中有一个很重要的部分就是 <code>User Record</code> 区域就是用来存放我们的数据的地方。我们所插入的数据，<code>InnoDB</code> 会根据规则，转变成一定的 <code>行格式</code> 插入到数据页中去，行格式除了存储我们生产的数据以外，还存储着一些额外的信息，用于加快<strong>查数据</strong>的速度（当然删和改也都以来着查，新增也会以来查来确定主要的位置，所以查是一个数据库中至关重要的功能）。</p>
<p><code>MySQL</code> 发展到现在，已经有好几种 <code>数据行</code> 的格式了，分别有：<code>Compact</code> <code>Redundant</code> <code>Dynamic</code> 和 <code>Compressed</code>。</p>
<p><code>Redundant</code> 是为了解决与之前版本的兼容性问题而存在的，剩下的 <code>Dynamic</code> 和 <code>Compressed</code> 本质上是 <code>Compact</code> 格式，只不过在处理溢出页的时候不同，只要说了 <code>Compact</code> 就相当于说了三种，至于什么是溢出页，在下面会详细说到。</p>
<p>首先来看看 <code>Compact</code> 的数据行包含了什么鬼：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121094525787"></p>
<h3 id="5-1-额外信息-5"><a href="#5-1-额外信息-5" class="headerlink" title="5.1 额外信息"></a>5.1 额外信息</h3><p>这部分是 <code>InnoDB</code> 为了方便快速查找统计而新加进去的一些记录行额外信息，主要用来标记可变长字段的长度（比如 <code>varchar</code> 占用多长）、哪些定义可为 <code>NULL</code> 的列在这条记录中出现了 <code>NULL</code> 以及一部分有用的记录头信息。</p>
<p>接下来一个一个来看这些有什么作用，为了防止标题太多层级我直接使用跟这里一样的标题。</p>
<h3 id="5-1-1-可变长字段的长度列表-5"><a href="#5-1-1-可变长字段的长度列表-5" class="headerlink" title="5.1.1 可变长字段的长度列表"></a>5.1.1 可变长字段的长度列表</h3><p>在 <code>Compact</code> 中，把表定义的可变长字段，在当前数据行中所占用的实际长度，按照 <strong>逆序</strong> 存储他们当前的长度。</p>
<p>怎么说呢，举个例子来做吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_db(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  addr <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  sex <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>这个表包含一个主键、一个不为空的 <code>name</code>，一个可为空的 <code>addr</code>，还有一个不可变长可为空的 <code>sex</code>。字符集是 <code>ascii</code>（就是包含简单字母的那个），以及指定行格式是 <code>Compact</code>。</p>
<p>然后我插入 <code>5</code> 个数据来玩玩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_db (<span class="keyword">id</span>, <span class="keyword">name</span>, addr, sex)</span><br><span class="line">	<span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;goudan&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">	(<span class="number">2</span>, <span class="string">&#x27;gousheng&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>, <span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">	(<span class="number">3</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">	(<span class="number">4</span>, <span class="string">&#x27;adan&#x27;</span>, <span class="string">&#x27;tianhe&#x27;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM user_db;</span></span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">| id | name     | addr      | sex  |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">|  1 | goudan   | NULL      | b    |</span><br><span class="line">|  2 | gousheng | guangzhou | g    |</span><br><span class="line">|  3 | xiaoming | NULL      | NULL |</span><br><span class="line">|  4 | adan     | tianhe    | NULL |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>好，终于搞定 <code>demo</code> 数据。</p>
<p>我们回到可变长字段的长度列表来看，就拿 <code>id = 2</code> 的数据来看吧：</p>
<p>因为在这个表中 <code>name</code> <code>addr</code> 都是可变长字段，<code>name</code> 的长度是 <code>8</code>，<code>addr</code> 的长度是 <code>9</code> 他们通过十六进制表示分别是：<code>0×08</code> <code>0×09</code> ，然后，可变长字段存储是逆序的，所有，存储在可变长字段列表里面的数据就是 <code>0908</code></p>
<p>这里有两个地方需要注意的是</p>
<ol>
<li>如果这个可变长的列，他的真实值是 <code>NULL</code>，则他不会被记录在此列表中，也就是说在 <code>id = 3</code> 的记录中，可变长字段的长度列表只需要记录 <code>name</code> 列的长度即可；</li>
<li>这个长度列表可能需要 <code>1字节</code> 也可能因为记录不下，而开辟了 <code>2字节</code> 的长度来记录，怎么说呢：</li>
</ol>
<p>我们知道 <code>1字节</code> 数的二进制是 <code>8</code> 位，然后，第一位像 <code>Protobuf</code> 一样用来记录后面还有没有位数，所以真实使用存储长度的是后 <code>7</code> 位。而 <code>7</code> 位最大能表示多大长度呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121105157176"></p>
<p>所以，如果这个长度他需要记录 <strong>小于等于</strong> <code>127</code> 的长度的时候，使用 <code>1字节</code>，而如果记录的值 <strong>大于</strong> <code>127</code> 的时候则使用 <code>2字节</code>。<code>8位</code> 的第一位用来标记，我后面还有没有 <code>1字节</code> 来一起记录长度，如果是 <code>0</code> 则表示我当前字节已经记录完所有的了，如果是 <code>1</code> 则表示我后面的 <code>1字节</code> 也是用来记录长度的。而如果长度，他 <code>1字节 = 255</code> 可以存储完毕，则使用 <code>1字节</code>。</p>
<p>那怎么大概计算字段占用多少字节的长度呢：</p>
<p>因为上面的 <code>user_db</code> 使用的是 <code>ascii</code> 来做记录的，让我们用臭名远扬的 <code>utf-8</code> 来说，我们知道，<code>MySQL</code> 中的 <code>utf-8</code> 是个假的，他其实只使用了 <code>3字节</code> 一个字符的方法来存储。</p>
<p>我们假设这个表只有一个列(varchar(MAXLEN))，那如果字符串的最大字节占用长度 = <code>MAXLEN * 3</code>，则如果最大占用字节 <strong>小于等于</strong> <code>255</code> 的时候，使用一个字节来存储，如果他大于 <code>255</code> 则根据他是否 <strong>小于等于</strong> <code>127</code> 也就是 <code>127 / 3 = 42</code> 个字符来看，如果小于等于127，则使用 <code>1字节</code>，否则使用 <code>2字节</code>。好累，弄个伪代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 占用的最大字节数，LocalCharsetLeng是当前字符集的最大字节长度 */</span></span><br><span class="line"><span class="keyword">let</span> maxByteLeng = LocalCharsetLeng * MAXLEN;</span><br><span class="line"><span class="comment">/** 可变长字段列表的长度 */</span></span><br><span class="line"><span class="keyword">let</span> lengthOfVariableColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (maxByteLeng &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">  lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/** 她当前数据行存储的长度 */</span></span><br><span class="line">  <span class="keyword">let</span> lengthOfData = ...</span><br><span class="line">  <span class="keyword">let</span> byteLengthOfData = LocalCharsetLeng * lengthOfData;</span><br><span class="line">  <span class="keyword">if</span> (byteLengthOfData &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-NULL值列表-4"><a href="#5-1-2-NULL值列表-4" class="headerlink" title="5.1.2 NULL值列表"></a>5.1.2 NULL值列表</h3><p><code>NULL值列表</code> 也是按照列中可以为NULL的列逆序来排放的，直接上图更清晰：</p>
<p>我们加入要看 <code>id = 3</code> 的数据，他的 <code>addr</code> 和 <code>sex</code> 都为 <code>NULL</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121151849940"></p>
<p>所以从最后一位开始，对应列中第一个可以为 <code>NULL</code> 的列（被 <code>NOT NULL</code> 修饰的列），如果是 <code>NULL</code> 则为 <code>1</code> 否则为 <code>0</code>。</p>
<p>所以，<code>NULL</code> 值并不会占用存储空间。</p>
<h3 id="5-1-3-记录头信息-4"><a href="#5-1-3-记录头信息-4" class="headerlink" title="5.1.3 记录头信息"></a>5.1.3 记录头信息</h3><p>这个可就很重要，因为他是构成索引搜索条件的基础。</p>
<p>记录头有以下这些头部信息，共占用 <code>40字节</code> 不同的字节数作用都不相同：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>占位符1</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>占位符2</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>delete_flag</td>
<td>1</td>
<td>标记记录是否被删除（也就是我们开发常说的逻辑删除）</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000普通记录 001B+树节点指针 010Infimum<br/>011Supremum 1xx保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>页中玉东道下一条记录需要的偏移量</td>
</tr>
</tbody></table>
<p>OK一起说完真实记录再来看看怎么搜索数据的吧</p>
<h3 id="5-2-真实数据-4"><a href="#5-2-真实数据-4" class="headerlink" title="5.2 真实数据"></a>5.2 真实数据</h3><p>真实数据的存储，都是存储有效的数据，即如果某个值没有数据，则不做存储。那他怎么知道谁是有的谁是没的，这就需要结合上面可变长字段列表、NULL值列表以及下一条记录的偏移量来确定了。</p>
<p>其实真实数据中，<code>InnoDB</code> 还会在真实数据的头部增加两个列：<code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> 分别是事务的指针以及回滚的指针（用于重做？）。如果当前的表没有定义主键的话，那么 <code>InnoDB</code> 还会真实数据的头部增加 <code>ROW_ID</code> 这个隐藏列来作为主键（为啥一定要主键？后面索引会说说的）</p>
<p>所以记录应该是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114503.png"></p>
<h3 id="5-3-溢出页-4"><a href="#5-3-溢出页-4" class="headerlink" title="5.3 溢出页"></a>5.3 溢出页</h3><p>针对 <code>VARCHAR</code> 定义的数据列最多能存储多少个数据？一个记录最大能存储 <code>65535</code> 个字节的数据，但是并不是真的可以存储，因为在上面看来，还需要记录变长字段以及 <code>NULL值列表</code>，如果被 <code>NOT NULL</code> 修饰，则还可以节省 <code>1字节</code>，所以假设我这个表只有一个列的情况下分为下面两种情况：</p>
<ol>
<li>被 <code>NOT NULL</code> 修饰，存储 <code>65533</code> 个字节；</li>
<li>没有修饰，存储 <code>65532</code> 个字节。</li>
</ol>
<p>那如果存储的数据超出一个页 <code>16kb</code> 的定义怎么办，那就需要额外的溢出页来存储数据了。</p>
<p>但是 <code>Compact</code> 格式的数据有点纠结，如果占用的字节数小于 <code>768</code> 字节的时候，存储在本页，如果超出了，则该页依然会记录前 <code>768字节</code> 的数据，然后再使用 <code>20字节</code> 来存储溢出页的地址以及字节数大小。</p>
<p>而 <code>MySQL 5.7</code> 使用的 <code>InnoDB Plugin</code> 默认的格式 <code>Dynamic</code> 以及新增的 <code>Compress</code> 格式则不同，他们只在当前记录这里记录溢出页的位置，将所有的数据都放在溢出页里面，而 <code>Compress</code> 还会将溢出页进行压缩处理，减少存储空间。</p>
<h2 id="总结一下-4"><a href="#总结一下-4" class="headerlink" title="总结一下"></a>总结一下</h2><p>主要了解了表的逻辑存储、数据页、数据行的格式。不过不用太担心没记住，后面我都会重复这里的内容来说接下来的所有事情的，毕竟这里面的一堆属性都是为后面 <code>MySQL</code> 的功能做铺垫。</p>
<p>所以，如果这个长度他需要记录 <strong>小于等于</strong> <code>127</code> 的长度的时候，使用 <code>1字节</code>，而如果记录的值 <strong>大于</strong> <code>127</code> 的时候则使用 <code>2字节</code>。<code>8位</code> 的第一位用来标记，我后面还有没有 <code>1字节</code> 来一起记录长度，如果是 <code>0</code> 则表示我当前字节已经记录完所有的了，如果是 <code>1</code> 则表示我后面的 <code>1字节</code> 也是用来记录长度的。而如果长度，他 <code>1字节 = 255</code> 可以存储完毕，则使用 <code>1字节</code>。</p>
<p>那怎么大概计算字段占用多少字节的长度呢：</p>
<p>因为上面的 <code>user_db</code> 使用的是 <code>ascii</code> 来做记录的，让我们用臭名远扬的 <code>utf-8</code> 来说，我们知道，<code>MySQL</code> 中的 <code>utf-8</code> 是个假的，他其实只使用了 <code>3字节</code> 一个字符的方法来存储。</p>
<p>我们假设这个表只有一个列(varchar(MAXLEN))，那如果字符串的最大字节占用长度 = <code>MAXLEN * 3</code>，则如果最大占用字节 <strong>小于等于</strong> <code>255</code> 的时候，使用一个字节来存储，如果他大于 <code>255</code> 则根据他是否 <strong>小于等于</strong> <code>127</code> 也就是 <code>127 / 3 = 42</code> 个字符来看，如果小于等于127，则使用 <code>1字节</code>，否则使用 <code>2字节</code>。好累，弄个伪代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 占用的最大字节数，LocalCharsetLeng是当前字符集的最大字节长度 */</span></span><br><span class="line"><span class="keyword">let</span> maxByteLeng = LocalCharsetLeng * MAXLEN;</span><br><span class="line"><span class="comment">/** 可变长字段列表的长度 */</span></span><br><span class="line"><span class="keyword">let</span> lengthOfVariableColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (maxByteLeng &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">  lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/** 她当前数据行存储的长度 */</span></span><br><span class="line">  <span class="keyword">let</span> lengthOfData = ...</span><br><span class="line">  <span class="keyword">let</span> byteLengthOfData = LocalCharsetLeng * lengthOfData;</span><br><span class="line">  <span class="keyword">if</span> (byteLengthOfData &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-NULL值列表-5"><a href="#5-1-2-NULL值列表-5" class="headerlink" title="5.1.2 NULL值列表"></a>5.1.2 NULL值列表</h3><p><code>NULL值列表</code> 也是按照列中可以为NULL的列逆序来排放的，直接上图更清晰：</p>
<p>我们加入要看 <code>id = 3</code> 的数据，他的 <code>addr</code> 和 <code>sex</code> 都为 <code>NULL</code>。</p>
<h2 id="一-InnoDB的表和数据-6"><a href="#一-InnoDB的表和数据-6" class="headerlink" title="一.InnoDB的表和数据"></a>一.InnoDB的表和数据</h2><p><code>InnoDB</code> 是怎样存储数据的，表是大概怎样的一种格式，表中的数据行又是怎样的一种格式。如果想要大概知道 <code>B+</code> 索引的执行过程，这块基本是跳不过去的。当然关于 <code>表</code> 和 <code>数据行</code> 的东西特别多，没办法涵盖所有，所以我只能将我学的，大概知道的重要部分取出来说一说。</p>
<p>这里先大概说下后面才说的 <code>索引</code> 问题，<code>B+索引</code> 其实利用了表中的 <code>行记录头</code>（可以想象是 <code>HTTP</code> 请求的请求头），然后进行数据结构组织实现快速检索的一种结构。所以不用说啦，<code>行记录头</code> 一些必要的属性，基本要知道的，也可以优化数据库的占用空间。</p>
<p><code>Innodb</code> 存储引擎表在创建的时候，如果没有显示定义主键（<code>Primary Key</code>），则会通过以下的规则创建主键：</p>
<ol>
<li>如果表中有非空的唯一索引，则该列为主键；</li>
<li>如果 <code>1</code> 不满足，则在你看不见的地方（行头）创建一个 <code>6</code> 字节大小的指针。</li>
</ol>
<p>我先从宏观的表空间进入，到段、区，到页，到行，那么这样看完行的时候，可以直接感受下一篇讲索引使用的行中的信息，也算是有一定的逻辑顺序吧。</p>
<p>他们的大致关系是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h2 id="二-表空间-6"><a href="#二-表空间-6" class="headerlink" title="二.表空间"></a>二.表空间</h2><h3 id="2-1-表的物理存储-6"><a href="#2-1-表的物理存储-6" class="headerlink" title="2.1 表的物理存储"></a>2.1 表的物理存储</h3><p><strong>数据、表、数据库文件</strong></p>
<p>至于要找到表结构的文件，我们至少需要先知道数据文件存在哪个地方，所以我们可以直接通过 <code>SQL</code> 语句进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;datadir&#39;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>OK，结果返回，我们的数据存储在 <code>/var/lib/mysql/</code> 中，所以我们现在进去瞅一瞅是什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql       20 9月  23 00:00 demo</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>为了能够继续说下去，我需要建立一些数据库以及表来做演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database innodb_study;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; use innodb_study;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table table_file_user (id int, name varchar(10));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>好了，创建了一个 <code>innodb_study</code> 的数据库以及一个 <code>table_file_user</code> 的表，现在我们重新来看看数据文件里面多了些什么东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:44 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 10月  9 22:44 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:42 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql       74 10月  9 22:44 innodb_study # 多了这个数据库文件夹</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>好了进去 <code>innodb_study</code> 瞅瞅有哪些东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# ll</span><br><span class="line">总用量 112</span><br><span class="line">-rw-r-----. 1 mysql mysql    65 10月  9 22:43 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql  8586 10月  9 22:44 table_file_user.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 98304 10月  9 22:44 table_file_user.ibd</span><br></pre></td></tr></table></figure>

<ol>
<li><code>db.opt</code> 猜一下，应该是数据库的设定，比如字符集啊，使用的存储引擎啊等等；</li>
<li><code>table_file_user.frm</code> 则是我创建的用户表的结构文件了；</li>
<li><code>table_file_user.ibd</code> 是 <code>InnoDB</code> 存储引擎的数据库文件；</li>
</ol>
<p>首先我们先来看看 <code>db.opt</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# cat db.opt</span><br><span class="line">default-character-set&#x3D;latin1</span><br><span class="line">default-collation&#x3D;latin1_swedish_ci</span><br></pre></td></tr></table></figure>

<p>可以看到，我刚刚在创建这个数据库的时候，一切用的是默认的，所以默认的字符集以及排序规则都是 <code>latin1</code> 相关的。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/latin1/1183590?fr=aladdin">latin1百科</a></p>
<p><code>table_file_user.frm</code> 则无法直接使用 <code>cat</code> 进行查看，需要通过  <a target="_blank" rel="noopener" href="https://pdf.us/2019/01/10/2620.html">MySQL管理工具集 MySQL Utilities</a> 的方式进行查看，不过在这里我就不演示了。</p>
<p><code>table_file_user.ibd</code> 则就是数据库文件了，存储的是数据库数据，后面再说。</p>
<p><strong>表空间设置参数</strong></p>
<p>针对 <code>table_file_user.ibd</code> 有个参数需要提一下 <code>innodb_file_per_table</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;innodb_file_per_table&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>什么意思咧，就是每个表的数据都存储在独立的表空间，<code>5.7</code> 以前默认是 <code>off</code> 的，后面的版本就默认开启了。如果是 <code>off</code> 的话，所有表的数据都会记录在一个文件里面。但是即使开启了独立表空间的参数，也只是记录表的数据、索引、插入缓冲等信息，其他的回滚日志还是会存储在公共的空间中的。</p>
<p><strong>定义表空间文件大小位置</strong></p>
<p>可以通过定义 <code>my.cnf</code> 中的配置，来定义存储的表空间文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path &#x3D; &#x2F;db&#x2F;ibdata1:2000M;&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>

<p>我们可以这样定义由两个文件组成表空间，后面的文件容量大小限定表示文件限制大小，而 <code>ibdata2</code> 增长到 <code>2000M</code> 的时候还可以自动增长。</p>
<h3 id="2-1-表的逻辑存储-6"><a href="#2-1-表的逻辑存储-6" class="headerlink" title="2.1 表的逻辑存储"></a>2.1 表的逻辑存储</h3><p>接下来简单说下上图中，表空间的下级几个东西：</p>
<p><strong>段</strong></p>
<p>表空间由很多个段组成，段又有数据段、索引段、回滚段等等。因为 <code>InnoDB</code> 存储数据本质上就是利用索引树进行存储的，所以数据段即是 <code>B+树</code> 的<code>叶节点</code>，而索引段即为<code>非叶子节点</code>。</p>
<p><strong>区</strong></p>
<p>每个区由 <code>64个页</code> 组成，每页大小 <code>16KB</code>，因此每个区是 <code>1MB</code>。针对需要插入大数据段的操作，<code>InnoDB</code> 每次至多申请 <code>4个区</code>。</p>
<p>我们启用 <code>innodb_file_per_table</code> 参数的时候，创建表的时候即段的开始，<code>InnoDB</code> 先使用 <code>32个页</code> 的碎片页来存放数据，当这些数据存储完了才会申请上面说的 <code>64个页</code>。</p>
<p>具体其他创建的时候怎么创建的细节，因为对我们使用数据库的时候帮助不是很大，这里就不再阐述（可以参考《MySQL技术内幕：InnoDB存储引擎》的 <code>4.2.3</code> 小节）</p>
<p><strong>页</strong></p>
<p>页太重要了，请允许我现在马上提取到大标题来讲！</p>
<p><strong>行</strong></p>
<p>行和页一样，太重要了，现在也一样马上提取到大标题来讲！</p>
<h2 id="三-InnoDB的数据页-6"><a href="#三-InnoDB的数据页-6" class="headerlink" title="三. InnoDB的数据页"></a>三. InnoDB的数据页</h2><p>页是 <code>MySQL InnoDB</code> 与服务器硬盘打交道的单位，当我们需要查询数据的时候，数据库每次至少加载 <code>一个页</code> 的数据到内存进行查找，而在前面说的刷新脏数据的时候，每次至少刷新 <code>一个页</code> 的数据，而页在 <code>区</code> 中说的，是 <code>16KB</code>。所以交互不会太小导致频繁 <code>IO</code> 也不会因为太大导致读取太慢。</p>
<p>页不仅有数据页，所有的页包含有：</p>
<ol>
<li>数据页（<code>B-tree Node</code>）；</li>
<li>Undo页（<code>Undo Log Page</code>）；</li>
<li>系统页（<code>System Page</code>）；</li>
<li>事务数据页（<code>Transaction system Page</code>）；</li>
<li>插入缓冲位图页（<code>Insert Buffer Bitmap</code>）；</li>
<li>插入缓冲空闲列表页（<code>Insert Buffer Free List</code>）；</li>
<li>未压缩的二进制大对象页（<code>Uncompress BLOB Page</code>）；</li>
<li>压缩的二进制大对象页（<code>Compressed BLOB Page</code>）。</li>
</ol>
<blockquote>
<p>第四节数据页的结构和第五节数据行的结构应该是并行了解，也就是两者共同构成搜索数据的基础，阅读建议是数据页格式先有个大概的概念，然后数据行，再两个并起来聊聊数据查询的内部原理.</p>
</blockquote>
<h2 id="四-数据页的结构-6"><a href="#四-数据页的结构-6" class="headerlink" title="四. 数据页的结构"></a>四. 数据页的结构</h2><p>这是一个页的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191120152749956"></p>
<p>OK，现在我们知道了，<code>InnoDB 数据页</code> 一共由 <code>7</code> 个部分组成。其中 <code>User Records 数据行</code> 存储的是我们用户的数据，他会按照 <code>Table</code> 指定的 <code>Row Format 行格式</code> 的规定进行存储。然而当一个页没有数据页格式的时候，是不存在 <code>User Records</code> 空间的，也就是说 <code>Free Space</code> 将会占领图中 <code>User Records</code> 那部分的空间。</p>
<p>好了，我们先摊开来每部分，大致的说一下是什么功能：</p>
<h3 id="4-1-FileHeader-文件头信息-6"><a href="#4-1-FileHeader-文件头信息-6" class="headerlink" title="4.1 FileHeader 文件头信息"></a>4.1 FileHeader 文件头信息</h3><p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
<p>在页头信息里面有个 <code>FILE_PAGE_TYPE</code>，它主要有以下几种类型：</p>
<ol>
<li><code>FILE_PAGE_INDEX</code> ：<code>B+树</code> 叶节点</li>
<li><code>FILE_PAGE_UNDO_LOG</code> ：<code>Undo Log</code> 页</li>
<li><code>FILE_PAGE_INODE</code> ：索引节点</li>
<li><code>FILE_PAGE_IBUF_FREE_LIST</code> ：<code>Insert Buffer</code> 空闲列表</li>
<li><code>FILE_PAGE_TYPE_ALLOCATED</code> ：最新分配的页</li>
<li><code>FILE_PAGE_BITMAP</code> ：<code>Insert Buffer</code> 位图</li>
<li><code>FILE_PAGE_SYS</code> ：系统页</li>
<li><code>FILE_PAGE_TRX_SYS</code> ：事务系统数据</li>
<li><code>FILE_PAGE_FSP_HDR</code> ：File Space Header</li>
<li><code>FILE_PAGE_XDES</code> ：拓展描述页</li>
<li><code>FILE_PAGE_BLOB</code> ：<code>BLOB</code> 页</li>
</ol>
<h3 id="4-2-PageHeader-页头信息-6"><a href="#4-2-PageHeader-页头信息-6" class="headerlink" title="4.2 PageHeader 页头信息"></a>4.2 PageHeader 页头信息</h3><p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
<h3 id="4-3-Infimum-和-Supremum-最值记录-6"><a href="#4-3-Infimum-和-Supremum-最值记录-6" class="headerlink" title="4.3 Infimum 和 Supremum 最值记录"></a>4.3 Infimum 和 Supremum 最值记录</h3><p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
<h3 id="4-4-User-Records-用户记录-和-Free-Space-空闲空间-6"><a href="#4-4-User-Records-用户记录-和-Free-Space-空闲空间-6" class="headerlink" title="4.4 User Records 用户记录 和 Free Space 空闲空间"></a>4.4 User Records 用户记录 和 Free Space 空闲空间</h3><p>这两个放在一起说是有原因的，因为一个空的页，是没有 <code>User Records</code> 的，全部都是 <code>Free Space</code>。慢慢的插入数据的时候，<code>User Records</code> 慢慢增大，<code>Free Space</code> 慢慢减小，直到这个页塞满了数据，就开启下一页。</p>
<p>想了想，弄个动图演示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h3 id="4-5-Page-Director-页目录-6"><a href="#4-5-Page-Director-页目录-6" class="headerlink" title="4.5 Page Director 页目录"></a>4.5 Page Director 页目录</h3><p>页目录 <code>Page Director</code> 存储了很多槽，用来存储最大最小记录的槽，<code>InnoDB</code> 就是通过这些槽来提高查询的速度的，下面会详细说。</p>
<h3 id="4-6-File-Trailer-页尾部-6"><a href="#4-6-File-Trailer-页尾部-6" class="headerlink" title="4.6 File Trailer 页尾部"></a>4.6 File Trailer 页尾部</h3><p>校验页数据用的地方，这个页有两个部分：</p>
<ol>
<li>页的校验和</li>
</ol>
<p>与 <code>FileHeader</code> 中的 <code>FILE_PAGE_SPACE_OR_CHKSUM</code> 值相对应，因为 <code>FileHeader</code> 在页的头部，被首先写入硬盘，当写入硬盘的过程中发现错误导致页不完整的时候，头部和尾部的值就会出现不相同的情况，这时候就需要根据日志来重新做这个页。</p>
<ol start="2">
<li>被最后修改时对应的日志序列位置（LSN）</li>
</ol>
<p>也是用来做校验的，后面会说到。</p>
<h2 id="五-数据行-6"><a href="#五-数据行-6" class="headerlink" title="五. 数据行"></a>五. 数据行</h2><p>我们知道了，一个数据页是 <code>16kb</code> 的大小，而数据页中有一个很重要的部分就是 <code>User Record</code> 区域就是用来存放我们的数据的地方。我们所插入的数据，<code>InnoDB</code> 会根据规则，转变成一定的 <code>行格式</code> 插入到数据页中去，行格式除了存储我们生产的数据以外，还存储着一些额外的信息，用于加快<strong>查数据</strong>的速度（当然删和改也都以来着查，新增也会以来查来确定主要的位置，所以查是一个数据库中至关重要的功能）。</p>
<p><code>MySQL</code> 发展到现在，已经有好几种 <code>数据行</code> 的格式了，分别有：<code>Compact</code> <code>Redundant</code> <code>Dynamic</code> 和 <code>Compressed</code>。</p>
<p><code>Redundant</code> 是为了解决与之前版本的兼容性问题而存在的，剩下的 <code>Dynamic</code> 和 <code>Compressed</code> 本质上是 <code>Compact</code> 格式，只不过在处理溢出页的时候不同，只要说了 <code>Compact</code> 就相当于说了三种，至于什么是溢出页，在下面会详细说到。</p>
<p>首先来看看 <code>Compact</code> 的数据行包含了什么鬼：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121094525787"></p>
<h3 id="5-1-额外信息-6"><a href="#5-1-额外信息-6" class="headerlink" title="5.1 额外信息"></a>5.1 额外信息</h3><p>这部分是 <code>InnoDB</code> 为了方便快速查找统计而新加进去的一些记录行额外信息，主要用来标记可变长字段的长度（比如 <code>varchar</code> 占用多长）、哪些定义可为 <code>NULL</code> 的列在这条记录中出现了 <code>NULL</code> 以及一部分有用的记录头信息。</p>
<p>接下来一个一个来看这些有什么作用，为了防止标题太多层级我直接使用跟这里一样的标题。</p>
<h3 id="5-1-1-可变长字段的长度列表-6"><a href="#5-1-1-可变长字段的长度列表-6" class="headerlink" title="5.1.1 可变长字段的长度列表"></a>5.1.1 可变长字段的长度列表</h3><p>在 <code>Compact</code> 中，把表定义的可变长字段，在当前数据行中所占用的实际长度，按照 <strong>逆序</strong> 存储他们当前的长度。</p>
<p>怎么说呢，举个例子来做吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_db(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  addr <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  sex <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>这个表包含一个主键、一个不为空的 <code>name</code>，一个可为空的 <code>addr</code>，还有一个不可变长可为空的 <code>sex</code>。字符集是 <code>ascii</code>（就是包含简单字母的那个），以及指定行格式是 <code>Compact</code>。</p>
<p>然后我插入 <code>5</code> 个数据来玩玩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_db (<span class="keyword">id</span>, <span class="keyword">name</span>, addr, sex)</span><br><span class="line">	<span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;goudan&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">	(<span class="number">2</span>, <span class="string">&#x27;gousheng&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>, <span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">	(<span class="number">3</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">	(<span class="number">4</span>, <span class="string">&#x27;adan&#x27;</span>, <span class="string">&#x27;tianhe&#x27;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM user_db;</span></span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">| id | name     | addr      | sex  |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">|  1 | goudan   | NULL      | b    |</span><br><span class="line">|  2 | gousheng | guangzhou | g    |</span><br><span class="line">|  3 | xiaoming | NULL      | NULL |</span><br><span class="line">|  4 | adan     | tianhe    | NULL |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>好，终于搞定 <code>demo</code> 数据。</p>
<p>我们回到可变长字段的长度列表来看，就拿 <code>id = 2</code> 的数据来看吧：</p>
<p>因为在这个表中 <code>name</code> <code>addr</code> 都是可变长字段，<code>name</code> 的长度是 <code>8</code>，<code>addr</code> 的长度是 <code>9</code> 他们通过十六进制表示分别是：<code>0×08</code> <code>0×09</code> ，然后，可变长字段存储是逆序的，所有，存储在可变长字段列表里面的数据就是 <code>0908</code></p>
<p>这里有两个地方需要注意的是</p>
<ol>
<li>如果这个可变长的列，他的真实值是 <code>NULL</code>，则他不会被记录在此列表中，也就是说在 <code>id = 3</code> 的记录中，可变长字段的长度列表只需要记录 <code>name</code> 列的长度即可；</li>
<li>这个长度列表可能需要 <code>1字节</code> 也可能因为记录不下，而开辟了 <code>2字节</code> 的长度来记录，怎么说呢：</li>
</ol>
<p>我们知道 <code>1字节</code> 数的二进制是 <code>8</code> 位，然后，第一位像 <code>Protobuf</code> 一样用来记录后面还有没有位数，所以真实使用存储长度的是后 <code>7</code> 位。而 <code>7</code> 位最大能表示多大长度呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121105157176"></p>
<p>所以，如果这个长度他需要记录 <strong>小于等于</strong> <code>127</code> 的长度的时候，使用 <code>1字节</code>，而如果记录的值 <strong>大于</strong> <code>127</code> 的时候则使用 <code>2字节</code>。<code>8位</code> 的第一位用来标记，我后面还有没有 <code>1字节</code> 来一起记录长度，如果是 <code>0</code> 则表示我当前字节已经记录完所有的了，如果是 <code>1</code> 则表示我后面的 <code>1字节</code> 也是用来记录长度的。而如果长度，他 <code>1字节 = 255</code> 可以存储完毕，则使用 <code>1字节</code>。</p>
<p>那怎么大概计算字段占用多少字节的长度呢：</p>
<p>因为上面的 <code>user_db</code> 使用的是 <code>ascii</code> 来做记录的，让我们用臭名远扬的 <code>utf-8</code> 来说，我们知道，<code>MySQL</code> 中的 <code>utf-8</code> 是个假的，他其实只使用了 <code>3字节</code> 一个字符的方法来存储。</p>
<p>我们假设这个表只有一个列(varchar(MAXLEN))，那如果字符串的最大字节占用长度 = <code>MAXLEN * 3</code>，则如果最大占用字节 <strong>小于等于</strong> <code>255</code> 的时候，使用一个字节来存储，如果他大于 <code>255</code> 则根据他是否 <strong>小于等于</strong> <code>127</code> 也就是 <code>127 / 3 = 42</code> 个字符来看，如果小于等于127，则使用 <code>1字节</code>，否则使用 <code>2字节</code>。好累，弄个伪代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 占用的最大字节数，LocalCharsetLeng是当前字符集的最大字节长度 */</span></span><br><span class="line"><span class="keyword">let</span> maxByteLeng = LocalCharsetLeng * MAXLEN;</span><br><span class="line"><span class="comment">/** 可变长字段列表的长度 */</span></span><br><span class="line"><span class="keyword">let</span> lengthOfVariableColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (maxByteLeng &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">  lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/** 她当前数据行存储的长度 */</span></span><br><span class="line">  <span class="keyword">let</span> lengthOfData = ...</span><br><span class="line">  <span class="keyword">let</span> byteLengthOfData = LocalCharsetLeng * lengthOfData;</span><br><span class="line">  <span class="keyword">if</span> (byteLengthOfData &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-NULL值列表-6"><a href="#5-1-2-NULL值列表-6" class="headerlink" title="5.1.2 NULL值列表"></a>5.1.2 NULL值列表</h3><p><code>NULL值列表</code> 也是按照列中可以为NULL的列逆序来排放的，直接上图更清晰：</p>
<p>我们加入要看 <code>id = 3</code> 的数据，他的 <code>addr</code> 和 <code>sex</code> 都为 <code>NULL</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121151849940"></p>
<p>所以从最后一位开始，对应列中第一个可以为 <code>NULL</code> 的列（被 <code>NOT NULL</code> 修饰的列），如果是 <code>NULL</code> 则为 <code>1</code> 否则为 <code>0</code>。</p>
<p>所以，<code>NULL</code> 值并不会占用存储空间。</p>
<h3 id="5-1-3-记录头信息-5"><a href="#5-1-3-记录头信息-5" class="headerlink" title="5.1.3 记录头信息"></a>5.1.3 记录头信息</h3><p>这个可就很重要，因为他是构成索引搜索条件的基础。</p>
<p>记录头有以下这些头部信息，共占用 <code>40字节</code> 不同的字节数作用都不相同：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>占位符1</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>占位符2</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>delete_flag</td>
<td>1</td>
<td>标记记录是否被删除（也就是我们开发常说的逻辑删除）</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000普通记录 001B+树节点指针 010Infimum<br/>011Supremum 1xx保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>页中玉东道下一条记录需要的偏移量</td>
</tr>
</tbody></table>
<p>OK一起说完真实记录再来看看怎么搜索数据的吧</p>
<h3 id="5-2-真实数据-5"><a href="#5-2-真实数据-5" class="headerlink" title="5.2 真实数据"></a>5.2 真实数据</h3><p>真实数据的存储，都是存储有效的数据，即如果某个值没有数据，则不做存储。那他怎么知道谁是有的谁是没的，这就需要结合上面可变长字段列表、NULL值列表以及下一条记录的偏移量来确定了。</p>
<p>其实真实数据中，<code>InnoDB</code> 还会在真实数据的头部增加两个列：<code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> 分别是事务的指针以及回滚的指针（用于重做？）。如果当前的表没有定义主键的话，那么 <code>InnoDB</code> 还会真实数据的头部增加 <code>ROW_ID</code> 这个隐藏列来作为主键（为啥一定要主键？后面索引会说说的）</p>
<p>所以记录应该是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114503.png"></p>
<h3 id="5-3-溢出页-5"><a href="#5-3-溢出页-5" class="headerlink" title="5.3 溢出页"></a>5.3 溢出页</h3><p>针对 <code>VARCHAR</code> 定义的数据列最多能存储多少个数据？一个记录最大能存储 <code>65535</code> 个字节的数据，但是并不是真的可以存储，因为在上面看来，还需要记录变长字段以及 <code>NULL值列表</code>，如果被 <code>NOT NULL</code> 修饰，则还可以节省 <code>1字节</code>，所以假设我这个表只有一个列的情况下分为下面两种情况：</p>
<ol>
<li>被 <code>NOT NULL</code> 修饰，存储 <code>65533</code> 个字节；</li>
<li>没有修饰，存储 <code>65532</code> 个字节。</li>
</ol>
<p>那如果存储的数据超出一个页 <code>16kb</code> 的定义怎么办，那就需要额外的溢出页来存储数据了。</p>
<p>但是 <code>Compact</code> 格式的数据有点纠结，如果占用的字节数小于 <code>768</code> 字节的时候，存储在本页，如果超出了，则该页依然会记录前 <code>768字节</code> 的数据，然后再使用 <code>20字节</code> 来存储溢出页的地址以及字节数大小。</p>
<p>而 <code>MySQL 5.7</code> 使用的 <code>InnoDB Plugin</code> 默认的格式 <code>Dynamic</code> 以及新增的 <code>Compress</code> 格式则不同，他们只在当前记录这里记录溢出页的位置，将所有的数据都放在溢出页里面，而 <code>Compress</code> 还会将溢出页进行压缩处理，减少存储空间。</p>
<h2 id="总结一下-5"><a href="#总结一下-5" class="headerlink" title="总结一下"></a>总结一下</h2><p>主要了解了表的逻辑存储、数据页、数据行的格式。不过不用太担心没记住，后面我都会重复这里的内容来说接下来的所有事情的，毕竟这里面的一堆属性都是为后面 <code>MySQL</code> 的功能做铺垫。</p>
<p>所以从最后一位开始，对应列中第一个可以为 <code>NULL</code> 的列（被 <code>NOT NULL</code> 修饰的列），如果是 <code>NULL</code> 则为 <code>1</code> 否则为 <code>0</code>。</p>
<p>所以，<code>NULL</code> 值并不会占用存储空间。</p>
<h3 id="5-1-3-记录头信息-6"><a href="#5-1-3-记录头信息-6" class="headerlink" title="5.1.3 记录头信息"></a>5.1.3 记录头信息</h3><p>这个可就很重要，因为他是构成索引搜索条件的基础。</p>
<p>记录头有以下这些头部信息，共占用 <code>40字节</code> 不同的字节数作用都不相同：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>占位符1</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>占位符2</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>delete_flag</td>
<td>1</td>
<td>标记记录是否被删除（也就是我们开发常说的逻辑删除）</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000普通记录 001B+树节点指针 010Infimum<br/>011Supremum 1xx保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>页中玉东道下一条记录需要的偏移量</td>
</tr>
</tbody></table>
<p>OK一起说完真实记录再来看看怎么搜索数据的吧</p>
<h3 id="5-2-真实数据-6"><a href="#5-2-真实数据-6" class="headerlink" title="5.2 真实数据"></a>5.2 真实数据</h3><p>真实数据的存储，都是存储有效的数据，即如果某个值没有数据，则不做存储。那他怎么知道谁是有的谁是没的，这就需要结合上面可变长字段列表、NULL值列表以及下一条记录的偏移量来确定了。</p>
<p>其实真实数据中，<code>InnoDB</code> 还会在真实数据的头部增加两个列：<code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> 分别是事务的指针以及回滚的指针（用于重做？）。如果当前的表没有定义主键的话，那么 <code>InnoDB</code> 还会真实数据的头部增加 <code>ROW_ID</code> 这个隐藏列来作为主键（为啥一定要主键？后面索引会说说的）</p>
<p>所以记录应该是这样的：</p>
<h2 id="一-InnoDB的表和数据-7"><a href="#一-InnoDB的表和数据-7" class="headerlink" title="一.InnoDB的表和数据"></a>一.InnoDB的表和数据</h2><p><code>InnoDB</code> 是怎样存储数据的，表是大概怎样的一种格式，表中的数据行又是怎样的一种格式。如果想要大概知道 <code>B+</code> 索引的执行过程，这块基本是跳不过去的。当然关于 <code>表</code> 和 <code>数据行</code> 的东西特别多，没办法涵盖所有，所以我只能将我学的，大概知道的重要部分取出来说一说。</p>
<p>这里先大概说下后面才说的 <code>索引</code> 问题，<code>B+索引</code> 其实利用了表中的 <code>行记录头</code>（可以想象是 <code>HTTP</code> 请求的请求头），然后进行数据结构组织实现快速检索的一种结构。所以不用说啦，<code>行记录头</code> 一些必要的属性，基本要知道的，也可以优化数据库的占用空间。</p>
<p><code>Innodb</code> 存储引擎表在创建的时候，如果没有显示定义主键（<code>Primary Key</code>），则会通过以下的规则创建主键：</p>
<ol>
<li>如果表中有非空的唯一索引，则该列为主键；</li>
<li>如果 <code>1</code> 不满足，则在你看不见的地方（行头）创建一个 <code>6</code> 字节大小的指针。</li>
</ol>
<p>我先从宏观的表空间进入，到段、区，到页，到行，那么这样看完行的时候，可以直接感受下一篇讲索引使用的行中的信息，也算是有一定的逻辑顺序吧。</p>
<p>他们的大致关系是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h2 id="二-表空间-7"><a href="#二-表空间-7" class="headerlink" title="二.表空间"></a>二.表空间</h2><h3 id="2-1-表的物理存储-7"><a href="#2-1-表的物理存储-7" class="headerlink" title="2.1 表的物理存储"></a>2.1 表的物理存储</h3><p><strong>数据、表、数据库文件</strong></p>
<p>至于要找到表结构的文件，我们至少需要先知道数据文件存在哪个地方，所以我们可以直接通过 <code>SQL</code> 语句进行查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;datadir&#39;;</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>OK，结果返回，我们的数据存储在 <code>/var/lib/mysql/</code> 中，所以我们现在进去瞅一瞅是什么东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</span><br><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql       20 9月  23 00:00 demo</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 9月  22 23:54 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>为了能够继续说下去，我需要建立一些数据库以及表来做演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database innodb_study;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">mysql&gt; use innodb_study;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; create table table_file_user (id int, name varchar(10));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>好了，创建了一个 <code>innodb_study</code> 的数据库以及一个 <code>table_file_user</code> 的表，现在我们重新来看看数据文件里面多了些什么东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# ll</span><br><span class="line">总用量 122952</span><br><span class="line">-rw-r-----. 1 mysql mysql       56 9月  22 23:54 auto.cnf</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 ca-key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 ca.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 client-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1679 9月  22 23:54 client-key.pem</span><br><span class="line">-rw-r-----. 1 mysql mysql      424 9月  22 23:54 ib_buffer_pool</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:44 ibdata1</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 10月  9 22:44 ib_logfile0</span><br><span class="line">-rw-r-----. 1 mysql mysql 50331648 9月  22 23:54 ib_logfile1</span><br><span class="line">-rw-r-----. 1 mysql mysql 12582912 10月  9 22:42 ibtmp1</span><br><span class="line">drwxr-x---. 2 mysql mysql       74 10月  9 22:44 innodb_study # 多了这个数据库文件夹</span><br><span class="line">drwxr-x---. 2 mysql mysql     4096 9月  22 23:54 mysql</span><br><span class="line">srwxrwxrwx. 1 mysql mysql        0 9月  22 23:54 mysql.sock</span><br><span class="line">-rw-------. 1 mysql mysql        5 9月  22 23:54 mysql.sock.lock</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 performance_schema</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 private_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql      451 9月  22 23:54 public_key.pem</span><br><span class="line">-rw-r--r--. 1 mysql mysql     1107 9月  22 23:54 server-cert.pem</span><br><span class="line">-rw-------. 1 mysql mysql     1675 9月  22 23:54 server-key.pem</span><br><span class="line">drwxr-x---. 2 mysql mysql     8192 9月  22 23:54 sys</span><br></pre></td></tr></table></figure>

<p>好了进去 <code>innodb_study</code> 瞅瞅有哪些东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# ll</span><br><span class="line">总用量 112</span><br><span class="line">-rw-r-----. 1 mysql mysql    65 10月  9 22:43 db.opt</span><br><span class="line">-rw-r-----. 1 mysql mysql  8586 10月  9 22:44 table_file_user.frm</span><br><span class="line">-rw-r-----. 1 mysql mysql 98304 10月  9 22:44 table_file_user.ibd</span><br></pre></td></tr></table></figure>

<ol>
<li><code>db.opt</code> 猜一下，应该是数据库的设定，比如字符集啊，使用的存储引擎啊等等；</li>
<li><code>table_file_user.frm</code> 则是我创建的用户表的结构文件了；</li>
<li><code>table_file_user.ibd</code> 是 <code>InnoDB</code> 存储引擎的数据库文件；</li>
</ol>
<p>首先我们先来看看 <code>db.opt</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost innodb_study]# cat db.opt</span><br><span class="line">default-character-set&#x3D;latin1</span><br><span class="line">default-collation&#x3D;latin1_swedish_ci</span><br></pre></td></tr></table></figure>

<p>可以看到，我刚刚在创建这个数据库的时候，一切用的是默认的，所以默认的字符集以及排序规则都是 <code>latin1</code> 相关的。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/latin1/1183590?fr=aladdin">latin1百科</a></p>
<p><code>table_file_user.frm</code> 则无法直接使用 <code>cat</code> 进行查看，需要通过  <a target="_blank" rel="noopener" href="https://pdf.us/2019/01/10/2620.html">MySQL管理工具集 MySQL Utilities</a> 的方式进行查看，不过在这里我就不演示了。</p>
<p><code>table_file_user.ibd</code> 则就是数据库文件了，存储的是数据库数据，后面再说。</p>
<p><strong>表空间设置参数</strong></p>
<p>针对 <code>table_file_user.ibd</code> 有个参数需要提一下 <code>innodb_file_per_table</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW variables like &#39;innodb_file_per_table&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: innodb_file_per_table</span><br><span class="line">        Value: ON</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>什么意思咧，就是每个表的数据都存储在独立的表空间，<code>5.7</code> 以前默认是 <code>off</code> 的，后面的版本就默认开启了。如果是 <code>off</code> 的话，所有表的数据都会记录在一个文件里面。但是即使开启了独立表空间的参数，也只是记录表的数据、索引、插入缓冲等信息，其他的回滚日志还是会存储在公共的空间中的。</p>
<p><strong>定义表空间文件大小位置</strong></p>
<p>可以通过定义 <code>my.cnf</code> 中的配置，来定义存储的表空间文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_data_file_path &#x3D; &#x2F;db&#x2F;ibdata1:2000M;&#x2F;db&#x2F;ibdata2:2000M:autoextend</span><br></pre></td></tr></table></figure>

<p>我们可以这样定义由两个文件组成表空间，后面的文件容量大小限定表示文件限制大小，而 <code>ibdata2</code> 增长到 <code>2000M</code> 的时候还可以自动增长。</p>
<h3 id="2-1-表的逻辑存储-7"><a href="#2-1-表的逻辑存储-7" class="headerlink" title="2.1 表的逻辑存储"></a>2.1 表的逻辑存储</h3><p>接下来简单说下上图中，表空间的下级几个东西：</p>
<p><strong>段</strong></p>
<p>表空间由很多个段组成，段又有数据段、索引段、回滚段等等。因为 <code>InnoDB</code> 存储数据本质上就是利用索引树进行存储的，所以数据段即是 <code>B+树</code> 的<code>叶节点</code>，而索引段即为<code>非叶子节点</code>。</p>
<p><strong>区</strong></p>
<p>每个区由 <code>64个页</code> 组成，每页大小 <code>16KB</code>，因此每个区是 <code>1MB</code>。针对需要插入大数据段的操作，<code>InnoDB</code> 每次至多申请 <code>4个区</code>。</p>
<p>我们启用 <code>innodb_file_per_table</code> 参数的时候，创建表的时候即段的开始，<code>InnoDB</code> 先使用 <code>32个页</code> 的碎片页来存放数据，当这些数据存储完了才会申请上面说的 <code>64个页</code>。</p>
<p>具体其他创建的时候怎么创建的细节，因为对我们使用数据库的时候帮助不是很大，这里就不再阐述（可以参考《MySQL技术内幕：InnoDB存储引擎》的 <code>4.2.3</code> 小节）</p>
<p><strong>页</strong></p>
<p>页太重要了，请允许我现在马上提取到大标题来讲！</p>
<p><strong>行</strong></p>
<p>行和页一样，太重要了，现在也一样马上提取到大标题来讲！</p>
<h2 id="三-InnoDB的数据页-7"><a href="#三-InnoDB的数据页-7" class="headerlink" title="三. InnoDB的数据页"></a>三. InnoDB的数据页</h2><p>页是 <code>MySQL InnoDB</code> 与服务器硬盘打交道的单位，当我们需要查询数据的时候，数据库每次至少加载 <code>一个页</code> 的数据到内存进行查找，而在前面说的刷新脏数据的时候，每次至少刷新 <code>一个页</code> 的数据，而页在 <code>区</code> 中说的，是 <code>16KB</code>。所以交互不会太小导致频繁 <code>IO</code> 也不会因为太大导致读取太慢。</p>
<p>页不仅有数据页，所有的页包含有：</p>
<ol>
<li>数据页（<code>B-tree Node</code>）；</li>
<li>Undo页（<code>Undo Log Page</code>）；</li>
<li>系统页（<code>System Page</code>）；</li>
<li>事务数据页（<code>Transaction system Page</code>）；</li>
<li>插入缓冲位图页（<code>Insert Buffer Bitmap</code>）；</li>
<li>插入缓冲空闲列表页（<code>Insert Buffer Free List</code>）；</li>
<li>未压缩的二进制大对象页（<code>Uncompress BLOB Page</code>）；</li>
<li>压缩的二进制大对象页（<code>Compressed BLOB Page</code>）。</li>
</ol>
<blockquote>
<p>第四节数据页的结构和第五节数据行的结构应该是并行了解，也就是两者共同构成搜索数据的基础，阅读建议是数据页格式先有个大概的概念，然后数据行，再两个并起来聊聊数据查询的内部原理.</p>
</blockquote>
<h2 id="四-数据页的结构-7"><a href="#四-数据页的结构-7" class="headerlink" title="四. 数据页的结构"></a>四. 数据页的结构</h2><p>这是一个页的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191120152749956"></p>
<p>OK，现在我们知道了，<code>InnoDB 数据页</code> 一共由 <code>7</code> 个部分组成。其中 <code>User Records 数据行</code> 存储的是我们用户的数据，他会按照 <code>Table</code> 指定的 <code>Row Format 行格式</code> 的规定进行存储。然而当一个页没有数据页格式的时候，是不存在 <code>User Records</code> 空间的，也就是说 <code>Free Space</code> 将会占领图中 <code>User Records</code> 那部分的空间。</p>
<p>好了，我们先摊开来每部分，大致的说一下是什么功能：</p>
<h3 id="4-1-FileHeader-文件头信息-7"><a href="#4-1-FileHeader-文件头信息-7" class="headerlink" title="4.1 FileHeader 文件头信息"></a>4.1 FileHeader 文件头信息</h3><p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
<p>在页头信息里面有个 <code>FILE_PAGE_TYPE</code>，它主要有以下几种类型：</p>
<ol>
<li><code>FILE_PAGE_INDEX</code> ：<code>B+树</code> 叶节点</li>
<li><code>FILE_PAGE_UNDO_LOG</code> ：<code>Undo Log</code> 页</li>
<li><code>FILE_PAGE_INODE</code> ：索引节点</li>
<li><code>FILE_PAGE_IBUF_FREE_LIST</code> ：<code>Insert Buffer</code> 空闲列表</li>
<li><code>FILE_PAGE_TYPE_ALLOCATED</code> ：最新分配的页</li>
<li><code>FILE_PAGE_BITMAP</code> ：<code>Insert Buffer</code> 位图</li>
<li><code>FILE_PAGE_SYS</code> ：系统页</li>
<li><code>FILE_PAGE_TRX_SYS</code> ：事务系统数据</li>
<li><code>FILE_PAGE_FSP_HDR</code> ：File Space Header</li>
<li><code>FILE_PAGE_XDES</code> ：拓展描述页</li>
<li><code>FILE_PAGE_BLOB</code> ：<code>BLOB</code> 页</li>
</ol>
<h3 id="4-2-PageHeader-页头信息-7"><a href="#4-2-PageHeader-页头信息-7" class="headerlink" title="4.2 PageHeader 页头信息"></a>4.2 PageHeader 页头信息</h3><p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
<h3 id="4-3-Infimum-和-Supremum-最值记录-7"><a href="#4-3-Infimum-和-Supremum-最值记录-7" class="headerlink" title="4.3 Infimum 和 Supremum 最值记录"></a>4.3 Infimum 和 Supremum 最值记录</h3><p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
<h3 id="4-4-User-Records-用户记录-和-Free-Space-空闲空间-7"><a href="#4-4-User-Records-用户记录-和-Free-Space-空闲空间-7" class="headerlink" title="4.4 User Records 用户记录 和 Free Space 空闲空间"></a>4.4 User Records 用户记录 和 Free Space 空闲空间</h3><p>这两个放在一起说是有原因的，因为一个空的页，是没有 <code>User Records</code> 的，全部都是 <code>Free Space</code>。慢慢的插入数据的时候，<code>User Records</code> 慢慢增大，<code>Free Space</code> 慢慢减小，直到这个页塞满了数据，就开启下一页。</p>
<p>想了想，弄个动图演示一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png"></p>
<h3 id="4-5-Page-Director-页目录-7"><a href="#4-5-Page-Director-页目录-7" class="headerlink" title="4.5 Page Director 页目录"></a>4.5 Page Director 页目录</h3><p>页目录 <code>Page Director</code> 存储了很多槽，用来存储最大最小记录的槽，<code>InnoDB</code> 就是通过这些槽来提高查询的速度的，下面会详细说。</p>
<h3 id="4-6-File-Trailer-页尾部-7"><a href="#4-6-File-Trailer-页尾部-7" class="headerlink" title="4.6 File Trailer 页尾部"></a>4.6 File Trailer 页尾部</h3><p>校验页数据用的地方，这个页有两个部分：</p>
<ol>
<li>页的校验和</li>
</ol>
<p>与 <code>FileHeader</code> 中的 <code>FILE_PAGE_SPACE_OR_CHKSUM</code> 值相对应，因为 <code>FileHeader</code> 在页的头部，被首先写入硬盘，当写入硬盘的过程中发现错误导致页不完整的时候，头部和尾部的值就会出现不相同的情况，这时候就需要根据日志来重新做这个页。</p>
<ol start="2">
<li>被最后修改时对应的日志序列位置（LSN）</li>
</ol>
<p>也是用来做校验的，后面会说到。</p>
<h2 id="五-数据行-7"><a href="#五-数据行-7" class="headerlink" title="五. 数据行"></a>五. 数据行</h2><p>我们知道了，一个数据页是 <code>16kb</code> 的大小，而数据页中有一个很重要的部分就是 <code>User Record</code> 区域就是用来存放我们的数据的地方。我们所插入的数据，<code>InnoDB</code> 会根据规则，转变成一定的 <code>行格式</code> 插入到数据页中去，行格式除了存储我们生产的数据以外，还存储着一些额外的信息，用于加快<strong>查数据</strong>的速度（当然删和改也都以来着查，新增也会以来查来确定主要的位置，所以查是一个数据库中至关重要的功能）。</p>
<p><code>MySQL</code> 发展到现在，已经有好几种 <code>数据行</code> 的格式了，分别有：<code>Compact</code> <code>Redundant</code> <code>Dynamic</code> 和 <code>Compressed</code>。</p>
<p><code>Redundant</code> 是为了解决与之前版本的兼容性问题而存在的，剩下的 <code>Dynamic</code> 和 <code>Compressed</code> 本质上是 <code>Compact</code> 格式，只不过在处理溢出页的时候不同，只要说了 <code>Compact</code> 就相当于说了三种，至于什么是溢出页，在下面会详细说到。</p>
<p>首先来看看 <code>Compact</code> 的数据行包含了什么鬼：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121094525787"></p>
<h3 id="5-1-额外信息-7"><a href="#5-1-额外信息-7" class="headerlink" title="5.1 额外信息"></a>5.1 额外信息</h3><p>这部分是 <code>InnoDB</code> 为了方便快速查找统计而新加进去的一些记录行额外信息，主要用来标记可变长字段的长度（比如 <code>varchar</code> 占用多长）、哪些定义可为 <code>NULL</code> 的列在这条记录中出现了 <code>NULL</code> 以及一部分有用的记录头信息。</p>
<p>接下来一个一个来看这些有什么作用，为了防止标题太多层级我直接使用跟这里一样的标题。</p>
<h3 id="5-1-1-可变长字段的长度列表-7"><a href="#5-1-1-可变长字段的长度列表-7" class="headerlink" title="5.1.1 可变长字段的长度列表"></a>5.1.1 可变长字段的长度列表</h3><p>在 <code>Compact</code> 中，把表定义的可变长字段，在当前数据行中所占用的实际长度，按照 <strong>逆序</strong> 存储他们当前的长度。</p>
<p>怎么说呢，举个例子来做吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_db(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  addr <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">  sex <span class="built_in">char</span>(<span class="number">1</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">COMPACT</span>;</span><br></pre></td></tr></table></figure>

<p>这个表包含一个主键、一个不为空的 <code>name</code>，一个可为空的 <code>addr</code>，还有一个不可变长可为空的 <code>sex</code>。字符集是 <code>ascii</code>（就是包含简单字母的那个），以及指定行格式是 <code>Compact</code>。</p>
<p>然后我插入 <code>5</code> 个数据来玩玩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_db (<span class="keyword">id</span>, <span class="keyword">name</span>, addr, sex)</span><br><span class="line">	<span class="keyword">values</span>(<span class="number">1</span>, <span class="string">&#x27;goudan&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">	(<span class="number">2</span>, <span class="string">&#x27;gousheng&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>, <span class="string">&#x27;g&#x27;</span>),</span><br><span class="line">	(<span class="number">3</span>, <span class="string">&#x27;xiaoming&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>),</span><br><span class="line">	(<span class="number">4</span>, <span class="string">&#x27;adan&#x27;</span>, <span class="string">&#x27;tianhe&#x27;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM user_db;</span></span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">| id | name     | addr      | sex  |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">|  1 | goudan   | NULL      | b    |</span><br><span class="line">|  2 | gousheng | guangzhou | g    |</span><br><span class="line">|  3 | xiaoming | NULL      | NULL |</span><br><span class="line">|  4 | adan     | tianhe    | NULL |</span><br><span class="line">+----+----------+-----------+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>好，终于搞定 <code>demo</code> 数据。</p>
<p>我们回到可变长字段的长度列表来看，就拿 <code>id = 2</code> 的数据来看吧：</p>
<p>因为在这个表中 <code>name</code> <code>addr</code> 都是可变长字段，<code>name</code> 的长度是 <code>8</code>，<code>addr</code> 的长度是 <code>9</code> 他们通过十六进制表示分别是：<code>0×08</code> <code>0×09</code> ，然后，可变长字段存储是逆序的，所有，存储在可变长字段列表里面的数据就是 <code>0908</code></p>
<p>这里有两个地方需要注意的是</p>
<ol>
<li>如果这个可变长的列，他的真实值是 <code>NULL</code>，则他不会被记录在此列表中，也就是说在 <code>id = 3</code> 的记录中，可变长字段的长度列表只需要记录 <code>name</code> 列的长度即可；</li>
<li>这个长度列表可能需要 <code>1字节</code> 也可能因为记录不下，而开辟了 <code>2字节</code> 的长度来记录，怎么说呢：</li>
</ol>
<p>我们知道 <code>1字节</code> 数的二进制是 <code>8</code> 位，然后，第一位像 <code>Protobuf</code> 一样用来记录后面还有没有位数，所以真实使用存储长度的是后 <code>7</code> 位。而 <code>7</code> 位最大能表示多大长度呢：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121105157176"></p>
<p>所以，如果这个长度他需要记录 <strong>小于等于</strong> <code>127</code> 的长度的时候，使用 <code>1字节</code>，而如果记录的值 <strong>大于</strong> <code>127</code> 的时候则使用 <code>2字节</code>。<code>8位</code> 的第一位用来标记，我后面还有没有 <code>1字节</code> 来一起记录长度，如果是 <code>0</code> 则表示我当前字节已经记录完所有的了，如果是 <code>1</code> 则表示我后面的 <code>1字节</code> 也是用来记录长度的。而如果长度，他 <code>1字节 = 255</code> 可以存储完毕，则使用 <code>1字节</code>。</p>
<p>那怎么大概计算字段占用多少字节的长度呢：</p>
<p>因为上面的 <code>user_db</code> 使用的是 <code>ascii</code> 来做记录的，让我们用臭名远扬的 <code>utf-8</code> 来说，我们知道，<code>MySQL</code> 中的 <code>utf-8</code> 是个假的，他其实只使用了 <code>3字节</code> 一个字符的方法来存储。</p>
<p>我们假设这个表只有一个列(varchar(MAXLEN))，那如果字符串的最大字节占用长度 = <code>MAXLEN * 3</code>，则如果最大占用字节 <strong>小于等于</strong> <code>255</code> 的时候，使用一个字节来存储，如果他大于 <code>255</code> 则根据他是否 <strong>小于等于</strong> <code>127</code> 也就是 <code>127 / 3 = 42</code> 个字符来看，如果小于等于127，则使用 <code>1字节</code>，否则使用 <code>2字节</code>。好累，弄个伪代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 占用的最大字节数，LocalCharsetLeng是当前字符集的最大字节长度 */</span></span><br><span class="line"><span class="keyword">let</span> maxByteLeng = LocalCharsetLeng * MAXLEN;</span><br><span class="line"><span class="comment">/** 可变长字段列表的长度 */</span></span><br><span class="line"><span class="keyword">let</span> lengthOfVariableColumn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (maxByteLeng &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">  lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/** 她当前数据行存储的长度 */</span></span><br><span class="line">  <span class="keyword">let</span> lengthOfData = ...</span><br><span class="line">  <span class="keyword">let</span> byteLengthOfData = LocalCharsetLeng * lengthOfData;</span><br><span class="line">  <span class="keyword">if</span> (byteLengthOfData &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lengthOfVariableColumn = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-NULL值列表-7"><a href="#5-1-2-NULL值列表-7" class="headerlink" title="5.1.2 NULL值列表"></a>5.1.2 NULL值列表</h3><p><code>NULL值列表</code> 也是按照列中可以为NULL的列逆序来排放的，直接上图更清晰：</p>
<p>我们加入要看 <code>id = 3</code> 的数据，他的 <code>addr</code> 和 <code>sex</code> 都为 <code>NULL</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114421.png" alt="image-20191121151849940"></p>
<p>所以从最后一位开始，对应列中第一个可以为 <code>NULL</code> 的列（被 <code>NOT NULL</code> 修饰的列），如果是 <code>NULL</code> 则为 <code>1</code> 否则为 <code>0</code>。</p>
<p>所以，<code>NULL</code> 值并不会占用存储空间。</p>
<h3 id="5-1-3-记录头信息-7"><a href="#5-1-3-记录头信息-7" class="headerlink" title="5.1.3 记录头信息"></a>5.1.3 记录头信息</h3><p>这个可就很重要，因为他是构成索引搜索条件的基础。</p>
<p>记录头有以下这些头部信息，共占用 <code>40字节</code> 不同的字节数作用都不相同：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>占位符1</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>占位符2</td>
<td>1</td>
<td>无作用</td>
</tr>
<tr>
<td>delete_flag</td>
<td>1</td>
<td>标记记录是否被删除（也就是我们开发常说的逻辑删除）</td>
</tr>
<tr>
<td>min_rec_flag</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>该记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>索引堆中该条记录的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>记录类型：000普通记录 001B+树节点指针 010Infimum<br/>011Supremum 1xx保留</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>页中玉东道下一条记录需要的偏移量</td>
</tr>
</tbody></table>
<p>OK一起说完真实记录再来看看怎么搜索数据的吧</p>
<h3 id="5-2-真实数据-7"><a href="#5-2-真实数据-7" class="headerlink" title="5.2 真实数据"></a>5.2 真实数据</h3><p>真实数据的存储，都是存储有效的数据，即如果某个值没有数据，则不做存储。那他怎么知道谁是有的谁是没的，这就需要结合上面可变长字段列表、NULL值列表以及下一条记录的偏移量来确定了。</p>
<p>其实真实数据中，<code>InnoDB</code> 还会在真实数据的头部增加两个列：<code>DB_TRX_ID</code> <code>DB_ROLL_PTR</code> 分别是事务的指针以及回滚的指针（用于重做？）。如果当前的表没有定义主键的话，那么 <code>InnoDB</code> 还会真实数据的头部增加 <code>ROW_ID</code> 这个隐藏列来作为主键（为啥一定要主键？后面索引会说说的）</p>
<p>所以记录应该是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114503.png"></p>
<h3 id="5-3-溢出页-6"><a href="#5-3-溢出页-6" class="headerlink" title="5.3 溢出页"></a>5.3 溢出页</h3><p>针对 <code>VARCHAR</code> 定义的数据列最多能存储多少个数据？一个记录最大能存储 <code>65535</code> 个字节的数据，但是并不是真的可以存储，因为在上面看来，还需要记录变长字段以及 <code>NULL值列表</code>，如果被 <code>NOT NULL</code> 修饰，则还可以节省 <code>1字节</code>，所以假设我这个表只有一个列的情况下分为下面两种情况：</p>
<ol>
<li>被 <code>NOT NULL</code> 修饰，存储 <code>65533</code> 个字节；</li>
<li>没有修饰，存储 <code>65532</code> 个字节。</li>
</ol>
<p>那如果存储的数据超出一个页 <code>16kb</code> 的定义怎么办，那就需要额外的溢出页来存储数据了。</p>
<p>但是 <code>Compact</code> 格式的数据有点纠结，如果占用的字节数小于 <code>768</code> 字节的时候，存储在本页，如果超出了，则该页依然会记录前 <code>768字节</code> 的数据，然后再使用 <code>20字节</code> 来存储溢出页的地址以及字节数大小。</p>
<p>而 <code>MySQL 5.7</code> 使用的 <code>InnoDB Plugin</code> 默认的格式 <code>Dynamic</code> 以及新增的 <code>Compress</code> 格式则不同，他们只在当前记录这里记录溢出页的位置，将所有的数据都放在溢出页里面，而 <code>Compress</code> 还会将溢出页进行压缩处理，减少存储空间。</p>
<h2 id="总结一下-6"><a href="#总结一下-6" class="headerlink" title="总结一下"></a>总结一下</h2><p>主要了解了表的逻辑存储、数据页、数据行的格式。不过不用太担心没记住，后面我都会重复这里的内容来说接下来的所有事情的，毕竟这里面的一堆属性都是为后面 <code>MySQL</code> 的功能做铺垫。</p>
<h3 id="5-3-溢出页-7"><a href="#5-3-溢出页-7" class="headerlink" title="5.3 溢出页"></a>5.3 溢出页</h3><p>针对 <code>VARCHAR</code> 定义的数据列最多能存储多少个数据？一个记录最大能存储 <code>65535</code> 个字节的数据，但是并不是真的可以存储，因为在上面看来，还需要记录变长字段以及 <code>NULL值列表</code>，如果被 <code>NOT NULL</code> 修饰，则还可以节省 <code>1字节</code>，所以假设我这个表只有一个列的情况下分为下面两种情况：</p>
<ol>
<li>被 <code>NOT NULL</code> 修饰，存储 <code>65533</code> 个字节；</li>
<li>没有修饰，存储 <code>65532</code> 个字节。</li>
</ol>
<p>那如果存储的数据超出一个页 <code>16kb</code> 的定义怎么办，那就需要额外的溢出页来存储数据了。</p>
<p>但是 <code>Compact</code> 格式的数据有点纠结，如果占用的字节数小于 <code>768</code> 字节的时候，存储在本页，如果超出了，则该页依然会记录前 <code>768字节</code> 的数据，然后再使用 <code>20字节</code> 来存储溢出页的地址以及字节数大小。</p>
<p>而 <code>MySQL 5.7</code> 使用的 <code>InnoDB Plugin</code> 默认的格式 <code>Dynamic</code> 以及新增的 <code>Compress</code> 格式则不同，他们只在当前记录这里记录溢出页的位置，将所有的数据都放在溢出页里面，而 <code>Compress</code> 还会将溢出页进行压缩处理，减少存储空间。</p>
<h2 id="总结一下-7"><a href="#总结一下-7" class="headerlink" title="总结一下"></a>总结一下</h2><p>主要了解了表的逻辑存储、数据页、数据行的格式。不过不用太担心没记住，后面我都会重复这里的内容来说接下来的所有事情的，毕竟这里面的一堆属性都是为后面 <code>MySQL</code> 的功能做铺垫。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%BA%8C-innodb%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%BA%8C-innodb%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">【聊聊MySQL】二. InnoDB体系结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-05 16:09:51" itemprop="dateCreated datePublished" datetime="2019-09-05T16:09:51+08:00">2019-09-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 11:35:31" itemprop="dateModified" datetime="2020-11-10T11:35:31+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-InnoDB存储引擎"><a href="#一-InnoDB存储引擎" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li>支持完整 <code>ACID</code> 事务；</li>
<li>行锁设计，可提高并发；</li>
<li>支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li>支持外键；</li>
<li>优秀的 <code>B+</code> 索引。</li>
</ol>
<h2 id="二-InnoDB体系架构"><a href="#二-InnoDB体系架构" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2><h2 id="一-InnoDB存储引擎-1"><a href="#一-InnoDB存储引擎-1" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li>支持完整 <code>ACID</code> 事务；</li>
<li>行锁设计，可提高并发；</li>
<li>支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li>支持外键；</li>
<li>优秀的 <code>B+</code> 索引。</li>
</ol>
<h2 id="二-InnoDB体系架构-1"><a href="#二-InnoDB体系架构-1" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg"> <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程"><a href="#2-1-后台线程" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li><code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li><code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li>…</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;99, Main thread ID&#x3D;123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存使用"><a href="#2-2-内存使用" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li>缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li>重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li>额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.64 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113500.png"></p>
<h2 id="三-一个一直在循环的主线程"><a href="#三-一个一直在循环的主线程" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情"><a href="#3-1-每一秒做的事情" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个来看看吧：</p>
<ol>
<li>刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li>合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li>刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务"><a href="#3-2-每十秒做的任务" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程"><a href="#3-3-后台活动线程" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程"><a href="#3-4-5-7Innodb的后台线程" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write"><a href="#四-Double-Write" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113519.png"></p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_dblwr%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 1865308</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 248718</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure>

<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引"><a href="#五-自适应哈希索引" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">691</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">112</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">307</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">481</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">463</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">281</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">410</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> <span class="keyword">hash</span> searches/s, <span class="number">42.04</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置"><a href="#六-MySQL-InnoDB启动关闭行为的配置" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown"><a href="#6-1-innodb-fast-shutdown" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery"><a href="#6-2-innodb-force-recovery" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。 <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程-1"><a href="#2-1-后台线程-1" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li><code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li><code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li>…</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;99, Main thread ID&#x3D;123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存使用-1"><a href="#2-2-内存使用-1" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li>缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li>重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li>额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.64 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 </p>
<h2 id="一-InnoDB存储引擎-2"><a href="#一-InnoDB存储引擎-2" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li>支持完整 <code>ACID</code> 事务；</li>
<li>行锁设计，可提高并发；</li>
<li>支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li>支持外键；</li>
<li>优秀的 <code>B+</code> 索引。</li>
</ol>
<h2 id="二-InnoDB体系架构-2"><a href="#二-InnoDB体系架构-2" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg"> <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程-2"><a href="#2-1-后台线程-2" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li><code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li><code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li>…</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;99, Main thread ID&#x3D;123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存使用-2"><a href="#2-2-内存使用-2" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li>缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li>重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li>额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.64 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113500.png"></p>
<h2 id="三-一个一直在循环的主线程-1"><a href="#三-一个一直在循环的主线程-1" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情-1"><a href="#3-1-每一秒做的事情-1" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个来看看吧：</p>
<ol>
<li>刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li>合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li>刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务-1"><a href="#3-2-每十秒做的任务-1" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程-1"><a href="#3-3-后台活动线程-1" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程-1"><a href="#3-4-5-7Innodb的后台线程-1" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write-1"><a href="#四-Double-Write-1" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113519.png"></p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_dblwr%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 1865308</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 248718</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure>

<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引-1"><a href="#五-自适应哈希索引-1" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">691</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">112</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">307</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">481</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">463</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">281</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">410</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> <span class="keyword">hash</span> searches/s, <span class="number">42.04</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置-1"><a href="#六-MySQL-InnoDB启动关闭行为的配置-1" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown-1"><a href="#6-1-innodb-fast-shutdown-1" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery-1"><a href="#6-2-innodb-force-recovery-1" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结-1"><a href="#五-总结-1" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。</p>
<h2 id="三-一个一直在循环的主线程-2"><a href="#三-一个一直在循环的主线程-2" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情-2"><a href="#3-1-每一秒做的事情-2" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个来看看吧：</p>
<ol>
<li>刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li>合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li>刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务-2"><a href="#3-2-每十秒做的任务-2" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程-2"><a href="#3-3-后台活动线程-2" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程-2"><a href="#3-4-5-7Innodb的后台线程-2" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write-2"><a href="#四-Double-Write-2" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 </p>
<h2 id="一-InnoDB存储引擎-3"><a href="#一-InnoDB存储引擎-3" class="headerlink" title="一.InnoDB存储引擎"></a>一.InnoDB存储引擎</h2><p>自从 <code>InnoDB</code> 被 <code>Heikki Tuuri</code> 发明出来以后，可以说安装 <code>MySQL</code> 肯定默认的引擎就是设置 <code>InnoDB</code>，因为其功能强大，实用性强，基本很多业务需求不要太过纠结的话都可以使用 <code>InnoDB</code> 进行存储（当然现在看来，当你的表不需要事务的时候可以使用 <code>MyISAM</code> 来进行存储）。 <code>InnoDB</code> 相比其他的存储引擎，拥有以下几个特点：</p>
<ol>
<li>支持完整 <code>ACID</code> 事务；</li>
<li>行锁设计，可提高并发；</li>
<li>支持 <code>MVCC</code> 可以说是数据行的版本控制，利用他来避免 <code>幻读</code> 的产生；</li>
<li>支持外键；</li>
<li>优秀的 <code>B+</code> 索引。</li>
</ol>
<h2 id="二-InnoDB体系架构-3"><a href="#二-InnoDB体系架构-3" class="headerlink" title="二.InnoDB体系架构"></a>二.InnoDB体系架构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113448.jpeg"> <code>InnoDB</code> 维护了类似于上图的一个内存块，内存块中存在一些线程，负责维护数据结构、缓存数据、刷写数据、<code>redo log</code> 等等。保证读取数据的快速，以及保证缓存数据的准确性。当数据库异常退出时还保证数据库能够恢复正常运行状态。</p>
<h3 id="2-1-后台线程-3"><a href="#2-1-后台线程-3" class="headerlink" title="2.1 后台线程"></a>2.1 后台线程</h3><p><code>MySQL</code> 默认拥有一些后台线程，来做一些事情：</p>
<ol>
<li><code>10</code> 个 <code>IO Thread</code>：（<code>8</code> 个读写线程、<code>1</code> 个 <code>insert buffer thread</code>、<code>1</code> 个 <code>log thread</code>）</li>
<li><code>1</code> 个 <code>Master Thread</code>：执行必要的操作</li>
<li>…</li>
</ol>
<p>我们可以通过 <code>show engine innodb status\G;</code> 来获取后台线程的一些状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name:</span><br><span class="line">Status:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2019-08-31 16:16:34 0x70000adcf000 INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Per second averages calculated from the last 59 seconds</span><br><span class="line">-----------------</span><br><span class="line">BACKGROUND THREAD 【后台线程的执行情况】</span><br><span class="line">-----------------</span><br><span class="line">srv_master_thread loops: 1 srv_active, 0 srv_shutdown, 58089 srv_idle</span><br><span class="line">srv_master_thread log flush and writes: 58083</span><br><span class="line">----------</span><br><span class="line">SEMAPHORES</span><br><span class="line">【这一块描述有多少线程在等待（自旋），以及大概需要等待锁的时间。</span><br><span class="line">大量线程可能在等待硬盘IO或者连接，】</span><br><span class="line">----------</span><br><span class="line">OS WAIT ARRAY INFO: reservation count 1</span><br><span class="line">OS WAIT ARRAY INFO: signal count 1</span><br><span class="line">RW-shared spins 0, rounds 3, OS waits 1</span><br><span class="line">RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">RW-sx spins 0, rounds 0, OS waits 0</span><br><span class="line">Spin rounds per wait: 3.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS【应用发生锁争抢情况】</span><br><span class="line">------------</span><br><span class="line">Trx id counter 3331</span><br><span class="line">Purge done for trx&#39;s n:o &lt; 0 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 281479450789680, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">--------</span><br><span class="line">FILE I&#x2F;O</span><br><span class="line">【FileIO 线程】</span><br><span class="line">--------</span><br><span class="line">I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread)</span><br><span class="line">I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread)</span><br><span class="line">I&#x2F;O thread 2 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 3 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 4 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 5 state: waiting for i&#x2F;o request (read thread)</span><br><span class="line">I&#x2F;O thread 6 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">I&#x2F;O thread 9 state: waiting for i&#x2F;o request (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"> ibuf aio reads:, log i&#x2F;o&#39;s:, sync i&#x2F;o&#39;s:</span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">242 OS file reads, 53 OS file writes, 7 OS fsyncs</span><br><span class="line">0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s</span><br><span class="line">-------------------------------------</span><br><span class="line">INSERT BUFFER AND ADAPTIVE HASH INDEX【缓冲区信息，显示写入缓冲区的用量】</span><br><span class="line">-------------------------------------</span><br><span class="line">Ibuf: size 1, free list len 0, seg size 2, 0 merges</span><br><span class="line">merged operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">discarded operations:</span><br><span class="line"> insert 0, delete mark 0, delete 0</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">Hash table size 34679, node heap has 0 buffer(s)</span><br><span class="line">0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s</span><br><span class="line">---</span><br><span class="line">LOG【日志信息：显示日志长度，多少被刷新到硬盘，以及最后日志记录的检查点】</span><br><span class="line">---</span><br><span class="line">Log sequence number 2625594</span><br><span class="line">Log flushed up to   2625594</span><br><span class="line">Pages flushed up to 2625594</span><br><span class="line">Last checkpoint at  2625585</span><br><span class="line">0 pending log flushes, 0 pending chkp writes</span><br><span class="line">10 log i&#x2F;o&#39;s done, 0.00 log i&#x2F;o&#39;s&#x2F;second</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY【缓冲内存用量，读取写入多少页的信息】</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992</span><br><span class="line">Dictionary memory allocated 100382</span><br><span class="line">Buffer pool size   8192</span><br><span class="line">Free buffers       7945</span><br><span class="line">Database pages     247</span><br><span class="line">Old database pages 0</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 213, created 34, written 36</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 247, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">ROW OPERATIONS【显示主线程在干嘛，包括每种行类型的操作的性能以及数量】</span><br><span class="line">--------------</span><br><span class="line">0 queries inside InnoDB, 0 queries in queue</span><br><span class="line">0 read views open inside InnoDB</span><br><span class="line">Process ID&#x3D;99, Main thread ID&#x3D;123145479176192, state: sleeping</span><br><span class="line">Number of rows inserted 0, updated 0, deleted 0, read 8</span><br><span class="line">0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s</span><br><span class="line">----------------------------</span><br><span class="line">END OF INNODB MONITOR OUTPUT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">1 row in set (0.04 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-2-内存使用-3"><a href="#2-2-内存使用-3" class="headerlink" title="2.2 内存使用"></a>2.2 内存使用</h3><p>在 <code>MySQL</code> 中，使用内存可以分几个部分：</p>
<ol>
<li>缓冲池（<code>Buffer Pool</code>）查询： <code>show variables like &#39;innodb_buffer_pool_size&#39;\G</code>；</li>
<li>重做日志缓冲池（<code>Redo Log Buffer</code>）查询： <code>show variables like &#39;innodb_log_buffer_size&#39;\G</code>；</li>
<li>额外内存池（<code>Additional Memory Pool</code>）查询： <code>show variables like &#39;innodb_additional_mem_pool_size&#39;\G</code>；</li>
</ol>
<p>缓冲池是占用内存最大的一块，通常用来存储查询的缓存以及存储修改的数据页，如果发生修改，会先修改这里面的数据，然后按照一定频率刷新到硬盘。每个 <code>Buffer Frame</code> 是 <code>16k</code>，所以按照上节中查询出来的数据：<code>8192 * 16 / 1024 = 128k</code> 说明当前分配了 <code>128m</code> 的缓冲池。 而上面查询到另外一个参数 <code>Free buffers</code> 则表示当前空闲的缓冲区，<code>Database pages</code> 则表示已经使用的缓冲区，所以当前两个值：<code>7945 + 147 &lt;= 8192</code> <code>Modified db pages</code> 则表示已经被修改的页的数量（其实为啥要翻译成脏页，是因为被修改了，跟硬盘不同步，所以脏了吗….脑洞好大） <code>Old database pages</code> 大概意思是 <code>jvm</code> 中的老年代分区，即老年代存放了多少页 <code>Pages made young 19, not young 0</code> 则表示移动到新生代的有多少页以及没有移动的有多少个。 怎么查看压力是否大，就看当前空闲的缓冲区还剩下多少。我拿个生产的来看看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       9549</span><br><span class="line">Database pages     14578</span><br><span class="line">Old database pages 5391</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 19, not young 0</span><br><span class="line">0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s</span><br><span class="line">Pages read 10966, created 3612, written 82315</span><br><span class="line">0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.64 writes&#x2F;s</span><br><span class="line">Buffer pool hit rate 1000 &#x2F; 1000, young-making rate 0 &#x2F; 1000 not 0 &#x2F; 1000</span><br><span class="line">Pages read ahead 0.00&#x2F;s, evicted without access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s</span><br><span class="line">LRU len: 14578, unzip_LRU len: 0</span><br><span class="line">I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>383m</code> 的缓冲区，空闲的有 <code>149m</code>，已经缓冲的有 <code>227m</code>，不存在被修改的页…好像压力很小（真的有点丢人）。 缓冲池还存储着其他的信息：插入缓冲（<code>Insert Buffer</code>）、自适应哈希索引（<code>Adaptive Hash Index</code>）、锁信息（<code>Lock Info</code>）、数据字典信息等等。不过，<code>数据页</code> 和 <code>索引页</code> 一般占用最大的容量。 日志缓冲一般存储重做日志（后面聊聊）然后按照一定频率（一般每一秒）刷新到硬盘。 额外内存池则是当某些操作需要大量内存的时候，会先从这里申请，如果不足则从缓冲池申请（这时候会使用 <code>LRU</code> 规则淘汰一些数据）所以当缓冲区占用比较大的时候（缓存比较多），则应该尽量的加大该区的容量。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113500.png"></p>
<h2 id="三-一个一直在循环的主线程-3"><a href="#三-一个一直在循环的主线程-3" class="headerlink" title="三. 一个一直在循环的主线程"></a>三. 一个一直在循环的主线程</h2><p><code>MySQL</code> 存在着一个主要线程，循环的做着一些重要的功能，比如刷新缓存、刷新日志等。那现在就来看看这个 <code>Master Thread</code> 的主要事情。 首先，<code>Master Thread</code> 他总是在自循环的，类似于 <code>Java</code> 中启动一个线程，而 <code>run</code> 方法里面放的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一些任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，这个循环里面还有个 <code>for</code> 循环来分割一些任务的执行频率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不慌，<code>MySQL</code> 也是通过 <code>sleep</code> 函数来实现这个停顿的，所以，准确的说，每一秒这个说法并不是绝对准确，而是会有点误差。</p>
<h3 id="3-1-每一秒做的事情-3"><a href="#3-1-每一秒做的事情-3" class="headerlink" title="3.1 每一秒做的事情"></a>3.1 每一秒做的事情</h3><p>那接下来我们分开来康康，每一秒都在做什么事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个来看看吧：</p>
<ol>
<li>刷新日志：主要是 <code>redo log</code> （这是一个记录了一个事务中主要做了什么修改的日志），无论事务有没有提交，<code>MySQL</code> 都会在每秒钟将日志刷新到硬盘，所以即使是一个很大的事务，永远可以很快的进行提交；</li>
<li>合并插入缓冲：会根据当前一秒内的 <code>IO</code> 次数来决定，就是说不是每一次都会做合并插入缓冲区；这里我感觉得先小声BB插入缓冲区是什么：就是 <code>MySQL</code> 对插入的数据要更新 <code>非聚簇索引</code> 时，因为通常来说这种索引都不是唯一的，所以如果大量的更新，则需要大量的随机读硬盘，那么 <code>MySQL</code> 数据库会先把这部分插入的数据以及数据页，放在插入缓冲区，然后再以一定的频率写入硬盘，也就是这个 <code>合并插入缓冲</code>；</li>
<li>刷新数据页：上面说的是刷新 <code>非聚簇索引</code>，而现在则需要将真正的数据页刷新到硬盘，当然也不是每一秒都发生，而是脏页的比例 <code>buf_get_modified_radio_pct</code> 超过了配置文件的 <code>innodb_max_dirty_pages_pct</code> 时，才刷新 <code>100</code> 个脏页到硬盘。</li>
</ol>
<h3 id="3-2-每十秒做的任务-3"><a href="#3-2-每十秒做的任务-3" class="headerlink" title="3.2 每十秒做的任务"></a>3.2 每十秒做的任务</h3><p>接下来继续康康每十秒的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，跳过上面已经说过的 <code>刷新脏页</code>、<code>刷新插入缓冲</code>、<code>刷新日志</code>，我们来看看剩下的两个 <code>删除无用的undo日志</code>、<code>插入检查点</code> <code>无用的undo页</code>：我们知道，<code>MySQL</code> 通过行版本控制默认事务的 <code>幻读</code>，那 <code>undo页</code> 指的是当用户发生 <code>update</code> <code>delete</code> 两个操作的时候，会产生一些”无用”（注意双引号）的行信息，但是由于其他事物读取的这些行，所以这些行还不是真正的无用，只有当所有事务都不需要这些版本的行信息的时候，才可以说这些行信息是 <code>无用的undo页</code>。那么删除 <code>无用的undo页</code> 指的就是删除这些无用的不同版本（但绝对不是当前版本）的行信息。 <code>插入检查点</code>：我们知道，<code>MySQL</code> 做什么事情都有日志，但是当日志很大的时候，不仅不利于 <code>IO</code> 也不利于存储空间的利用。那么插入检查点就相当于做了一个标记，标记我上面做的 <code>刷新缓冲页</code> <code>删除undo日志</code> 到达了哪里，这样在 <code>MySQL</code> 发生问题重启后需要恢复数据的时候，只需要检查这个检查点后面的数据即可。这样，可以有效提高 <code>MySQL</code> 发生问题重启恢复数据的速度。 参考： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/lintong/p/4381578.html">mysql的checkpoint</a> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-checkpoints.html">官方文档</a></p>
<h3 id="3-3-后台活动线程-3"><a href="#3-3-后台活动线程-3" class="headerlink" title="3.3 后台活动线程"></a>3.3 后台活动线程</h3><p>最后来看看没有用户活动的时候，后台循环做的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后台线程完整伪代码</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> noUserAct = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一秒循环一次的任务.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新日志.</span></span><br><span class="line">    flushLogs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (当前一秒内的IO次数 &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 合并插入缓冲.</span></span><br><span class="line">      mergeInsertBuf();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (脏页比例 &gt; 配置的阈值) &#123;</span><br><span class="line">        <span class="comment">// 刷新数据页到硬盘.</span></span><br><span class="line">      flushPageToDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (无用户活动) &#123;</span><br><span class="line">        <span class="comment">// 切换到 background loop（因为Java没有goto我就是用标记来表示了）</span></span><br><span class="line">      noUserAct = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 十秒循环一次的任务.</span></span><br><span class="line">  <span class="keyword">if</span> (当前十秒内的IO次数 &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">    flush100DirtyPages();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新至多5个插入缓冲.</span></span><br><span class="line">  merge5InsertBuf();</span><br><span class="line">  <span class="comment">// 刷新日志.</span></span><br><span class="line">  flushLogs();</span><br><span class="line">  <span class="comment">// 删除无用的undo日志（至多20个）.</span></span><br><span class="line">  delUndoLogUseLess();</span><br><span class="line">  <span class="comment">// 删除100或10个脏页.</span></span><br><span class="line">  flush5or10DirtyPages();<span class="comment">// 如果脏页比例 &gt; 70% 刷新100个脏页，否则刷新10个脏页.</span></span><br><span class="line">  <span class="comment">// 产生检查点.</span></span><br><span class="line">  createCheckPoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (noUserAct) &#123;</span><br><span class="line">    <span class="comment">// 后台活动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有无用的undo日志</span></span><br><span class="line">    delUndoLogUseLess();</span><br><span class="line">    <span class="comment">// 刷新至多20个插入缓冲.</span></span><br><span class="line">    merge20InsertBuf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有其他需要做的事情了 回到主线程</span></span><br><span class="line">    <span class="keyword">if</span> (没有需要做的任务) &#123;</span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 刷新100个脏页.</span></span><br><span class="line">        flush100DirtyPages();</span><br><span class="line">        <span class="keyword">if</span> (脏页比例 &lt; 配置的阈值) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      noUserAct = <span class="keyword">false</span></span><br><span class="line">      <span class="comment">// 休眠 等待唤醒 继续主线程</span></span><br><span class="line">      wait();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实做的事情和之前的差不多，就是因为没有用户在使用了，所以线程变得十分狂野，能刷新就刷新，能删除就删除，不限制次数和数量的做这些任务。最后，休眠线程，等待其他事件的唤醒，重新开始后台线程的执行。</p>
<h3 id="3-4-5-7Innodb的后台线程-3"><a href="#3-4-5-7Innodb的后台线程-3" class="headerlink" title="3.4 5.7Innodb的后台线程"></a>3.4 5.7Innodb的后台线程</h3><p>从上面这些可以看到，我们的后台线程十分忙碌，而且刷新脏页的工作十分的多，导致后台线程会有很大的负载（就是为了刷脏总是拖了很多时间），所以在 <code>MySQL 5.62</code> 开始引入一个新的线程负责刷写脏数据这项伟大的任务，而后台线程则减轻了负担。<code>5.7.4</code> 开始，提升为多线程刷新线程。 参考：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool-flushing.html">多线程刷脏</a></p>
<h2 id="四-Double-Write-3"><a href="#四-Double-Write-3" class="headerlink" title="四. Double Write"></a>四. Double Write</h2><p><code>MySQL</code> 中有一个保证数据安全的特性：<code>Double Write</code>。 怎么理解这个玩意儿呢，就是说，当我们在修改一个数据页的时候（刚开始修改一部分，还没修改完成），这时候一个突然，你养的爱猫抓掉了你的电源线。这时候，你的这个页已经被损坏了，就算准备好了重做日志，也无法恢复之前的状态。 那怎么解决呢，这时候就需要在开始修改数据页之前，对这个页进行备份。当发生上面的不幸的时候，<code>MySQL</code> 如果判断到你的数据页被损坏了，则使用先前备份的数据页进行恢复，然后再使用重做日志对这个数据页进行修改。 <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113519.png"></p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_dblwr%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 1865308</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 248718</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure>

<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引-2"><a href="#五-自适应哈希索引-2" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">691</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">112</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">307</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">481</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">463</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">281</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">410</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> <span class="keyword">hash</span> searches/s, <span class="number">42.04</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置-2"><a href="#六-MySQL-InnoDB启动关闭行为的配置-2" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown-2"><a href="#6-1-innodb-fast-shutdown-2" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery-2"><a href="#6-2-innodb-force-recovery-2" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结-2"><a href="#五-总结-2" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。</p>
<blockquote>
<p>PS：图片来自《MySQL技术内幕：InnoDB存储引擎》</p>
</blockquote>
<p>当缓冲页需要刷新的时候，先通过脏页拷贝到内存中的 <code>Doublewrite Buffer</code>，然后内存中的 <code>Doublewrite Buffer</code> 再通过两次每次 <code>1m</code> 的大小写入到硬盘中的共享表空间（因为基本是连续硬盘写，所以效率损失不会特别大）。再将 <code>Doublewrite Buffer</code> 中的数据页写入各个表空间的文件中。 查看 <code>Doublewrite Buffer</code> 的情况可以通过下面的 <code>SQL</code> 来查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#x27;innodb_dblwr%&#x27;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_pages_written</span><br><span class="line">        Value: 1865308</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">Variable_name: Innodb_dblwr_writes</span><br><span class="line">        Value: 248718</span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ERROR</span>:</span><br><span class="line"><span class="keyword">No</span> <span class="keyword">query</span> specified</span><br></pre></td></tr></table></figure>

<p>OK，这是我们公司线上的数据库情况：一共写了 <code>1865308</code> 个页，实际写入次数 <code>248718</code>。远远小于 <code>64:1</code> 的比例，说明还是有压力的。</p>
<h2 id="五-自适应哈希索引-3"><a href="#五-自适应哈希索引-3" class="headerlink" title="五. 自适应哈希索引"></a>五. 自适应哈希索引</h2><p>哈希思想，基本做程序的都不会陌生，即通过某种算法，将输入的对象/文件/其他一切东西转换成一串拥有固定规则的均匀的代码，然后使用这串代码来做定位或者其他用途，大大压缩了内存的使用。例如 <code>Java</code> 最典型的 <code>HashMap</code>。 而 <code>MySQL</code> 则会监控表上索引的查找，如果判断到访问的频率以及模式达到一定的阈值，则会为这些列建立 <code>哈希索引</code>。<code>哈希索引</code> 的简历是通过缓冲池中的 <code>B+树</code> 建立而来的，因此效率大大的好。 但是！注意 <code>哈希索引</code> 只能用在等值搜索的查询上，像 <code>LIKE</code> <code>范围查找</code> 搜索用不了 <code>哈希索引</code>。 查询 <code>哈希索引</code> 情况：<code>show engine innodb status\G;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">0</span>, seg <span class="keyword">size</span> <span class="number">2</span>, <span class="number">4985</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">7415</span>, <span class="keyword">delete</span> mark <span class="number">197</span>, <span class="keyword">delete</span> <span class="number">110</span></span><br><span class="line">discarded <span class="keyword">operations</span>:</span><br><span class="line"> <span class="keyword">insert</span> <span class="number">0</span>, <span class="keyword">delete</span> mark <span class="number">0</span>, <span class="keyword">delete</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">691</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">112</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">307</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">481</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">463</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">281</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">410</span> buffer(s)</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">796871</span>, node <span class="keyword">heap</span> has <span class="number">1493</span> buffer(s)</span><br><span class="line"><span class="number">2741.97</span> <span class="keyword">hash</span> searches/s, <span class="number">42.04</span> non-<span class="keyword">hash</span> searches/s</span><br></pre></td></tr></table></figure>

<p>可以看到使用 <code>哈希索引</code> 以及不使用的效率。</p>
<h2 id="六-MySQL-InnoDB启动关闭行为的配置-3"><a href="#六-MySQL-InnoDB启动关闭行为的配置-3" class="headerlink" title="六. MySQL_InnoDB启动关闭行为的配置"></a>六. MySQL_InnoDB启动关闭行为的配置</h2><h3 id="6-1-innodb-fast-shutdown-3"><a href="#6-1-innodb-fast-shutdown-3" class="headerlink" title="6.1 innodb_fast_shutdown"></a>6.1 innodb_fast_shutdown</h3><p>该参数影响着关闭数据库所做的行为，可以设置的值有 <code>0</code> <code>1</code> <code>2</code>。 <code>0</code>：代表关闭数据库时，需要昨晚所有的 <code>full purge</code> 和 <code>merge insert buffer</code> 操作，直接感受就是 <code>MySQL</code> 关闭会变得很慢。一般需要做软件升级的时候，才开启这个选项，使其做好一切关闭准备。 <code>1</code>：默认值，代表不需要昨晚上面选项的所有行为，但是会刷新脏页到硬盘。 <code>2</code>：不做任何事情，只记录日志文件，下次启动会执行恢复动作。</p>
<blockquote>
<p>PS：如果非正常关闭数据库比如宕机，则需要将该参数值改成 <code>2</code> 让 <code>MySQL</code> 完整恢复数据再启动。</p>
</blockquote>
<h3 id="6-2-innodb-force-recovery-3"><a href="#6-2-innodb-force-recovery-3" class="headerlink" title="6.2 innodb_force_recovery"></a>6.2 innodb_force_recovery</h3><p>该值配置启动数据库时的恢复方式。默认值是 <code>0</code>，表示需要恢复上次关闭的所有日志。 但是当我们知道怎么恢复而且恢复需要很长时间的时候，我们可以把该值设置成 <code>6</code> 不让数据库进行恢复。 其他值： <code>0</code>：默认恢复方式； <code>1</code>：(SRV_FORCE_IGNORE_CORRUPT):忽略检查到的corrupt页。 <code>2</code>：(SRV_FORCE_NO_BACKGROUND):阻止主线程的运行，如主线程需要执行full purge操作，会导致crash。 <code>3</code>：(SRV_FORCE_NO_TRX_UNDO):不执行事务回滚操作。 <code>4</code>：(SRV_FORCE_NO_IBUF_MERGE):不执行插入缓冲的合并操作。 <code>5</code>：(SRV_FORCE_NO_UNDO_LOG_SCAN):不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交。 <code>6</code>：(SRV_FORCE_NO_LOG_REDO):不执行前滚的操作。 大于 <code>0</code> 的方式可以对标进行 <code>CREATE</code> <code>SELECT</code> <code>DROP</code> 而不允许 <code>UPDATE</code> <code>INSERT</code> <code>DELETE</code></p>
<h2 id="五-总结-3"><a href="#五-总结-3" class="headerlink" title="五.总结"></a>五.总结</h2><p>大概了解 <code>Inno_DB</code> 存储引擎的架构以及后台的执行线程。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%80-mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%80-mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">【聊聊MySQL】一. MySQL存储引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-05 16:06:25" itemprop="dateCreated datePublished" datetime="2019-09-05T16:06:25+08:00">2019-09-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 14:42:51" itemprop="dateModified" datetime="2020-11-10T14:42:51+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-MySQL介绍"><a href="#一-MySQL介绍" class="headerlink" title="一.MySQL介绍"></a>一.MySQL介绍</h2><p>作为 <code>MySQL</code> 系列的开篇，我觉得还是有必要说说大家熟悉的 <code>MySQL</code> 数据库的一些东西。 <code>MySQL</code> 我想作为开发者应该没有人不认识或者不熟悉了吧。不管所在的厂子是大中小，基本上很多时候都会采用 <code>MySQL</code> 作为我们数据的存储介质。当然政府项目很多都会采用 <code>Oracle</code> 数据库，不过最近看来，这个事情貌似也不是绝对。也有很多政府的项目已经决定采用 <code>MySQL</code> 或者其他厂商封装的 <code>MySQL</code> 分支了。 作为数据库，其实定义是这样的：</p>
<ul>
<li>数据库：文件或者其他文件类型的集合，在 <code>MySQL</code> 中，文件被存储为 <code>frm</code> <code>myd</code> <code>ibd</code> 等多种形式的文件。而有些存储引擎比如 <code>NDB</code> 他的数据信息则是被存储在内存之中的，并不会持久化到硬盘上面，所以他不需要文件来进行存储。速度稍稍快但数据库出现异常重启的话，数据就会丢失。</li>
<li>数据库实例或软件：其实就是运行的，可以读取以上数据库文件的软件进程，他可能是一个也可能是多个，日常开发经常是运行一个的情形。我们运行 <code>SQL</code> 或者其他操作的，其实都是在跟数据库实例进行交互，数据库实例会根据命令，计算出来比较高效的查询策略在硬盘上进行数据查询。</li>
</ul>
<h2 id="二-MySQL体系结构"><a href="#二-MySQL体系结构" class="headerlink" title="二.MySQL体系结构"></a>二.MySQL体系结构</h2><h2 id="一-MySQL介绍-1"><a href="#一-MySQL介绍-1" class="headerlink" title="一.MySQL介绍"></a>一.MySQL介绍</h2><p>作为 <code>MySQL</code> 系列的开篇，我觉得还是有必要说说大家熟悉的 <code>MySQL</code> 数据库的一些东西。 <code>MySQL</code> 我想作为开发者应该没有人不认识或者不熟悉了吧。不管所在的厂子是大中小，基本上很多时候都会采用 <code>MySQL</code> 作为我们数据的存储介质。当然政府项目很多都会采用 <code>Oracle</code> 数据库，不过最近看来，这个事情貌似也不是绝对。也有很多政府的项目已经决定采用 <code>MySQL</code> 或者其他厂商封装的 <code>MySQL</code> 分支了。 作为数据库，其实定义是这样的：</p>
<ul>
<li>数据库：文件或者其他文件类型的集合，在 <code>MySQL</code> 中，文件被存储为 <code>frm</code> <code>myd</code> <code>ibd</code> 等多种形式的文件。而有些存储引擎比如 <code>NDB</code> 他的数据信息则是被存储在内存之中的，并不会持久化到硬盘上面，所以他不需要文件来进行存储。速度稍稍快但数据库出现异常重启的话，数据就会丢失。</li>
<li>数据库实例或软件：其实就是运行的，可以读取以上数据库文件的软件进程，他可能是一个也可能是多个，日常开发经常是运行一个的情形。我们运行 <code>SQL</code> 或者其他操作的，其实都是在跟数据库实例进行交互，数据库实例会根据命令，计算出来比较高效的查询策略在硬盘上进行数据查询。</li>
</ul>
<h2 id="二-MySQL体系结构-1"><a href="#二-MySQL体系结构-1" class="headerlink" title="二.MySQL体系结构"></a>二.MySQL体系结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144225.png"></p>
<p> 数据库由上面几大部分组成，每一部分基本上所做的事情都非常多，而且对数据操作过程中都起着非常重要的作用。<code>MySQL</code> 还有个特点就是存储引擎采用插件式的方式，只要我们按照 <code>MySQL</code> 规范去开发引擎，即可引入数据库软件然后进行启动存储。引擎不是存储数据的地方，而是定义怎么存储数据的地方。而且存储引擎的细粒度是表，也就是说我们新建一个数据库（database），可以使用多个存储引擎来建表。</p>
<h2 id="三-MySQL存储引擎"><a href="#三-MySQL存储引擎" class="headerlink" title="三.MySQL存储引擎"></a>三.MySQL存储引擎</h2><p>由于我们经常使用的无非就是 <code>InnoDB</code> 和 <code>MyISAM</code> 两种引擎，所以其他的我并不打算细讲，稍微带过去就可以了。</p>
<h3 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h3><p><code>InnoDB</code> 支持数据库事务（<code>SQL</code> 要么一起成功要么一起失败）现在 <code>MySQL</code> 版本默认的存储引擎，支持行级锁，支持外键，以及支持非锁定读（读取不会产生锁）。 通过多版本并发控制 <code>MVCC</code> 来获得高并发性，并且实现 <code>SQL</code> 标准的 <code>4</code> 种隔离机制，默认隔离机制是 <code>REPEATABLE</code>，同时使用一种 <code>next-key locking</code> 策略（简单说就是版本控制）来避免幻读的产生。 说到这得回忆一下 <code>MySQL</code> 的四种隔离级别：</p>
<p>隔离级别</p>
<p>说明</p>
<p><code>Serializable</code></p>
<p>最严格的级别，有事务一个一个来，最慢也最安全</p>
<p><code>REPEATABLE READ</code></p>
<p>避免修改另外一个事务读取但未修改的数据，但不能避免幻读</p>
<p><code>READ COMMITTED</code></p>
<p>大多数数据库采用的级别，避免脏读但不避免幻读和不可重复读</p>
<p><code>Read Uncommitted</code></p>
<p>事务会读取到另外一个事物已修改但未提交的数据</p>
<blockquote>
<ul>
<li>脏读：读取到了其他事务已修改但未提交的数据，如A读取到了B事务修改后的数据X，但是B事务进行了回滚，这时候说明A事务产生了脏读。</li>
<li>不可重复读：事务A读取一条数据，后面B事务修改了这条数据，A再次读取时发现数据不匹配，这就是不可重复读</li>
<li>幻读：事务A根据某个条件读取N条数据，事务B改变了其他数据使之满足A的搜索条件，事务再次读取发现有大于N条的数据</li>
</ul>
</blockquote>
<p><code>InnoDB</code> 存数数据的时候是按照主键（如果没有设置主键，<code>InnoDB</code> 会偷偷的给一个主键）的顺序进行存储，形成 <code>B+</code> 树结构，根据其他索引查询的时候需要回表，即回到最原始的这棵树进行匹配再返回所有数据。</p>
<h3 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h3><p><code>InnoDB</code> 支持的事务、表锁他都不支持，也不支持全文索引。由 <code>MYD</code> 和 <code>MYI</code> 文件共同协助。前者存储数据后者存储索引。支持全文索引。</p>
<h3 id="3-NDB"><a href="#3-NDB" class="headerlink" title="3.NDB"></a>3.NDB</h3><p>集群存储引擎，<code>NDB</code> 是将数据全部放置于内存中（<code>5.1</code> 之后可以将非索引数据放置于硬盘），因此主键查找很快，也可以新增节点提高性能。但是连接操作是在 <code>MySQL</code> 数据库层，并非引擎完成（其实就是说连接的时候不能真正的连接而是需要一个一个查询连接）效率较低。</p>
<h3 id="4-Memory"><a href="#4-Memory" class="headerlink" title="4.Memory"></a>4.Memory</h3><p>也是数据存储于内存的引擎，使用哈希索引进行查询。但有些限制：不支持 <code>VARCHAR</code> 使用 <code>CHAR</code> 的形式进行存储，也不支持大文本数据。临时表会使用该引擎进行查询，但是如果临时表有大文本或者超过容量设置，就会降级至 <code>MyISAM</code> 进行存储到硬盘，由于 <code>MyISAM</code> 不支持缓存数据文件，因此此时临时表可能会拖慢查询速度。</p>
<h3 id="5-Archive"><a href="#5-Archive" class="headerlink" title="5.Archive"></a>5.Archive</h3><p>只支持 <code>INSERT</code> 和 <code>SELECT</code> 的引擎，对数据进行压缩，压缩比高，适合存储归档数据如日志信息等。其目的是压缩。</p>
<h3 id="6-Federated"><a href="#6-Federated" class="headerlink" title="6.Federated"></a>6.Federated</h3><p>不存放数据的引擎，指向一台远程的 <code>MySQL</code> 数据库服务器的表。</p>
<h3 id="7-Maria"><a href="#7-Maria" class="headerlink" title="7.Maria"></a>7.Maria</h3><p><code>MyISAM</code> 的后续版本，支持缓存数据和索引文件，行级锁设计、提供 <code>MVCC</code> 功能，支持事务，以及更好的 <code>BLOB</code> 字符类型的处理性能。 <code>MySQL</code> 支持哪些存储引擎可以通过语句 <code>SHOW ENGINES\G</code> 来查看。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144242.png"></p>
<h2 id="四-连接MySQL"><a href="#四-连接MySQL" class="headerlink" title="四.连接MySQL"></a>四.连接MySQL</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>可以说最常见的连接方式了，使用 <code>IP</code> <code>用户名</code> <code>密码</code> 进行连接基本是我们调试，生产一直使用的方式。请求连接时 <code>MySQL</code> 数据库实例会判断当前用户是否拥有权限进行连接，一般来说，会限制用户只能从哪个 <code>IP</code> 进行连接。</p>
<h3 id="命令管道和共享内存"><a href="#命令管道和共享内存" class="headerlink" title="命令管道和共享内存"></a>命令管道和共享内存</h3><p>在 <code>Windows</code> 系列上，如果客户端和服务端同属于一台服务器上，那么可以通过配置文件配置 <code>--enable-named-pipe</code> 选项开启命令管道，当然这些方法都不常用，不细说。</p>
<h3 id="UNIX管道"><a href="#UNIX管道" class="headerlink" title="UNIX管道"></a>UNIX管道</h3><p>首先使用 <code>TCP/IP</code> 进行数据库连接，运行 <code>SHOW VARIABLES LIKE &#39;socket&#39;</code> 命令查看 <code>Socket</code> 管道所在的位置，然后我们就可以通过 <code>mysql -uroot -S /tmp/mysql.sock</code> 从而使用 <code>UNIX管道</code> 的方式进行数据库连接。</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><p>了解 <code>MySQL</code> 术语； 了解 <code>MySQL</code> 体系架构； 了解 <code>MySQL</code> 支持的引擎系列； 了解 <code>MySQL</code> 的连接方式。</p>
<p> 数据库由上面几大部分组成，每一部分基本上所做的事情都非常多，而且对数据操作过程中都起着非常重要的作用。<code>MySQL</code> 还有个特点就是存储引擎采用插件式的方式，只要我们按照 <code>MySQL</code> 规范去开发引擎，即可引入数据库软件然后进行启动存储。引擎不是存储数据的地方，而是定义怎么存储数据的地方。而且存储引擎的细粒度是表，也就是说我们新建一个数据库（database），可以使用多个存储引擎来建表。</p>
<h2 id="三-MySQL存储引擎-1"><a href="#三-MySQL存储引擎-1" class="headerlink" title="三.MySQL存储引擎"></a>三.MySQL存储引擎</h2><p>由于我们经常使用的无非就是 <code>InnoDB</code> 和 <code>MyISAM</code> 两种引擎，所以其他的我并不打算细讲，稍微带过去就可以了。</p>
<h3 id="1-InnoDB-1"><a href="#1-InnoDB-1" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h3><p><code>InnoDB</code> 支持数据库事务（<code>SQL</code> 要么一起成功要么一起失败）现在 <code>MySQL</code> 版本默认的存储引擎，支持行级锁，支持外键，以及支持非锁定读（读取不会产生锁）。 通过多版本并发控制 <code>MVCC</code> 来获得高并发性，并且实现 <code>SQL</code> 标准的 <code>4</code> 种隔离机制，默认隔离机制是 <code>REPEATABLE</code>，同时使用一种 <code>next-key locking</code> 策略（简单说就是版本控制）来避免幻读的产生。 说到这得回忆一下 <code>MySQL</code> 的四种隔离级别：</p>
<p>隔离级别</p>
<p>说明</p>
<p><code>Serializable</code></p>
<p>最严格的级别，有事务一个一个来，最慢也最安全</p>
<p><code>REPEATABLE READ</code></p>
<p>避免修改另外一个事务读取但未修改的数据，但不能避免幻读</p>
<p><code>READ COMMITTED</code></p>
<p>大多数数据库采用的级别，避免脏读但不避免幻读和不可重复读</p>
<p><code>Read Uncommitted</code></p>
<p>事务会读取到另外一个事物已修改但未提交的数据</p>
<blockquote>
<ul>
<li>脏读：读取到了其他事务已修改但未提交的数据，如A读取到了B事务修改后的数据X，但是B事务进行了回滚，这时候说明A事务产生了脏读。</li>
<li>不可重复读：事务A读取一条数据，后面B事务修改了这条数据，A再次读取时发现数据不匹配，这就是不可重复读</li>
<li>幻读：事务A根据某个条件读取N条数据，事务B改变了其他数据使之满足A的搜索条件，事务再次读取发现有大于N条的数据</li>
</ul>
</blockquote>
<p><code>InnoDB</code> 存数数据的时候是按照主键（如果没有设置主键，<code>InnoDB</code> 会偷偷的给一个主键）的顺序进行存储，形成 <code>B+</code> 树结构，根据其他索引查询的时候需要回表，即回到最原始的这棵树进行匹配再返回所有数据。</p>
<h3 id="2-MyISAM-1"><a href="#2-MyISAM-1" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h3><p><code>InnoDB</code> 支持的事务、表锁他都不支持，也不支持全文索引。由 <code>MYD</code> 和 <code>MYI</code> 文件共同协助。前者存储数据后者存储索引。支持全文索引。</p>
<h3 id="3-NDB-1"><a href="#3-NDB-1" class="headerlink" title="3.NDB"></a>3.NDB</h3><p>集群存储引擎，<code>NDB</code> 是将数据全部放置于内存中（<code>5.1</code> 之后可以将非索引数据放置于硬盘），因此主键查找很快，也可以新增节点提高性能。但是连接操作是在 <code>MySQL</code> 数据库层，并非引擎完成（其实就是说连接的时候不能真正的连接而是需要一个一个查询连接）效率较低。</p>
<h3 id="4-Memory-1"><a href="#4-Memory-1" class="headerlink" title="4.Memory"></a>4.Memory</h3><p>也是数据存储于内存的引擎，使用哈希索引进行查询。但有些限制：不支持 <code>VARCHAR</code> 使用 <code>CHAR</code> 的形式进行存储，也不支持大文本数据。临时表会使用该引擎进行查询，但是如果临时表有大文本或者超过容量设置，就会降级至 <code>MyISAM</code> 进行存储到硬盘，由于 <code>MyISAM</code> 不支持缓存数据文件，因此此时临时表可能会拖慢查询速度。</p>
<h3 id="5-Archive-1"><a href="#5-Archive-1" class="headerlink" title="5.Archive"></a>5.Archive</h3><p>只支持 <code>INSERT</code> 和 <code>SELECT</code> 的引擎，对数据进行压缩，压缩比高，适合存储归档数据如日志信息等。其目的是压缩。</p>
<h3 id="6-Federated-1"><a href="#6-Federated-1" class="headerlink" title="6.Federated"></a>6.Federated</h3><p>不存放数据的引擎，指向一台远程的 <code>MySQL</code> 数据库服务器的表。</p>
<h3 id="7-Maria-1"><a href="#7-Maria-1" class="headerlink" title="7.Maria"></a>7.Maria</h3><p><code>MyISAM</code> 的后续版本，支持缓存数据和索引文件，行级锁设计、提供 <code>MVCC</code> 功能，支持事务，以及更好的 <code>BLOB</code> 字符类型的处理性能。 <code>MySQL</code> 支持哪些存储引擎可以通过语句 <code>SHOW ENGINES\G</code> 来查看。 </p>
<h2 id="一-MySQL介绍-2"><a href="#一-MySQL介绍-2" class="headerlink" title="一.MySQL介绍"></a>一.MySQL介绍</h2><p>作为 <code>MySQL</code> 系列的开篇，我觉得还是有必要说说大家熟悉的 <code>MySQL</code> 数据库的一些东西。 <code>MySQL</code> 我想作为开发者应该没有人不认识或者不熟悉了吧。不管所在的厂子是大中小，基本上很多时候都会采用 <code>MySQL</code> 作为我们数据的存储介质。当然政府项目很多都会采用 <code>Oracle</code> 数据库，不过最近看来，这个事情貌似也不是绝对。也有很多政府的项目已经决定采用 <code>MySQL</code> 或者其他厂商封装的 <code>MySQL</code> 分支了。 作为数据库，其实定义是这样的：</p>
<ul>
<li>数据库：文件或者其他文件类型的集合，在 <code>MySQL</code> 中，文件被存储为 <code>frm</code> <code>myd</code> <code>ibd</code> 等多种形式的文件。而有些存储引擎比如 <code>NDB</code> 他的数据信息则是被存储在内存之中的，并不会持久化到硬盘上面，所以他不需要文件来进行存储。速度稍稍快但数据库出现异常重启的话，数据就会丢失。</li>
<li>数据库实例或软件：其实就是运行的，可以读取以上数据库文件的软件进程，他可能是一个也可能是多个，日常开发经常是运行一个的情形。我们运行 <code>SQL</code> 或者其他操作的，其实都是在跟数据库实例进行交互，数据库实例会根据命令，计算出来比较高效的查询策略在硬盘上进行数据查询。</li>
</ul>
<h2 id="二-MySQL体系结构-2"><a href="#二-MySQL体系结构-2" class="headerlink" title="二.MySQL体系结构"></a>二.MySQL体系结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144225.png"></p>
<p> 数据库由上面几大部分组成，每一部分基本上所做的事情都非常多，而且对数据操作过程中都起着非常重要的作用。<code>MySQL</code> 还有个特点就是存储引擎采用插件式的方式，只要我们按照 <code>MySQL</code> 规范去开发引擎，即可引入数据库软件然后进行启动存储。引擎不是存储数据的地方，而是定义怎么存储数据的地方。而且存储引擎的细粒度是表，也就是说我们新建一个数据库（database），可以使用多个存储引擎来建表。</p>
<h2 id="三-MySQL存储引擎-2"><a href="#三-MySQL存储引擎-2" class="headerlink" title="三.MySQL存储引擎"></a>三.MySQL存储引擎</h2><p>由于我们经常使用的无非就是 <code>InnoDB</code> 和 <code>MyISAM</code> 两种引擎，所以其他的我并不打算细讲，稍微带过去就可以了。</p>
<h3 id="1-InnoDB-2"><a href="#1-InnoDB-2" class="headerlink" title="1.InnoDB"></a>1.InnoDB</h3><p><code>InnoDB</code> 支持数据库事务（<code>SQL</code> 要么一起成功要么一起失败）现在 <code>MySQL</code> 版本默认的存储引擎，支持行级锁，支持外键，以及支持非锁定读（读取不会产生锁）。 通过多版本并发控制 <code>MVCC</code> 来获得高并发性，并且实现 <code>SQL</code> 标准的 <code>4</code> 种隔离机制，默认隔离机制是 <code>REPEATABLE</code>，同时使用一种 <code>next-key locking</code> 策略（简单说就是版本控制）来避免幻读的产生。 说到这得回忆一下 <code>MySQL</code> 的四种隔离级别：</p>
<p>隔离级别</p>
<p>说明</p>
<p><code>Serializable</code></p>
<p>最严格的级别，有事务一个一个来，最慢也最安全</p>
<p><code>REPEATABLE READ</code></p>
<p>避免修改另外一个事务读取但未修改的数据，但不能避免幻读</p>
<p><code>READ COMMITTED</code></p>
<p>大多数数据库采用的级别，避免脏读但不避免幻读和不可重复读</p>
<p><code>Read Uncommitted</code></p>
<p>事务会读取到另外一个事物已修改但未提交的数据</p>
<blockquote>
<ul>
<li>脏读：读取到了其他事务已修改但未提交的数据，如A读取到了B事务修改后的数据X，但是B事务进行了回滚，这时候说明A事务产生了脏读。</li>
<li>不可重复读：事务A读取一条数据，后面B事务修改了这条数据，A再次读取时发现数据不匹配，这就是不可重复读</li>
<li>幻读：事务A根据某个条件读取N条数据，事务B改变了其他数据使之满足A的搜索条件，事务再次读取发现有大于N条的数据</li>
</ul>
</blockquote>
<p><code>InnoDB</code> 存数数据的时候是按照主键（如果没有设置主键，<code>InnoDB</code> 会偷偷的给一个主键）的顺序进行存储，形成 <code>B+</code> 树结构，根据其他索引查询的时候需要回表，即回到最原始的这棵树进行匹配再返回所有数据。</p>
<h3 id="2-MyISAM-2"><a href="#2-MyISAM-2" class="headerlink" title="2.MyISAM"></a>2.MyISAM</h3><p><code>InnoDB</code> 支持的事务、表锁他都不支持，也不支持全文索引。由 <code>MYD</code> 和 <code>MYI</code> 文件共同协助。前者存储数据后者存储索引。支持全文索引。</p>
<h3 id="3-NDB-2"><a href="#3-NDB-2" class="headerlink" title="3.NDB"></a>3.NDB</h3><p>集群存储引擎，<code>NDB</code> 是将数据全部放置于内存中（<code>5.1</code> 之后可以将非索引数据放置于硬盘），因此主键查找很快，也可以新增节点提高性能。但是连接操作是在 <code>MySQL</code> 数据库层，并非引擎完成（其实就是说连接的时候不能真正的连接而是需要一个一个查询连接）效率较低。</p>
<h3 id="4-Memory-2"><a href="#4-Memory-2" class="headerlink" title="4.Memory"></a>4.Memory</h3><p>也是数据存储于内存的引擎，使用哈希索引进行查询。但有些限制：不支持 <code>VARCHAR</code> 使用 <code>CHAR</code> 的形式进行存储，也不支持大文本数据。临时表会使用该引擎进行查询，但是如果临时表有大文本或者超过容量设置，就会降级至 <code>MyISAM</code> 进行存储到硬盘，由于 <code>MyISAM</code> 不支持缓存数据文件，因此此时临时表可能会拖慢查询速度。</p>
<h3 id="5-Archive-2"><a href="#5-Archive-2" class="headerlink" title="5.Archive"></a>5.Archive</h3><p>只支持 <code>INSERT</code> 和 <code>SELECT</code> 的引擎，对数据进行压缩，压缩比高，适合存储归档数据如日志信息等。其目的是压缩。</p>
<h3 id="6-Federated-2"><a href="#6-Federated-2" class="headerlink" title="6.Federated"></a>6.Federated</h3><p>不存放数据的引擎，指向一台远程的 <code>MySQL</code> 数据库服务器的表。</p>
<h3 id="7-Maria-2"><a href="#7-Maria-2" class="headerlink" title="7.Maria"></a>7.Maria</h3><p><code>MyISAM</code> 的后续版本，支持缓存数据和索引文件，行级锁设计、提供 <code>MVCC</code> 功能，支持事务，以及更好的 <code>BLOB</code> 字符类型的处理性能。 <code>MySQL</code> 支持哪些存储引擎可以通过语句 <code>SHOW ENGINES\G</code> 来查看。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110144242.png"></p>
<h2 id="四-连接MySQL-1"><a href="#四-连接MySQL-1" class="headerlink" title="四.连接MySQL"></a>四.连接MySQL</h2><h3 id="TCP-IP-1"><a href="#TCP-IP-1" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>可以说最常见的连接方式了，使用 <code>IP</code> <code>用户名</code> <code>密码</code> 进行连接基本是我们调试，生产一直使用的方式。请求连接时 <code>MySQL</code> 数据库实例会判断当前用户是否拥有权限进行连接，一般来说，会限制用户只能从哪个 <code>IP</code> 进行连接。</p>
<h3 id="命令管道和共享内存-1"><a href="#命令管道和共享内存-1" class="headerlink" title="命令管道和共享内存"></a>命令管道和共享内存</h3><p>在 <code>Windows</code> 系列上，如果客户端和服务端同属于一台服务器上，那么可以通过配置文件配置 <code>--enable-named-pipe</code> 选项开启命令管道，当然这些方法都不常用，不细说。</p>
<h3 id="UNIX管道-1"><a href="#UNIX管道-1" class="headerlink" title="UNIX管道"></a>UNIX管道</h3><p>首先使用 <code>TCP/IP</code> 进行数据库连接，运行 <code>SHOW VARIABLES LIKE &#39;socket&#39;</code> 命令查看 <code>Socket</code> 管道所在的位置，然后我们就可以通过 <code>mysql -uroot -S /tmp/mysql.sock</code> 从而使用 <code>UNIX管道</code> 的方式进行数据库连接。</p>
<h2 id="五-总结-1"><a href="#五-总结-1" class="headerlink" title="五.总结"></a>五.总结</h2><p>了解 <code>MySQL</code> 术语； 了解 <code>MySQL</code> 体系架构； 了解 <code>MySQL</code> 支持的引擎系列； 了解 <code>MySQL</code> 的连接方式。</p>
<h2 id="四-连接MySQL-2"><a href="#四-连接MySQL-2" class="headerlink" title="四.连接MySQL"></a>四.连接MySQL</h2><h3 id="TCP-IP-2"><a href="#TCP-IP-2" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>可以说最常见的连接方式了，使用 <code>IP</code> <code>用户名</code> <code>密码</code> 进行连接基本是我们调试，生产一直使用的方式。请求连接时 <code>MySQL</code> 数据库实例会判断当前用户是否拥有权限进行连接，一般来说，会限制用户只能从哪个 <code>IP</code> 进行连接。</p>
<h3 id="命令管道和共享内存-2"><a href="#命令管道和共享内存-2" class="headerlink" title="命令管道和共享内存"></a>命令管道和共享内存</h3><p>在 <code>Windows</code> 系列上，如果客户端和服务端同属于一台服务器上，那么可以通过配置文件配置 <code>--enable-named-pipe</code> 选项开启命令管道，当然这些方法都不常用，不细说。</p>
<h3 id="UNIX管道-2"><a href="#UNIX管道-2" class="headerlink" title="UNIX管道"></a>UNIX管道</h3><p>首先使用 <code>TCP/IP</code> 进行数据库连接，运行 <code>SHOW VARIABLES LIKE &#39;socket&#39;</code> 命令查看 <code>Socket</code> 管道所在的位置，然后我们就可以通过 <code>mysql -uroot -S /tmp/mysql.sock</code> 从而使用 <code>UNIX管道</code> 的方式进行数据库连接。</p>
<h2 id="五-总结-2"><a href="#五-总结-2" class="headerlink" title="五.总结"></a>五.总结</h2><p>了解 <code>MySQL</code> 术语； 了解 <code>MySQL</code> 体系架构； 了解 <code>MySQL</code> 支持的引擎系列； 了解 <code>MySQL</code> 的连接方式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/frame/Netty/netty%E5%A4%84%E7%90%86websocket%EF%BC%8Cnginx%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/frame/Netty/netty%E5%A4%84%E7%90%86websocket%EF%BC%8Cnginx%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Netty处理WebSocket，Nginx配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-04 16:41:00" itemprop="dateCreated datePublished" datetime="2019-08-04T16:41:00+08:00">2019-08-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 16:14:34" itemprop="dateModified" datetime="2020-11-10T16:14:34+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/" itemprop="url" rel="index"><span itemprop="name">frame</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-实时消息WebSocket"><a href="#一-实时消息WebSocket" class="headerlink" title="一.实时消息WebSocket"></a>一.实时消息WebSocket</h2><p>传统的 <code>WEB</code> 开发中，通常我们渲染数据或者请求增删改的时候，都需要通过发送 <code>HTTP</code> 请求。 而每次发送 <code>HTTP</code> 请求基本都需要经历下面的历程（其实和 <code>TCP</code> 大致相同）： </p>
<h2 id="一-实时消息WebSocket-1"><a href="#一-实时消息WebSocket-1" class="headerlink" title="一.实时消息WebSocket"></a>一.实时消息WebSocket</h2><p>传统的 <code>WEB</code> 开发中，通常我们渲染数据或者请求增删改的时候，都需要通过发送 <code>HTTP</code> 请求。 而每次发送 <code>HTTP</code> 请求基本都需要经历下面的历程（其实和 <code>TCP</code> 大致相同）： <img src="https://liweidan.cn/wp-content/uploads/2019/08/HTTP-PROCESS.png" alt="image-20190804143610798"> 而当我们需要一些实时消息的需求的时候，比如聊天或者消息推送，那么我们有一种做法就是。浏览器每隔几秒轮训一次服务器（因为不请求服务器就没法回复消息），走一下上面的步骤，然后服务器如果有数据响应数据，没有数据就响应空的数据。哇啊啊啊啊你看这个过程，如果我的后台系统这个账号刚好没什么生意，基本很少需要推送有人下单的消息给我，可是我还是要走这些流程，服务器也还是需要处理我这个没用的卖家的请求。 当然并不是这种方式没人采用，还是有的，因为开发简单。但是性能其实并不怎么样，而且还要浪费一个服务来处理这个请求。 这个问题看起来还是比较棘手的而且很迫切的一个需求，于是乎我们的 <code>W3C</code> 组织站了出来，为浏览器新增了一个新的协议 <code>WebSocket</code> 协议，在 <code>HTML5</code> 发布的时候新增进去的。 <code>WebSocket</code> 跟 <code>HTTP</code> 在同一层，利用 <code>HTTP</code> 向服务器请求升级 <code>WebSocket</code>，服务器应答即可将当前的连接升级为 <code>WebSocket</code> 连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET ws:&#x2F;&#x2F;localhost:9999&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket # 请求升级WebSocket</span><br><span class="line">Connection: Upgrade # 同样</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:8000</span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<p>服务器如果答应了，就会响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br></pre></td></tr></table></figure>

<p>这时候相当于说，我浏览器和服务器经历了三次握手，然后在中间建设了一个管道。 这个管道，谁都可以随时使用，客户端和服务端都可以同时发送消息。也就是说在上面订单通知的例子中，我服务器收到了一个订单支付成功，即可立马发送一条消息给你客户端。</p>
<h2 id="二-Netty处理WebSocket"><a href="#二-Netty处理WebSocket" class="headerlink" title="二.Netty处理WebSocket"></a>二.Netty处理WebSocket</h2><p>OK，接下来轮到 <code>Netty</code> 来干活了。 我们知道 <code>Netty</code> 基本是由一堆 <code>Handler</code> 组成一个链条来处理请求的。</p>
<h3 id="2-1-Netty的WebSocket解码器"><a href="#2-1-Netty的WebSocket解码器" class="headerlink" title="2.1 Netty的WebSocket解码器"></a>2.1 Netty的WebSocket解码器</h3><p>所以我们组装 <code>Pipeline</code> 的时候需要安装一个 <code>WebSocketServerProtocolHandler</code> 处理器，他会将 <code>WebSocket</code> 请求处理并且传递给下一个 <code>handler</code>（一般是我们的业务处理器）。构造器需要指定 <code>WebSocket</code> 处理的 <code>uri</code>。 安装：<code>pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/&quot;));</code> 具体详细的引导安装下面再说。</p>
<h3 id="2-2-编写我们自己的Handler"><a href="#2-2-编写我们自己的Handler" class="headerlink" title="2.2 编写我们自己的Handler"></a>2.2 编写我们自己的Handler</h3><p>因为浏览器发送的数据也是二进制的进行，有自己的帧规则，而上一步我们安装了 <code>Netty</code> 提供的处理器以后，这时候我们已经可以取出来浏览器发送的字符串了，所以我们自己的处理器需要处理 <code>TextWebSocketFrame</code>。这是一个数据封装的包裹（前面说的 <code>ByteBuf</code>，只不过内部已经进行了翻译）所以我们可以很简单的根据业务需求封装一些请求类以及响应类，这里为了简单不做进一步封装。 我现在有个需求，连接了 <code>Netty</code> 服务器，发送一个消息后，假装服务器有通知需要发送，每隔 <code>2</code> 秒就给浏览器发送，浏览器打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(text));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 每隔2秒发送一个消息 */</span></span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;你有一个新的淘金订单，请尽快处理&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实应该不是很难理解这个代码…</p>
<h3 id="2-3-引导安装服务器"><a href="#2-3-引导安装服务器" class="headerlink" title="2.3 引导安装服务器"></a>2.3 引导安装服务器</h3><p>我们知道 <code>WebSocket</code> 是通过 <code>HTTP</code> 来升级的，所以这时，<code>HTTP</code> 处理器还是不能少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="keyword">final</span> NotifyHandler notifyHandler = <span class="keyword">new</span> NotifyHandler();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">9999</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 新增HTTP处理器，处理请求升级问题 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">                  <span class="comment">/** 安装 WebSocket 处理器 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">                  <span class="comment">/** 安装我自己的Handler */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(notifyHandler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动，进行测试。</p>
<h3 id="2-4-测试WebSocket接口"><a href="#2-4-测试WebSocket接口" class="headerlink" title="2.4 测试WebSocket接口"></a>2.4 测试WebSocket接口</h3><p>在开发的时候发现了这个很有用的小工具 <a target="_blank" rel="noopener" href="http://www.websocket-test.com/">在线测试WebSocket</a> OK，我们的端口是 <code>9999</code>，这时候只要在左侧窗口的连接地址写 <code>ws://localhost:9999/</code>，然后尝试写消息给服务器，让服务器不断的写消息给我们。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161228.gif"></p>
<h2 id="三-开发实时通知页面"><a href="#三-开发实时通知页面" class="headerlink" title="三.开发实时通知页面"></a>三.开发实时通知页面</h2><p>服务端有了，现在需要页面来做对接呀。 直接上代码好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;TEST-WEBSOCKET&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    let retry &#x3D; null</span><br><span class="line">    let wbs &#x3D; null</span><br><span class="line">    function openWebSocket() &#123;</span><br><span class="line">        &#x2F;** 创建WebSocket客户端 *&#x2F;</span><br><span class="line">        wbs &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:9999&#x2F;&quot;)</span><br><span class="line">        &#x2F;** 定义接收消息弹窗显示 *&#x2F;</span><br><span class="line">        wbs.onmessage &#x3D; (evt) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;** 弹窗打印服务器发送的消息内容 *&#x2F;</span><br><span class="line">            alert(evt.data)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 定义连接打开后需要发送的消息 *&#x2F;</span><br><span class="line">        wbs.onopen &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;WebSocket连接已打开&quot;)</span><br><span class="line">            &#x2F;** 打开连接即发送消息 *&#x2F;</span><br><span class="line">            wbs.send(&quot;HELLO&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;** 打开后如果重试还在 清楚重试对象 *&#x2F;</span><br><span class="line">            if (retry !&#x3D;&#x3D; null) &#123;</span><br><span class="line">                clearInterval(retry)</span><br><span class="line">                retry &#x3D; null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 *&#x2F;</span><br><span class="line">        wbs.onclose &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;WebSocket被关闭了&#39;)</span><br><span class="line">            if (null &#x3D;&#x3D;&#x3D; retry) &#123;</span><br><span class="line">                retry &#x3D; setInterval(function () &#123;</span><br><span class="line">                    console.log(&quot;尝试重连....&quot;)</span><br><span class="line">                    openWebSocket()</span><br><span class="line">                &#125;, 3000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openWebSocket();</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://liweidan.cn/wp-content/uploads/2019/08/HTML-WEBSOCKET.gif"></p>
<h2 id="四-Nginx反向代理"><a href="#四-Nginx反向代理" class="headerlink" title="四.Nginx反向代理"></a>四.Nginx反向代理</h2><p><code>Nginx</code> 通常在生产中被用作反向代理服务器，什么意思咧，相当于请求进门，进门之前，证书什么的都在这里配置。 我跟往常一样在这里配置 <code>WebSocket</code> 服务端的证书呀反向代理服务器呀。 唯独没有关注连接超时被断开的问题，上了测试，我的 <code>Web</code> 项目居然过了 <code>1</code> 分钟就总是偷偷断开。导致后面用户接受不到订单的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 升级请求</span><br><span class="line">map $http_upgrade $connection_upgrade &#123;  </span><br><span class="line">    default upgrade;  </span><br><span class="line">    &#39;&#39; close;  </span><br><span class="line">&#125;  </span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on ;</span><br><span class="line">    server_name wbs.liweidan.com;</span><br><span class="line">    ssl_certificate   XXXXX.pem;</span><br><span class="line">    ssl_certificate_key  XXXXX.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:9999&#x2F;;  </span><br><span class="line">        proxy_http_version 1.1;  </span><br><span class="line">                proxy_connect_timeout 4s; </span><br><span class="line">        proxy_read_timeout 1200s; # 20分钟没有接受请求才超时断开</span><br><span class="line">        proxy_send_timeout 12s; # 十二秒没有发送成功即发送超时</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">        proxy_set_header Connection &quot;Upgrade&quot;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Emm，没错，有中文注释的是配置关键点。表示 <code>20分钟</code> 没有数据读取才关闭连接。 但是有些需求不需要关闭连接啊，怎么办，来个 <code>PING</code> <code>PONG</code> 心跳咯： 然而浏览器没有这个机制啊，而且只认得服务器发送的 <code>PONG</code> 帧。也就是说，我们需要服务端发送一个 <code>PONG</code> 他浏览器会返回一个 <code>PING</code>（怪怪的然而事实就是这样） 可是我不想服务器来做这个事情，因为毕竟连接的都有时间差嘛。所以我准备在前端发送 <code>PING</code> 服务端收到后返回 <code>PONG</code> 即可。 改一改我们自己的处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;PING&quot;</span>.equals(text)) &#123;</span><br><span class="line">      ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;PONG&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 省略代码 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再改一改前端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> retry = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> ping = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wbs = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** 创建WebSocket客户端 */</span></span><br><span class="line">  wbs = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:9999/&quot;</span>)</span><br><span class="line">  <span class="comment">/** 定义接收消息弹窗显示 */</span></span><br><span class="line">  wbs.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/** 弹窗打印服务器发送的消息内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (evt.data !== <span class="string">&#x27;PONG&#x27;</span>) &#123;</span><br><span class="line">      alert(evt.data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(evt.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 定义连接打开后需要发送的消息 */</span></span><br><span class="line">  wbs.onopen = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;WebSocket连接已打开&quot;</span>)</span><br><span class="line">    <span class="comment">/** 打开连接即发送消息 */</span></span><br><span class="line">    wbs.send(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 打开后如果重试还在 清楚重试对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (retry !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(retry)</span><br><span class="line">      retry = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 连接后启动 PING，PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === ping) &#123;</span><br><span class="line">      <span class="comment">/** 7分钟心跳一次，注意这个值需要设置的比 Nginx 设置的值要小，不然被关闭了就没意义了。 */</span></span><br><span class="line">      ping = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        wbs.send(<span class="string">&quot;PING&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">60000</span> * <span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 */</span></span><br><span class="line">  wbs.onclose = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;WebSocket被关闭了&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === retry) &#123;</span><br><span class="line">      retry = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;尝试重连....&quot;</span>)</span><br><span class="line">        openWebSocket()</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 连接被关闭后停止 PING-PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> !== ping) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(ping)</span><br><span class="line">      ping = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openWebSocket();</span><br></pre></td></tr></table></figure>

<p>测试： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161408.png"></p>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p><code>WebSocket</code> 相关内容完结。 而当我们需要一些实时消息的需求的时候，比如聊天或者消息推送，那么我们有一种做法就是。浏览器每隔几秒轮训一次服务器（因为不请求服务器就没法回复消息），走一下上面的步骤，然后服务器如果有数据响应数据，没有数据就响应空的数据。哇啊啊啊啊你看这个过程，如果我的后台系统这个账号刚好没什么生意，基本很少需要推送有人下单的消息给我，可是我还是要走这些流程，服务器也还是需要处理我这个没用的卖家的请求。 当然并不是这种方式没人采用，还是有的，因为开发简单。但是性能其实并不怎么样，而且还要浪费一个服务来处理这个请求。 这个问题看起来还是比较棘手的而且很迫切的一个需求，于是乎我们的 <code>W3C</code> 组织站了出来，为浏览器新增了一个新的协议 <code>WebSocket</code> 协议，在 <code>HTML5</code> 发布的时候新增进去的。 <code>WebSocket</code> 跟 <code>HTTP</code> 在同一层，利用 <code>HTTP</code> 向服务器请求升级 <code>WebSocket</code>，服务器应答即可将当前的连接升级为 <code>WebSocket</code> 连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET ws:&#x2F;&#x2F;localhost:9999&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket # 请求升级WebSocket</span><br><span class="line">Connection: Upgrade # 同样</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:8000</span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<p>服务器如果答应了，就会响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br></pre></td></tr></table></figure>

<p>这时候相当于说，我浏览器和服务器经历了三次握手，然后在中间建设了一个管道。 这个管道，谁都可以随时使用，客户端和服务端都可以同时发送消息。也就是说在上面订单通知的例子中，我服务器收到了一个订单支付成功，即可立马发送一条消息给你客户端。</p>
<h2 id="二-Netty处理WebSocket-1"><a href="#二-Netty处理WebSocket-1" class="headerlink" title="二.Netty处理WebSocket"></a>二.Netty处理WebSocket</h2><p>OK，接下来轮到 <code>Netty</code> 来干活了。 我们知道 <code>Netty</code> 基本是由一堆 <code>Handler</code> 组成一个链条来处理请求的。</p>
<h3 id="2-1-Netty的WebSocket解码器-1"><a href="#2-1-Netty的WebSocket解码器-1" class="headerlink" title="2.1 Netty的WebSocket解码器"></a>2.1 Netty的WebSocket解码器</h3><p>所以我们组装 <code>Pipeline</code> 的时候需要安装一个 <code>WebSocketServerProtocolHandler</code> 处理器，他会将 <code>WebSocket</code> 请求处理并且传递给下一个 <code>handler</code>（一般是我们的业务处理器）。构造器需要指定 <code>WebSocket</code> 处理的 <code>uri</code>。 安装：<code>pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/&quot;));</code> 具体详细的引导安装下面再说。</p>
<h3 id="2-2-编写我们自己的Handler-1"><a href="#2-2-编写我们自己的Handler-1" class="headerlink" title="2.2 编写我们自己的Handler"></a>2.2 编写我们自己的Handler</h3><p>因为浏览器发送的数据也是二进制的进行，有自己的帧规则，而上一步我们安装了 <code>Netty</code> 提供的处理器以后，这时候我们已经可以取出来浏览器发送的字符串了，所以我们自己的处理器需要处理 <code>TextWebSocketFrame</code>。这是一个数据封装的包裹（前面说的 <code>ByteBuf</code>，只不过内部已经进行了翻译）所以我们可以很简单的根据业务需求封装一些请求类以及响应类，这里为了简单不做进一步封装。 我现在有个需求，连接了 <code>Netty</code> 服务器，发送一个消息后，假装服务器有通知需要发送，每隔 <code>2</code> 秒就给浏览器发送，浏览器打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(text));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 每隔2秒发送一个消息 */</span></span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;你有一个新的淘金订单，请尽快处理&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实应该不是很难理解这个代码…</p>
<h3 id="2-3-引导安装服务器-1"><a href="#2-3-引导安装服务器-1" class="headerlink" title="2.3 引导安装服务器"></a>2.3 引导安装服务器</h3><p>我们知道 <code>WebSocket</code> 是通过 <code>HTTP</code> 来升级的，所以这时，<code>HTTP</code> 处理器还是不能少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="keyword">final</span> NotifyHandler notifyHandler = <span class="keyword">new</span> NotifyHandler();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">9999</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 新增HTTP处理器，处理请求升级问题 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">                  <span class="comment">/** 安装 WebSocket 处理器 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">                  <span class="comment">/** 安装我自己的Handler */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(notifyHandler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动，进行测试。</p>
<h3 id="2-4-测试WebSocket接口-1"><a href="#2-4-测试WebSocket接口-1" class="headerlink" title="2.4 测试WebSocket接口"></a>2.4 测试WebSocket接口</h3><p>在开发的时候发现了这个很有用的小工具 <a target="_blank" rel="noopener" href="http://www.websocket-test.com/">在线测试WebSocket</a> OK，我们的端口是 <code>9999</code>，这时候只要在左侧窗口的连接地址写 <code>ws://localhost:9999/</code>，然后尝试写消息给服务器，让服务器不断的写消息给我们。 </p>
<h2 id="一-实时消息WebSocket-2"><a href="#一-实时消息WebSocket-2" class="headerlink" title="一.实时消息WebSocket"></a>一.实时消息WebSocket</h2><p>传统的 <code>WEB</code> 开发中，通常我们渲染数据或者请求增删改的时候，都需要通过发送 <code>HTTP</code> 请求。 而每次发送 <code>HTTP</code> 请求基本都需要经历下面的历程（其实和 <code>TCP</code> 大致相同）： <img src="https://liweidan.cn/wp-content/uploads/2019/08/HTTP-PROCESS.png" alt="image-20190804143610798"> 而当我们需要一些实时消息的需求的时候，比如聊天或者消息推送，那么我们有一种做法就是。浏览器每隔几秒轮训一次服务器（因为不请求服务器就没法回复消息），走一下上面的步骤，然后服务器如果有数据响应数据，没有数据就响应空的数据。哇啊啊啊啊你看这个过程，如果我的后台系统这个账号刚好没什么生意，基本很少需要推送有人下单的消息给我，可是我还是要走这些流程，服务器也还是需要处理我这个没用的卖家的请求。 当然并不是这种方式没人采用，还是有的，因为开发简单。但是性能其实并不怎么样，而且还要浪费一个服务来处理这个请求。 这个问题看起来还是比较棘手的而且很迫切的一个需求，于是乎我们的 <code>W3C</code> 组织站了出来，为浏览器新增了一个新的协议 <code>WebSocket</code> 协议，在 <code>HTML5</code> 发布的时候新增进去的。 <code>WebSocket</code> 跟 <code>HTTP</code> 在同一层，利用 <code>HTTP</code> 向服务器请求升级 <code>WebSocket</code>，服务器应答即可将当前的连接升级为 <code>WebSocket</code> 连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET ws:&#x2F;&#x2F;localhost:9999&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket # 请求升级WebSocket</span><br><span class="line">Connection: Upgrade # 同样</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:8000</span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<p>服务器如果答应了，就会响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br></pre></td></tr></table></figure>

<p>这时候相当于说，我浏览器和服务器经历了三次握手，然后在中间建设了一个管道。 这个管道，谁都可以随时使用，客户端和服务端都可以同时发送消息。也就是说在上面订单通知的例子中，我服务器收到了一个订单支付成功，即可立马发送一条消息给你客户端。</p>
<h2 id="二-Netty处理WebSocket-2"><a href="#二-Netty处理WebSocket-2" class="headerlink" title="二.Netty处理WebSocket"></a>二.Netty处理WebSocket</h2><p>OK，接下来轮到 <code>Netty</code> 来干活了。 我们知道 <code>Netty</code> 基本是由一堆 <code>Handler</code> 组成一个链条来处理请求的。</p>
<h3 id="2-1-Netty的WebSocket解码器-2"><a href="#2-1-Netty的WebSocket解码器-2" class="headerlink" title="2.1 Netty的WebSocket解码器"></a>2.1 Netty的WebSocket解码器</h3><p>所以我们组装 <code>Pipeline</code> 的时候需要安装一个 <code>WebSocketServerProtocolHandler</code> 处理器，他会将 <code>WebSocket</code> 请求处理并且传递给下一个 <code>handler</code>（一般是我们的业务处理器）。构造器需要指定 <code>WebSocket</code> 处理的 <code>uri</code>。 安装：<code>pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/&quot;));</code> 具体详细的引导安装下面再说。</p>
<h3 id="2-2-编写我们自己的Handler-2"><a href="#2-2-编写我们自己的Handler-2" class="headerlink" title="2.2 编写我们自己的Handler"></a>2.2 编写我们自己的Handler</h3><p>因为浏览器发送的数据也是二进制的进行，有自己的帧规则，而上一步我们安装了 <code>Netty</code> 提供的处理器以后，这时候我们已经可以取出来浏览器发送的字符串了，所以我们自己的处理器需要处理 <code>TextWebSocketFrame</code>。这是一个数据封装的包裹（前面说的 <code>ByteBuf</code>，只不过内部已经进行了翻译）所以我们可以很简单的根据业务需求封装一些请求类以及响应类，这里为了简单不做进一步封装。 我现在有个需求，连接了 <code>Netty</code> 服务器，发送一个消息后，假装服务器有通知需要发送，每隔 <code>2</code> 秒就给浏览器发送，浏览器打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(text));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 每隔2秒发送一个消息 */</span></span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;你有一个新的淘金订单，请尽快处理&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实应该不是很难理解这个代码…</p>
<h3 id="2-3-引导安装服务器-2"><a href="#2-3-引导安装服务器-2" class="headerlink" title="2.3 引导安装服务器"></a>2.3 引导安装服务器</h3><p>我们知道 <code>WebSocket</code> 是通过 <code>HTTP</code> 来升级的，所以这时，<code>HTTP</code> 处理器还是不能少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="keyword">final</span> NotifyHandler notifyHandler = <span class="keyword">new</span> NotifyHandler();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">9999</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 新增HTTP处理器，处理请求升级问题 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">                  <span class="comment">/** 安装 WebSocket 处理器 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">                  <span class="comment">/** 安装我自己的Handler */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(notifyHandler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动，进行测试。</p>
<h3 id="2-4-测试WebSocket接口-2"><a href="#2-4-测试WebSocket接口-2" class="headerlink" title="2.4 测试WebSocket接口"></a>2.4 测试WebSocket接口</h3><p>在开发的时候发现了这个很有用的小工具 <a target="_blank" rel="noopener" href="http://www.websocket-test.com/">在线测试WebSocket</a> OK，我们的端口是 <code>9999</code>，这时候只要在左侧窗口的连接地址写 <code>ws://localhost:9999/</code>，然后尝试写消息给服务器，让服务器不断的写消息给我们。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161228.gif"></p>
<h2 id="三-开发实时通知页面-1"><a href="#三-开发实时通知页面-1" class="headerlink" title="三.开发实时通知页面"></a>三.开发实时通知页面</h2><p>服务端有了，现在需要页面来做对接呀。 直接上代码好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;TEST-WEBSOCKET&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    let retry &#x3D; null</span><br><span class="line">    let wbs &#x3D; null</span><br><span class="line">    function openWebSocket() &#123;</span><br><span class="line">        &#x2F;** 创建WebSocket客户端 *&#x2F;</span><br><span class="line">        wbs &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:9999&#x2F;&quot;)</span><br><span class="line">        &#x2F;** 定义接收消息弹窗显示 *&#x2F;</span><br><span class="line">        wbs.onmessage &#x3D; (evt) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;** 弹窗打印服务器发送的消息内容 *&#x2F;</span><br><span class="line">            alert(evt.data)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 定义连接打开后需要发送的消息 *&#x2F;</span><br><span class="line">        wbs.onopen &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;WebSocket连接已打开&quot;)</span><br><span class="line">            &#x2F;** 打开连接即发送消息 *&#x2F;</span><br><span class="line">            wbs.send(&quot;HELLO&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;** 打开后如果重试还在 清楚重试对象 *&#x2F;</span><br><span class="line">            if (retry !&#x3D;&#x3D; null) &#123;</span><br><span class="line">                clearInterval(retry)</span><br><span class="line">                retry &#x3D; null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 *&#x2F;</span><br><span class="line">        wbs.onclose &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;WebSocket被关闭了&#39;)</span><br><span class="line">            if (null &#x3D;&#x3D;&#x3D; retry) &#123;</span><br><span class="line">                retry &#x3D; setInterval(function () &#123;</span><br><span class="line">                    console.log(&quot;尝试重连....&quot;)</span><br><span class="line">                    openWebSocket()</span><br><span class="line">                &#125;, 3000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openWebSocket();</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://liweidan.cn/wp-content/uploads/2019/08/HTML-WEBSOCKET.gif"></p>
<h2 id="四-Nginx反向代理-1"><a href="#四-Nginx反向代理-1" class="headerlink" title="四.Nginx反向代理"></a>四.Nginx反向代理</h2><p><code>Nginx</code> 通常在生产中被用作反向代理服务器，什么意思咧，相当于请求进门，进门之前，证书什么的都在这里配置。 我跟往常一样在这里配置 <code>WebSocket</code> 服务端的证书呀反向代理服务器呀。 唯独没有关注连接超时被断开的问题，上了测试，我的 <code>Web</code> 项目居然过了 <code>1</code> 分钟就总是偷偷断开。导致后面用户接受不到订单的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 升级请求</span><br><span class="line">map $http_upgrade $connection_upgrade &#123;  </span><br><span class="line">    default upgrade;  </span><br><span class="line">    &#39;&#39; close;  </span><br><span class="line">&#125;  </span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on ;</span><br><span class="line">    server_name wbs.liweidan.com;</span><br><span class="line">    ssl_certificate   XXXXX.pem;</span><br><span class="line">    ssl_certificate_key  XXXXX.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:9999&#x2F;;  </span><br><span class="line">        proxy_http_version 1.1;  </span><br><span class="line">                proxy_connect_timeout 4s; </span><br><span class="line">        proxy_read_timeout 1200s; # 20分钟没有接受请求才超时断开</span><br><span class="line">        proxy_send_timeout 12s; # 十二秒没有发送成功即发送超时</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">        proxy_set_header Connection &quot;Upgrade&quot;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Emm，没错，有中文注释的是配置关键点。表示 <code>20分钟</code> 没有数据读取才关闭连接。 但是有些需求不需要关闭连接啊，怎么办，来个 <code>PING</code> <code>PONG</code> 心跳咯： 然而浏览器没有这个机制啊，而且只认得服务器发送的 <code>PONG</code> 帧。也就是说，我们需要服务端发送一个 <code>PONG</code> 他浏览器会返回一个 <code>PING</code>（怪怪的然而事实就是这样） 可是我不想服务器来做这个事情，因为毕竟连接的都有时间差嘛。所以我准备在前端发送 <code>PING</code> 服务端收到后返回 <code>PONG</code> 即可。 改一改我们自己的处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;PING&quot;</span>.equals(text)) &#123;</span><br><span class="line">      ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;PONG&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 省略代码 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再改一改前端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> retry = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> ping = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wbs = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** 创建WebSocket客户端 */</span></span><br><span class="line">  wbs = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:9999/&quot;</span>)</span><br><span class="line">  <span class="comment">/** 定义接收消息弹窗显示 */</span></span><br><span class="line">  wbs.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/** 弹窗打印服务器发送的消息内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (evt.data !== <span class="string">&#x27;PONG&#x27;</span>) &#123;</span><br><span class="line">      alert(evt.data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(evt.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 定义连接打开后需要发送的消息 */</span></span><br><span class="line">  wbs.onopen = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;WebSocket连接已打开&quot;</span>)</span><br><span class="line">    <span class="comment">/** 打开连接即发送消息 */</span></span><br><span class="line">    wbs.send(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 打开后如果重试还在 清楚重试对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (retry !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(retry)</span><br><span class="line">      retry = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 连接后启动 PING，PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === ping) &#123;</span><br><span class="line">      <span class="comment">/** 7分钟心跳一次，注意这个值需要设置的比 Nginx 设置的值要小，不然被关闭了就没意义了。 */</span></span><br><span class="line">      ping = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        wbs.send(<span class="string">&quot;PING&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">60000</span> * <span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 */</span></span><br><span class="line">  wbs.onclose = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;WebSocket被关闭了&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === retry) &#123;</span><br><span class="line">      retry = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;尝试重连....&quot;</span>)</span><br><span class="line">        openWebSocket()</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 连接被关闭后停止 PING-PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> !== ping) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(ping)</span><br><span class="line">      ping = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openWebSocket();</span><br></pre></td></tr></table></figure>

<p>测试： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161408.png"></p>
<h2 id="完-1"><a href="#完-1" class="headerlink" title="完"></a>完</h2><p><code>WebSocket</code> 相关内容完结。</p>
<h2 id="三-开发实时通知页面-2"><a href="#三-开发实时通知页面-2" class="headerlink" title="三.开发实时通知页面"></a>三.开发实时通知页面</h2><p>服务端有了，现在需要页面来做对接呀。 直接上代码好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;TEST-WEBSOCKET&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    let retry &#x3D; null</span><br><span class="line">    let wbs &#x3D; null</span><br><span class="line">    function openWebSocket() &#123;</span><br><span class="line">        &#x2F;** 创建WebSocket客户端 *&#x2F;</span><br><span class="line">        wbs &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:9999&#x2F;&quot;)</span><br><span class="line">        &#x2F;** 定义接收消息弹窗显示 *&#x2F;</span><br><span class="line">        wbs.onmessage &#x3D; (evt) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;** 弹窗打印服务器发送的消息内容 *&#x2F;</span><br><span class="line">            alert(evt.data)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 定义连接打开后需要发送的消息 *&#x2F;</span><br><span class="line">        wbs.onopen &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;WebSocket连接已打开&quot;)</span><br><span class="line">            &#x2F;** 打开连接即发送消息 *&#x2F;</span><br><span class="line">            wbs.send(&quot;HELLO&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;** 打开后如果重试还在 清楚重试对象 *&#x2F;</span><br><span class="line">            if (retry !&#x3D;&#x3D; null) &#123;</span><br><span class="line">                clearInterval(retry)</span><br><span class="line">                retry &#x3D; null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 *&#x2F;</span><br><span class="line">        wbs.onclose &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;WebSocket被关闭了&#39;)</span><br><span class="line">            if (null &#x3D;&#x3D;&#x3D; retry) &#123;</span><br><span class="line">                retry &#x3D; setInterval(function () &#123;</span><br><span class="line">                    console.log(&quot;尝试重连....&quot;)</span><br><span class="line">                    openWebSocket()</span><br><span class="line">                &#125;, 3000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openWebSocket();</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>


<h2 id="一-实时消息WebSocket-3"><a href="#一-实时消息WebSocket-3" class="headerlink" title="一.实时消息WebSocket"></a>一.实时消息WebSocket</h2><p>传统的 <code>WEB</code> 开发中，通常我们渲染数据或者请求增删改的时候，都需要通过发送 <code>HTTP</code> 请求。 而每次发送 <code>HTTP</code> 请求基本都需要经历下面的历程（其实和 <code>TCP</code> 大致相同）： <img src="https://liweidan.cn/wp-content/uploads/2019/08/HTTP-PROCESS.png" alt="image-20190804143610798"> 而当我们需要一些实时消息的需求的时候，比如聊天或者消息推送，那么我们有一种做法就是。浏览器每隔几秒轮训一次服务器（因为不请求服务器就没法回复消息），走一下上面的步骤，然后服务器如果有数据响应数据，没有数据就响应空的数据。哇啊啊啊啊你看这个过程，如果我的后台系统这个账号刚好没什么生意，基本很少需要推送有人下单的消息给我，可是我还是要走这些流程，服务器也还是需要处理我这个没用的卖家的请求。 当然并不是这种方式没人采用，还是有的，因为开发简单。但是性能其实并不怎么样，而且还要浪费一个服务来处理这个请求。 这个问题看起来还是比较棘手的而且很迫切的一个需求，于是乎我们的 <code>W3C</code> 组织站了出来，为浏览器新增了一个新的协议 <code>WebSocket</code> 协议，在 <code>HTML5</code> 发布的时候新增进去的。 <code>WebSocket</code> 跟 <code>HTTP</code> 在同一层，利用 <code>HTTP</code> 向服务器请求升级 <code>WebSocket</code>，服务器应答即可将当前的连接升级为 <code>WebSocket</code> 连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET ws:&#x2F;&#x2F;localhost:9999&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket # 请求升级WebSocket</span><br><span class="line">Connection: Upgrade # 同样</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:8000</span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<p>服务器如果答应了，就会响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br></pre></td></tr></table></figure>

<p>这时候相当于说，我浏览器和服务器经历了三次握手，然后在中间建设了一个管道。 这个管道，谁都可以随时使用，客户端和服务端都可以同时发送消息。也就是说在上面订单通知的例子中，我服务器收到了一个订单支付成功，即可立马发送一条消息给你客户端。</p>
<h2 id="二-Netty处理WebSocket-3"><a href="#二-Netty处理WebSocket-3" class="headerlink" title="二.Netty处理WebSocket"></a>二.Netty处理WebSocket</h2><p>OK，接下来轮到 <code>Netty</code> 来干活了。 我们知道 <code>Netty</code> 基本是由一堆 <code>Handler</code> 组成一个链条来处理请求的。</p>
<h3 id="2-1-Netty的WebSocket解码器-3"><a href="#2-1-Netty的WebSocket解码器-3" class="headerlink" title="2.1 Netty的WebSocket解码器"></a>2.1 Netty的WebSocket解码器</h3><p>所以我们组装 <code>Pipeline</code> 的时候需要安装一个 <code>WebSocketServerProtocolHandler</code> 处理器，他会将 <code>WebSocket</code> 请求处理并且传递给下一个 <code>handler</code>（一般是我们的业务处理器）。构造器需要指定 <code>WebSocket</code> 处理的 <code>uri</code>。 安装：<code>pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/&quot;));</code> 具体详细的引导安装下面再说。</p>
<h3 id="2-2-编写我们自己的Handler-3"><a href="#2-2-编写我们自己的Handler-3" class="headerlink" title="2.2 编写我们自己的Handler"></a>2.2 编写我们自己的Handler</h3><p>因为浏览器发送的数据也是二进制的进行，有自己的帧规则，而上一步我们安装了 <code>Netty</code> 提供的处理器以后，这时候我们已经可以取出来浏览器发送的字符串了，所以我们自己的处理器需要处理 <code>TextWebSocketFrame</code>。这是一个数据封装的包裹（前面说的 <code>ByteBuf</code>，只不过内部已经进行了翻译）所以我们可以很简单的根据业务需求封装一些请求类以及响应类，这里为了简单不做进一步封装。 我现在有个需求，连接了 <code>Netty</code> 服务器，发送一个消息后，假装服务器有通知需要发送，每隔 <code>2</code> 秒就给浏览器发送，浏览器打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(text));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 每隔2秒发送一个消息 */</span></span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;你有一个新的淘金订单，请尽快处理&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实应该不是很难理解这个代码…</p>
<h3 id="2-3-引导安装服务器-3"><a href="#2-3-引导安装服务器-3" class="headerlink" title="2.3 引导安装服务器"></a>2.3 引导安装服务器</h3><p>我们知道 <code>WebSocket</code> 是通过 <code>HTTP</code> 来升级的，所以这时，<code>HTTP</code> 处理器还是不能少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="keyword">final</span> NotifyHandler notifyHandler = <span class="keyword">new</span> NotifyHandler();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">9999</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 新增HTTP处理器，处理请求升级问题 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">                  <span class="comment">/** 安装 WebSocket 处理器 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">                  <span class="comment">/** 安装我自己的Handler */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(notifyHandler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动，进行测试。</p>
<h3 id="2-4-测试WebSocket接口-3"><a href="#2-4-测试WebSocket接口-3" class="headerlink" title="2.4 测试WebSocket接口"></a>2.4 测试WebSocket接口</h3><p>在开发的时候发现了这个很有用的小工具 <a target="_blank" rel="noopener" href="http://www.websocket-test.com/">在线测试WebSocket</a> OK，我们的端口是 <code>9999</code>，这时候只要在左侧窗口的连接地址写 <code>ws://localhost:9999/</code>，然后尝试写消息给服务器，让服务器不断的写消息给我们。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161228.gif"></p>
<h2 id="三-开发实时通知页面-3"><a href="#三-开发实时通知页面-3" class="headerlink" title="三.开发实时通知页面"></a>三.开发实时通知页面</h2><p>服务端有了，现在需要页面来做对接呀。 直接上代码好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;TEST-WEBSOCKET&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    let retry &#x3D; null</span><br><span class="line">    let wbs &#x3D; null</span><br><span class="line">    function openWebSocket() &#123;</span><br><span class="line">        &#x2F;** 创建WebSocket客户端 *&#x2F;</span><br><span class="line">        wbs &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:9999&#x2F;&quot;)</span><br><span class="line">        &#x2F;** 定义接收消息弹窗显示 *&#x2F;</span><br><span class="line">        wbs.onmessage &#x3D; (evt) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;** 弹窗打印服务器发送的消息内容 *&#x2F;</span><br><span class="line">            alert(evt.data)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 定义连接打开后需要发送的消息 *&#x2F;</span><br><span class="line">        wbs.onopen &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;WebSocket连接已打开&quot;)</span><br><span class="line">            &#x2F;** 打开连接即发送消息 *&#x2F;</span><br><span class="line">            wbs.send(&quot;HELLO&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;** 打开后如果重试还在 清楚重试对象 *&#x2F;</span><br><span class="line">            if (retry !&#x3D;&#x3D; null) &#123;</span><br><span class="line">                clearInterval(retry)</span><br><span class="line">                retry &#x3D; null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 *&#x2F;</span><br><span class="line">        wbs.onclose &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;WebSocket被关闭了&#39;)</span><br><span class="line">            if (null &#x3D;&#x3D;&#x3D; retry) &#123;</span><br><span class="line">                retry &#x3D; setInterval(function () &#123;</span><br><span class="line">                    console.log(&quot;尝试重连....&quot;)</span><br><span class="line">                    openWebSocket()</span><br><span class="line">                &#125;, 3000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openWebSocket();</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://liweidan.cn/wp-content/uploads/2019/08/HTML-WEBSOCKET.gif"></p>
<h2 id="四-Nginx反向代理-2"><a href="#四-Nginx反向代理-2" class="headerlink" title="四.Nginx反向代理"></a>四.Nginx反向代理</h2><p><code>Nginx</code> 通常在生产中被用作反向代理服务器，什么意思咧，相当于请求进门，进门之前，证书什么的都在这里配置。 我跟往常一样在这里配置 <code>WebSocket</code> 服务端的证书呀反向代理服务器呀。 唯独没有关注连接超时被断开的问题，上了测试，我的 <code>Web</code> 项目居然过了 <code>1</code> 分钟就总是偷偷断开。导致后面用户接受不到订单的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 升级请求</span><br><span class="line">map $http_upgrade $connection_upgrade &#123;  </span><br><span class="line">    default upgrade;  </span><br><span class="line">    &#39;&#39; close;  </span><br><span class="line">&#125;  </span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on ;</span><br><span class="line">    server_name wbs.liweidan.com;</span><br><span class="line">    ssl_certificate   XXXXX.pem;</span><br><span class="line">    ssl_certificate_key  XXXXX.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:9999&#x2F;;  </span><br><span class="line">        proxy_http_version 1.1;  </span><br><span class="line">                proxy_connect_timeout 4s; </span><br><span class="line">        proxy_read_timeout 1200s; # 20分钟没有接受请求才超时断开</span><br><span class="line">        proxy_send_timeout 12s; # 十二秒没有发送成功即发送超时</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">        proxy_set_header Connection &quot;Upgrade&quot;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Emm，没错，有中文注释的是配置关键点。表示 <code>20分钟</code> 没有数据读取才关闭连接。 但是有些需求不需要关闭连接啊，怎么办，来个 <code>PING</code> <code>PONG</code> 心跳咯： 然而浏览器没有这个机制啊，而且只认得服务器发送的 <code>PONG</code> 帧。也就是说，我们需要服务端发送一个 <code>PONG</code> 他浏览器会返回一个 <code>PING</code>（怪怪的然而事实就是这样） 可是我不想服务器来做这个事情，因为毕竟连接的都有时间差嘛。所以我准备在前端发送 <code>PING</code> 服务端收到后返回 <code>PONG</code> 即可。 改一改我们自己的处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;PING&quot;</span>.equals(text)) &#123;</span><br><span class="line">      ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;PONG&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 省略代码 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再改一改前端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> retry = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> ping = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wbs = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** 创建WebSocket客户端 */</span></span><br><span class="line">  wbs = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:9999/&quot;</span>)</span><br><span class="line">  <span class="comment">/** 定义接收消息弹窗显示 */</span></span><br><span class="line">  wbs.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/** 弹窗打印服务器发送的消息内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (evt.data !== <span class="string">&#x27;PONG&#x27;</span>) &#123;</span><br><span class="line">      alert(evt.data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(evt.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 定义连接打开后需要发送的消息 */</span></span><br><span class="line">  wbs.onopen = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;WebSocket连接已打开&quot;</span>)</span><br><span class="line">    <span class="comment">/** 打开连接即发送消息 */</span></span><br><span class="line">    wbs.send(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 打开后如果重试还在 清楚重试对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (retry !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(retry)</span><br><span class="line">      retry = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 连接后启动 PING，PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === ping) &#123;</span><br><span class="line">      <span class="comment">/** 7分钟心跳一次，注意这个值需要设置的比 Nginx 设置的值要小，不然被关闭了就没意义了。 */</span></span><br><span class="line">      ping = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        wbs.send(<span class="string">&quot;PING&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">60000</span> * <span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 */</span></span><br><span class="line">  wbs.onclose = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;WebSocket被关闭了&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === retry) &#123;</span><br><span class="line">      retry = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;尝试重连....&quot;</span>)</span><br><span class="line">        openWebSocket()</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 连接被关闭后停止 PING-PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> !== ping) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(ping)</span><br><span class="line">      ping = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openWebSocket();</span><br></pre></td></tr></table></figure>

<p>测试： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161408.png"></p>
<h2 id="完-2"><a href="#完-2" class="headerlink" title="完"></a>完</h2><p><code>WebSocket</code> 相关内容完结。</p>
<h2 id="四-Nginx反向代理-3"><a href="#四-Nginx反向代理-3" class="headerlink" title="四.Nginx反向代理"></a>四.Nginx反向代理</h2><p><code>Nginx</code> 通常在生产中被用作反向代理服务器，什么意思咧，相当于请求进门，进门之前，证书什么的都在这里配置。 我跟往常一样在这里配置 <code>WebSocket</code> 服务端的证书呀反向代理服务器呀。 唯独没有关注连接超时被断开的问题，上了测试，我的 <code>Web</code> 项目居然过了 <code>1</code> 分钟就总是偷偷断开。导致后面用户接受不到订单的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 升级请求</span><br><span class="line">map $http_upgrade $connection_upgrade &#123;  </span><br><span class="line">    default upgrade;  </span><br><span class="line">    &#39;&#39; close;  </span><br><span class="line">&#125;  </span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on ;</span><br><span class="line">    server_name wbs.liweidan.com;</span><br><span class="line">    ssl_certificate   XXXXX.pem;</span><br><span class="line">    ssl_certificate_key  XXXXX.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:9999&#x2F;;  </span><br><span class="line">        proxy_http_version 1.1;  </span><br><span class="line">                proxy_connect_timeout 4s; </span><br><span class="line">        proxy_read_timeout 1200s; # 20分钟没有接受请求才超时断开</span><br><span class="line">        proxy_send_timeout 12s; # 十二秒没有发送成功即发送超时</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">        proxy_set_header Connection &quot;Upgrade&quot;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Emm，没错，有中文注释的是配置关键点。表示 <code>20分钟</code> 没有数据读取才关闭连接。 但是有些需求不需要关闭连接啊，怎么办，来个 <code>PING</code> <code>PONG</code> 心跳咯： 然而浏览器没有这个机制啊，而且只认得服务器发送的 <code>PONG</code> 帧。也就是说，我们需要服务端发送一个 <code>PONG</code> 他浏览器会返回一个 <code>PING</code>（怪怪的然而事实就是这样） 可是我不想服务器来做这个事情，因为毕竟连接的都有时间差嘛。所以我准备在前端发送 <code>PING</code> 服务端收到后返回 <code>PONG</code> 即可。 改一改我们自己的处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;PING&quot;</span>.equals(text)) &#123;</span><br><span class="line">      ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;PONG&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 省略代码 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再改一改前端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> retry = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> ping = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wbs = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** 创建WebSocket客户端 */</span></span><br><span class="line">  wbs = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:9999/&quot;</span>)</span><br><span class="line">  <span class="comment">/** 定义接收消息弹窗显示 */</span></span><br><span class="line">  wbs.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/** 弹窗打印服务器发送的消息内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (evt.data !== <span class="string">&#x27;PONG&#x27;</span>) &#123;</span><br><span class="line">      alert(evt.data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(evt.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 定义连接打开后需要发送的消息 */</span></span><br><span class="line">  wbs.onopen = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;WebSocket连接已打开&quot;</span>)</span><br><span class="line">    <span class="comment">/** 打开连接即发送消息 */</span></span><br><span class="line">    wbs.send(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 打开后如果重试还在 清楚重试对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (retry !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(retry)</span><br><span class="line">      retry = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 连接后启动 PING，PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === ping) &#123;</span><br><span class="line">      <span class="comment">/** 7分钟心跳一次，注意这个值需要设置的比 Nginx 设置的值要小，不然被关闭了就没意义了。 */</span></span><br><span class="line">      ping = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        wbs.send(<span class="string">&quot;PING&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">60000</span> * <span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 */</span></span><br><span class="line">  wbs.onclose = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;WebSocket被关闭了&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === retry) &#123;</span><br><span class="line">      retry = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;尝试重连....&quot;</span>)</span><br><span class="line">        openWebSocket()</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 连接被关闭后停止 PING-PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> !== ping) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(ping)</span><br><span class="line">      ping = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openWebSocket();</span><br></pre></td></tr></table></figure>

<p>测试： </p>
<h2 id="一-实时消息WebSocket-4"><a href="#一-实时消息WebSocket-4" class="headerlink" title="一.实时消息WebSocket"></a>一.实时消息WebSocket</h2><p>传统的 <code>WEB</code> 开发中，通常我们渲染数据或者请求增删改的时候，都需要通过发送 <code>HTTP</code> 请求。 而每次发送 <code>HTTP</code> 请求基本都需要经历下面的历程（其实和 <code>TCP</code> 大致相同）： <img src="https://liweidan.cn/wp-content/uploads/2019/08/HTTP-PROCESS.png" alt="image-20190804143610798"> 而当我们需要一些实时消息的需求的时候，比如聊天或者消息推送，那么我们有一种做法就是。浏览器每隔几秒轮训一次服务器（因为不请求服务器就没法回复消息），走一下上面的步骤，然后服务器如果有数据响应数据，没有数据就响应空的数据。哇啊啊啊啊你看这个过程，如果我的后台系统这个账号刚好没什么生意，基本很少需要推送有人下单的消息给我，可是我还是要走这些流程，服务器也还是需要处理我这个没用的卖家的请求。 当然并不是这种方式没人采用，还是有的，因为开发简单。但是性能其实并不怎么样，而且还要浪费一个服务来处理这个请求。 这个问题看起来还是比较棘手的而且很迫切的一个需求，于是乎我们的 <code>W3C</code> 组织站了出来，为浏览器新增了一个新的协议 <code>WebSocket</code> 协议，在 <code>HTML5</code> 发布的时候新增进去的。 <code>WebSocket</code> 跟 <code>HTTP</code> 在同一层，利用 <code>HTTP</code> 向服务器请求升级 <code>WebSocket</code>，服务器应答即可将当前的连接升级为 <code>WebSocket</code> 连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET ws:&#x2F;&#x2F;localhost:9999&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket # 请求升级WebSocket</span><br><span class="line">Connection: Upgrade # 同样</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:8000</span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>

<p>服务器如果答应了，就会响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br></pre></td></tr></table></figure>

<p>这时候相当于说，我浏览器和服务器经历了三次握手，然后在中间建设了一个管道。 这个管道，谁都可以随时使用，客户端和服务端都可以同时发送消息。也就是说在上面订单通知的例子中，我服务器收到了一个订单支付成功，即可立马发送一条消息给你客户端。</p>
<h2 id="二-Netty处理WebSocket-4"><a href="#二-Netty处理WebSocket-4" class="headerlink" title="二.Netty处理WebSocket"></a>二.Netty处理WebSocket</h2><p>OK，接下来轮到 <code>Netty</code> 来干活了。 我们知道 <code>Netty</code> 基本是由一堆 <code>Handler</code> 组成一个链条来处理请求的。</p>
<h3 id="2-1-Netty的WebSocket解码器-4"><a href="#2-1-Netty的WebSocket解码器-4" class="headerlink" title="2.1 Netty的WebSocket解码器"></a>2.1 Netty的WebSocket解码器</h3><p>所以我们组装 <code>Pipeline</code> 的时候需要安装一个 <code>WebSocketServerProtocolHandler</code> 处理器，他会将 <code>WebSocket</code> 请求处理并且传递给下一个 <code>handler</code>（一般是我们的业务处理器）。构造器需要指定 <code>WebSocket</code> 处理的 <code>uri</code>。 安装：<code>pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/&quot;));</code> 具体详细的引导安装下面再说。</p>
<h3 id="2-2-编写我们自己的Handler-4"><a href="#2-2-编写我们自己的Handler-4" class="headerlink" title="2.2 编写我们自己的Handler"></a>2.2 编写我们自己的Handler</h3><p>因为浏览器发送的数据也是二进制的进行，有自己的帧规则，而上一步我们安装了 <code>Netty</code> 提供的处理器以后，这时候我们已经可以取出来浏览器发送的字符串了，所以我们自己的处理器需要处理 <code>TextWebSocketFrame</code>。这是一个数据封装的包裹（前面说的 <code>ByteBuf</code>，只不过内部已经进行了翻译）所以我们可以很简单的根据业务需求封装一些请求类以及响应类，这里为了简单不做进一步封装。 我现在有个需求，连接了 <code>Netty</code> 服务器，发送一个消息后，假装服务器有通知需要发送，每隔 <code>2</code> 秒就给浏览器发送，浏览器打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(text));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 每隔2秒发送一个消息 */</span></span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;你有一个新的淘金订单，请尽快处理&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实应该不是很难理解这个代码…</p>
<h3 id="2-3-引导安装服务器-4"><a href="#2-3-引导安装服务器-4" class="headerlink" title="2.3 引导安装服务器"></a>2.3 引导安装服务器</h3><p>我们知道 <code>WebSocket</code> 是通过 <code>HTTP</code> 来升级的，所以这时，<code>HTTP</code> 处理器还是不能少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="keyword">final</span> NotifyHandler notifyHandler = <span class="keyword">new</span> NotifyHandler();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">9999</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 新增HTTP处理器，处理请求升级问题 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">64</span> * <span class="number">1024</span>));</span><br><span class="line">                  <span class="comment">/** 安装 WebSocket 处理器 */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">                  <span class="comment">/** 安装我自己的Handler */</span></span><br><span class="line">                  socketChannel.pipeline().addLast(notifyHandler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动，进行测试。</p>
<h3 id="2-4-测试WebSocket接口-4"><a href="#2-4-测试WebSocket接口-4" class="headerlink" title="2.4 测试WebSocket接口"></a>2.4 测试WebSocket接口</h3><p>在开发的时候发现了这个很有用的小工具 <a target="_blank" rel="noopener" href="http://www.websocket-test.com/">在线测试WebSocket</a> OK，我们的端口是 <code>9999</code>，这时候只要在左侧窗口的连接地址写 <code>ws://localhost:9999/</code>，然后尝试写消息给服务器，让服务器不断的写消息给我们。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161228.gif"></p>
<h2 id="三-开发实时通知页面-4"><a href="#三-开发实时通知页面-4" class="headerlink" title="三.开发实时通知页面"></a>三.开发实时通知页面</h2><p>服务端有了，现在需要页面来做对接呀。 直接上代码好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;TEST-WEBSOCKET&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    let retry &#x3D; null</span><br><span class="line">    let wbs &#x3D; null</span><br><span class="line">    function openWebSocket() &#123;</span><br><span class="line">        &#x2F;** 创建WebSocket客户端 *&#x2F;</span><br><span class="line">        wbs &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:9999&#x2F;&quot;)</span><br><span class="line">        &#x2F;** 定义接收消息弹窗显示 *&#x2F;</span><br><span class="line">        wbs.onmessage &#x3D; (evt) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;** 弹窗打印服务器发送的消息内容 *&#x2F;</span><br><span class="line">            alert(evt.data)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 定义连接打开后需要发送的消息 *&#x2F;</span><br><span class="line">        wbs.onopen &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&quot;WebSocket连接已打开&quot;)</span><br><span class="line">            &#x2F;** 打开连接即发送消息 *&#x2F;</span><br><span class="line">            wbs.send(&quot;HELLO&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;** 打开后如果重试还在 清楚重试对象 *&#x2F;</span><br><span class="line">            if (retry !&#x3D;&#x3D; null) &#123;</span><br><span class="line">                clearInterval(retry)</span><br><span class="line">                retry &#x3D; null</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 *&#x2F;</span><br><span class="line">        wbs.onclose &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#39;WebSocket被关闭了&#39;)</span><br><span class="line">            if (null &#x3D;&#x3D;&#x3D; retry) &#123;</span><br><span class="line">                retry &#x3D; setInterval(function () &#123;</span><br><span class="line">                    console.log(&quot;尝试重连....&quot;)</span><br><span class="line">                    openWebSocket()</span><br><span class="line">                &#125;, 3000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openWebSocket();</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://liweidan.cn/wp-content/uploads/2019/08/HTML-WEBSOCKET.gif"></p>
<h2 id="四-Nginx反向代理-4"><a href="#四-Nginx反向代理-4" class="headerlink" title="四.Nginx反向代理"></a>四.Nginx反向代理</h2><p><code>Nginx</code> 通常在生产中被用作反向代理服务器，什么意思咧，相当于请求进门，进门之前，证书什么的都在这里配置。 我跟往常一样在这里配置 <code>WebSocket</code> 服务端的证书呀反向代理服务器呀。 唯独没有关注连接超时被断开的问题，上了测试，我的 <code>Web</code> 项目居然过了 <code>1</code> 分钟就总是偷偷断开。导致后面用户接受不到订单的更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 升级请求</span><br><span class="line">map $http_upgrade $connection_upgrade &#123;  </span><br><span class="line">    default upgrade;  </span><br><span class="line">    &#39;&#39; close;  </span><br><span class="line">&#125;  </span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on ;</span><br><span class="line">    server_name wbs.liweidan.com;</span><br><span class="line">    ssl_certificate   XXXXX.pem;</span><br><span class="line">    ssl_certificate_key  XXXXX.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:9999&#x2F;;  </span><br><span class="line">        proxy_http_version 1.1;  </span><br><span class="line">                proxy_connect_timeout 4s; </span><br><span class="line">        proxy_read_timeout 1200s; # 20分钟没有接受请求才超时断开</span><br><span class="line">        proxy_send_timeout 12s; # 十二秒没有发送成功即发送超时</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;  </span><br><span class="line">        proxy_set_header Connection &quot;Upgrade&quot;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Emm，没错，有中文注释的是配置关键点。表示 <code>20分钟</code> 没有数据读取才关闭连接。 但是有些需求不需要关闭连接啊，怎么办，来个 <code>PING</code> <code>PONG</code> 心跳咯： 然而浏览器没有这个机制啊，而且只认得服务器发送的 <code>PONG</code> 帧。也就是说，我们需要服务端发送一个 <code>PONG</code> 他浏览器会返回一个 <code>PING</code>（怪怪的然而事实就是这样） 可是我不想服务器来做这个事情，因为毕竟连接的都有时间差嘛。所以我准备在前端发送 <code>PING</code> 服务端收到后返回 <code>PONG</code> 即可。 改一改我们自己的处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 获取浏览器发送的消息 */</span></span><br><span class="line">    String text = msg.text();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + text);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;PING&quot;</span>.equals(text)) &#123;</span><br><span class="line">      ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;PONG&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 省略代码 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再改一改前端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> retry = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> ping = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wbs = <span class="literal">null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** 创建WebSocket客户端 */</span></span><br><span class="line">  wbs = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:9999/&quot;</span>)</span><br><span class="line">  <span class="comment">/** 定义接收消息弹窗显示 */</span></span><br><span class="line">  wbs.onmessage = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">/** 弹窗打印服务器发送的消息内容 */</span></span><br><span class="line">    <span class="keyword">if</span> (evt.data !== <span class="string">&#x27;PONG&#x27;</span>) &#123;</span><br><span class="line">      alert(evt.data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(evt.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 定义连接打开后需要发送的消息 */</span></span><br><span class="line">  wbs.onopen = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;WebSocket连接已打开&quot;</span>)</span><br><span class="line">    <span class="comment">/** 打开连接即发送消息 */</span></span><br><span class="line">    wbs.send(<span class="string">&quot;HELLO&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 打开后如果重试还在 清楚重试对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (retry !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(retry)</span><br><span class="line">      retry = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 连接后启动 PING，PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === ping) &#123;</span><br><span class="line">      <span class="comment">/** 7分钟心跳一次，注意这个值需要设置的比 Nginx 设置的值要小，不然被关闭了就没意义了。 */</span></span><br><span class="line">      ping = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        wbs.send(<span class="string">&quot;PING&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">60000</span> * <span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 连接被关闭后需要做的事情，这里是关闭后重新轮询服务端是否已经准备好了，准备好了就打开连接 */</span></span><br><span class="line">  wbs.onclose = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;WebSocket被关闭了&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> === retry) &#123;</span><br><span class="line">      retry = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;尝试重连....&quot;</span>)</span><br><span class="line">        openWebSocket()</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 连接被关闭后停止 PING-PONG 心跳 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> !== ping) &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(ping)</span><br><span class="line">      ping = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openWebSocket();</span><br></pre></td></tr></table></figure>

<p>测试： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161408.png"></p>
<h2 id="完-3"><a href="#完-3" class="headerlink" title="完"></a>完</h2><p><code>WebSocket</code> 相关内容完结。</p>
<h2 id="完-4"><a href="#完-4" class="headerlink" title="完"></a>完</h2><p><code>WebSocket</code> 相关内容完结。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/frame/Netty/netty%E4%B9%8Bbytebuf%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/frame/Netty/netty%E4%B9%8Bbytebuf%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/" class="post-title-link" itemprop="url">Netty之ByteBuf以及编解码器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-27 08:48:51" itemprop="dateCreated datePublished" datetime="2019-07-27T08:48:51+08:00">2019-07-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-12 14:42:22" itemprop="dateModified" datetime="2020-11-12T14:42:22+08:00">2020-11-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/" itemprop="url" rel="index"><span itemprop="name">frame</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-数据传输的容器ByteBuf"><a href="#一-数据传输的容器ByteBuf" class="headerlink" title="一.数据传输的容器ByteBuf"></a>一.数据传输的容器ByteBuf</h2><h3 id="1-1-简单理解一下"><a href="#1-1-简单理解一下" class="headerlink" title="1.1. 简单理解一下"></a>1.1. 简单理解一下</h3><p>OK，上一篇文章我们大致了解了 <code>Netty</code> 在运行过程中所需要的一些组件。接下来需要慢慢的深入了解这些容器了。 为了方便回忆，我先贴一段上一篇的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ByteBuf in = (ByteBuf) msg;</span><br><span class="line">String message = in.toString(Charset.defaultCharset());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在服务端代码中，使用了 <code>ByteBuf</code> 来读取客户端所传递的消息，然后实现逻辑，再使用 <code>ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes(Charset.defaultCharset().name()));</code> 来将处理后的数据重新封装成字节，从而写出去，传递给客户端。 所以大概猜一下，<code>ByteBuf</code> 是一个装载着数据字节的容器，在 <code>Netty</code> 中通过网络进行传输。客户端又重新解码，读取出服务端返回的数据。 其实，<code>jdk</code> 自己的 <code>NIO</code> 也有个类似的类 <code>ByteBuffer</code>，但是这个类，他不太灵活，所以 <code>Netty</code> 才决定重写这个类，从而达到一些比较灵活的目的：</p>
<ol>
<li>可以被自定义缓冲区类型拓展；</li>
<li>通过内置的符合缓冲区类型实现透明的零拷贝；</li>
<li>容量可以自增；</li>
<li>读写模式不需要来回切换（得益于读写指针）；</li>
<li>支持链式调用、引用计数以及池化计数。</li>
</ol>
<h3 id="1-2-深入读写指针"><a href="#1-2-深入读写指针" class="headerlink" title="1.2. 深入读写指针"></a>1.2. 深入读写指针</h3><p>上一节说了，读写模式不需要来回切换，是因为 <code>ByteBuf</code> 内部提供了两个索引 <code>readIndex</code> 以及 <code>writeIndex</code>。当我们从 <code>ByteBuf</code> 读取数据的时候，<code>readIndex</code> 会慢慢的递增已经被读取的字节数，而写入时 <code>writeIndex</code> 同样也会进行移动。 </p>
<h2 id="一-数据传输的容器ByteBuf-1"><a href="#一-数据传输的容器ByteBuf-1" class="headerlink" title="一.数据传输的容器ByteBuf"></a>一.数据传输的容器ByteBuf</h2><h3 id="1-1-简单理解一下-1"><a href="#1-1-简单理解一下-1" class="headerlink" title="1.1. 简单理解一下"></a>1.1. 简单理解一下</h3><p>OK，上一篇文章我们大致了解了 <code>Netty</code> 在运行过程中所需要的一些组件。接下来需要慢慢的深入了解这些容器了。 为了方便回忆，我先贴一段上一篇的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ByteBuf in = (ByteBuf) msg;</span><br><span class="line">String message = in.toString(Charset.defaultCharset());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在服务端代码中，使用了 <code>ByteBuf</code> 来读取客户端所传递的消息，然后实现逻辑，再使用 <code>ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes(Charset.defaultCharset().name()));</code> 来将处理后的数据重新封装成字节，从而写出去，传递给客户端。 所以大概猜一下，<code>ByteBuf</code> 是一个装载着数据字节的容器，在 <code>Netty</code> 中通过网络进行传输。客户端又重新解码，读取出服务端返回的数据。 其实，<code>jdk</code> 自己的 <code>NIO</code> 也有个类似的类 <code>ByteBuffer</code>，但是这个类，他不太灵活，所以 <code>Netty</code> 才决定重写这个类，从而达到一些比较灵活的目的：</p>
<ol>
<li>可以被自定义缓冲区类型拓展；</li>
<li>通过内置的符合缓冲区类型实现透明的零拷贝；</li>
<li>容量可以自增；</li>
<li>读写模式不需要来回切换（得益于读写指针）；</li>
<li>支持链式调用、引用计数以及池化计数。</li>
</ol>
<h3 id="1-2-深入读写指针-1"><a href="#1-2-深入读写指针-1" class="headerlink" title="1.2. 深入读写指针"></a>1.2. 深入读写指针</h3><p>上一节说了，读写模式不需要来回切换，是因为 <code>ByteBuf</code> 内部提供了两个索引 <code>readIndex</code> 以及 <code>writeIndex</code>。当我们从 <code>ByteBuf</code> 读取数据的时候，<code>readIndex</code> 会慢慢的递增已经被读取的字节数，而写入时 <code>writeIndex</code> 同样也会进行移动。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161455.png"> </p>
<p>如上图所示，一个16字节的 <code>ByteBuf</code>，刚开始什么都没有的时候，读索引和写索引同在第 <code>0</code> 位上，随着数据慢慢写入，写索引会向右进行移动。这时候没有读取的发生，所以读索引还停留在第 <code>0</code> 位上，而随着我们业务的需求，会读取消息，所以读指针慢慢向后移动，但是这里有个需要注意的地方是，读索引不能超过写索引的位数（即使超过了读后面的消息也没什么意义），如果强行超过，<code>Netty</code> 会给你来一个 <code>IndexOutOfBoundsException</code>。 <code>ByteBuf</code> 自带有一些方法，通过调用 <code>read</code> 和 <code>write</code> 开头的方法，将会推进这两个相对应的索引位置，而如果说我们不想要推动索引而是想直接读取，则可以通过调用 <code>get</code> <code>set</code> 开头的方法，便可以直接操作 <code>ByteBuf</code> 中相对应位置的数据。 可以指定 <code>ByteBuf</code> 的最大容量，如果不指定默认是 <code>Integer.MAX_VALUE</code>。</p>
<h3 id="1-3-不同内存下的-ByteBuf"><a href="#1-3-不同内存下的-ByteBuf" class="headerlink" title="1.3. 不同内存下的 ByteBuf"></a>1.3. 不同内存下的 <code>ByteBuf</code></h3><h4 id="1-1-3-1-堆缓冲区的ByteBuf"><a href="#1-1-3-1-堆缓冲区的ByteBuf" class="headerlink" title="1.1.3.1 堆缓冲区的ByteBuf"></a>1.1.3.1 堆缓冲区的ByteBuf</h4><p>最常用的模式下是堆缓冲区的 <code>ByteBuf</code>，顾名思义堆缓冲区 <code>ByteBuf</code> 是用于存储在 <code>JVM</code> 堆内存中的缓冲区。这种模式称为 <code>支撑数组</code>。他可以在 <code>Java</code> 程序中快速的创建以及被垃圾回收器回收，但是，如果需要写出到 <code>IO设备</code> 则需要经过以下这么几个步骤。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161515.png"> </p>
<p>上图所示，<code>Netty</code> 需要先将堆上的数据逐一拷贝到系统直接缓冲区，然后再发送出去。会造成多了一步拷贝的过程。 但是，<code>Java</code> 可以直接操作堆缓冲区的数据呀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (heapBuf.hasArray()) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] arrays = heapBuf.array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-2-直接缓冲区"><a href="#1-1-3-2-直接缓冲区" class="headerlink" title="1.1.3.2 直接缓冲区"></a>1.1.3.2 直接缓冲区</h4><p><code>JDK 1.4</code> 以后官方提供了直接向系统申请内存的方法，申请后的内存也不在垃圾回收器清理范围以内，所以当我们申请了直接内存缓冲区的时候，都需要进行手动释放，否则将会造成系统内存溢出。 直接缓冲区的优点刚好是堆缓冲区最不擅长的点，可以直接调用本地 <code>IO</code> 设备，不需要通过拷贝从而将数据传输出去。 但是另外的缺点也有：相比堆缓冲区，如果程序需要读取操作缓冲区的数据的时候，则需要跟以上第一步逆相反的步骤，将直接内存缓冲区的数据拷贝到堆缓冲区才可以进行操作。而且向系统申请和释放内存也会造成性能的降低。</p>
<h4 id="1-1-3-3-复合缓冲区"><a href="#1-1-3-3-复合缓冲区" class="headerlink" title="1.1.3.3 复合缓冲区"></a>1.1.3.3 复合缓冲区</h4><p><code>jdk</code> 完全没有的一个功能，可以提供消息体复用的优势。 比如 <code>HTTP</code> 协议传输消息的时候，我们知道 <code>HTTP</code> 头部很多时候是相似或者说相同的，那么头部就可以存储在直接内存中，使用复合缓冲区 <code>CompositeByteBuf</code> 来聚合直接缓冲区中的头部信息以及堆内存中的消息体，然后进行写出。</p>
<blockquote>
<p>因为可能包含直接内存分配和非直接内存分配，如果只存在一个聚合ByteBuf元素，那么调用 <code>hasArray()</code> 将直接返回这个元素的结果，否则会返回 <code>false</code></p>
</blockquote>
<p>创建复合缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();</span><br><span class="line">ByteBuf head = ...;</span><br><span class="line">ByteBuf body = ...;</span><br><span class="line">compBuf.addComponents(head, body);</span><br></pre></td></tr></table></figure>

<p>访问缓冲区数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();</span><br><span class="line"><span class="keyword">int</span> length = compBuf.readableBytes();</span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">compBuf.getBytes(compBuf.readerIndex(), arr);<span class="comment">// 读取数据到数组中</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-4-池化缓冲区"><a href="#1-1-3-4-池化缓冲区" class="headerlink" title="1.1.3.4 池化缓冲区"></a>1.1.3.4 池化缓冲区</h4><p>一般来说，我们需要池化缓冲区，达到可以复用的效果，也可以减少计算机资源的开销，所以 <code>Netty</code> 提供了 <code>ByteBufAllocator</code> 来实现缓冲区的池化效果。 我们可以通过 <code>ByteBufAllocator.DEFAULT</code> 来获取 <code>ByteBufAllocator</code> 对象，从而调用以下方法，建立我们所需要的缓冲区：</p>
<p>方法名称</p>
<p>说明</p>
<p>buffer()<br>buffer(int initialCapacity)<br>buffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆或者直接内存的 <code>ByteBuf</code></p>
<p>heapBuffer()<br>heapBuffer(int initialCapacity)<br>heapBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆缓冲区的 <code>ByteBuf</code></p>
<p>directBuffer()<br>directBuffer(int initialCapacity)<br>directBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于直接内存缓冲区的 <code>ByteBuf</code></p>
<p>compositeBuffer()<br>compositeBuffer(int maxNumComponents)<br>compositeDirectBuffer()<br>compositeDirectBuffer(int maxNumComponents)<br>compositeHeapBuffer()<br>compositeHeapBuffer(int maxNumComponents)</p>
<p>返回指定最大元素的基于堆或者直接内存的<br>缓冲区视图</p>
<p>ioBuffer()</p>
<p>返回基于 <code>Socket</code> 的 <code>IO</code> 操作的 <code>ByteBuf</code></p>
<p>运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ByteBuf&gt; byteBufs = <span class="keyword">new</span> ArrayList&lt;ByteBuf&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">  ByteBuf byteBuf2 = ByteBufAllocator.DEFAULT.directBuffer(<span class="number">200</span>);</span><br><span class="line">  byteBuf2.writeBytes(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name()));</span><br><span class="line">  byteBufs.add(byteBuf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161610.png"> </p>
<p>可以看到，内存一直不断飙升，直到系统拒绝给出内存，抛出异常，程序终止，进程被干掉才结束。</p>
<h4 id="1-1-3-5-非池化缓冲区"><a href="#1-1-3-5-非池化缓冲区" class="headerlink" title="1.1.3.5 非池化缓冲区"></a>1.1.3.5 非池化缓冲区</h4><p>即我第一篇中用到的 <code>Unpooled</code> 类，<code>api</code> 跟上面差不多，不再重复。 主要提供给其他不需要使用 <code>Netty</code> 的项目使用。</p>
<h4 id="1-1-3-6-ByteBufUtil"><a href="#1-1-3-6-ByteBufUtil" class="headerlink" title="1.1.3.6 ByteBufUtil"></a>1.1.3.6 ByteBufUtil</h4><p>主要提供两个方法使用： <code>hexdump()</code> : 主要用于将缓冲区内容写入日志，易于调试，也可以还原成字节数组。 <code>equals(ByteBuf, ByteBuf)</code> : 传递两个 <code>ByteBuf</code> 用于比较相等性。</p>
<h4 id="1-1-3-7-引用计数（TODO）"><a href="#1-1-3-7-引用计数（TODO）" class="headerlink" title="1.1.3.7 引用计数（TODO）"></a>1.1.3.7 引用计数（TODO）</h4><p>这块放在后面 <code>ChannelPipeline</code> 再说。</p>
<h2 id="二-解码和编码"><a href="#二-解码和编码" class="headerlink" title="二.解码和编码"></a>二.解码和编码</h2><h3 id="2-1-啰嗦一下什么是编解码器"><a href="#2-1-啰嗦一下什么是编解码器" class="headerlink" title="2.1 啰嗦一下什么是编解码器"></a>2.1 啰嗦一下什么是编解码器</h3><p>本来应该不需要这个的，但是还是为了篇幅的完整性还是啰嗦一下。 我们知道在传递消息的时候，我们的 <code>Java</code> 对象是不能够实现网络传输的，必须将对象序列化成某种格式（Byte数组），然后网卡再编码成 <code>10101…</code> 传输给另外一台服务器，另外的一台服务器再从 <code>10101...</code> 去重新解码，解成我们所序列化后的数组，然后传递到我们程序再使用我们自己的规则去重新把对象信息还原回来（当然此时客户端的对象的元信息跟服务器端的没有半毛钱关系） 大白话说就是，通过某种规则，在客户端机器上创建一个数据一毛一样的对象。 我们网络开发常见的编解码器有哪些比较耳濡目染的，大概就是 <code>JSON</code> 了吧，可读性强，兼容性棒（各个语言都支持），都 <code>9012</code> 年了就不要来一句 <code>XML</code> 了吧，如果还说 <code>XML</code> 我立马把43码的鞋子pia到你脸上去。 然而，除了 <code>JSON</code> 格式，如果不需要考虑兼容性最强的话，我们也可以使用同行语言都懂的 <code>Byte</code> 数组进行传输，总的来说，使用 <code>Byte</code> 数组可以达到效率更高（编码和解码），传输容量更小，传输速度更快的目的。因为 <code>JSON</code> 格式毕竟都是字符串，传输容量还是属于比较大的，而且频繁操作 <code>String</code> 编码和解码的效率也更低。</p>
<h3 id="2-2-Netty自带的编解码器"><a href="#2-2-Netty自带的编解码器" class="headerlink" title="2.2 Netty自带的编解码器"></a>2.2 Netty自带的编解码器</h3><ol>
<li>ByteToMessageDecoder 和 ReplayingDecoder；</li>
<li>MessageToMessageDecoder；</li>
</ol>
<h4 id="2-2-1-ByteToMessageDecoder"><a href="#2-2-1-ByteToMessageDecoder" class="headerlink" title="2.2.1 ByteToMessageDecoder"></a>2.2.1 ByteToMessageDecoder</h4><p><code>ByteToMessageDecoder</code> 是一个抽象的基类，通过我们做解码的方式去拓展。 我们可以编写自己的解码类，继承 <code>ByteToMessageDecoder</code> 类，需要编写以下的编码方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>比如，我们需要读取多个 <code>int</code> 值，我们也知道一个 <code>int</code> 值的长度是 <code>4</code>，所以我们在读取的时候，就需要判断 <code>ByteBuf</code> 的可读长度是否达到了 <code>4</code> ，才开始读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoderHandler</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (byteBuf.readableBytes() &gt; <span class="number">4</span>) &#123;</span><br><span class="line">      list.add(byteBuf.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递的参数中，<code>List&lt;Object&gt; list</code> 是用来保存解码信息的，当我们解码一个对象的时候，信息将保存在这里，<code>Netty</code> 将会为我们把这个 <code>list</code> 传递给 <code>ChannelPipeline</code> 的下一个 <code>ChannelInboundHandler</code> 处理器中。 当然，<code>ByteToMessageDecoder</code> 还提供了一个 <code>decodeLast</code> 方法，用来当 <code>Channel</code> 变成非活动状态的时候，调用最后一次解码。 来个例子： 现在有个需求，要求客户端发送 <code>RandomNum</code> 给服务端，服务端返回 <code>16</code> 个 <code>int</code> 类型的随机数，客户端接收并打印：</p>
<h5 id="服务端Handler"><a href="#服务端Handler" class="headerlink" title="服务端Handler"></a>服务端Handler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机数处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">if</span> (message.equals(<span class="string">&quot;RandomNumber&quot;</span>)) &#123;</span><br><span class="line">      ByteBuf byteBuf = ctx.channel().alloc().heapBuffer();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        byteBuf.writeInt(<span class="keyword">new</span> Random().nextInt() * <span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务端引导代码"><a href="#服务端引导代码" class="headerlink" title="服务端引导代码"></a>服务端引导代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> IntegerHandler handler = <span class="keyword">new</span> IntegerHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端解码器"><a href="#客户端解码器" class="headerlink" title="客户端解码器"></a>客户端解码器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * .</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 一个 int 是 4 个字节 */</span></span><br><span class="line">    <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      out.add(in.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端处理Handler"><a href="#客户端处理Handler" class="headerlink" title="客户端处理Handler"></a>客户端处理Handler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">Object</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;RandomNumber&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端引导代码"><a href="#客户端引导代码" class="headerlink" title="客户端引导代码"></a>客户端引导代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端启动类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">      b.group(group)</span><br><span class="line">              .channel(NioSocketChannel.class)</span><br><span class="line">              .remoteAddress(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>))</span><br><span class="line">              .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(<span class="keyword">new</span> ToIntegerDecoder(), <span class="keyword">new</span> RequestHandler());</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      ChannelFuture future = b.connect().sync();</span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h5><p><img src="./RandomNettyDemo.gif"></p>
<h4 id="2-2-2-ReplayingDecoder"><a href="#2-2-2-ReplayingDecoder" class="headerlink" title="2.2.2 ReplayingDecoder"></a>2.2.2 ReplayingDecoder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    out.add(in.readInt());</span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ReplayingDecoder</code> 有个泛型，表示需要处理的状态类型，使用 <code>Void</code> 表示没有状态需要处理。 与之前不同的是，每读取一次就会调用一次后面的处理器，因为每次解码都会发送。 需要注意 <code>ReplayingDecoder</code> 并不是支持所有的 <code>ByteBuf</code> 操作，如果调用不支持的方法，将会抛出异常。而且效率较上面的解码器比较低下。</p>
<h4 id="2-2-3-MessageToMessageDecoder"><a href="#2-2-3-MessageToMessageDecoder" class="headerlink" title="2.2.3 MessageToMessageDecoder"></a>2.2.3 MessageToMessageDecoder</h4><p>这个的作用是将一种消息的格式转换为另外一种消息的格式。 不多说上代码就好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;<span class="comment">// 泛型表示传入的类型</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    out.add(<span class="string">&quot;String:&quot;</span> + String.valueOf(msg));</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-TooLongFrameException"><a href="#2-2-4-TooLongFrameException" class="headerlink" title="2.2.4 TooLongFrameException"></a>2.2.4 TooLongFrameException</h4><p>这是一个异常类，用于让我们自定义抛出异常的，主要作用是为了保护 <code>Netty</code> 程序的内存不至于被过大的消息体耗尽，所以我们可以定义一个 <code>Decoder</code>，用于判断消息体是否超出我们的需求，如果超出可以直接抛出异常，终止调用链的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectTooLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALLOW_LENGTH = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readableBytes = in.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (readableBytes &gt; ALLOW_LENGTH) &#123;</span><br><span class="line">        <span class="comment">// 清空ByteBuf</span></span><br><span class="line">      in.skipBytes(readableBytes);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException(<span class="string">&quot;Bytes Too Long!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-MessageToByteEncoder-MessageToMessageEncoder"><a href="#2-2-5-MessageToByteEncoder-MessageToMessageEncoder" class="headerlink" title="2.2.5 MessageToByteEncoder/MessageToMessageEncoder"></a>2.2.5 MessageToByteEncoder/MessageToMessageEncoder</h4><p>其实与解码器相对应，方法参数差不多，偷懒不打算写了。</p>
<h4 id="2-2-6-编解码一体"><a href="#2-2-6-编解码一体" class="headerlink" title="2.2.6 编解码一体"></a>2.2.6 编解码一体</h4><p>项目上，我们一般都会把编解码这种粗活交给一个 <code>Maven</code> 模块来做，当然这样子的话就需要在客户端服务端重复安装编解码器了。 聚合在一起的一种方式是使用 <code>ByteToMessageCodec</code>，通过集成他重写编码和解码两个方法达到重用。 还有另外一种方法是通过继承 <code>CombinedChannelDuplexHandler</code> ，在泛型中指定编解码的类来实现。 当然这两种方式看个人喜好使用，我的话偏向于后者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedIntegerCodec</span> <span class="keyword">extends</span> <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">IntegerDecoder</span>, <span class="title">IntegerEncoder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CombinedIntegerCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> IntegerDecoder(), <span class="keyword">new</span> IntegerEncoder())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续…… </p>
<p>如上图所示，一个16字节的 <code>ByteBuf</code>，刚开始什么都没有的时候，读索引和写索引同在第 <code>0</code> 位上，随着数据慢慢写入，写索引会向右进行移动。这时候没有读取的发生，所以读索引还停留在第 <code>0</code> 位上，而随着我们业务的需求，会读取消息，所以读指针慢慢向后移动，但是这里有个需要注意的地方是，读索引不能超过写索引的位数（即使超过了读后面的消息也没什么意义），如果强行超过，<code>Netty</code> 会给你来一个 <code>IndexOutOfBoundsException</code>。 <code>ByteBuf</code> 自带有一些方法，通过调用 <code>read</code> 和 <code>write</code> 开头的方法，将会推进这两个相对应的索引位置，而如果说我们不想要推动索引而是想直接读取，则可以通过调用 <code>get</code> <code>set</code> 开头的方法，便可以直接操作 <code>ByteBuf</code> 中相对应位置的数据。 可以指定 <code>ByteBuf</code> 的最大容量，如果不指定默认是 <code>Integer.MAX_VALUE</code>。</p>
<h3 id="1-3-不同内存下的-ByteBuf-1"><a href="#1-3-不同内存下的-ByteBuf-1" class="headerlink" title="1.3. 不同内存下的 ByteBuf"></a>1.3. 不同内存下的 <code>ByteBuf</code></h3><h4 id="1-1-3-1-堆缓冲区的ByteBuf-1"><a href="#1-1-3-1-堆缓冲区的ByteBuf-1" class="headerlink" title="1.1.3.1 堆缓冲区的ByteBuf"></a>1.1.3.1 堆缓冲区的ByteBuf</h4><p>最常用的模式下是堆缓冲区的 <code>ByteBuf</code>，顾名思义堆缓冲区 <code>ByteBuf</code> 是用于存储在 <code>JVM</code> 堆内存中的缓冲区。这种模式称为 <code>支撑数组</code>。他可以在 <code>Java</code> 程序中快速的创建以及被垃圾回收器回收，但是，如果需要写出到 <code>IO设备</code> 则需要经过以下这么几个步骤。 </p>
<h2 id="一-数据传输的容器ByteBuf-2"><a href="#一-数据传输的容器ByteBuf-2" class="headerlink" title="一.数据传输的容器ByteBuf"></a>一.数据传输的容器ByteBuf</h2><h3 id="1-1-简单理解一下-2"><a href="#1-1-简单理解一下-2" class="headerlink" title="1.1. 简单理解一下"></a>1.1. 简单理解一下</h3><p>OK，上一篇文章我们大致了解了 <code>Netty</code> 在运行过程中所需要的一些组件。接下来需要慢慢的深入了解这些容器了。 为了方便回忆，我先贴一段上一篇的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ByteBuf in = (ByteBuf) msg;</span><br><span class="line">String message = in.toString(Charset.defaultCharset());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在服务端代码中，使用了 <code>ByteBuf</code> 来读取客户端所传递的消息，然后实现逻辑，再使用 <code>ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes(Charset.defaultCharset().name()));</code> 来将处理后的数据重新封装成字节，从而写出去，传递给客户端。 所以大概猜一下，<code>ByteBuf</code> 是一个装载着数据字节的容器，在 <code>Netty</code> 中通过网络进行传输。客户端又重新解码，读取出服务端返回的数据。 其实，<code>jdk</code> 自己的 <code>NIO</code> 也有个类似的类 <code>ByteBuffer</code>，但是这个类，他不太灵活，所以 <code>Netty</code> 才决定重写这个类，从而达到一些比较灵活的目的：</p>
<ol>
<li>可以被自定义缓冲区类型拓展；</li>
<li>通过内置的符合缓冲区类型实现透明的零拷贝；</li>
<li>容量可以自增；</li>
<li>读写模式不需要来回切换（得益于读写指针）；</li>
<li>支持链式调用、引用计数以及池化计数。</li>
</ol>
<h3 id="1-2-深入读写指针-2"><a href="#1-2-深入读写指针-2" class="headerlink" title="1.2. 深入读写指针"></a>1.2. 深入读写指针</h3><p>上一节说了，读写模式不需要来回切换，是因为 <code>ByteBuf</code> 内部提供了两个索引 <code>readIndex</code> 以及 <code>writeIndex</code>。当我们从 <code>ByteBuf</code> 读取数据的时候，<code>readIndex</code> 会慢慢的递增已经被读取的字节数，而写入时 <code>writeIndex</code> 同样也会进行移动。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161455.png"> </p>
<p>如上图所示，一个16字节的 <code>ByteBuf</code>，刚开始什么都没有的时候，读索引和写索引同在第 <code>0</code> 位上，随着数据慢慢写入，写索引会向右进行移动。这时候没有读取的发生，所以读索引还停留在第 <code>0</code> 位上，而随着我们业务的需求，会读取消息，所以读指针慢慢向后移动，但是这里有个需要注意的地方是，读索引不能超过写索引的位数（即使超过了读后面的消息也没什么意义），如果强行超过，<code>Netty</code> 会给你来一个 <code>IndexOutOfBoundsException</code>。 <code>ByteBuf</code> 自带有一些方法，通过调用 <code>read</code> 和 <code>write</code> 开头的方法，将会推进这两个相对应的索引位置，而如果说我们不想要推动索引而是想直接读取，则可以通过调用 <code>get</code> <code>set</code> 开头的方法，便可以直接操作 <code>ByteBuf</code> 中相对应位置的数据。 可以指定 <code>ByteBuf</code> 的最大容量，如果不指定默认是 <code>Integer.MAX_VALUE</code>。</p>
<h3 id="1-3-不同内存下的-ByteBuf-2"><a href="#1-3-不同内存下的-ByteBuf-2" class="headerlink" title="1.3. 不同内存下的 ByteBuf"></a>1.3. 不同内存下的 <code>ByteBuf</code></h3><h4 id="1-1-3-1-堆缓冲区的ByteBuf-2"><a href="#1-1-3-1-堆缓冲区的ByteBuf-2" class="headerlink" title="1.1.3.1 堆缓冲区的ByteBuf"></a>1.1.3.1 堆缓冲区的ByteBuf</h4><p>最常用的模式下是堆缓冲区的 <code>ByteBuf</code>，顾名思义堆缓冲区 <code>ByteBuf</code> 是用于存储在 <code>JVM</code> 堆内存中的缓冲区。这种模式称为 <code>支撑数组</code>。他可以在 <code>Java</code> 程序中快速的创建以及被垃圾回收器回收，但是，如果需要写出到 <code>IO设备</code> 则需要经过以下这么几个步骤。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161515.png"> </p>
<p>上图所示，<code>Netty</code> 需要先将堆上的数据逐一拷贝到系统直接缓冲区，然后再发送出去。会造成多了一步拷贝的过程。 但是，<code>Java</code> 可以直接操作堆缓冲区的数据呀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (heapBuf.hasArray()) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] arrays = heapBuf.array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-2-直接缓冲区-1"><a href="#1-1-3-2-直接缓冲区-1" class="headerlink" title="1.1.3.2 直接缓冲区"></a>1.1.3.2 直接缓冲区</h4><p><code>JDK 1.4</code> 以后官方提供了直接向系统申请内存的方法，申请后的内存也不在垃圾回收器清理范围以内，所以当我们申请了直接内存缓冲区的时候，都需要进行手动释放，否则将会造成系统内存溢出。 直接缓冲区的优点刚好是堆缓冲区最不擅长的点，可以直接调用本地 <code>IO</code> 设备，不需要通过拷贝从而将数据传输出去。 但是另外的缺点也有：相比堆缓冲区，如果程序需要读取操作缓冲区的数据的时候，则需要跟以上第一步逆相反的步骤，将直接内存缓冲区的数据拷贝到堆缓冲区才可以进行操作。而且向系统申请和释放内存也会造成性能的降低。</p>
<h4 id="1-1-3-3-复合缓冲区-1"><a href="#1-1-3-3-复合缓冲区-1" class="headerlink" title="1.1.3.3 复合缓冲区"></a>1.1.3.3 复合缓冲区</h4><p><code>jdk</code> 完全没有的一个功能，可以提供消息体复用的优势。 比如 <code>HTTP</code> 协议传输消息的时候，我们知道 <code>HTTP</code> 头部很多时候是相似或者说相同的，那么头部就可以存储在直接内存中，使用复合缓冲区 <code>CompositeByteBuf</code> 来聚合直接缓冲区中的头部信息以及堆内存中的消息体，然后进行写出。</p>
<blockquote>
<p>因为可能包含直接内存分配和非直接内存分配，如果只存在一个聚合ByteBuf元素，那么调用 <code>hasArray()</code> 将直接返回这个元素的结果，否则会返回 <code>false</code></p>
</blockquote>
<p>创建复合缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();</span><br><span class="line">ByteBuf head = ...;</span><br><span class="line">ByteBuf body = ...;</span><br><span class="line">compBuf.addComponents(head, body);</span><br></pre></td></tr></table></figure>

<p>访问缓冲区数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();</span><br><span class="line"><span class="keyword">int</span> length = compBuf.readableBytes();</span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">compBuf.getBytes(compBuf.readerIndex(), arr);<span class="comment">// 读取数据到数组中</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-4-池化缓冲区-1"><a href="#1-1-3-4-池化缓冲区-1" class="headerlink" title="1.1.3.4 池化缓冲区"></a>1.1.3.4 池化缓冲区</h4><p>一般来说，我们需要池化缓冲区，达到可以复用的效果，也可以减少计算机资源的开销，所以 <code>Netty</code> 提供了 <code>ByteBufAllocator</code> 来实现缓冲区的池化效果。 我们可以通过 <code>ByteBufAllocator.DEFAULT</code> 来获取 <code>ByteBufAllocator</code> 对象，从而调用以下方法，建立我们所需要的缓冲区：</p>
<p>方法名称</p>
<p>说明</p>
<p>buffer()<br>buffer(int initialCapacity)<br>buffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆或者直接内存的 <code>ByteBuf</code></p>
<p>heapBuffer()<br>heapBuffer(int initialCapacity)<br>heapBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆缓冲区的 <code>ByteBuf</code></p>
<p>directBuffer()<br>directBuffer(int initialCapacity)<br>directBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于直接内存缓冲区的 <code>ByteBuf</code></p>
<p>compositeBuffer()<br>compositeBuffer(int maxNumComponents)<br>compositeDirectBuffer()<br>compositeDirectBuffer(int maxNumComponents)<br>compositeHeapBuffer()<br>compositeHeapBuffer(int maxNumComponents)</p>
<p>返回指定最大元素的基于堆或者直接内存的<br>缓冲区视图</p>
<p>ioBuffer()</p>
<p>返回基于 <code>Socket</code> 的 <code>IO</code> 操作的 <code>ByteBuf</code></p>
<p>运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ByteBuf&gt; byteBufs = <span class="keyword">new</span> ArrayList&lt;ByteBuf&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">  ByteBuf byteBuf2 = ByteBufAllocator.DEFAULT.directBuffer(<span class="number">200</span>);</span><br><span class="line">  byteBuf2.writeBytes(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name()));</span><br><span class="line">  byteBufs.add(byteBuf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161610.png"> </p>
<p>可以看到，内存一直不断飙升，直到系统拒绝给出内存，抛出异常，程序终止，进程被干掉才结束。</p>
<h4 id="1-1-3-5-非池化缓冲区-1"><a href="#1-1-3-5-非池化缓冲区-1" class="headerlink" title="1.1.3.5 非池化缓冲区"></a>1.1.3.5 非池化缓冲区</h4><p>即我第一篇中用到的 <code>Unpooled</code> 类，<code>api</code> 跟上面差不多，不再重复。 主要提供给其他不需要使用 <code>Netty</code> 的项目使用。</p>
<h4 id="1-1-3-6-ByteBufUtil-1"><a href="#1-1-3-6-ByteBufUtil-1" class="headerlink" title="1.1.3.6 ByteBufUtil"></a>1.1.3.6 ByteBufUtil</h4><p>主要提供两个方法使用： <code>hexdump()</code> : 主要用于将缓冲区内容写入日志，易于调试，也可以还原成字节数组。 <code>equals(ByteBuf, ByteBuf)</code> : 传递两个 <code>ByteBuf</code> 用于比较相等性。</p>
<h4 id="1-1-3-7-引用计数（TODO）-1"><a href="#1-1-3-7-引用计数（TODO）-1" class="headerlink" title="1.1.3.7 引用计数（TODO）"></a>1.1.3.7 引用计数（TODO）</h4><p>这块放在后面 <code>ChannelPipeline</code> 再说。</p>
<h2 id="二-解码和编码-1"><a href="#二-解码和编码-1" class="headerlink" title="二.解码和编码"></a>二.解码和编码</h2><h3 id="2-1-啰嗦一下什么是编解码器-1"><a href="#2-1-啰嗦一下什么是编解码器-1" class="headerlink" title="2.1 啰嗦一下什么是编解码器"></a>2.1 啰嗦一下什么是编解码器</h3><p>本来应该不需要这个的，但是还是为了篇幅的完整性还是啰嗦一下。 我们知道在传递消息的时候，我们的 <code>Java</code> 对象是不能够实现网络传输的，必须将对象序列化成某种格式（Byte数组），然后网卡再编码成 <code>10101…</code> 传输给另外一台服务器，另外的一台服务器再从 <code>10101...</code> 去重新解码，解成我们所序列化后的数组，然后传递到我们程序再使用我们自己的规则去重新把对象信息还原回来（当然此时客户端的对象的元信息跟服务器端的没有半毛钱关系） 大白话说就是，通过某种规则，在客户端机器上创建一个数据一毛一样的对象。 我们网络开发常见的编解码器有哪些比较耳濡目染的，大概就是 <code>JSON</code> 了吧，可读性强，兼容性棒（各个语言都支持），都 <code>9012</code> 年了就不要来一句 <code>XML</code> 了吧，如果还说 <code>XML</code> 我立马把43码的鞋子pia到你脸上去。 然而，除了 <code>JSON</code> 格式，如果不需要考虑兼容性最强的话，我们也可以使用同行语言都懂的 <code>Byte</code> 数组进行传输，总的来说，使用 <code>Byte</code> 数组可以达到效率更高（编码和解码），传输容量更小，传输速度更快的目的。因为 <code>JSON</code> 格式毕竟都是字符串，传输容量还是属于比较大的，而且频繁操作 <code>String</code> 编码和解码的效率也更低。</p>
<h3 id="2-2-Netty自带的编解码器-1"><a href="#2-2-Netty自带的编解码器-1" class="headerlink" title="2.2 Netty自带的编解码器"></a>2.2 Netty自带的编解码器</h3><ol>
<li>ByteToMessageDecoder 和 ReplayingDecoder；</li>
<li>MessageToMessageDecoder；</li>
</ol>
<h4 id="2-2-1-ByteToMessageDecoder-1"><a href="#2-2-1-ByteToMessageDecoder-1" class="headerlink" title="2.2.1 ByteToMessageDecoder"></a>2.2.1 ByteToMessageDecoder</h4><p><code>ByteToMessageDecoder</code> 是一个抽象的基类，通过我们做解码的方式去拓展。 我们可以编写自己的解码类，继承 <code>ByteToMessageDecoder</code> 类，需要编写以下的编码方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>比如，我们需要读取多个 <code>int</code> 值，我们也知道一个 <code>int</code> 值的长度是 <code>4</code>，所以我们在读取的时候，就需要判断 <code>ByteBuf</code> 的可读长度是否达到了 <code>4</code> ，才开始读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoderHandler</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (byteBuf.readableBytes() &gt; <span class="number">4</span>) &#123;</span><br><span class="line">      list.add(byteBuf.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递的参数中，<code>List&lt;Object&gt; list</code> 是用来保存解码信息的，当我们解码一个对象的时候，信息将保存在这里，<code>Netty</code> 将会为我们把这个 <code>list</code> 传递给 <code>ChannelPipeline</code> 的下一个 <code>ChannelInboundHandler</code> 处理器中。 当然，<code>ByteToMessageDecoder</code> 还提供了一个 <code>decodeLast</code> 方法，用来当 <code>Channel</code> 变成非活动状态的时候，调用最后一次解码。 来个例子： 现在有个需求，要求客户端发送 <code>RandomNum</code> 给服务端，服务端返回 <code>16</code> 个 <code>int</code> 类型的随机数，客户端接收并打印：</p>
<h5 id="服务端Handler-1"><a href="#服务端Handler-1" class="headerlink" title="服务端Handler"></a>服务端Handler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机数处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">if</span> (message.equals(<span class="string">&quot;RandomNumber&quot;</span>)) &#123;</span><br><span class="line">      ByteBuf byteBuf = ctx.channel().alloc().heapBuffer();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        byteBuf.writeInt(<span class="keyword">new</span> Random().nextInt() * <span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务端引导代码-1"><a href="#服务端引导代码-1" class="headerlink" title="服务端引导代码"></a>服务端引导代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> IntegerHandler handler = <span class="keyword">new</span> IntegerHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端解码器-1"><a href="#客户端解码器-1" class="headerlink" title="客户端解码器"></a>客户端解码器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * .</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 一个 int 是 4 个字节 */</span></span><br><span class="line">    <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      out.add(in.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端处理Handler-1"><a href="#客户端处理Handler-1" class="headerlink" title="客户端处理Handler"></a>客户端处理Handler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">Object</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;RandomNumber&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端引导代码-1"><a href="#客户端引导代码-1" class="headerlink" title="客户端引导代码"></a>客户端引导代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端启动类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">      b.group(group)</span><br><span class="line">              .channel(NioSocketChannel.class)</span><br><span class="line">              .remoteAddress(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>))</span><br><span class="line">              .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(<span class="keyword">new</span> ToIntegerDecoder(), <span class="keyword">new</span> RequestHandler());</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      ChannelFuture future = b.connect().sync();</span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行效果-1"><a href="#运行效果-1" class="headerlink" title="运行效果"></a>运行效果</h5><p><img src="./RandomNettyDemo.gif"></p>
<h4 id="2-2-2-ReplayingDecoder-1"><a href="#2-2-2-ReplayingDecoder-1" class="headerlink" title="2.2.2 ReplayingDecoder"></a>2.2.2 ReplayingDecoder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    out.add(in.readInt());</span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ReplayingDecoder</code> 有个泛型，表示需要处理的状态类型，使用 <code>Void</code> 表示没有状态需要处理。 与之前不同的是，每读取一次就会调用一次后面的处理器，因为每次解码都会发送。 需要注意 <code>ReplayingDecoder</code> 并不是支持所有的 <code>ByteBuf</code> 操作，如果调用不支持的方法，将会抛出异常。而且效率较上面的解码器比较低下。</p>
<h4 id="2-2-3-MessageToMessageDecoder-1"><a href="#2-2-3-MessageToMessageDecoder-1" class="headerlink" title="2.2.3 MessageToMessageDecoder"></a>2.2.3 MessageToMessageDecoder</h4><p>这个的作用是将一种消息的格式转换为另外一种消息的格式。 不多说上代码就好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;<span class="comment">// 泛型表示传入的类型</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    out.add(<span class="string">&quot;String:&quot;</span> + String.valueOf(msg));</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-TooLongFrameException-1"><a href="#2-2-4-TooLongFrameException-1" class="headerlink" title="2.2.4 TooLongFrameException"></a>2.2.4 TooLongFrameException</h4><p>这是一个异常类，用于让我们自定义抛出异常的，主要作用是为了保护 <code>Netty</code> 程序的内存不至于被过大的消息体耗尽，所以我们可以定义一个 <code>Decoder</code>，用于判断消息体是否超出我们的需求，如果超出可以直接抛出异常，终止调用链的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectTooLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALLOW_LENGTH = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readableBytes = in.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (readableBytes &gt; ALLOW_LENGTH) &#123;</span><br><span class="line">        <span class="comment">// 清空ByteBuf</span></span><br><span class="line">      in.skipBytes(readableBytes);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException(<span class="string">&quot;Bytes Too Long!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-MessageToByteEncoder-MessageToMessageEncoder-1"><a href="#2-2-5-MessageToByteEncoder-MessageToMessageEncoder-1" class="headerlink" title="2.2.5 MessageToByteEncoder/MessageToMessageEncoder"></a>2.2.5 MessageToByteEncoder/MessageToMessageEncoder</h4><p>其实与解码器相对应，方法参数差不多，偷懒不打算写了。</p>
<h4 id="2-2-6-编解码一体-1"><a href="#2-2-6-编解码一体-1" class="headerlink" title="2.2.6 编解码一体"></a>2.2.6 编解码一体</h4><p>项目上，我们一般都会把编解码这种粗活交给一个 <code>Maven</code> 模块来做，当然这样子的话就需要在客户端服务端重复安装编解码器了。 聚合在一起的一种方式是使用 <code>ByteToMessageCodec</code>，通过集成他重写编码和解码两个方法达到重用。 还有另外一种方法是通过继承 <code>CombinedChannelDuplexHandler</code> ，在泛型中指定编解码的类来实现。 当然这两种方式看个人喜好使用，我的话偏向于后者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedIntegerCodec</span> <span class="keyword">extends</span> <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">IntegerDecoder</span>, <span class="title">IntegerEncoder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CombinedIntegerCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> IntegerDecoder(), <span class="keyword">new</span> IntegerEncoder())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续…… </p>
<p>上图所示，<code>Netty</code> 需要先将堆上的数据逐一拷贝到系统直接缓冲区，然后再发送出去。会造成多了一步拷贝的过程。 但是，<code>Java</code> 可以直接操作堆缓冲区的数据呀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (heapBuf.hasArray()) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] arrays = heapBuf.array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-2-直接缓冲区-2"><a href="#1-1-3-2-直接缓冲区-2" class="headerlink" title="1.1.3.2 直接缓冲区"></a>1.1.3.2 直接缓冲区</h4><p><code>JDK 1.4</code> 以后官方提供了直接向系统申请内存的方法，申请后的内存也不在垃圾回收器清理范围以内，所以当我们申请了直接内存缓冲区的时候，都需要进行手动释放，否则将会造成系统内存溢出。 直接缓冲区的优点刚好是堆缓冲区最不擅长的点，可以直接调用本地 <code>IO</code> 设备，不需要通过拷贝从而将数据传输出去。 但是另外的缺点也有：相比堆缓冲区，如果程序需要读取操作缓冲区的数据的时候，则需要跟以上第一步逆相反的步骤，将直接内存缓冲区的数据拷贝到堆缓冲区才可以进行操作。而且向系统申请和释放内存也会造成性能的降低。</p>
<h4 id="1-1-3-3-复合缓冲区-2"><a href="#1-1-3-3-复合缓冲区-2" class="headerlink" title="1.1.3.3 复合缓冲区"></a>1.1.3.3 复合缓冲区</h4><p><code>jdk</code> 完全没有的一个功能，可以提供消息体复用的优势。 比如 <code>HTTP</code> 协议传输消息的时候，我们知道 <code>HTTP</code> 头部很多时候是相似或者说相同的，那么头部就可以存储在直接内存中，使用复合缓冲区 <code>CompositeByteBuf</code> 来聚合直接缓冲区中的头部信息以及堆内存中的消息体，然后进行写出。</p>
<blockquote>
<p>因为可能包含直接内存分配和非直接内存分配，如果只存在一个聚合ByteBuf元素，那么调用 <code>hasArray()</code> 将直接返回这个元素的结果，否则会返回 <code>false</code></p>
</blockquote>
<p>创建复合缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();</span><br><span class="line">ByteBuf head = ...;</span><br><span class="line">ByteBuf body = ...;</span><br><span class="line">compBuf.addComponents(head, body);</span><br></pre></td></tr></table></figure>

<p>访问缓冲区数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();</span><br><span class="line"><span class="keyword">int</span> length = compBuf.readableBytes();</span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">compBuf.getBytes(compBuf.readerIndex(), arr);<span class="comment">// 读取数据到数组中</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-4-池化缓冲区-2"><a href="#1-1-3-4-池化缓冲区-2" class="headerlink" title="1.1.3.4 池化缓冲区"></a>1.1.3.4 池化缓冲区</h4><p>一般来说，我们需要池化缓冲区，达到可以复用的效果，也可以减少计算机资源的开销，所以 <code>Netty</code> 提供了 <code>ByteBufAllocator</code> 来实现缓冲区的池化效果。 我们可以通过 <code>ByteBufAllocator.DEFAULT</code> 来获取 <code>ByteBufAllocator</code> 对象，从而调用以下方法，建立我们所需要的缓冲区：</p>
<p>方法名称</p>
<p>说明</p>
<p>buffer()<br>buffer(int initialCapacity)<br>buffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆或者直接内存的 <code>ByteBuf</code></p>
<p>heapBuffer()<br>heapBuffer(int initialCapacity)<br>heapBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆缓冲区的 <code>ByteBuf</code></p>
<p>directBuffer()<br>directBuffer(int initialCapacity)<br>directBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于直接内存缓冲区的 <code>ByteBuf</code></p>
<p>compositeBuffer()<br>compositeBuffer(int maxNumComponents)<br>compositeDirectBuffer()<br>compositeDirectBuffer(int maxNumComponents)<br>compositeHeapBuffer()<br>compositeHeapBuffer(int maxNumComponents)</p>
<p>返回指定最大元素的基于堆或者直接内存的<br>缓冲区视图</p>
<p>ioBuffer()</p>
<p>返回基于 <code>Socket</code> 的 <code>IO</code> 操作的 <code>ByteBuf</code></p>
<p>运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ByteBuf&gt; byteBufs = <span class="keyword">new</span> ArrayList&lt;ByteBuf&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">  ByteBuf byteBuf2 = ByteBufAllocator.DEFAULT.directBuffer(<span class="number">200</span>);</span><br><span class="line">  byteBuf2.writeBytes(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name()));</span><br><span class="line">  byteBufs.add(byteBuf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="一-数据传输的容器ByteBuf-3"><a href="#一-数据传输的容器ByteBuf-3" class="headerlink" title="一.数据传输的容器ByteBuf"></a>一.数据传输的容器ByteBuf</h2><h3 id="1-1-简单理解一下-3"><a href="#1-1-简单理解一下-3" class="headerlink" title="1.1. 简单理解一下"></a>1.1. 简单理解一下</h3><p>OK，上一篇文章我们大致了解了 <code>Netty</code> 在运行过程中所需要的一些组件。接下来需要慢慢的深入了解这些容器了。 为了方便回忆，我先贴一段上一篇的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ByteBuf in = (ByteBuf) msg;</span><br><span class="line">String message = in.toString(Charset.defaultCharset());</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在服务端代码中，使用了 <code>ByteBuf</code> 来读取客户端所传递的消息，然后实现逻辑，再使用 <code>ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes(Charset.defaultCharset().name()));</code> 来将处理后的数据重新封装成字节，从而写出去，传递给客户端。 所以大概猜一下，<code>ByteBuf</code> 是一个装载着数据字节的容器，在 <code>Netty</code> 中通过网络进行传输。客户端又重新解码，读取出服务端返回的数据。 其实，<code>jdk</code> 自己的 <code>NIO</code> 也有个类似的类 <code>ByteBuffer</code>，但是这个类，他不太灵活，所以 <code>Netty</code> 才决定重写这个类，从而达到一些比较灵活的目的：</p>
<ol>
<li>可以被自定义缓冲区类型拓展；</li>
<li>通过内置的符合缓冲区类型实现透明的零拷贝；</li>
<li>容量可以自增；</li>
<li>读写模式不需要来回切换（得益于读写指针）；</li>
<li>支持链式调用、引用计数以及池化计数。</li>
</ol>
<h3 id="1-2-深入读写指针-3"><a href="#1-2-深入读写指针-3" class="headerlink" title="1.2. 深入读写指针"></a>1.2. 深入读写指针</h3><p>上一节说了，读写模式不需要来回切换，是因为 <code>ByteBuf</code> 内部提供了两个索引 <code>readIndex</code> 以及 <code>writeIndex</code>。当我们从 <code>ByteBuf</code> 读取数据的时候，<code>readIndex</code> 会慢慢的递增已经被读取的字节数，而写入时 <code>writeIndex</code> 同样也会进行移动。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161455.png"> </p>
<p>如上图所示，一个16字节的 <code>ByteBuf</code>，刚开始什么都没有的时候，读索引和写索引同在第 <code>0</code> 位上，随着数据慢慢写入，写索引会向右进行移动。这时候没有读取的发生，所以读索引还停留在第 <code>0</code> 位上，而随着我们业务的需求，会读取消息，所以读指针慢慢向后移动，但是这里有个需要注意的地方是，读索引不能超过写索引的位数（即使超过了读后面的消息也没什么意义），如果强行超过，<code>Netty</code> 会给你来一个 <code>IndexOutOfBoundsException</code>。 <code>ByteBuf</code> 自带有一些方法，通过调用 <code>read</code> 和 <code>write</code> 开头的方法，将会推进这两个相对应的索引位置，而如果说我们不想要推动索引而是想直接读取，则可以通过调用 <code>get</code> <code>set</code> 开头的方法，便可以直接操作 <code>ByteBuf</code> 中相对应位置的数据。 可以指定 <code>ByteBuf</code> 的最大容量，如果不指定默认是 <code>Integer.MAX_VALUE</code>。</p>
<h3 id="1-3-不同内存下的-ByteBuf-3"><a href="#1-3-不同内存下的-ByteBuf-3" class="headerlink" title="1.3. 不同内存下的 ByteBuf"></a>1.3. 不同内存下的 <code>ByteBuf</code></h3><h4 id="1-1-3-1-堆缓冲区的ByteBuf-3"><a href="#1-1-3-1-堆缓冲区的ByteBuf-3" class="headerlink" title="1.1.3.1 堆缓冲区的ByteBuf"></a>1.1.3.1 堆缓冲区的ByteBuf</h4><p>最常用的模式下是堆缓冲区的 <code>ByteBuf</code>，顾名思义堆缓冲区 <code>ByteBuf</code> 是用于存储在 <code>JVM</code> 堆内存中的缓冲区。这种模式称为 <code>支撑数组</code>。他可以在 <code>Java</code> 程序中快速的创建以及被垃圾回收器回收，但是，如果需要写出到 <code>IO设备</code> 则需要经过以下这么几个步骤。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161515.png"> </p>
<p>上图所示，<code>Netty</code> 需要先将堆上的数据逐一拷贝到系统直接缓冲区，然后再发送出去。会造成多了一步拷贝的过程。 但是，<code>Java</code> 可以直接操作堆缓冲区的数据呀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (heapBuf.hasArray()) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] arrays = heapBuf.array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-2-直接缓冲区-3"><a href="#1-1-3-2-直接缓冲区-3" class="headerlink" title="1.1.3.2 直接缓冲区"></a>1.1.3.2 直接缓冲区</h4><p><code>JDK 1.4</code> 以后官方提供了直接向系统申请内存的方法，申请后的内存也不在垃圾回收器清理范围以内，所以当我们申请了直接内存缓冲区的时候，都需要进行手动释放，否则将会造成系统内存溢出。 直接缓冲区的优点刚好是堆缓冲区最不擅长的点，可以直接调用本地 <code>IO</code> 设备，不需要通过拷贝从而将数据传输出去。 但是另外的缺点也有：相比堆缓冲区，如果程序需要读取操作缓冲区的数据的时候，则需要跟以上第一步逆相反的步骤，将直接内存缓冲区的数据拷贝到堆缓冲区才可以进行操作。而且向系统申请和释放内存也会造成性能的降低。</p>
<h4 id="1-1-3-3-复合缓冲区-3"><a href="#1-1-3-3-复合缓冲区-3" class="headerlink" title="1.1.3.3 复合缓冲区"></a>1.1.3.3 复合缓冲区</h4><p><code>jdk</code> 完全没有的一个功能，可以提供消息体复用的优势。 比如 <code>HTTP</code> 协议传输消息的时候，我们知道 <code>HTTP</code> 头部很多时候是相似或者说相同的，那么头部就可以存储在直接内存中，使用复合缓冲区 <code>CompositeByteBuf</code> 来聚合直接缓冲区中的头部信息以及堆内存中的消息体，然后进行写出。</p>
<blockquote>
<p>因为可能包含直接内存分配和非直接内存分配，如果只存在一个聚合ByteBuf元素，那么调用 <code>hasArray()</code> 将直接返回这个元素的结果，否则会返回 <code>false</code></p>
</blockquote>
<p>创建复合缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();</span><br><span class="line">ByteBuf head = ...;</span><br><span class="line">ByteBuf body = ...;</span><br><span class="line">compBuf.addComponents(head, body);</span><br></pre></td></tr></table></figure>

<p>访问缓冲区数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf compBuf = Unpooled.compositeBuffer();</span><br><span class="line"><span class="keyword">int</span> length = compBuf.readableBytes();</span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">compBuf.getBytes(compBuf.readerIndex(), arr);<span class="comment">// 读取数据到数组中</span></span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-4-池化缓冲区-3"><a href="#1-1-3-4-池化缓冲区-3" class="headerlink" title="1.1.3.4 池化缓冲区"></a>1.1.3.4 池化缓冲区</h4><p>一般来说，我们需要池化缓冲区，达到可以复用的效果，也可以减少计算机资源的开销，所以 <code>Netty</code> 提供了 <code>ByteBufAllocator</code> 来实现缓冲区的池化效果。 我们可以通过 <code>ByteBufAllocator.DEFAULT</code> 来获取 <code>ByteBufAllocator</code> 对象，从而调用以下方法，建立我们所需要的缓冲区：</p>
<p>方法名称</p>
<p>说明</p>
<p>buffer()<br>buffer(int initialCapacity)<br>buffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆或者直接内存的 <code>ByteBuf</code></p>
<p>heapBuffer()<br>heapBuffer(int initialCapacity)<br>heapBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于堆缓冲区的 <code>ByteBuf</code></p>
<p>directBuffer()<br>directBuffer(int initialCapacity)<br>directBuffer(int initialCapacity, int maxCapacity)</p>
<p>返回基于直接内存缓冲区的 <code>ByteBuf</code></p>
<p>compositeBuffer()<br>compositeBuffer(int maxNumComponents)<br>compositeDirectBuffer()<br>compositeDirectBuffer(int maxNumComponents)<br>compositeHeapBuffer()<br>compositeHeapBuffer(int maxNumComponents)</p>
<p>返回指定最大元素的基于堆或者直接内存的<br>缓冲区视图</p>
<p>ioBuffer()</p>
<p>返回基于 <code>Socket</code> 的 <code>IO</code> 操作的 <code>ByteBuf</code></p>
<p>运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ByteBuf&gt; byteBufs = <span class="keyword">new</span> ArrayList&lt;ByteBuf&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">  ByteBuf byteBuf2 = ByteBufAllocator.DEFAULT.directBuffer(<span class="number">200</span>);</span><br><span class="line">  byteBuf2.writeBytes(<span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name()));</span><br><span class="line">  byteBufs.add(byteBuf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161610.png"> </p>
<p>可以看到，内存一直不断飙升，直到系统拒绝给出内存，抛出异常，程序终止，进程被干掉才结束。</p>
<h4 id="1-1-3-5-非池化缓冲区-2"><a href="#1-1-3-5-非池化缓冲区-2" class="headerlink" title="1.1.3.5 非池化缓冲区"></a>1.1.3.5 非池化缓冲区</h4><p>即我第一篇中用到的 <code>Unpooled</code> 类，<code>api</code> 跟上面差不多，不再重复。 主要提供给其他不需要使用 <code>Netty</code> 的项目使用。</p>
<h4 id="1-1-3-6-ByteBufUtil-2"><a href="#1-1-3-6-ByteBufUtil-2" class="headerlink" title="1.1.3.6 ByteBufUtil"></a>1.1.3.6 ByteBufUtil</h4><p>主要提供两个方法使用： <code>hexdump()</code> : 主要用于将缓冲区内容写入日志，易于调试，也可以还原成字节数组。 <code>equals(ByteBuf, ByteBuf)</code> : 传递两个 <code>ByteBuf</code> 用于比较相等性。</p>
<h4 id="1-1-3-7-引用计数（TODO）-2"><a href="#1-1-3-7-引用计数（TODO）-2" class="headerlink" title="1.1.3.7 引用计数（TODO）"></a>1.1.3.7 引用计数（TODO）</h4><p>这块放在后面 <code>ChannelPipeline</code> 再说。</p>
<h2 id="二-解码和编码-2"><a href="#二-解码和编码-2" class="headerlink" title="二.解码和编码"></a>二.解码和编码</h2><h3 id="2-1-啰嗦一下什么是编解码器-2"><a href="#2-1-啰嗦一下什么是编解码器-2" class="headerlink" title="2.1 啰嗦一下什么是编解码器"></a>2.1 啰嗦一下什么是编解码器</h3><p>本来应该不需要这个的，但是还是为了篇幅的完整性还是啰嗦一下。 我们知道在传递消息的时候，我们的 <code>Java</code> 对象是不能够实现网络传输的，必须将对象序列化成某种格式（Byte数组），然后网卡再编码成 <code>10101…</code> 传输给另外一台服务器，另外的一台服务器再从 <code>10101...</code> 去重新解码，解成我们所序列化后的数组，然后传递到我们程序再使用我们自己的规则去重新把对象信息还原回来（当然此时客户端的对象的元信息跟服务器端的没有半毛钱关系） 大白话说就是，通过某种规则，在客户端机器上创建一个数据一毛一样的对象。 我们网络开发常见的编解码器有哪些比较耳濡目染的，大概就是 <code>JSON</code> 了吧，可读性强，兼容性棒（各个语言都支持），都 <code>9012</code> 年了就不要来一句 <code>XML</code> 了吧，如果还说 <code>XML</code> 我立马把43码的鞋子pia到你脸上去。 然而，除了 <code>JSON</code> 格式，如果不需要考虑兼容性最强的话，我们也可以使用同行语言都懂的 <code>Byte</code> 数组进行传输，总的来说，使用 <code>Byte</code> 数组可以达到效率更高（编码和解码），传输容量更小，传输速度更快的目的。因为 <code>JSON</code> 格式毕竟都是字符串，传输容量还是属于比较大的，而且频繁操作 <code>String</code> 编码和解码的效率也更低。</p>
<h3 id="2-2-Netty自带的编解码器-2"><a href="#2-2-Netty自带的编解码器-2" class="headerlink" title="2.2 Netty自带的编解码器"></a>2.2 Netty自带的编解码器</h3><ol>
<li>ByteToMessageDecoder 和 ReplayingDecoder；</li>
<li>MessageToMessageDecoder；</li>
</ol>
<h4 id="2-2-1-ByteToMessageDecoder-2"><a href="#2-2-1-ByteToMessageDecoder-2" class="headerlink" title="2.2.1 ByteToMessageDecoder"></a>2.2.1 ByteToMessageDecoder</h4><p><code>ByteToMessageDecoder</code> 是一个抽象的基类，通过我们做解码的方式去拓展。 我们可以编写自己的解码类，继承 <code>ByteToMessageDecoder</code> 类，需要编写以下的编码方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>比如，我们需要读取多个 <code>int</code> 值，我们也知道一个 <code>int</code> 值的长度是 <code>4</code>，所以我们在读取的时候，就需要判断 <code>ByteBuf</code> 的可读长度是否达到了 <code>4</code> ，才开始读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoderHandler</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (byteBuf.readableBytes() &gt; <span class="number">4</span>) &#123;</span><br><span class="line">      list.add(byteBuf.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递的参数中，<code>List&lt;Object&gt; list</code> 是用来保存解码信息的，当我们解码一个对象的时候，信息将保存在这里，<code>Netty</code> 将会为我们把这个 <code>list</code> 传递给 <code>ChannelPipeline</code> 的下一个 <code>ChannelInboundHandler</code> 处理器中。 当然，<code>ByteToMessageDecoder</code> 还提供了一个 <code>decodeLast</code> 方法，用来当 <code>Channel</code> 变成非活动状态的时候，调用最后一次解码。 来个例子： 现在有个需求，要求客户端发送 <code>RandomNum</code> 给服务端，服务端返回 <code>16</code> 个 <code>int</code> 类型的随机数，客户端接收并打印：</p>
<h5 id="服务端Handler-2"><a href="#服务端Handler-2" class="headerlink" title="服务端Handler"></a>服务端Handler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机数处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">if</span> (message.equals(<span class="string">&quot;RandomNumber&quot;</span>)) &#123;</span><br><span class="line">      ByteBuf byteBuf = ctx.channel().alloc().heapBuffer();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        byteBuf.writeInt(<span class="keyword">new</span> Random().nextInt() * <span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务端引导代码-2"><a href="#服务端引导代码-2" class="headerlink" title="服务端引导代码"></a>服务端引导代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> IntegerHandler handler = <span class="keyword">new</span> IntegerHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端解码器-2"><a href="#客户端解码器-2" class="headerlink" title="客户端解码器"></a>客户端解码器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * .</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 一个 int 是 4 个字节 */</span></span><br><span class="line">    <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      out.add(in.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端处理Handler-2"><a href="#客户端处理Handler-2" class="headerlink" title="客户端处理Handler"></a>客户端处理Handler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">Object</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;RandomNumber&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端引导代码-2"><a href="#客户端引导代码-2" class="headerlink" title="客户端引导代码"></a>客户端引导代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端启动类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">      b.group(group)</span><br><span class="line">              .channel(NioSocketChannel.class)</span><br><span class="line">              .remoteAddress(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>))</span><br><span class="line">              .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(<span class="keyword">new</span> ToIntegerDecoder(), <span class="keyword">new</span> RequestHandler());</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      ChannelFuture future = b.connect().sync();</span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行效果-2"><a href="#运行效果-2" class="headerlink" title="运行效果"></a>运行效果</h5><p><img src="./RandomNettyDemo.gif"></p>
<h4 id="2-2-2-ReplayingDecoder-2"><a href="#2-2-2-ReplayingDecoder-2" class="headerlink" title="2.2.2 ReplayingDecoder"></a>2.2.2 ReplayingDecoder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    out.add(in.readInt());</span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ReplayingDecoder</code> 有个泛型，表示需要处理的状态类型，使用 <code>Void</code> 表示没有状态需要处理。 与之前不同的是，每读取一次就会调用一次后面的处理器，因为每次解码都会发送。 需要注意 <code>ReplayingDecoder</code> 并不是支持所有的 <code>ByteBuf</code> 操作，如果调用不支持的方法，将会抛出异常。而且效率较上面的解码器比较低下。</p>
<h4 id="2-2-3-MessageToMessageDecoder-2"><a href="#2-2-3-MessageToMessageDecoder-2" class="headerlink" title="2.2.3 MessageToMessageDecoder"></a>2.2.3 MessageToMessageDecoder</h4><p>这个的作用是将一种消息的格式转换为另外一种消息的格式。 不多说上代码就好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;<span class="comment">// 泛型表示传入的类型</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    out.add(<span class="string">&quot;String:&quot;</span> + String.valueOf(msg));</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-TooLongFrameException-2"><a href="#2-2-4-TooLongFrameException-2" class="headerlink" title="2.2.4 TooLongFrameException"></a>2.2.4 TooLongFrameException</h4><p>这是一个异常类，用于让我们自定义抛出异常的，主要作用是为了保护 <code>Netty</code> 程序的内存不至于被过大的消息体耗尽，所以我们可以定义一个 <code>Decoder</code>，用于判断消息体是否超出我们的需求，如果超出可以直接抛出异常，终止调用链的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectTooLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALLOW_LENGTH = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readableBytes = in.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (readableBytes &gt; ALLOW_LENGTH) &#123;</span><br><span class="line">        <span class="comment">// 清空ByteBuf</span></span><br><span class="line">      in.skipBytes(readableBytes);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException(<span class="string">&quot;Bytes Too Long!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-MessageToByteEncoder-MessageToMessageEncoder-2"><a href="#2-2-5-MessageToByteEncoder-MessageToMessageEncoder-2" class="headerlink" title="2.2.5 MessageToByteEncoder/MessageToMessageEncoder"></a>2.2.5 MessageToByteEncoder/MessageToMessageEncoder</h4><p>其实与解码器相对应，方法参数差不多，偷懒不打算写了。</p>
<h4 id="2-2-6-编解码一体-2"><a href="#2-2-6-编解码一体-2" class="headerlink" title="2.2.6 编解码一体"></a>2.2.6 编解码一体</h4><p>项目上，我们一般都会把编解码这种粗活交给一个 <code>Maven</code> 模块来做，当然这样子的话就需要在客户端服务端重复安装编解码器了。 聚合在一起的一种方式是使用 <code>ByteToMessageCodec</code>，通过集成他重写编码和解码两个方法达到重用。 还有另外一种方法是通过继承 <code>CombinedChannelDuplexHandler</code> ，在泛型中指定编解码的类来实现。 当然这两种方式看个人喜好使用，我的话偏向于后者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedIntegerCodec</span> <span class="keyword">extends</span> <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">IntegerDecoder</span>, <span class="title">IntegerEncoder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CombinedIntegerCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> IntegerDecoder(), <span class="keyword">new</span> IntegerEncoder())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续…… </p>
<p>可以看到，内存一直不断飙升，直到系统拒绝给出内存，抛出异常，程序终止，进程被干掉才结束。</p>
<h4 id="1-1-3-5-非池化缓冲区-3"><a href="#1-1-3-5-非池化缓冲区-3" class="headerlink" title="1.1.3.5 非池化缓冲区"></a>1.1.3.5 非池化缓冲区</h4><p>即我第一篇中用到的 <code>Unpooled</code> 类，<code>api</code> 跟上面差不多，不再重复。 主要提供给其他不需要使用 <code>Netty</code> 的项目使用。</p>
<h4 id="1-1-3-6-ByteBufUtil-3"><a href="#1-1-3-6-ByteBufUtil-3" class="headerlink" title="1.1.3.6 ByteBufUtil"></a>1.1.3.6 ByteBufUtil</h4><p>主要提供两个方法使用： <code>hexdump()</code> : 主要用于将缓冲区内容写入日志，易于调试，也可以还原成字节数组。 <code>equals(ByteBuf, ByteBuf)</code> : 传递两个 <code>ByteBuf</code> 用于比较相等性。</p>
<h4 id="1-1-3-7-引用计数（TODO）-3"><a href="#1-1-3-7-引用计数（TODO）-3" class="headerlink" title="1.1.3.7 引用计数（TODO）"></a>1.1.3.7 引用计数（TODO）</h4><p>这块放在后面 <code>ChannelPipeline</code> 再说。</p>
<h2 id="二-解码和编码-3"><a href="#二-解码和编码-3" class="headerlink" title="二.解码和编码"></a>二.解码和编码</h2><h3 id="2-1-啰嗦一下什么是编解码器-3"><a href="#2-1-啰嗦一下什么是编解码器-3" class="headerlink" title="2.1 啰嗦一下什么是编解码器"></a>2.1 啰嗦一下什么是编解码器</h3><p>本来应该不需要这个的，但是还是为了篇幅的完整性还是啰嗦一下。 我们知道在传递消息的时候，我们的 <code>Java</code> 对象是不能够实现网络传输的，必须将对象序列化成某种格式（Byte数组），然后网卡再编码成 <code>10101…</code> 传输给另外一台服务器，另外的一台服务器再从 <code>10101...</code> 去重新解码，解成我们所序列化后的数组，然后传递到我们程序再使用我们自己的规则去重新把对象信息还原回来（当然此时客户端的对象的元信息跟服务器端的没有半毛钱关系） 大白话说就是，通过某种规则，在客户端机器上创建一个数据一毛一样的对象。 我们网络开发常见的编解码器有哪些比较耳濡目染的，大概就是 <code>JSON</code> 了吧，可读性强，兼容性棒（各个语言都支持），都 <code>9012</code> 年了就不要来一句 <code>XML</code> 了吧，如果还说 <code>XML</code> 我立马把43码的鞋子pia到你脸上去。 然而，除了 <code>JSON</code> 格式，如果不需要考虑兼容性最强的话，我们也可以使用同行语言都懂的 <code>Byte</code> 数组进行传输，总的来说，使用 <code>Byte</code> 数组可以达到效率更高（编码和解码），传输容量更小，传输速度更快的目的。因为 <code>JSON</code> 格式毕竟都是字符串，传输容量还是属于比较大的，而且频繁操作 <code>String</code> 编码和解码的效率也更低。</p>
<h3 id="2-2-Netty自带的编解码器-3"><a href="#2-2-Netty自带的编解码器-3" class="headerlink" title="2.2 Netty自带的编解码器"></a>2.2 Netty自带的编解码器</h3><ol>
<li>ByteToMessageDecoder 和 ReplayingDecoder；</li>
<li>MessageToMessageDecoder；</li>
</ol>
<h4 id="2-2-1-ByteToMessageDecoder-3"><a href="#2-2-1-ByteToMessageDecoder-3" class="headerlink" title="2.2.1 ByteToMessageDecoder"></a>2.2.1 ByteToMessageDecoder</h4><p><code>ByteToMessageDecoder</code> 是一个抽象的基类，通过我们做解码的方式去拓展。 我们可以编写自己的解码类，继承 <code>ByteToMessageDecoder</code> 类，需要编写以下的编码方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure>

<p>比如，我们需要读取多个 <code>int</code> 值，我们也知道一个 <code>int</code> 值的长度是 <code>4</code>，所以我们在读取的时候，就需要判断 <code>ByteBuf</code> 的可读长度是否达到了 <code>4</code> ，才开始读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoderHandler</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object&gt; list)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (byteBuf.readableBytes() &gt; <span class="number">4</span>) &#123;</span><br><span class="line">      list.add(byteBuf.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递的参数中，<code>List&lt;Object&gt; list</code> 是用来保存解码信息的，当我们解码一个对象的时候，信息将保存在这里，<code>Netty</code> 将会为我们把这个 <code>list</code> 传递给 <code>ChannelPipeline</code> 的下一个 <code>ChannelInboundHandler</code> 处理器中。 当然，<code>ByteToMessageDecoder</code> 还提供了一个 <code>decodeLast</code> 方法，用来当 <code>Channel</code> 变成非活动状态的时候，调用最后一次解码。 来个例子： 现在有个需求，要求客户端发送 <code>RandomNum</code> 给服务端，服务端返回 <code>16</code> 个 <code>int</code> 类型的随机数，客户端接收并打印：</p>
<h5 id="服务端Handler-3"><a href="#服务端Handler-3" class="headerlink" title="服务端Handler"></a>服务端Handler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFutureListener;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机数处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">if</span> (message.equals(<span class="string">&quot;RandomNumber&quot;</span>)) &#123;</span><br><span class="line">      ByteBuf byteBuf = ctx.channel().alloc().heapBuffer();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        byteBuf.writeInt(<span class="keyword">new</span> Random().nextInt() * <span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务端引导代码-3"><a href="#服务端引导代码-3" class="headerlink" title="服务端引导代码"></a>服务端引导代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> IntegerHandler handler = <span class="keyword">new</span> IntegerHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端解码器-3"><a href="#客户端解码器-3" class="headerlink" title="客户端解码器"></a>客户端解码器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * .</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 一个 int 是 4 个字节 */</span></span><br><span class="line">    <span class="keyword">while</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">      out.add(in.readInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端处理Handler-3"><a href="#客户端处理Handler-3" class="headerlink" title="客户端处理Handler"></a>客户端处理Handler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">List</span>&lt;<span class="title">Object</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;RandomNumber&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端引导代码-3"><a href="#客户端引导代码-3" class="headerlink" title="客户端引导代码"></a>客户端引导代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端启动类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">      b.group(group)</span><br><span class="line">              .channel(NioSocketChannel.class)</span><br><span class="line">              .remoteAddress(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>))</span><br><span class="line">              .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(<span class="keyword">new</span> ToIntegerDecoder(), <span class="keyword">new</span> RequestHandler());</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      ChannelFuture future = b.connect().sync();</span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行效果-3"><a href="#运行效果-3" class="headerlink" title="运行效果"></a>运行效果</h5><img src="/frame/Netty/netty%E4%B9%8Bbytebuf%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8/RandomNettyDemo.gif" class="">

<h4 id="2-2-2-ReplayingDecoder-3"><a href="#2-2-2-ReplayingDecoder-3" class="headerlink" title="2.2.2 ReplayingDecoder"></a>2.2.2 ReplayingDecoder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo02.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ReplayingDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    out.add(in.readInt());</span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decodeLast</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ReplayingDecoder</code> 有个泛型，表示需要处理的状态类型，使用 <code>Void</code> 表示没有状态需要处理。 与之前不同的是，每读取一次就会调用一次后面的处理器，因为每次解码都会发送。 需要注意 <code>ReplayingDecoder</code> 并不是支持所有的 <code>ByteBuf</code> 操作，如果调用不支持的方法，将会抛出异常。而且效率较上面的解码器比较低下。</p>
<h4 id="2-2-3-MessageToMessageDecoder-3"><a href="#2-2-3-MessageToMessageDecoder-3" class="headerlink" title="2.2.3 MessageToMessageDecoder"></a>2.2.3 MessageToMessageDecoder</h4><p>这个的作用是将一种消息的格式转换为另外一种消息的格式。 不多说上代码就好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;<span class="comment">// 泛型表示传入的类型</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    out.add(<span class="string">&quot;String:&quot;</span> + String.valueOf(msg));</span><br><span class="line">    <span class="comment">/** 触发下一个 handler 的读取操作 */</span></span><br><span class="line">    ctx.pipeline().fireChannelRead(out);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-4-TooLongFrameException-3"><a href="#2-2-4-TooLongFrameException-3" class="headerlink" title="2.2.4 TooLongFrameException"></a>2.2.4 TooLongFrameException</h4><p>这是一个异常类，用于让我们自定义抛出异常的，主要作用是为了保护 <code>Netty</code> 程序的内存不至于被过大的消息体耗尽，所以我们可以定义一个 <code>Decoder</code>，用于判断消息体是否超出我们的需求，如果超出可以直接抛出异常，终止调用链的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectTooLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALLOW_LENGTH = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readableBytes = in.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (readableBytes &gt; ALLOW_LENGTH) &#123;</span><br><span class="line">        <span class="comment">// 清空ByteBuf</span></span><br><span class="line">      in.skipBytes(readableBytes);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException(<span class="string">&quot;Bytes Too Long!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-5-MessageToByteEncoder-MessageToMessageEncoder-3"><a href="#2-2-5-MessageToByteEncoder-MessageToMessageEncoder-3" class="headerlink" title="2.2.5 MessageToByteEncoder/MessageToMessageEncoder"></a>2.2.5 MessageToByteEncoder/MessageToMessageEncoder</h4><p>其实与解码器相对应，方法参数差不多，偷懒不打算写了。</p>
<h4 id="2-2-6-编解码一体-3"><a href="#2-2-6-编解码一体-3" class="headerlink" title="2.2.6 编解码一体"></a>2.2.6 编解码一体</h4><p>项目上，我们一般都会把编解码这种粗活交给一个 <code>Maven</code> 模块来做，当然这样子的话就需要在客户端服务端重复安装编解码器了。 聚合在一起的一种方式是使用 <code>ByteToMessageCodec</code>，通过集成他重写编码和解码两个方法达到重用。 还有另外一种方法是通过继承 <code>CombinedChannelDuplexHandler</code> ，在泛型中指定编解码的类来实现。 当然这两种方式看个人喜好使用，我的话偏向于后者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedIntegerCodec</span> <span class="keyword">extends</span> <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">IntegerDecoder</span>, <span class="title">IntegerEncoder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CombinedIntegerCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> IntegerDecoder(), <span class="keyword">new</span> IntegerEncoder())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续……</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/frame/Netty/netty%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/frame/Netty/netty%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/" class="post-title-link" itemprop="url">Netty组件以及入门体验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-18 10:56:39" itemprop="dateCreated datePublished" datetime="2019-07-18T10:56:39+08:00">2019-07-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-12 14:42:44" itemprop="dateModified" datetime="2020-11-12T14:42:44+08:00">2020-11-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/" itemprop="url" rel="index"><span itemprop="name">frame</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="零-Netty"><a href="#零-Netty" class="headerlink" title="零.Netty"></a>零.Netty</h2><p>其实了解到 <code>Netty</code> 已经很久了，一直想用，但是因为之前的水平还不够格，回调事件 <code>TCP</code> 什么的还没感觉，所以学起来一头雾水，加上官网的文档，哎呀，官网貌似就没有文档只有示例代码，读不懂。 写了挺多的回调函数，渐渐地有了感觉（通常使用 <code>CompleteFuture</code> 来请求其他服务的数据信息，请求完在执行自己的业务）。其实我也不知道我做了什么，貌似什么没做就突然融会贯通了，所以我感觉理解回调还是蛮重要的一点吧。 突然看到自己的书本库有本书《Netty实战》翻起来阅读，还是蛮好的，这篇文章其实是我读这本书，加上自己的一些理解写出来的。 <code>Netty</code> 是什么应该没人不会知道吧，就是 <code>Java</code> 行业中一个能够顶级处理网络通讯的轻量级框架，如果公司在使用 <code>Dubbo</code> 或者 <code>Thrift</code> 的话，那么也是间接在使用 <code>Netty</code> 框架了。所以学一学无伤大雅还可以了解一些很有趣的东西。</p>
<h2 id="一-Netty服务端"><a href="#一-Netty服务端" class="headerlink" title="一.Netty服务端"></a>一.Netty服务端</h2><p>所有 <code>Netty服务器</code> 通常需要以下两部分：</p>
<ol>
<li>至少一个 <code>ChannelHandler</code> 来接手客户端的数据以及处理数据；</li>
<li>引导服务器启动的配置，配置启动参数，这个就没啥好说的了。</li>
</ol>
<p><code>ChannelHandler</code> 是 <code>Netty</code> 中一个接口族的父接口，它主要负责接收和响应事件通知。 在 <code>Netty</code> 中 <code>ChannelHandler</code> 有很多默认实现，用来处理服务器中常见的数据传输问题。 因为服务器会响应传入的消息，所以需要实现 <code>ChannelInboundHandler</code> 接口，用来定义响应入站事件的方法。由于刚开始的程序只需要简单的方式即可，所以我们实现 <code>ChannelInboundHandlerAdapter</code> 即可，他提供了 <code>ChannelInboundHandler</code> 接口的默认实现。 我现在想要简单的实现一个服务，就是能够把把我发送的字符串，给反转过来，即发送 <code>abc</code> 服务器给我响应 <code>cba</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转服务器的处理逻辑类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringReverseHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(<span class="string">&quot;Server Receive Message: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    String newMsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] strings = message.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      newMsg += strings[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用工具类构建 ByteBuf 对象写出去 */</span></span><br><span class="line">    ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes());</span><br><span class="line">    ctx.writeAndFlush(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要编写服务的引导类，这个引导类主要实现两大功能：</p>
<ol>
<li>绑定哪个端口；</li>
<li>绑定上面写的 <code>Handler</code> 实现业务处理.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoop;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> StringReverseHandler handler = <span class="keyword">new</span> StringReverseHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此服务端任务就完成了，这时候只要启动服务端，等待客户端的介入即可处理业务。</p>
<h2 id="二-Netty客户端"><a href="#二-Netty客户端" class="headerlink" title="二.Netty客户端"></a>二.Netty客户端</h2><p>同上，所有的 <code>Netty客户端</code> 基本也是跟服务端差不多的事情：</p>
<ol>
<li>连接服务端；</li>
<li>发送消息；</li>
<li>获取服务端处理的结果；</li>
<li>关闭连接.</li>
</ol>
<p>同服务端处理一致，客户端也拥有一个 <code>ChannelInboundHandler</code> 来处理我们需要请求的业务。我们暂时可以使用 <code>SimpleChannelInboundHandler</code> 来执行我们必须的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.deploy.net.CrossDomainXML;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 服务端发送消息后执行的逻辑，直接打印 */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Client Receive Message: &quot;</span> + byteBuf.toString(Charset.defaultCharset()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们需要实现客户端的启动器，除了客户端需要使用 <code>OIO</code> 传输以外，其他需要做的事情基本是一致的。</p>
<h2 id="三-运行服务端和客户端"><a href="#三-运行服务端和客户端" class="headerlink" title="三.运行服务端和客户端"></a>三.运行服务端和客户端</h2><img src="/frame/Netty/netty%E7%BB%84%E4%BB%B6%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/SimpleNettyDemoTest.gif" class=""> 

<p>OK，我们分别启动 <code>服务端</code> 和 <code>客户端</code>，可见 <code>客户端</code> 在连接完成的时候，像 <code>服务端</code> 发送了 <code>HelloWorld</code>，服务端处理完成后，客户端即接收到 <code>Client Receive Message: dlroWolleH</code></p>
<h2 id="三-Netty组件"><a href="#三-Netty组件" class="headerlink" title="三.Netty组件"></a>三.Netty组件</h2><p>OK，硬着头皮写到这里，项目也运行还算正常，感觉还不错。那么接下来就需要来了解一下各个组件了。</p>
<h3 id="3-1-Netty主要组件"><a href="#3-1-Netty主要组件" class="headerlink" title="3.1 Netty主要组件"></a>3.1 Netty主要组件</h3><p>组件的顺序是从业务处理器，再到软件启动引导：</p>
<ol>
<li><code>ChannelHandler</code></li>
<li><code>EventLoopGroup</code></li>
<li><code>Channel</code></li>
<li><code>ServerBootstrap</code> 服务端启动类，而客户端使用的是 <code>Bootstrap</code></li>
<li><code>ChannelInitializer</code> 主要用来初始化注册安装 <code>ChannelHandler</code></li>
<li><code>ChannelPipeline</code> 存放 <code>ChannelHandler</code> 的链表容器</li>
</ol>
<p>而下面的顺序则没有按照上面的顺序，因为我想从里面了解到外面，里面相对看起来比较简单。</p>
<h3 id="3-2-ChannelHandler和ChannelPipeline"><a href="#3-2-ChannelHandler和ChannelPipeline" class="headerlink" title="3.2 ChannelHandler和ChannelPipeline"></a>3.2 ChannelHandler和ChannelPipeline</h3><h4 id="3-2-1-ChannelHandler"><a href="#3-2-1-ChannelHandler" class="headerlink" title="3.2.1 ChannelHandler"></a>3.2.1 ChannelHandler</h4><p>从上面的例子上可以看到，我们在服务端使用了继承 <code>ChannelHandler</code> 的方式去做业务逻辑，其实这块一般也是业务的重要地方，需要做什么处理，然后写出什么数据，跟 <code>Controller</code> 的作用相同。 在上面的服务端例子中，业务处理通过继承 <code>ChannelInboundHandlerAdapter</code>（是一个 <code>ChannelHandler</code> 的子类，下面说） 的方式来处理，它的作用是：</p>
<ol>
<li>接收入站事件和数据；</li>
<li>处理完以后，冲刷数据到客户端；</li>
<li>可以关闭连接的方式来结束客户端的连接。</li>
</ol>
<p>通常来说，一个项目会有多个 <code>ChannelInboundHandler</code> 在运行着，处理着业务数据。</p>
<h4 id="3-2-1-ChannelPipeline"><a href="#3-2-1-ChannelPipeline" class="headerlink" title="3.2.1 ChannelPipeline"></a>3.2.1 ChannelPipeline</h4><p>在服务端和客户端都可以看到 <code>socketChannel.pipeline().addLast(new RequestHandler())</code> 这段代码，那么根据编码经验来说，他应该是个容器。 没错，他还真的是一个容器，一个链表容器，里面装着一个一个的 <code>ChannelHandler</code> 。 具体过程是：</p>
<ol>
<li>启动的时候定义 <code>ChannelInitializer</code>，他将在 <code>Bootstrap</code> 或者 <code>ServerBootstrap</code> 启动的时候进行初始化操作；</li>
<li>当 <code>initChannel</code> 被调用的时候，我们即可安装我们自己的 <code>ChannelHandler</code> 实现，来处理数据传输；</li>
<li><code>ChannelInitializer</code> 将自己从 <code>ChannelPipeline</code> 中移除。</li>
</ol>
<p><code>ChannelHandler</code> 以及子类：</p>
<h2 id="零-Netty-1"><a href="#零-Netty-1" class="headerlink" title="零.Netty"></a>零.Netty</h2><p>其实了解到 <code>Netty</code> 已经很久了，一直想用，但是因为之前的水平还不够格，回调事件 <code>TCP</code> 什么的还没感觉，所以学起来一头雾水，加上官网的文档，哎呀，官网貌似就没有文档只有示例代码，读不懂。 写了挺多的回调函数，渐渐地有了感觉（通常使用 <code>CompleteFuture</code> 来请求其他服务的数据信息，请求完在执行自己的业务）。其实我也不知道我做了什么，貌似什么没做就突然融会贯通了，所以我感觉理解回调还是蛮重要的一点吧。 突然看到自己的书本库有本书《Netty实战》翻起来阅读，还是蛮好的，这篇文章其实是我读这本书，加上自己的一些理解写出来的。 <code>Netty</code> 是什么应该没人不会知道吧，就是 <code>Java</code> 行业中一个能够顶级处理网络通讯的轻量级框架，如果公司在使用 <code>Dubbo</code> 或者 <code>Thrift</code> 的话，那么也是间接在使用 <code>Netty</code> 框架了。所以学一学无伤大雅还可以了解一些很有趣的东西。</p>
<h2 id="一-Netty服务端-1"><a href="#一-Netty服务端-1" class="headerlink" title="一.Netty服务端"></a>一.Netty服务端</h2><p>所有 <code>Netty服务器</code> 通常需要以下两部分：</p>
<ol>
<li>至少一个 <code>ChannelHandler</code> 来接手客户端的数据以及处理数据；</li>
<li>引导服务器启动的配置，配置启动参数，这个就没啥好说的了。</li>
</ol>
<p><code>ChannelHandler</code> 是 <code>Netty</code> 中一个接口族的父接口，它主要负责接收和响应事件通知。 在 <code>Netty</code> 中 <code>ChannelHandler</code> 有很多默认实现，用来处理服务器中常见的数据传输问题。 因为服务器会响应传入的消息，所以需要实现 <code>ChannelInboundHandler</code> 接口，用来定义响应入站事件的方法。由于刚开始的程序只需要简单的方式即可，所以我们实现 <code>ChannelInboundHandlerAdapter</code> 即可，他提供了 <code>ChannelInboundHandler</code> 接口的默认实现。 我现在想要简单的实现一个服务，就是能够把把我发送的字符串，给反转过来，即发送 <code>abc</code> 服务器给我响应 <code>cba</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转服务器的处理逻辑类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringReverseHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(<span class="string">&quot;Server Receive Message: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    String newMsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] strings = message.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      newMsg += strings[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用工具类构建 ByteBuf 对象写出去 */</span></span><br><span class="line">    ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes());</span><br><span class="line">    ctx.writeAndFlush(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要编写服务的引导类，这个引导类主要实现两大功能：</p>
<ol>
<li>绑定哪个端口；</li>
<li>绑定上面写的 <code>Handler</code> 实现业务处理.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoop;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> StringReverseHandler handler = <span class="keyword">new</span> StringReverseHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此服务端任务就完成了，这时候只要启动服务端，等待客户端的介入即可处理业务。</p>
<h2 id="二-Netty客户端-1"><a href="#二-Netty客户端-1" class="headerlink" title="二.Netty客户端"></a>二.Netty客户端</h2><p>同上，所有的 <code>Netty客户端</code> 基本也是跟服务端差不多的事情：</p>
<ol>
<li>连接服务端；</li>
<li>发送消息；</li>
<li>获取服务端处理的结果；</li>
<li>关闭连接.</li>
</ol>
<p>同服务端处理一致，客户端也拥有一个 <code>ChannelInboundHandler</code> 来处理我们需要请求的业务。我们暂时可以使用 <code>SimpleChannelInboundHandler</code> 来执行我们必须的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.deploy.net.CrossDomainXML;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 服务端发送消息后执行的逻辑，直接打印 */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Client Receive Message: &quot;</span> + byteBuf.toString(Charset.defaultCharset()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们需要实现客户端的启动器，除了客户端需要使用 <code>OIO</code> 传输以外，其他需要做的事情基本是一致的。</p>
<h2 id="三-运行服务端和客户端-1"><a href="#三-运行服务端和客户端-1" class="headerlink" title="三.运行服务端和客户端"></a>三.运行服务端和客户端</h2><p><img src="./SimpleNettyDemoTest.gif"> </p>
<p>OK，我们分别启动 <code>服务端</code> 和 <code>客户端</code>，可见 <code>客户端</code> 在连接完成的时候，像 <code>服务端</code> 发送了 <code>HelloWorld</code>，服务端处理完成后，客户端即接收到 <code>Client Receive Message: dlroWolleH</code></p>
<h2 id="三-Netty组件-1"><a href="#三-Netty组件-1" class="headerlink" title="三.Netty组件"></a>三.Netty组件</h2><p>OK，硬着头皮写到这里，项目也运行还算正常，感觉还不错。那么接下来就需要来了解一下各个组件了。</p>
<h3 id="3-1-Netty主要组件-1"><a href="#3-1-Netty主要组件-1" class="headerlink" title="3.1 Netty主要组件"></a>3.1 Netty主要组件</h3><p>组件的顺序是从业务处理器，再到软件启动引导：</p>
<ol>
<li><code>ChannelHandler</code></li>
<li><code>EventLoopGroup</code></li>
<li><code>Channel</code></li>
<li><code>ServerBootstrap</code> 服务端启动类，而客户端使用的是 <code>Bootstrap</code></li>
<li><code>ChannelInitializer</code> 主要用来初始化注册安装 <code>ChannelHandler</code></li>
<li><code>ChannelPipeline</code> 存放 <code>ChannelHandler</code> 的链表容器</li>
</ol>
<p>而下面的顺序则没有按照上面的顺序，因为我想从里面了解到外面，里面相对看起来比较简单。</p>
<h3 id="3-2-ChannelHandler和ChannelPipeline-1"><a href="#3-2-ChannelHandler和ChannelPipeline-1" class="headerlink" title="3.2 ChannelHandler和ChannelPipeline"></a>3.2 ChannelHandler和ChannelPipeline</h3><h4 id="3-2-1-ChannelHandler-1"><a href="#3-2-1-ChannelHandler-1" class="headerlink" title="3.2.1 ChannelHandler"></a>3.2.1 ChannelHandler</h4><p>从上面的例子上可以看到，我们在服务端使用了继承 <code>ChannelHandler</code> 的方式去做业务逻辑，其实这块一般也是业务的重要地方，需要做什么处理，然后写出什么数据，跟 <code>Controller</code> 的作用相同。 在上面的服务端例子中，业务处理通过继承 <code>ChannelInboundHandlerAdapter</code>（是一个 <code>ChannelHandler</code> 的子类，下面说） 的方式来处理，它的作用是：</p>
<ol>
<li>接收入站事件和数据；</li>
<li>处理完以后，冲刷数据到客户端；</li>
<li>可以关闭连接的方式来结束客户端的连接。</li>
</ol>
<p>通常来说，一个项目会有多个 <code>ChannelInboundHandler</code> 在运行着，处理着业务数据。</p>
<h4 id="3-2-1-ChannelPipeline-1"><a href="#3-2-1-ChannelPipeline-1" class="headerlink" title="3.2.1 ChannelPipeline"></a>3.2.1 ChannelPipeline</h4><p>在服务端和客户端都可以看到 <code>socketChannel.pipeline().addLast(new RequestHandler())</code> 这段代码，那么根据编码经验来说，他应该是个容器。 没错，他还真的是一个容器，一个链表容器，里面装着一个一个的 <code>ChannelHandler</code> 。 具体过程是：</p>
<ol>
<li>启动的时候定义 <code>ChannelInitializer</code>，他将在 <code>Bootstrap</code> 或者 <code>ServerBootstrap</code> 启动的时候进行初始化操作；</li>
<li>当 <code>initChannel</code> 被调用的时候，我们即可安装我们自己的 <code>ChannelHandler</code> 实现，来处理数据传输；</li>
<li><code>ChannelInitializer</code> 将自己从 <code>ChannelPipeline</code> 中移除。</li>
</ol>
<p><code>ChannelHandler</code> 以及子类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162538.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162458.png"></p>
<p>数据入站的时候，将按照安装的顺序，依次执行 <code>ChannelInboundHandler</code> 中的逻辑，其实说到底就是处理链吧，当数据到达 <code>Pipeline</code> 尾端的时候，表示数据处理已经结束。 数据的出站运动（正在被写的数据）则是从 <code>Pipeline</code> 末端开始执行，与 <code>ChannelInboundHandler</code> 执行顺序相反的情况下依次处理。</p>
<blockquote>
<p>Netty 中 提供了 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 两个适配类，其实这两个类就是已经解决了简单顺序传值的问题，Netty 会简单的帮你按照上面的顺序执行 ChannelHandler 我们只需要覆写与业务相关的处理即可。所以如果我们只是想简单的传递的话可以直接使用这两个类。</p>
</blockquote>
<p>在覆写我们感兴趣的函数的时候，通常都可以看到有一个 <code>ChannelHandlerContext</code> 而且示例中也是使用他来写出消息的，除了这种方法写出消息，还有另外一种方法就是使用 <code>Channel</code> 写出（调用：<code>ctx.channel().writeAndFlush()</code>）。前者写出会将消息写到下一个 <code>ChannelHandler</code> 而后者则是让消息从上图中的 <code>ChannelPipeline</code> 末端开始走（与上面区别就是跳过下一个 <code>ChannelInboundHandler</code>）</p>
<h3 id="3-3-Channel和EventLoop"><a href="#3-3-Channel和EventLoop" class="headerlink" title="3.3 Channel和EventLoop"></a>3.3 Channel和EventLoop</h3><h4 id="3-3-1-Channel"><a href="#3-3-1-Channel" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h4><h5 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h5><p>说到 <code>Channel</code> 就要说到 <code>Java NIO</code> ，说到 <code>NIO</code> 就要说到 <code>Selector</code> 和 <code>Socket</code>。 说到 <code>NIO</code> 就要先说说这个有趣的名字~</p>
<blockquote>
<p>NIO 刚开始我感觉就是 New IO，可是这么多年过去了，再叫 New IO 就有点不合适了。 所以现在大多数人认为应该叫 Non-blocking IO，而阻塞IO则是 block IO 或者 old IO (BIO/OIO)</p>
</blockquote>
<p>其实聊到 <code>NIO</code> 就应该是，传统的 <code>IO</code> 如果同时执行同一个业务的话，而且想要多人都可以同时并行处理的话，那么就需要开启多个线程来同时执行。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162252.png"> </p>
<p>那么每一个新的客户端进来，我就需要预留一个线程来处理，线程中 <code>BIO</code> 在读取文件或者其他 <code>IO</code> 输入的时候，需要阻塞进入等待，这都算是一种资源浪费（CPU还需要切换线程去查看哪个线程已经阻塞完成了）。据我们所知，一个线程占用栈空间 <code>64k</code> - <code>1m</code>，理论线程越多每个线程拿到的栈空间就更少了。这时候线程他就在那里等待了什么事情都不做，然后还占用了系统上一个线程的位置（系统限制可开启线程数）。如果小数量的线程数（用户数）那么勉强还是撑得过去的，而且工作的也还不错。那么如果上万个用户上十万个用户呢，这时候，<code>CPU</code> 需要浪费很大的力气来切换轮询。 于是乎这时候，<code>NIO</code> 横空出世（其实系统早就支持了，在 <code>jdk1.4</code> 之前都没有支持） <code>NIO</code> 有个很牛逼的管理员 <code>Selector</code>，他的任务就是提交 <code>IO</code> 任务并且告诉系统，他做完了告诉我，我会执行下一步操作。于是乎模型就编程这样：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162315.png"> </p>
<p>这个模型只要一个线程就够了，他找 <code>Selector</code> 要已经完成 <code>IO</code> 操作的名单，然后放到自己的线程开始执行我们的业务逻辑，如果没有 <code>IO</code> 那么这个线程还可以去做其他的事情。</p>
<h5 id="Netty中的Channel"><a href="#Netty中的Channel" class="headerlink" title="Netty中的Channel"></a>Netty中的Channel</h5><p>在 <code>Netty</code> 中，一个 <code>Channel</code> 代表一个实体（硬件设备，文件，Socket，能够执行一个或不同 <code>IO</code> 操作的程序组件）的连接。这里可以套用 <code>Linux</code> 中万物皆文件的理念，只要是一个物，他就有输入输出，那么她就是 <code>Channel</code>。 而 <code>Channel</code> 中我们实现了他的一些方法如 <code>channelRead</code> <code>channelReadComplete</code>，其实这些是回调事件，我们也可以称实现这些动作是实现回调事件。那么啥是回调事件：</p>
<blockquote>
<p>某件事情执行时间很长，你让他执行完告诉你你去接收他的参数并且接下去做。 比如洗衣服，你扔进洗衣机，洗衣机一般要洗1个小时，洗完了发出滴滴滴的声音。这就是回调了，在这1个小时里面你这个线程就可以去做其他事情，他滴滴滴响了你拿到了结果（衣服洗完了）再去执行一个函数：晾衣服。</p>
</blockquote>
<p>如果你熟悉 <code>JavaScript</code> 那么这一切都很自然，异步请求 <code>Promise</code> 类，<code>Promise.then((result) =&gt; &#123;...&#125;)</code> 里面的 <code>function</code> 她就是回调函数。 <code>jdk8</code> 中提供了很好的回调事件方式的线程类 <code>CompleteFuture</code> 就是用来做这个事情的，你可以使用这个类来体验一下回调事件的感受。（参考文章：<a target="_blank" rel="noopener" href="https://liweidan.cn/java/jdk8/2017/10/25/141/">jdk8 多线程处理的使用</a>） 而 <code>Netty</code> 时代 <code>jdk</code> 还没有到 <code>j8</code> 呀，只提供了 <code>CompleteFuture</code> 的爸爸 <code>Future</code>，那怎么办嘛，<code>Netty</code> 就自己写提个，这就是 <code>ChannelFuture</code> 的出现了。<code>ChannelFuture</code> 也提供了可以自定义的 <code>ChannelFutureListener</code> 来拓展，可以说比 <code>jdk8</code> 的 <code>CompleteFuture</code> 还厉害，可以监听连接完成时做什么（比如检查连接是否正常，远程服务是否能够正确返回信息）。只需要在引导代码里面，使用 <code>ChannelFuture.addListener</code> 即可添加相对应的逻辑。这么说的话，那么 <code>ChannelFutureListener</code> 就是 <code>Future</code> 生命周期中执行的钩子函数。</p>
<h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><h2 id="零-Netty-2"><a href="#零-Netty-2" class="headerlink" title="零.Netty"></a>零.Netty</h2><p>其实了解到 <code>Netty</code> 已经很久了，一直想用，但是因为之前的水平还不够格，回调事件 <code>TCP</code> 什么的还没感觉，所以学起来一头雾水，加上官网的文档，哎呀，官网貌似就没有文档只有示例代码，读不懂。 写了挺多的回调函数，渐渐地有了感觉（通常使用 <code>CompleteFuture</code> 来请求其他服务的数据信息，请求完在执行自己的业务）。其实我也不知道我做了什么，貌似什么没做就突然融会贯通了，所以我感觉理解回调还是蛮重要的一点吧。 突然看到自己的书本库有本书《Netty实战》翻起来阅读，还是蛮好的，这篇文章其实是我读这本书，加上自己的一些理解写出来的。 <code>Netty</code> 是什么应该没人不会知道吧，就是 <code>Java</code> 行业中一个能够顶级处理网络通讯的轻量级框架，如果公司在使用 <code>Dubbo</code> 或者 <code>Thrift</code> 的话，那么也是间接在使用 <code>Netty</code> 框架了。所以学一学无伤大雅还可以了解一些很有趣的东西。</p>
<h2 id="一-Netty服务端-2"><a href="#一-Netty服务端-2" class="headerlink" title="一.Netty服务端"></a>一.Netty服务端</h2><p>所有 <code>Netty服务器</code> 通常需要以下两部分：</p>
<ol>
<li>至少一个 <code>ChannelHandler</code> 来接手客户端的数据以及处理数据；</li>
<li>引导服务器启动的配置，配置启动参数，这个就没啥好说的了。</li>
</ol>
<p><code>ChannelHandler</code> 是 <code>Netty</code> 中一个接口族的父接口，它主要负责接收和响应事件通知。 在 <code>Netty</code> 中 <code>ChannelHandler</code> 有很多默认实现，用来处理服务器中常见的数据传输问题。 因为服务器会响应传入的消息，所以需要实现 <code>ChannelInboundHandler</code> 接口，用来定义响应入站事件的方法。由于刚开始的程序只需要简单的方式即可，所以我们实现 <code>ChannelInboundHandlerAdapter</code> 即可，他提供了 <code>ChannelInboundHandler</code> 接口的默认实现。 我现在想要简单的实现一个服务，就是能够把把我发送的字符串，给反转过来，即发送 <code>abc</code> 服务器给我响应 <code>cba</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转服务器的处理逻辑类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringReverseHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(<span class="string">&quot;Server Receive Message: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    String newMsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] strings = message.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      newMsg += strings[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用工具类构建 ByteBuf 对象写出去 */</span></span><br><span class="line">    ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes());</span><br><span class="line">    ctx.writeAndFlush(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要编写服务的引导类，这个引导类主要实现两大功能：</p>
<ol>
<li>绑定哪个端口；</li>
<li>绑定上面写的 <code>Handler</code> 实现业务处理.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoop;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> StringReverseHandler handler = <span class="keyword">new</span> StringReverseHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此服务端任务就完成了，这时候只要启动服务端，等待客户端的介入即可处理业务。</p>
<h2 id="二-Netty客户端-2"><a href="#二-Netty客户端-2" class="headerlink" title="二.Netty客户端"></a>二.Netty客户端</h2><p>同上，所有的 <code>Netty客户端</code> 基本也是跟服务端差不多的事情：</p>
<ol>
<li>连接服务端；</li>
<li>发送消息；</li>
<li>获取服务端处理的结果；</li>
<li>关闭连接.</li>
</ol>
<p>同服务端处理一致，客户端也拥有一个 <code>ChannelInboundHandler</code> 来处理我们需要请求的业务。我们暂时可以使用 <code>SimpleChannelInboundHandler</code> 来执行我们必须的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.deploy.net.CrossDomainXML;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 服务端发送消息后执行的逻辑，直接打印 */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Client Receive Message: &quot;</span> + byteBuf.toString(Charset.defaultCharset()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们需要实现客户端的启动器，除了客户端需要使用 <code>OIO</code> 传输以外，其他需要做的事情基本是一致的。</p>
<h2 id="三-运行服务端和客户端-2"><a href="#三-运行服务端和客户端-2" class="headerlink" title="三.运行服务端和客户端"></a>三.运行服务端和客户端</h2><p><img src="./SimpleNettyDemoTest.gif"> </p>
<p>OK，我们分别启动 <code>服务端</code> 和 <code>客户端</code>，可见 <code>客户端</code> 在连接完成的时候，像 <code>服务端</code> 发送了 <code>HelloWorld</code>，服务端处理完成后，客户端即接收到 <code>Client Receive Message: dlroWolleH</code></p>
<h2 id="三-Netty组件-2"><a href="#三-Netty组件-2" class="headerlink" title="三.Netty组件"></a>三.Netty组件</h2><p>OK，硬着头皮写到这里，项目也运行还算正常，感觉还不错。那么接下来就需要来了解一下各个组件了。</p>
<h3 id="3-1-Netty主要组件-2"><a href="#3-1-Netty主要组件-2" class="headerlink" title="3.1 Netty主要组件"></a>3.1 Netty主要组件</h3><p>组件的顺序是从业务处理器，再到软件启动引导：</p>
<ol>
<li><code>ChannelHandler</code></li>
<li><code>EventLoopGroup</code></li>
<li><code>Channel</code></li>
<li><code>ServerBootstrap</code> 服务端启动类，而客户端使用的是 <code>Bootstrap</code></li>
<li><code>ChannelInitializer</code> 主要用来初始化注册安装 <code>ChannelHandler</code></li>
<li><code>ChannelPipeline</code> 存放 <code>ChannelHandler</code> 的链表容器</li>
</ol>
<p>而下面的顺序则没有按照上面的顺序，因为我想从里面了解到外面，里面相对看起来比较简单。</p>
<h3 id="3-2-ChannelHandler和ChannelPipeline-2"><a href="#3-2-ChannelHandler和ChannelPipeline-2" class="headerlink" title="3.2 ChannelHandler和ChannelPipeline"></a>3.2 ChannelHandler和ChannelPipeline</h3><h4 id="3-2-1-ChannelHandler-2"><a href="#3-2-1-ChannelHandler-2" class="headerlink" title="3.2.1 ChannelHandler"></a>3.2.1 ChannelHandler</h4><p>从上面的例子上可以看到，我们在服务端使用了继承 <code>ChannelHandler</code> 的方式去做业务逻辑，其实这块一般也是业务的重要地方，需要做什么处理，然后写出什么数据，跟 <code>Controller</code> 的作用相同。 在上面的服务端例子中，业务处理通过继承 <code>ChannelInboundHandlerAdapter</code>（是一个 <code>ChannelHandler</code> 的子类，下面说） 的方式来处理，它的作用是：</p>
<ol>
<li>接收入站事件和数据；</li>
<li>处理完以后，冲刷数据到客户端；</li>
<li>可以关闭连接的方式来结束客户端的连接。</li>
</ol>
<p>通常来说，一个项目会有多个 <code>ChannelInboundHandler</code> 在运行着，处理着业务数据。</p>
<h4 id="3-2-1-ChannelPipeline-2"><a href="#3-2-1-ChannelPipeline-2" class="headerlink" title="3.2.1 ChannelPipeline"></a>3.2.1 ChannelPipeline</h4><p>在服务端和客户端都可以看到 <code>socketChannel.pipeline().addLast(new RequestHandler())</code> 这段代码，那么根据编码经验来说，他应该是个容器。 没错，他还真的是一个容器，一个链表容器，里面装着一个一个的 <code>ChannelHandler</code> 。 具体过程是：</p>
<ol>
<li>启动的时候定义 <code>ChannelInitializer</code>，他将在 <code>Bootstrap</code> 或者 <code>ServerBootstrap</code> 启动的时候进行初始化操作；</li>
<li>当 <code>initChannel</code> 被调用的时候，我们即可安装我们自己的 <code>ChannelHandler</code> 实现，来处理数据传输；</li>
<li><code>ChannelInitializer</code> 将自己从 <code>ChannelPipeline</code> 中移除。</li>
</ol>
<p><code>ChannelHandler</code> 以及子类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162538.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162458.png"></p>
<p>数据入站的时候，将按照安装的顺序，依次执行 <code>ChannelInboundHandler</code> 中的逻辑，其实说到底就是处理链吧，当数据到达 <code>Pipeline</code> 尾端的时候，表示数据处理已经结束。 数据的出站运动（正在被写的数据）则是从 <code>Pipeline</code> 末端开始执行，与 <code>ChannelInboundHandler</code> 执行顺序相反的情况下依次处理。</p>
<blockquote>
<p>Netty 中 提供了 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 两个适配类，其实这两个类就是已经解决了简单顺序传值的问题，Netty 会简单的帮你按照上面的顺序执行 ChannelHandler 我们只需要覆写与业务相关的处理即可。所以如果我们只是想简单的传递的话可以直接使用这两个类。</p>
</blockquote>
<p>在覆写我们感兴趣的函数的时候，通常都可以看到有一个 <code>ChannelHandlerContext</code> 而且示例中也是使用他来写出消息的，除了这种方法写出消息，还有另外一种方法就是使用 <code>Channel</code> 写出（调用：<code>ctx.channel().writeAndFlush()</code>）。前者写出会将消息写到下一个 <code>ChannelHandler</code> 而后者则是让消息从上图中的 <code>ChannelPipeline</code> 末端开始走（与上面区别就是跳过下一个 <code>ChannelInboundHandler</code>）</p>
<h3 id="3-3-Channel和EventLoop-1"><a href="#3-3-Channel和EventLoop-1" class="headerlink" title="3.3 Channel和EventLoop"></a>3.3 Channel和EventLoop</h3><h4 id="3-3-1-Channel-1"><a href="#3-3-1-Channel-1" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h4><h5 id="Java-NIO-1"><a href="#Java-NIO-1" class="headerlink" title="Java NIO"></a>Java NIO</h5><p>说到 <code>Channel</code> 就要说到 <code>Java NIO</code> ，说到 <code>NIO</code> 就要说到 <code>Selector</code> 和 <code>Socket</code>。 说到 <code>NIO</code> 就要先说说这个有趣的名字~</p>
<blockquote>
<p>NIO 刚开始我感觉就是 New IO，可是这么多年过去了，再叫 New IO 就有点不合适了。 所以现在大多数人认为应该叫 Non-blocking IO，而阻塞IO则是 block IO 或者 old IO (BIO/OIO)</p>
</blockquote>
<p>其实聊到 <code>NIO</code> 就应该是，传统的 <code>IO</code> 如果同时执行同一个业务的话，而且想要多人都可以同时并行处理的话，那么就需要开启多个线程来同时执行。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162252.png"> </p>
<p>那么每一个新的客户端进来，我就需要预留一个线程来处理，线程中 <code>BIO</code> 在读取文件或者其他 <code>IO</code> 输入的时候，需要阻塞进入等待，这都算是一种资源浪费（CPU还需要切换线程去查看哪个线程已经阻塞完成了）。据我们所知，一个线程占用栈空间 <code>64k</code> - <code>1m</code>，理论线程越多每个线程拿到的栈空间就更少了。这时候线程他就在那里等待了什么事情都不做，然后还占用了系统上一个线程的位置（系统限制可开启线程数）。如果小数量的线程数（用户数）那么勉强还是撑得过去的，而且工作的也还不错。那么如果上万个用户上十万个用户呢，这时候，<code>CPU</code> 需要浪费很大的力气来切换轮询。 于是乎这时候，<code>NIO</code> 横空出世（其实系统早就支持了，在 <code>jdk1.4</code> 之前都没有支持） <code>NIO</code> 有个很牛逼的管理员 <code>Selector</code>，他的任务就是提交 <code>IO</code> 任务并且告诉系统，他做完了告诉我，我会执行下一步操作。于是乎模型就编程这样：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162315.png"> </p>
<p>这个模型只要一个线程就够了，他找 <code>Selector</code> 要已经完成 <code>IO</code> 操作的名单，然后放到自己的线程开始执行我们的业务逻辑，如果没有 <code>IO</code> 那么这个线程还可以去做其他的事情。</p>
<h5 id="Netty中的Channel-1"><a href="#Netty中的Channel-1" class="headerlink" title="Netty中的Channel"></a>Netty中的Channel</h5><p>在 <code>Netty</code> 中，一个 <code>Channel</code> 代表一个实体（硬件设备，文件，Socket，能够执行一个或不同 <code>IO</code> 操作的程序组件）的连接。这里可以套用 <code>Linux</code> 中万物皆文件的理念，只要是一个物，他就有输入输出，那么她就是 <code>Channel</code>。 而 <code>Channel</code> 中我们实现了他的一些方法如 <code>channelRead</code> <code>channelReadComplete</code>，其实这些是回调事件，我们也可以称实现这些动作是实现回调事件。那么啥是回调事件：</p>
<blockquote>
<p>某件事情执行时间很长，你让他执行完告诉你你去接收他的参数并且接下去做。 比如洗衣服，你扔进洗衣机，洗衣机一般要洗1个小时，洗完了发出滴滴滴的声音。这就是回调了，在这1个小时里面你这个线程就可以去做其他事情，他滴滴滴响了你拿到了结果（衣服洗完了）再去执行一个函数：晾衣服。</p>
</blockquote>
<p>如果你熟悉 <code>JavaScript</code> 那么这一切都很自然，异步请求 <code>Promise</code> 类，<code>Promise.then((result) =&gt; &#123;...&#125;)</code> 里面的 <code>function</code> 她就是回调函数。 <code>jdk8</code> 中提供了很好的回调事件方式的线程类 <code>CompleteFuture</code> 就是用来做这个事情的，你可以使用这个类来体验一下回调事件的感受。（参考文章：<a target="_blank" rel="noopener" href="https://liweidan.cn/java/jdk8/2017/10/25/141/">jdk8 多线程处理的使用</a>） 而 <code>Netty</code> 时代 <code>jdk</code> 还没有到 <code>j8</code> 呀，只提供了 <code>CompleteFuture</code> 的爸爸 <code>Future</code>，那怎么办嘛，<code>Netty</code> 就自己写提个，这就是 <code>ChannelFuture</code> 的出现了。<code>ChannelFuture</code> 也提供了可以自定义的 <code>ChannelFutureListener</code> 来拓展，可以说比 <code>jdk8</code> 的 <code>CompleteFuture</code> 还厉害，可以监听连接完成时做什么（比如检查连接是否正常，远程服务是否能够正确返回信息）。只需要在引导代码里面，使用 <code>ChannelFuture.addListener</code> 即可添加相对应的逻辑。这么说的话，那么 <code>ChannelFutureListener</code> 就是 <code>Future</code> 生命周期中执行的钩子函数。</p>
<h2 id="完结-1"><a href="#完结-1" class="headerlink" title="完结"></a>完结</h2><p>数据入站的时候，将按照安装的顺序，依次执行 <code>ChannelInboundHandler</code> 中的逻辑，其实说到底就是处理链吧，当数据到达 <code>Pipeline</code> 尾端的时候，表示数据处理已经结束。 数据的出站运动（正在被写的数据）则是从 <code>Pipeline</code> 末端开始执行，与 <code>ChannelInboundHandler</code> 执行顺序相反的情况下依次处理。</p>
<blockquote>
<p>Netty 中 提供了 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 两个适配类，其实这两个类就是已经解决了简单顺序传值的问题，Netty 会简单的帮你按照上面的顺序执行 ChannelHandler 我们只需要覆写与业务相关的处理即可。所以如果我们只是想简单的传递的话可以直接使用这两个类。</p>
</blockquote>
<p>在覆写我们感兴趣的函数的时候，通常都可以看到有一个 <code>ChannelHandlerContext</code> 而且示例中也是使用他来写出消息的，除了这种方法写出消息，还有另外一种方法就是使用 <code>Channel</code> 写出（调用：<code>ctx.channel().writeAndFlush()</code>）。前者写出会将消息写到下一个 <code>ChannelHandler</code> 而后者则是让消息从上图中的 <code>ChannelPipeline</code> 末端开始走（与上面区别就是跳过下一个 <code>ChannelInboundHandler</code>）</p>
<h3 id="3-3-Channel和EventLoop-2"><a href="#3-3-Channel和EventLoop-2" class="headerlink" title="3.3 Channel和EventLoop"></a>3.3 Channel和EventLoop</h3><h4 id="3-3-1-Channel-2"><a href="#3-3-1-Channel-2" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h4><h5 id="Java-NIO-2"><a href="#Java-NIO-2" class="headerlink" title="Java NIO"></a>Java NIO</h5><p>说到 <code>Channel</code> 就要说到 <code>Java NIO</code> ，说到 <code>NIO</code> 就要说到 <code>Selector</code> 和 <code>Socket</code>。 说到 <code>NIO</code> 就要先说说这个有趣的名字~</p>
<blockquote>
<p>NIO 刚开始我感觉就是 New IO，可是这么多年过去了，再叫 New IO 就有点不合适了。 所以现在大多数人认为应该叫 Non-blocking IO，而阻塞IO则是 block IO 或者 old IO (BIO/OIO)</p>
</blockquote>
<p>其实聊到 <code>NIO</code> 就应该是，传统的 <code>IO</code> 如果同时执行同一个业务的话，而且想要多人都可以同时并行处理的话，那么就需要开启多个线程来同时执行。 </p>
<h2 id="零-Netty-3"><a href="#零-Netty-3" class="headerlink" title="零.Netty"></a>零.Netty</h2><p>其实了解到 <code>Netty</code> 已经很久了，一直想用，但是因为之前的水平还不够格，回调事件 <code>TCP</code> 什么的还没感觉，所以学起来一头雾水，加上官网的文档，哎呀，官网貌似就没有文档只有示例代码，读不懂。 写了挺多的回调函数，渐渐地有了感觉（通常使用 <code>CompleteFuture</code> 来请求其他服务的数据信息，请求完在执行自己的业务）。其实我也不知道我做了什么，貌似什么没做就突然融会贯通了，所以我感觉理解回调还是蛮重要的一点吧。 突然看到自己的书本库有本书《Netty实战》翻起来阅读，还是蛮好的，这篇文章其实是我读这本书，加上自己的一些理解写出来的。 <code>Netty</code> 是什么应该没人不会知道吧，就是 <code>Java</code> 行业中一个能够顶级处理网络通讯的轻量级框架，如果公司在使用 <code>Dubbo</code> 或者 <code>Thrift</code> 的话，那么也是间接在使用 <code>Netty</code> 框架了。所以学一学无伤大雅还可以了解一些很有趣的东西。</p>
<h2 id="一-Netty服务端-3"><a href="#一-Netty服务端-3" class="headerlink" title="一.Netty服务端"></a>一.Netty服务端</h2><p>所有 <code>Netty服务器</code> 通常需要以下两部分：</p>
<ol>
<li>至少一个 <code>ChannelHandler</code> 来接手客户端的数据以及处理数据；</li>
<li>引导服务器启动的配置，配置启动参数，这个就没啥好说的了。</li>
</ol>
<p><code>ChannelHandler</code> 是 <code>Netty</code> 中一个接口族的父接口，它主要负责接收和响应事件通知。 在 <code>Netty</code> 中 <code>ChannelHandler</code> 有很多默认实现，用来处理服务器中常见的数据传输问题。 因为服务器会响应传入的消息，所以需要实现 <code>ChannelInboundHandler</code> 接口，用来定义响应入站事件的方法。由于刚开始的程序只需要简单的方式即可，所以我们实现 <code>ChannelInboundHandlerAdapter</code> 即可，他提供了 <code>ChannelInboundHandler</code> 接口的默认实现。 我现在想要简单的实现一个服务，就是能够把把我发送的字符串，给反转过来，即发送 <code>abc</code> 服务器给我响应 <code>cba</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转服务器的处理逻辑类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringReverseHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(<span class="string">&quot;Server Receive Message: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    String newMsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] strings = message.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      newMsg += strings[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用工具类构建 ByteBuf 对象写出去 */</span></span><br><span class="line">    ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes());</span><br><span class="line">    ctx.writeAndFlush(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要编写服务的引导类，这个引导类主要实现两大功能：</p>
<ol>
<li>绑定哪个端口；</li>
<li>绑定上面写的 <code>Handler</code> 实现业务处理.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoop;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> StringReverseHandler handler = <span class="keyword">new</span> StringReverseHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此服务端任务就完成了，这时候只要启动服务端，等待客户端的介入即可处理业务。</p>
<h2 id="二-Netty客户端-3"><a href="#二-Netty客户端-3" class="headerlink" title="二.Netty客户端"></a>二.Netty客户端</h2><p>同上，所有的 <code>Netty客户端</code> 基本也是跟服务端差不多的事情：</p>
<ol>
<li>连接服务端；</li>
<li>发送消息；</li>
<li>获取服务端处理的结果；</li>
<li>关闭连接.</li>
</ol>
<p>同服务端处理一致，客户端也拥有一个 <code>ChannelInboundHandler</code> 来处理我们需要请求的业务。我们暂时可以使用 <code>SimpleChannelInboundHandler</code> 来执行我们必须的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.deploy.net.CrossDomainXML;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 服务端发送消息后执行的逻辑，直接打印 */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Client Receive Message: &quot;</span> + byteBuf.toString(Charset.defaultCharset()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们需要实现客户端的启动器，除了客户端需要使用 <code>OIO</code> 传输以外，其他需要做的事情基本是一致的。</p>
<h2 id="三-运行服务端和客户端-3"><a href="#三-运行服务端和客户端-3" class="headerlink" title="三.运行服务端和客户端"></a>三.运行服务端和客户端</h2><p><img src="./SimpleNettyDemoTest.gif"> </p>
<p>OK，我们分别启动 <code>服务端</code> 和 <code>客户端</code>，可见 <code>客户端</code> 在连接完成的时候，像 <code>服务端</code> 发送了 <code>HelloWorld</code>，服务端处理完成后，客户端即接收到 <code>Client Receive Message: dlroWolleH</code></p>
<h2 id="三-Netty组件-3"><a href="#三-Netty组件-3" class="headerlink" title="三.Netty组件"></a>三.Netty组件</h2><p>OK，硬着头皮写到这里，项目也运行还算正常，感觉还不错。那么接下来就需要来了解一下各个组件了。</p>
<h3 id="3-1-Netty主要组件-3"><a href="#3-1-Netty主要组件-3" class="headerlink" title="3.1 Netty主要组件"></a>3.1 Netty主要组件</h3><p>组件的顺序是从业务处理器，再到软件启动引导：</p>
<ol>
<li><code>ChannelHandler</code></li>
<li><code>EventLoopGroup</code></li>
<li><code>Channel</code></li>
<li><code>ServerBootstrap</code> 服务端启动类，而客户端使用的是 <code>Bootstrap</code></li>
<li><code>ChannelInitializer</code> 主要用来初始化注册安装 <code>ChannelHandler</code></li>
<li><code>ChannelPipeline</code> 存放 <code>ChannelHandler</code> 的链表容器</li>
</ol>
<p>而下面的顺序则没有按照上面的顺序，因为我想从里面了解到外面，里面相对看起来比较简单。</p>
<h3 id="3-2-ChannelHandler和ChannelPipeline-3"><a href="#3-2-ChannelHandler和ChannelPipeline-3" class="headerlink" title="3.2 ChannelHandler和ChannelPipeline"></a>3.2 ChannelHandler和ChannelPipeline</h3><h4 id="3-2-1-ChannelHandler-3"><a href="#3-2-1-ChannelHandler-3" class="headerlink" title="3.2.1 ChannelHandler"></a>3.2.1 ChannelHandler</h4><p>从上面的例子上可以看到，我们在服务端使用了继承 <code>ChannelHandler</code> 的方式去做业务逻辑，其实这块一般也是业务的重要地方，需要做什么处理，然后写出什么数据，跟 <code>Controller</code> 的作用相同。 在上面的服务端例子中，业务处理通过继承 <code>ChannelInboundHandlerAdapter</code>（是一个 <code>ChannelHandler</code> 的子类，下面说） 的方式来处理，它的作用是：</p>
<ol>
<li>接收入站事件和数据；</li>
<li>处理完以后，冲刷数据到客户端；</li>
<li>可以关闭连接的方式来结束客户端的连接。</li>
</ol>
<p>通常来说，一个项目会有多个 <code>ChannelInboundHandler</code> 在运行着，处理着业务数据。</p>
<h4 id="3-2-1-ChannelPipeline-3"><a href="#3-2-1-ChannelPipeline-3" class="headerlink" title="3.2.1 ChannelPipeline"></a>3.2.1 ChannelPipeline</h4><p>在服务端和客户端都可以看到 <code>socketChannel.pipeline().addLast(new RequestHandler())</code> 这段代码，那么根据编码经验来说，他应该是个容器。 没错，他还真的是一个容器，一个链表容器，里面装着一个一个的 <code>ChannelHandler</code> 。 具体过程是：</p>
<ol>
<li>启动的时候定义 <code>ChannelInitializer</code>，他将在 <code>Bootstrap</code> 或者 <code>ServerBootstrap</code> 启动的时候进行初始化操作；</li>
<li>当 <code>initChannel</code> 被调用的时候，我们即可安装我们自己的 <code>ChannelHandler</code> 实现，来处理数据传输；</li>
<li><code>ChannelInitializer</code> 将自己从 <code>ChannelPipeline</code> 中移除。</li>
</ol>
<p><code>ChannelHandler</code> 以及子类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162538.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162458.png"></p>
<p>数据入站的时候，将按照安装的顺序，依次执行 <code>ChannelInboundHandler</code> 中的逻辑，其实说到底就是处理链吧，当数据到达 <code>Pipeline</code> 尾端的时候，表示数据处理已经结束。 数据的出站运动（正在被写的数据）则是从 <code>Pipeline</code> 末端开始执行，与 <code>ChannelInboundHandler</code> 执行顺序相反的情况下依次处理。</p>
<blockquote>
<p>Netty 中 提供了 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 两个适配类，其实这两个类就是已经解决了简单顺序传值的问题，Netty 会简单的帮你按照上面的顺序执行 ChannelHandler 我们只需要覆写与业务相关的处理即可。所以如果我们只是想简单的传递的话可以直接使用这两个类。</p>
</blockquote>
<p>在覆写我们感兴趣的函数的时候，通常都可以看到有一个 <code>ChannelHandlerContext</code> 而且示例中也是使用他来写出消息的，除了这种方法写出消息，还有另外一种方法就是使用 <code>Channel</code> 写出（调用：<code>ctx.channel().writeAndFlush()</code>）。前者写出会将消息写到下一个 <code>ChannelHandler</code> 而后者则是让消息从上图中的 <code>ChannelPipeline</code> 末端开始走（与上面区别就是跳过下一个 <code>ChannelInboundHandler</code>）</p>
<h3 id="3-3-Channel和EventLoop-3"><a href="#3-3-Channel和EventLoop-3" class="headerlink" title="3.3 Channel和EventLoop"></a>3.3 Channel和EventLoop</h3><h4 id="3-3-1-Channel-3"><a href="#3-3-1-Channel-3" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h4><h5 id="Java-NIO-3"><a href="#Java-NIO-3" class="headerlink" title="Java NIO"></a>Java NIO</h5><p>说到 <code>Channel</code> 就要说到 <code>Java NIO</code> ，说到 <code>NIO</code> 就要说到 <code>Selector</code> 和 <code>Socket</code>。 说到 <code>NIO</code> 就要先说说这个有趣的名字~</p>
<blockquote>
<p>NIO 刚开始我感觉就是 New IO，可是这么多年过去了，再叫 New IO 就有点不合适了。 所以现在大多数人认为应该叫 Non-blocking IO，而阻塞IO则是 block IO 或者 old IO (BIO/OIO)</p>
</blockquote>
<p>其实聊到 <code>NIO</code> 就应该是，传统的 <code>IO</code> 如果同时执行同一个业务的话，而且想要多人都可以同时并行处理的话，那么就需要开启多个线程来同时执行。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162252.png"> </p>
<p>那么每一个新的客户端进来，我就需要预留一个线程来处理，线程中 <code>BIO</code> 在读取文件或者其他 <code>IO</code> 输入的时候，需要阻塞进入等待，这都算是一种资源浪费（CPU还需要切换线程去查看哪个线程已经阻塞完成了）。据我们所知，一个线程占用栈空间 <code>64k</code> - <code>1m</code>，理论线程越多每个线程拿到的栈空间就更少了。这时候线程他就在那里等待了什么事情都不做，然后还占用了系统上一个线程的位置（系统限制可开启线程数）。如果小数量的线程数（用户数）那么勉强还是撑得过去的，而且工作的也还不错。那么如果上万个用户上十万个用户呢，这时候，<code>CPU</code> 需要浪费很大的力气来切换轮询。 于是乎这时候，<code>NIO</code> 横空出世（其实系统早就支持了，在 <code>jdk1.4</code> 之前都没有支持） <code>NIO</code> 有个很牛逼的管理员 <code>Selector</code>，他的任务就是提交 <code>IO</code> 任务并且告诉系统，他做完了告诉我，我会执行下一步操作。于是乎模型就编程这样：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162315.png"> </p>
<p>这个模型只要一个线程就够了，他找 <code>Selector</code> 要已经完成 <code>IO</code> 操作的名单，然后放到自己的线程开始执行我们的业务逻辑，如果没有 <code>IO</code> 那么这个线程还可以去做其他的事情。</p>
<h5 id="Netty中的Channel-2"><a href="#Netty中的Channel-2" class="headerlink" title="Netty中的Channel"></a>Netty中的Channel</h5><p>在 <code>Netty</code> 中，一个 <code>Channel</code> 代表一个实体（硬件设备，文件，Socket，能够执行一个或不同 <code>IO</code> 操作的程序组件）的连接。这里可以套用 <code>Linux</code> 中万物皆文件的理念，只要是一个物，他就有输入输出，那么她就是 <code>Channel</code>。 而 <code>Channel</code> 中我们实现了他的一些方法如 <code>channelRead</code> <code>channelReadComplete</code>，其实这些是回调事件，我们也可以称实现这些动作是实现回调事件。那么啥是回调事件：</p>
<blockquote>
<p>某件事情执行时间很长，你让他执行完告诉你你去接收他的参数并且接下去做。 比如洗衣服，你扔进洗衣机，洗衣机一般要洗1个小时，洗完了发出滴滴滴的声音。这就是回调了，在这1个小时里面你这个线程就可以去做其他事情，他滴滴滴响了你拿到了结果（衣服洗完了）再去执行一个函数：晾衣服。</p>
</blockquote>
<p>如果你熟悉 <code>JavaScript</code> 那么这一切都很自然，异步请求 <code>Promise</code> 类，<code>Promise.then((result) =&gt; &#123;...&#125;)</code> 里面的 <code>function</code> 她就是回调函数。 <code>jdk8</code> 中提供了很好的回调事件方式的线程类 <code>CompleteFuture</code> 就是用来做这个事情的，你可以使用这个类来体验一下回调事件的感受。（参考文章：<a target="_blank" rel="noopener" href="https://liweidan.cn/java/jdk8/2017/10/25/141/">jdk8 多线程处理的使用</a>） 而 <code>Netty</code> 时代 <code>jdk</code> 还没有到 <code>j8</code> 呀，只提供了 <code>CompleteFuture</code> 的爸爸 <code>Future</code>，那怎么办嘛，<code>Netty</code> 就自己写提个，这就是 <code>ChannelFuture</code> 的出现了。<code>ChannelFuture</code> 也提供了可以自定义的 <code>ChannelFutureListener</code> 来拓展，可以说比 <code>jdk8</code> 的 <code>CompleteFuture</code> 还厉害，可以监听连接完成时做什么（比如检查连接是否正常，远程服务是否能够正确返回信息）。只需要在引导代码里面，使用 <code>ChannelFuture.addListener</code> 即可添加相对应的逻辑。这么说的话，那么 <code>ChannelFutureListener</code> 就是 <code>Future</code> 生命周期中执行的钩子函数。</p>
<h2 id="完结-2"><a href="#完结-2" class="headerlink" title="完结"></a>完结</h2><p>那么每一个新的客户端进来，我就需要预留一个线程来处理，线程中 <code>BIO</code> 在读取文件或者其他 <code>IO</code> 输入的时候，需要阻塞进入等待，这都算是一种资源浪费（CPU还需要切换线程去查看哪个线程已经阻塞完成了）。据我们所知，一个线程占用栈空间 <code>64k</code> - <code>1m</code>，理论线程越多每个线程拿到的栈空间就更少了。这时候线程他就在那里等待了什么事情都不做，然后还占用了系统上一个线程的位置（系统限制可开启线程数）。如果小数量的线程数（用户数）那么勉强还是撑得过去的，而且工作的也还不错。那么如果上万个用户上十万个用户呢，这时候，<code>CPU</code> 需要浪费很大的力气来切换轮询。 于是乎这时候，<code>NIO</code> 横空出世（其实系统早就支持了，在 <code>jdk1.4</code> 之前都没有支持） <code>NIO</code> 有个很牛逼的管理员 <code>Selector</code>，他的任务就是提交 <code>IO</code> 任务并且告诉系统，他做完了告诉我，我会执行下一步操作。于是乎模型就编程这样：</p>
<h2 id="零-Netty-4"><a href="#零-Netty-4" class="headerlink" title="零.Netty"></a>零.Netty</h2><p>其实了解到 <code>Netty</code> 已经很久了，一直想用，但是因为之前的水平还不够格，回调事件 <code>TCP</code> 什么的还没感觉，所以学起来一头雾水，加上官网的文档，哎呀，官网貌似就没有文档只有示例代码，读不懂。 写了挺多的回调函数，渐渐地有了感觉（通常使用 <code>CompleteFuture</code> 来请求其他服务的数据信息，请求完在执行自己的业务）。其实我也不知道我做了什么，貌似什么没做就突然融会贯通了，所以我感觉理解回调还是蛮重要的一点吧。 突然看到自己的书本库有本书《Netty实战》翻起来阅读，还是蛮好的，这篇文章其实是我读这本书，加上自己的一些理解写出来的。 <code>Netty</code> 是什么应该没人不会知道吧，就是 <code>Java</code> 行业中一个能够顶级处理网络通讯的轻量级框架，如果公司在使用 <code>Dubbo</code> 或者 <code>Thrift</code> 的话，那么也是间接在使用 <code>Netty</code> 框架了。所以学一学无伤大雅还可以了解一些很有趣的东西。</p>
<h2 id="一-Netty服务端-4"><a href="#一-Netty服务端-4" class="headerlink" title="一.Netty服务端"></a>一.Netty服务端</h2><p>所有 <code>Netty服务器</code> 通常需要以下两部分：</p>
<ol>
<li>至少一个 <code>ChannelHandler</code> 来接手客户端的数据以及处理数据；</li>
<li>引导服务器启动的配置，配置启动参数，这个就没啥好说的了。</li>
</ol>
<p><code>ChannelHandler</code> 是 <code>Netty</code> 中一个接口族的父接口，它主要负责接收和响应事件通知。 在 <code>Netty</code> 中 <code>ChannelHandler</code> 有很多默认实现，用来处理服务器中常见的数据传输问题。 因为服务器会响应传入的消息，所以需要实现 <code>ChannelInboundHandler</code> 接口，用来定义响应入站事件的方法。由于刚开始的程序只需要简单的方式即可，所以我们实现 <code>ChannelInboundHandlerAdapter</code> 即可，他提供了 <code>ChannelInboundHandler</code> 接口的默认实现。 我现在想要简单的实现一个服务，就是能够把把我发送的字符串，给反转过来，即发送 <code>abc</code> 服务器给我响应 <code>cba</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转服务器的处理逻辑类.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** 标记该 Channel 是线程安全的. */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringReverseHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf in = (ByteBuf) msg;</span><br><span class="line">    String message = in.toString(Charset.defaultCharset());</span><br><span class="line">    System.out.println(<span class="string">&quot;Server Receive Message: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">    String newMsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String[] strings = message.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = strings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      newMsg += strings[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用工具类构建 ByteBuf 对象写出去 */</span></span><br><span class="line">    ByteBuf out = Unpooled.copiedBuffer(newMsg.getBytes());</span><br><span class="line">    ctx.writeAndFlush(out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 当客户端读取完毕的时候，关闭客户端 */</span></span><br><span class="line">    ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">            .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 可以覆写，实现出现异常的时候执行的逻辑 */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来需要编写服务的引导类，这个引导类主要实现两大功能：</p>
<ol>
<li>绑定哪个端口；</li>
<li>绑定上面写的 <code>Handler</code> 实现业务处理.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoop;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器引导类.</span></span><br><span class="line"><span class="comment"> * 主要实现：</span></span><br><span class="line"><span class="comment"> *  1. 绑定哪个端口；</span></span><br><span class="line"><span class="comment"> *  2. 绑定自己写的 Handler 以便执行业务.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerLaunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/** 创建 EventLoopGroup */</span></span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">final</span> StringReverseHandler handler = <span class="keyword">new</span> StringReverseHandler();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap sb = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      sb.group(group)</span><br><span class="line">              <span class="comment">/** 指定所使用的的 NIO 传输的 Channel */</span></span><br><span class="line">              .channel(NioServerSocketChannel.class)</span><br><span class="line">              <span class="comment">/** 绑定服务器端口 */</span></span><br><span class="line">              .localAddress(<span class="number">8888</span>)</span><br><span class="line">              <span class="comment">/** 添加我们自己的业务处理 Handler 到子级的 Channel 的 ChannelPipeline中  */</span></span><br><span class="line">              .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">/** 添加我们自己的 Handler 实现，因为线程安全的，所以只使用一个实例 */</span></span><br><span class="line">                  socketChannel.pipeline()</span><br><span class="line">                          .addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">      <span class="comment">/** 异步绑定服务器，阻塞到直到绑定完成 */</span></span><br><span class="line">      ChannelFuture future = sb.bind().sync();</span><br><span class="line">      <span class="comment">/** 获取 Channel 的 CloseFuture 阻塞到关闭完成 */</span></span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">/** 关闭 EventLoopGroup 释放资源 */</span></span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此服务端任务就完成了，这时候只要启动服务端，等待客户端的介入即可处理业务。</p>
<h2 id="二-Netty客户端-4"><a href="#二-Netty客户端-4" class="headerlink" title="二.Netty客户端"></a>二.Netty客户端</h2><p>同上，所有的 <code>Netty客户端</code> 基本也是跟服务端差不多的事情：</p>
<ol>
<li>连接服务端；</li>
<li>发送消息；</li>
<li>获取服务端处理的结果；</li>
<li>关闭连接.</li>
</ol>
<p>同服务端处理一致，客户端也拥有一个 <code>ChannelInboundHandler</code> 来处理我们需要请求的业务。我们暂时可以使用 <code>SimpleChannelInboundHandler</code> 来执行我们必须的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.liweidan.nettydemo.demo01.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.deploy.net.CrossDomainXML;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端请求处理器.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liweidan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-07-17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span> toweidan@126.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** Channel 建立连接完成后，执行的业务，发送一个 HelloWorld 的编码并使用 ByteBuf 包装 */</span></span><br><span class="line">    ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(</span><br><span class="line">                    <span class="string">&quot;HelloWorld&quot;</span>.getBytes(Charset.defaultCharset().name())));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 服务端发送消息后执行的逻辑，直接打印 */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Client Receive Message: &quot;</span> + byteBuf.toString(Charset.defaultCharset()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">/** 发生异常时关闭 Channel */</span></span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们需要实现客户端的启动器，除了客户端需要使用 <code>OIO</code> 传输以外，其他需要做的事情基本是一致的。</p>
<h2 id="三-运行服务端和客户端-4"><a href="#三-运行服务端和客户端-4" class="headerlink" title="三.运行服务端和客户端"></a>三.运行服务端和客户端</h2><p><img src="./SimpleNettyDemoTest.gif"> </p>
<p>OK，我们分别启动 <code>服务端</code> 和 <code>客户端</code>，可见 <code>客户端</code> 在连接完成的时候，像 <code>服务端</code> 发送了 <code>HelloWorld</code>，服务端处理完成后，客户端即接收到 <code>Client Receive Message: dlroWolleH</code></p>
<h2 id="三-Netty组件-4"><a href="#三-Netty组件-4" class="headerlink" title="三.Netty组件"></a>三.Netty组件</h2><p>OK，硬着头皮写到这里，项目也运行还算正常，感觉还不错。那么接下来就需要来了解一下各个组件了。</p>
<h3 id="3-1-Netty主要组件-4"><a href="#3-1-Netty主要组件-4" class="headerlink" title="3.1 Netty主要组件"></a>3.1 Netty主要组件</h3><p>组件的顺序是从业务处理器，再到软件启动引导：</p>
<ol>
<li><code>ChannelHandler</code></li>
<li><code>EventLoopGroup</code></li>
<li><code>Channel</code></li>
<li><code>ServerBootstrap</code> 服务端启动类，而客户端使用的是 <code>Bootstrap</code></li>
<li><code>ChannelInitializer</code> 主要用来初始化注册安装 <code>ChannelHandler</code></li>
<li><code>ChannelPipeline</code> 存放 <code>ChannelHandler</code> 的链表容器</li>
</ol>
<p>而下面的顺序则没有按照上面的顺序，因为我想从里面了解到外面，里面相对看起来比较简单。</p>
<h3 id="3-2-ChannelHandler和ChannelPipeline-4"><a href="#3-2-ChannelHandler和ChannelPipeline-4" class="headerlink" title="3.2 ChannelHandler和ChannelPipeline"></a>3.2 ChannelHandler和ChannelPipeline</h3><h4 id="3-2-1-ChannelHandler-4"><a href="#3-2-1-ChannelHandler-4" class="headerlink" title="3.2.1 ChannelHandler"></a>3.2.1 ChannelHandler</h4><p>从上面的例子上可以看到，我们在服务端使用了继承 <code>ChannelHandler</code> 的方式去做业务逻辑，其实这块一般也是业务的重要地方，需要做什么处理，然后写出什么数据，跟 <code>Controller</code> 的作用相同。 在上面的服务端例子中，业务处理通过继承 <code>ChannelInboundHandlerAdapter</code>（是一个 <code>ChannelHandler</code> 的子类，下面说） 的方式来处理，它的作用是：</p>
<ol>
<li>接收入站事件和数据；</li>
<li>处理完以后，冲刷数据到客户端；</li>
<li>可以关闭连接的方式来结束客户端的连接。</li>
</ol>
<p>通常来说，一个项目会有多个 <code>ChannelInboundHandler</code> 在运行着，处理着业务数据。</p>
<h4 id="3-2-1-ChannelPipeline-4"><a href="#3-2-1-ChannelPipeline-4" class="headerlink" title="3.2.1 ChannelPipeline"></a>3.2.1 ChannelPipeline</h4><p>在服务端和客户端都可以看到 <code>socketChannel.pipeline().addLast(new RequestHandler())</code> 这段代码，那么根据编码经验来说，他应该是个容器。 没错，他还真的是一个容器，一个链表容器，里面装着一个一个的 <code>ChannelHandler</code> 。 具体过程是：</p>
<ol>
<li>启动的时候定义 <code>ChannelInitializer</code>，他将在 <code>Bootstrap</code> 或者 <code>ServerBootstrap</code> 启动的时候进行初始化操作；</li>
<li>当 <code>initChannel</code> 被调用的时候，我们即可安装我们自己的 <code>ChannelHandler</code> 实现，来处理数据传输；</li>
<li><code>ChannelInitializer</code> 将自己从 <code>ChannelPipeline</code> 中移除。</li>
</ol>
<p><code>ChannelHandler</code> 以及子类：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162538.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162458.png"></p>
<p>数据入站的时候，将按照安装的顺序，依次执行 <code>ChannelInboundHandler</code> 中的逻辑，其实说到底就是处理链吧，当数据到达 <code>Pipeline</code> 尾端的时候，表示数据处理已经结束。 数据的出站运动（正在被写的数据）则是从 <code>Pipeline</code> 末端开始执行，与 <code>ChannelInboundHandler</code> 执行顺序相反的情况下依次处理。</p>
<blockquote>
<p>Netty 中 提供了 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 两个适配类，其实这两个类就是已经解决了简单顺序传值的问题，Netty 会简单的帮你按照上面的顺序执行 ChannelHandler 我们只需要覆写与业务相关的处理即可。所以如果我们只是想简单的传递的话可以直接使用这两个类。</p>
</blockquote>
<p>在覆写我们感兴趣的函数的时候，通常都可以看到有一个 <code>ChannelHandlerContext</code> 而且示例中也是使用他来写出消息的，除了这种方法写出消息，还有另外一种方法就是使用 <code>Channel</code> 写出（调用：<code>ctx.channel().writeAndFlush()</code>）。前者写出会将消息写到下一个 <code>ChannelHandler</code> 而后者则是让消息从上图中的 <code>ChannelPipeline</code> 末端开始走（与上面区别就是跳过下一个 <code>ChannelInboundHandler</code>）</p>
<h3 id="3-3-Channel和EventLoop-4"><a href="#3-3-Channel和EventLoop-4" class="headerlink" title="3.3 Channel和EventLoop"></a>3.3 Channel和EventLoop</h3><h4 id="3-3-1-Channel-4"><a href="#3-3-1-Channel-4" class="headerlink" title="3.3.1 Channel"></a>3.3.1 Channel</h4><h5 id="Java-NIO-4"><a href="#Java-NIO-4" class="headerlink" title="Java NIO"></a>Java NIO</h5><p>说到 <code>Channel</code> 就要说到 <code>Java NIO</code> ，说到 <code>NIO</code> 就要说到 <code>Selector</code> 和 <code>Socket</code>。 说到 <code>NIO</code> 就要先说说这个有趣的名字~</p>
<blockquote>
<p>NIO 刚开始我感觉就是 New IO，可是这么多年过去了，再叫 New IO 就有点不合适了。 所以现在大多数人认为应该叫 Non-blocking IO，而阻塞IO则是 block IO 或者 old IO (BIO/OIO)</p>
</blockquote>
<p>其实聊到 <code>NIO</code> 就应该是，传统的 <code>IO</code> 如果同时执行同一个业务的话，而且想要多人都可以同时并行处理的话，那么就需要开启多个线程来同时执行。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162252.png"> </p>
<p>那么每一个新的客户端进来，我就需要预留一个线程来处理，线程中 <code>BIO</code> 在读取文件或者其他 <code>IO</code> 输入的时候，需要阻塞进入等待，这都算是一种资源浪费（CPU还需要切换线程去查看哪个线程已经阻塞完成了）。据我们所知，一个线程占用栈空间 <code>64k</code> - <code>1m</code>，理论线程越多每个线程拿到的栈空间就更少了。这时候线程他就在那里等待了什么事情都不做，然后还占用了系统上一个线程的位置（系统限制可开启线程数）。如果小数量的线程数（用户数）那么勉强还是撑得过去的，而且工作的也还不错。那么如果上万个用户上十万个用户呢，这时候，<code>CPU</code> 需要浪费很大的力气来切换轮询。 于是乎这时候，<code>NIO</code> 横空出世（其实系统早就支持了，在 <code>jdk1.4</code> 之前都没有支持） <code>NIO</code> 有个很牛逼的管理员 <code>Selector</code>，他的任务就是提交 <code>IO</code> 任务并且告诉系统，他做完了告诉我，我会执行下一步操作。于是乎模型就编程这样：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110162315.png"> </p>
<p>这个模型只要一个线程就够了，他找 <code>Selector</code> 要已经完成 <code>IO</code> 操作的名单，然后放到自己的线程开始执行我们的业务逻辑，如果没有 <code>IO</code> 那么这个线程还可以去做其他的事情。</p>
<h5 id="Netty中的Channel-3"><a href="#Netty中的Channel-3" class="headerlink" title="Netty中的Channel"></a>Netty中的Channel</h5><p>在 <code>Netty</code> 中，一个 <code>Channel</code> 代表一个实体（硬件设备，文件，Socket，能够执行一个或不同 <code>IO</code> 操作的程序组件）的连接。这里可以套用 <code>Linux</code> 中万物皆文件的理念，只要是一个物，他就有输入输出，那么她就是 <code>Channel</code>。 而 <code>Channel</code> 中我们实现了他的一些方法如 <code>channelRead</code> <code>channelReadComplete</code>，其实这些是回调事件，我们也可以称实现这些动作是实现回调事件。那么啥是回调事件：</p>
<blockquote>
<p>某件事情执行时间很长，你让他执行完告诉你你去接收他的参数并且接下去做。 比如洗衣服，你扔进洗衣机，洗衣机一般要洗1个小时，洗完了发出滴滴滴的声音。这就是回调了，在这1个小时里面你这个线程就可以去做其他事情，他滴滴滴响了你拿到了结果（衣服洗完了）再去执行一个函数：晾衣服。</p>
</blockquote>
<p>如果你熟悉 <code>JavaScript</code> 那么这一切都很自然，异步请求 <code>Promise</code> 类，<code>Promise.then((result) =&gt; &#123;...&#125;)</code> 里面的 <code>function</code> 她就是回调函数。 <code>jdk8</code> 中提供了很好的回调事件方式的线程类 <code>CompleteFuture</code> 就是用来做这个事情的，你可以使用这个类来体验一下回调事件的感受。（参考文章：<a target="_blank" rel="noopener" href="https://liweidan.cn/java/jdk8/2017/10/25/141/">jdk8 多线程处理的使用</a>） 而 <code>Netty</code> 时代 <code>jdk</code> 还没有到 <code>j8</code> 呀，只提供了 <code>CompleteFuture</code> 的爸爸 <code>Future</code>，那怎么办嘛，<code>Netty</code> 就自己写提个，这就是 <code>ChannelFuture</code> 的出现了。<code>ChannelFuture</code> 也提供了可以自定义的 <code>ChannelFutureListener</code> 来拓展，可以说比 <code>jdk8</code> 的 <code>CompleteFuture</code> 还厉害，可以监听连接完成时做什么（比如检查连接是否正常，远程服务是否能够正确返回信息）。只需要在引导代码里面，使用 <code>ChannelFuture.addListener</code> 即可添加相对应的逻辑。这么说的话，那么 <code>ChannelFutureListener</code> 就是 <code>Future</code> 生命周期中执行的钩子函数。</p>
<h2 id="完结-3"><a href="#完结-3" class="headerlink" title="完结"></a>完结</h2><p>这个模型只要一个线程就够了，他找 <code>Selector</code> 要已经完成 <code>IO</code> 操作的名单，然后放到自己的线程开始执行我们的业务逻辑，如果没有 <code>IO</code> 那么这个线程还可以去做其他的事情。</p>
<h5 id="Netty中的Channel-4"><a href="#Netty中的Channel-4" class="headerlink" title="Netty中的Channel"></a>Netty中的Channel</h5><p>在 <code>Netty</code> 中，一个 <code>Channel</code> 代表一个实体（硬件设备，文件，Socket，能够执行一个或不同 <code>IO</code> 操作的程序组件）的连接。这里可以套用 <code>Linux</code> 中万物皆文件的理念，只要是一个物，他就有输入输出，那么她就是 <code>Channel</code>。 而 <code>Channel</code> 中我们实现了他的一些方法如 <code>channelRead</code> <code>channelReadComplete</code>，其实这些是回调事件，我们也可以称实现这些动作是实现回调事件。那么啥是回调事件：</p>
<blockquote>
<p>某件事情执行时间很长，你让他执行完告诉你你去接收他的参数并且接下去做。 比如洗衣服，你扔进洗衣机，洗衣机一般要洗1个小时，洗完了发出滴滴滴的声音。这就是回调了，在这1个小时里面你这个线程就可以去做其他事情，他滴滴滴响了你拿到了结果（衣服洗完了）再去执行一个函数：晾衣服。</p>
</blockquote>
<p>如果你熟悉 <code>JavaScript</code> 那么这一切都很自然，异步请求 <code>Promise</code> 类，<code>Promise.then((result) =&gt; &#123;...&#125;)</code> 里面的 <code>function</code> 她就是回调函数。 <code>jdk8</code> 中提供了很好的回调事件方式的线程类 <code>CompleteFuture</code> 就是用来做这个事情的，你可以使用这个类来体验一下回调事件的感受。（参考文章：<a target="_blank" rel="noopener" href="https://liweidan.cn/java/jdk8/2017/10/25/141/">jdk8 多线程处理的使用</a>） 而 <code>Netty</code> 时代 <code>jdk</code> 还没有到 <code>j8</code> 呀，只提供了 <code>CompleteFuture</code> 的爸爸 <code>Future</code>，那怎么办嘛，<code>Netty</code> 就自己写提个，这就是 <code>ChannelFuture</code> 的出现了。<code>ChannelFuture</code> 也提供了可以自定义的 <code>ChannelFutureListener</code> 来拓展，可以说比 <code>jdk8</code> 的 <code>CompleteFuture</code> 还厉害，可以监听连接完成时做什么（比如检查连接是否正常，远程服务是否能够正确返回信息）。只需要在引导代码里面，使用 <code>ChannelFuture.addListener</code> 即可添加相对应的逻辑。这么说的话，那么 <code>ChannelFutureListener</code> 就是 <code>Future</code> 生命周期中执行的钩子函数。</p>
<h2 id="完结-4"><a href="#完结-4" class="headerlink" title="完结"></a>完结</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/frame/spring-cloud/ddd%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/frame/spring-cloud/ddd%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">DDD和微服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-17 16:05:45" itemprop="dateCreated datePublished" datetime="2019-06-17T16:05:45+08:00">2019-06-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 16:11:56" itemprop="dateModified" datetime="2020-11-10T16:11:56+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/" itemprop="url" rel="index"><span itemprop="name">frame</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/frame/spring-cloud/" itemprop="url" rel="index"><span itemprop="name">spring-cloud</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-DDD"><a href="#一-DDD" class="headerlink" title="一. DDD"></a>一. DDD</h2><p><code>DDD</code> 是 Martin Folwer 提出来的，对现有常见开发模式的一种反转。 举个栗子，我们通常拿到一个业务需求，开始辨认可能需要用到的属性，然后做成数据库表，接着开始编写 <code>JavaBean</code> 映射类。写完了，就开始把需求在业务中实现，开始 <code>get</code> 来 <code>set</code> 去的生活。讲道理，我之前刚刚入门的时候就觉得这种模式太枯燥了，千篇一律，<code>Java</code> 刚开始学的面向对象思想也不知道跑到哪里去了。 后来接触了《领域驱动设计 Domain Design Driven》（简称 <code>DDD</code>）这本返璞归真的业务编写指导，才逐渐的觉悟，原来之前那种方式完全都是面向过程的形式，也就是说，我们在用面向对象语言编写面向过程的代码。 先简单说说 <code>DDD</code> 主要讲了什么: <code>DDD</code> 主要通过建立业务通用语言（该语言将会贯穿整个开发上下文，并且是开发人员与业务人员沟通的桥梁，如：一个产品在产品上下文叫产品定义，在仓储上下文则应该称为库存件），将语言通过一种<strong>易于维护的组织形式在编码中表达出来</strong>，这样开发人员可以通过快速阅读代码，达到如同在阅读业务文档一样的效果。</p>
<h2 id="二-DDD的概念"><a href="#二-DDD的概念" class="headerlink" title="二. DDD的概念"></a>二. DDD的概念</h2><p><code>DDD</code> 涉及一些概念，如果还没理解透彻 <code>Java</code> 中这些概念的使用的话，那么理解起来是有点晦涩的。 我这里可以先简单总结一下：在 <code>Java</code> 中，模块的划分可以通过 <code>包</code> 这个概念来划分，包中 <code>public</code> 是可以对外公开的，也就是说调用者一般只能看到该包中被 <code>public</code> 的类，至于这个类是接口还是实现类就要看这个包作者怎么做了，简单地说如果实现一个功能，作者通过工厂类的形式返回了一个接口，而内部实现类都是包级别 <code>default</code> 或以下的话，那么我们通过接口调用也就自然而然的看不到实现类了，那么这个包也就可以理解是一个设计的不错的包模块。当然在项目编程中我们通常需要配合诸如 <code>Spring</code> 之类的框架，所以我们写的这些类很可能都是 <code>public</code> 级别的。 那么我先从简单到难这个过程说说 <code>DDD</code> 中各个概念的作用（当然如果说 <code>DDD</code> 就是不同分层的话也不合适，但是万事都有个开头，我们可以先通过分层来做，慢慢体会其中的乐趣）</p>
<h3 id="2-1-模块module"><a href="#2-1-模块module" class="headerlink" title="2.1 模块module"></a>2.1 模块module</h3><p>OK，那么模块就是我上面举的例子中的包级别的意思了，通过包来分割不同的模块。 那么在 <code>DDD</code> 中一般是根据什么原则来划分的？ 答： 1. 第一级：根据业务模块，我们每个业务，都会分出来一个模块，比如：产品模块，购物车模块，仓储模块等等； 2. 第二级：根据不同功能的模块，有视图层，应用服务层以及领域层； 3. 领域层整个模块，还可以根据爱好决定是否划分成 <code>domain</code> 层、<code>repository</code> 层以及 <code>领域服务</code>层（这些层的职责我会在下面的领域层做解释）</p>
<h3 id="2-2-应用服务层"><a href="#2-2-应用服务层" class="headerlink" title="2.2 应用服务层"></a>2.2 应用服务层</h3><p>注意：这里是应用服务层不是叫做领域服务层，两者的职责是不同的。 那么应用服务层是做什么的，我得先总结一下，应用服务层不同于领域服务层，应用服务层只要是一项业务开始的入口，应用服务层是领域层的客户端，通过领域层暴露的公开接口，协调业务的完成（业务完成细节隐藏在领域层中），他主要完成三件事情： 1. 日志的记录； 2. 事务的管理； 3. 通过调用某个仓库获取需要操作的领域对象并且通过调用该领域对象的接口完成业务。 那么结合起来可以总结一句话，他是某个业务下可以完成的业务逻辑的集合。这个项目他可以完成哪些业务，通过应用服务层即可得知。</p>
<h3 id="2-3-领域层"><a href="#2-3-领域层" class="headerlink" title="2.3 领域层"></a>2.3 领域层</h3><p>这个题目是 <code>DDD</code> 设计的重中之重，只有这部分做好了，<code>DDD</code> 才算是落实的好。 在领域层中，有三个很重要的角色： 1. 领域类Entity； 2. 协助领域类的值对象ValueObject； 3. 不属于领域类的业务动作集合体领域服务层 <code>DominSevice</code></p>
<h4 id="2-3-1-实体Entity"><a href="#2-3-1-实体Entity" class="headerlink" title="2.3.1 实体Entity"></a>2.3.1 实体Entity</h4><p>说实话，在实体和聚合（其实是实体一种管理方式）我总是有模糊的印象，在现实编码过程中，也经常将实体和聚合混在一起。 查询了一些资料，结合了其他 <code>DDD</code> 玩家的认识，也可以稍微体会两者的区别。 实体其实是和值对象（关联的属性在业务意义上是不可变的）并行的。实体指的是一个业务对象他的属性，是可以通过业务方法进行变更的，比如我要修改订单状态为 <code>已支付</code>，那么订单实体是有暴露 <code>pay</code> 方法，这个方法则会修改内部属性，完成支付所需要的业务逻辑。 订单有订单明细，这部分就是关联订单明细对象了，按道理来说，这个关联应该是必须放在聚合类上的，但是没有确定的方式，所以通过组合的方式，放置于聚合也可以，毕竟订单和订单明细同属于一个事务，那么此时订单实体也就是一个订单聚合了。</p>
<h4 id="2-3-2-不可变值对象ValueObject"><a href="#2-3-2-不可变值对象ValueObject" class="headerlink" title="2.3.2 不可变值对象ValueObject"></a>2.3.2 不可变值对象ValueObject</h4><p>说实在先讲实体还是先讲 <code>ValueObject</code> 我没什么底，不过文章并没有并行的概念而且是先有实体后有值对象，所以就实体先说了。 值对象需要结合 <code>Java</code> 中的 <code>String</code> <code>Integer</code> 来说，很快就能获得灵感。 我们知道编程语言他只能提供给我们一些数据的值对象，比如字符串 <code>String</code> 以及数值 <code>Integer</code> 等等，那么我们业务的值对象就是需要辨认出来，哪个部分他一旦创建了就不可改变从而组合这些基础数值对象，不提供 <code>setter</code> 來达到业务值对象的目的。 还是以订单业务作为例子，我们知道订单业务中，下单者和下单时间，一旦建立了就不可改变。所以我们的订单中有个这样的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCreateInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String userUID;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date createDateTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderCreateInfo</span><span class="params">(String userUID, Date createDateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userUID = userUID;</span><br><span class="line">        <span class="keyword">this</span>.createDateTime = createDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getUserUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title">getCreateDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果下单用户以及下单时间相同的话，那么视两个创建信息为同一个对象 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="function"><span class="keyword">null</span>  <span class="title">getClass</span><span class="params">()</span> !</span>= o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        OrderCreateInfo that = (OrderCreateInfo) o;</span><br><span class="line">        <span class="keyword">return</span> userUID.equals(that.userUID) &amp;&amp;</span><br><span class="line">                        createDateTime.equals(that.createDateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(userUID, createDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HashCode &amp; equals Ends */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OrderCreateInfo&#123;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;userUID=&#x27;&quot;</span> + userUID + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                        <span class="string">&quot;, createDateTime=&quot;</span> + createDateTime +</span><br><span class="line">                        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而因为我们需要使用 <code>ORM</code> 框架与数据库打交道，所以以上的代码兵不兼容现在市面上的 <code>ORM</code> 框架，我们需要稍加修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCreateInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userUID;</span><br><span class="line">    <span class="keyword">private</span> Date createDateTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderCreateInfo</span><span class="params">(String userUID, Date createDateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userUID = userUID;</span><br><span class="line">        <span class="keyword">this</span>.createDateTime = createDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** protected 权限，目的是不是任何人就可以创建空对象，并且最小权限。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">OrderCreateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getUserUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title">getCreateDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果下单用户以及下单时间相同的话，那么视两个创建信息为同一个对象 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="function"><span class="keyword">null</span>  <span class="title">getClass</span><span class="params">()</span> !</span>= o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        OrderCreateInfo that = (OrderCreateInfo) o;</span><br><span class="line">        <span class="keyword">return</span> userUID.equals(that.userUID) &amp;&amp;</span><br><span class="line">                        createDateTime.equals(that.createDateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(userUID, createDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HashCode &amp; equals Ends */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OrderCreateInfo&#123;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;userUID=&#x27;&quot;</span> + userUID + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                        <span class="string">&quot;, createDateTime=&quot;</span> + createDateTime +</span><br><span class="line">                        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，完成了订单创建信息的 <code>ValueObject</code>，那么订单对象 <code>Order</code> 中就应该有这样一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderCreateInfo orderCreateInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然订单对象中还有其他的业务 <code>ValueObject</code> 类，基本很少有 <code>String</code> <code>Integer</code> 等这样的 <code>Java</code> 提供的基础数据类型。 而至于需不需要提供 <code>setter</code> 方法，这就需要视业务规则而定，基本上很少有属性需要单独提供 <code>setter</code> 方法，因为基本对订单的每一个业务操作都需要修改多个属性，那么在 <code>Order</code> 中提供业务方法即可。 而对于集合类型而言，比如订单明细，则需要用另外方式保证订单明细不被修改： 1. 返回 <code>Guava</code> 中的 <code>ImmutableList</code> 副本； 2. 返回另外一个重新拷贝的集合对象； 我个人而言偏喜欢第一种，比较方便。这么做的目的是防止将订单明细的可变集合暴露到外部，导致外部修改了。</p>
<h4 id="2-3-3-领域仓库"><a href="#2-3-3-领域仓库" class="headerlink" title="2.3.3 领域仓库"></a>2.3.3 领域仓库</h4><p>现在 <code>ORM</code> 框架这么成熟，一般来说，仓库都不需要我们自己编写，只需要提供 <code>Spring Data JPA</code> 中的仓库接口实现。 当然仓库我们可以通过 <code>命令查询CQRS</code> 的原则进行分割。</p>
<ol>
<li>命令仓库：一般只有增删改以及根据 <code>uid</code> 查询获取对象方法；</li>
<li>查询仓库：根据业务需求，不同条件查询列表；</li>
</ol>
<h4 id="2-3-4-领域事件"><a href="#2-3-4-领域事件" class="headerlink" title="2.3.4 领域事件"></a>2.3.4 领域事件</h4><p>这里涉及一个对象生命周期的概念：一个业务对象，从他诞生到死亡，一般经历了很多次修改，才会演变为死亡状态（当然也不是说就删掉，就是他已经进入一个稳定的状态，比如已经支付的订单） 举个例子，一个订单，从他创建的，到支付，到发货，到用户收货，评价等等经理了不同的历程。那么这些历程，均可以编写对应的领域事件来表达。比如： 1. 订单已创建，<code>new</code> 出来一个 <code>Order</code> 对象，存储数据库，并且发布 <code>OrderCreated</code> 事件将订单信息发布出去，其他业务需要的话就进行订阅，并做相对应的业务处理（比如积分奖励，发送短信）； 2. 订单支付，系统受到用户支付的费用，并且开始调用订单对象的 <code>finishPay()</code> 方法，修改订单状态，这时候可以发布 <code>OrderPaied</code> 事件，同上进行不同的业务处理； 3. …… 事件的定义：基本是领域自己事情完成以后发布，事件的名称均是过去式的形式，表示 <code>XXX已做好XXX</code>。这时候其他业务很方便的进行订阅集成，主领域也不需要去关注其他业务的动作，只要发布事件就好了，后期也可以很简单的进行集成。 可以说，一个业务牵连的另外一个业务的修改，均可以通过事件来发布。事件在内存中或者消息中间件中排队，依次做修改，是不是很熟悉，这就是分布式事务了，一般来说，大部分业务的分布式事务并不需要追求强一致性的概念，而只要最终一致性即可，即用户在做完一个业务以后，可以在允许时间内，奖励用户或者其他动作，只要用户可以收到结果即可。</p>
<h4 id="2-3-5-聚合"><a href="#2-3-5-聚合" class="headerlink" title="2.3.5 聚合"></a>2.3.5 聚合</h4><p>聚合可以说是领域设计中的重点所在了。 聚合有两个作用，其实就是个组合的类对象： 1. 组合实体以及 <code>ValueObject</code>； 2. 将领域范围内，设计数据库事务的操作，合并起来，共处在同一个事务中。 在现实编码中，我也是经常将实体 <code>Entity</code> 和聚合放在一起使用。 举个例子： 在订单的聚合类中，包含创建者信息，订单明细，支付单（另外一个聚合，可以通过 <code>ObjectID</code> 关联）等等。 这里有一篇不错的设计聚合文章，推荐进入查看：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/netfocus/p/3307971.html">关于领域驱动设计（DDD）中聚合设计的一些思考</a></p>
<h4 id="2-3-6-领域工厂"><a href="#2-3-6-领域工厂" class="headerlink" title="2.3.6 领域工厂"></a>2.3.6 领域工厂</h4><p>简单说是工厂模式，业务对象或者聚合对象出生地。 如果说对象只有一种状态，那么简单工厂模式即可。 但是如果说业务对象有多重不同的条件而出生的存在，抽象工厂就必不可少了。比如普通订单、<code>vip</code> 订单、预售订单。 那么根据参数，创建一个领域对象，只需要封装创建过程，比如调用领域服务创建订单的 <code>ValueObject</code> 或计算订单总价，创建出来的订单聚合返回，存入数据库即可。</p>
<h2 id="三-微服务和DDD的关系"><a href="#三-微服务和DDD的关系" class="headerlink" title="三. 微服务和DDD的关系"></a>三. 微服务和DDD的关系</h2><p>以上设计基本单体很容易实现，但是用在微服务上，就需要一些更改了。</p>
<h3 id="3-1-SpringCloud组件使用"><a href="#3-1-SpringCloud组件使用" class="headerlink" title="3.1 SpringCloud组件使用"></a>3.1 SpringCloud组件使用</h3><p>OK，我就使用最属性的 <code>SpringCloud</code> 来说吧。 <code>Eureka</code>：协调服务执行，心跳服务所需要的其他服务的调用信息更新； <code>Gateway</code>：系统总入口，对外提供服务，一套微服务就像单体一样，只需要调用必需的服务即可； <code>Feign</code>：聚合一般都需要其他服务的信息，比如产品信息，调用返回到仓储变成另外一个意思 <code>仓储物品</code>，那么可以使用 <code>Feign</code> 调用第三方，也可以配合 <code>ObjectMapper</code> 的注解配合使用，让客户端自动封装所需要的 <code>ValueObject</code> 或者 <code>Entity</code>，也可以修改其封装的数据形式使其更快传递数据：<a target="_blank" rel="noopener" href="https://liweidan.cn/java/frame/spring-cloud/2019/04/16/294/">SpringCloud服务使用ProtolBuffer编码进行传值</a>； <code>Stream</code>：<code>SpringCloud</code> 使用的连接第三方消息队列的工具，提供分组功能，此工具一般用来发送领域事件； <code>SpringDataJPA</code>：严格来说这部分不属于 <code>SpringCloud</code> 的内容，不过需要对象和数据库保持同步的时候，使用这个框架是比较舒服的，也可以在聚合类发送领域事件，但是缺乏灵活性<a target="_blank" rel="noopener" href="https://liweidan.cn/java/frame/spring-boot/2018/12/20/225/">SpringBootJpa 与 DDD 开发</a>；</p>
<h3 id="3-2-SpringCloud服务分层"><a href="#3-2-SpringCloud服务分层" class="headerlink" title="3.2 SpringCloud服务分层"></a>3.2 SpringCloud服务分层</h3><h2 id="一-DDD-1"><a href="#一-DDD-1" class="headerlink" title="一. DDD"></a>一. DDD</h2><p><code>DDD</code> 是 Martin Folwer 提出来的，对现有常见开发模式的一种反转。 举个栗子，我们通常拿到一个业务需求，开始辨认可能需要用到的属性，然后做成数据库表，接着开始编写 <code>JavaBean</code> 映射类。写完了，就开始把需求在业务中实现，开始 <code>get</code> 来 <code>set</code> 去的生活。讲道理，我之前刚刚入门的时候就觉得这种模式太枯燥了，千篇一律，<code>Java</code> 刚开始学的面向对象思想也不知道跑到哪里去了。 后来接触了《领域驱动设计 Domain Design Driven》（简称 <code>DDD</code>）这本返璞归真的业务编写指导，才逐渐的觉悟，原来之前那种方式完全都是面向过程的形式，也就是说，我们在用面向对象语言编写面向过程的代码。 先简单说说 <code>DDD</code> 主要讲了什么: <code>DDD</code> 主要通过建立业务通用语言（该语言将会贯穿整个开发上下文，并且是开发人员与业务人员沟通的桥梁，如：一个产品在产品上下文叫产品定义，在仓储上下文则应该称为库存件），将语言通过一种<strong>易于维护的组织形式在编码中表达出来</strong>，这样开发人员可以通过快速阅读代码，达到如同在阅读业务文档一样的效果。</p>
<h2 id="二-DDD的概念-1"><a href="#二-DDD的概念-1" class="headerlink" title="二. DDD的概念"></a>二. DDD的概念</h2><p><code>DDD</code> 涉及一些概念，如果还没理解透彻 <code>Java</code> 中这些概念的使用的话，那么理解起来是有点晦涩的。 我这里可以先简单总结一下：在 <code>Java</code> 中，模块的划分可以通过 <code>包</code> 这个概念来划分，包中 <code>public</code> 是可以对外公开的，也就是说调用者一般只能看到该包中被 <code>public</code> 的类，至于这个类是接口还是实现类就要看这个包作者怎么做了，简单地说如果实现一个功能，作者通过工厂类的形式返回了一个接口，而内部实现类都是包级别 <code>default</code> 或以下的话，那么我们通过接口调用也就自然而然的看不到实现类了，那么这个包也就可以理解是一个设计的不错的包模块。当然在项目编程中我们通常需要配合诸如 <code>Spring</code> 之类的框架，所以我们写的这些类很可能都是 <code>public</code> 级别的。 那么我先从简单到难这个过程说说 <code>DDD</code> 中各个概念的作用（当然如果说 <code>DDD</code> 就是不同分层的话也不合适，但是万事都有个开头，我们可以先通过分层来做，慢慢体会其中的乐趣）</p>
<h3 id="2-1-模块module-1"><a href="#2-1-模块module-1" class="headerlink" title="2.1 模块module"></a>2.1 模块module</h3><p>OK，那么模块就是我上面举的例子中的包级别的意思了，通过包来分割不同的模块。 那么在 <code>DDD</code> 中一般是根据什么原则来划分的？ 答： 1. 第一级：根据业务模块，我们每个业务，都会分出来一个模块，比如：产品模块，购物车模块，仓储模块等等； 2. 第二级：根据不同功能的模块，有视图层，应用服务层以及领域层； 3. 领域层整个模块，还可以根据爱好决定是否划分成 <code>domain</code> 层、<code>repository</code> 层以及 <code>领域服务</code>层（这些层的职责我会在下面的领域层做解释）</p>
<h3 id="2-2-应用服务层-1"><a href="#2-2-应用服务层-1" class="headerlink" title="2.2 应用服务层"></a>2.2 应用服务层</h3><p>注意：这里是应用服务层不是叫做领域服务层，两者的职责是不同的。 那么应用服务层是做什么的，我得先总结一下，应用服务层不同于领域服务层，应用服务层只要是一项业务开始的入口，应用服务层是领域层的客户端，通过领域层暴露的公开接口，协调业务的完成（业务完成细节隐藏在领域层中），他主要完成三件事情： 1. 日志的记录； 2. 事务的管理； 3. 通过调用某个仓库获取需要操作的领域对象并且通过调用该领域对象的接口完成业务。 那么结合起来可以总结一句话，他是某个业务下可以完成的业务逻辑的集合。这个项目他可以完成哪些业务，通过应用服务层即可得知。</p>
<h3 id="2-3-领域层-1"><a href="#2-3-领域层-1" class="headerlink" title="2.3 领域层"></a>2.3 领域层</h3><p>这个题目是 <code>DDD</code> 设计的重中之重，只有这部分做好了，<code>DDD</code> 才算是落实的好。 在领域层中，有三个很重要的角色： 1. 领域类Entity； 2. 协助领域类的值对象ValueObject； 3. 不属于领域类的业务动作集合体领域服务层 <code>DominSevice</code></p>
<h4 id="2-3-1-实体Entity-1"><a href="#2-3-1-实体Entity-1" class="headerlink" title="2.3.1 实体Entity"></a>2.3.1 实体Entity</h4><p>说实话，在实体和聚合（其实是实体一种管理方式）我总是有模糊的印象，在现实编码过程中，也经常将实体和聚合混在一起。 查询了一些资料，结合了其他 <code>DDD</code> 玩家的认识，也可以稍微体会两者的区别。 实体其实是和值对象（关联的属性在业务意义上是不可变的）并行的。实体指的是一个业务对象他的属性，是可以通过业务方法进行变更的，比如我要修改订单状态为 <code>已支付</code>，那么订单实体是有暴露 <code>pay</code> 方法，这个方法则会修改内部属性，完成支付所需要的业务逻辑。 订单有订单明细，这部分就是关联订单明细对象了，按道理来说，这个关联应该是必须放在聚合类上的，但是没有确定的方式，所以通过组合的方式，放置于聚合也可以，毕竟订单和订单明细同属于一个事务，那么此时订单实体也就是一个订单聚合了。</p>
<h4 id="2-3-2-不可变值对象ValueObject-1"><a href="#2-3-2-不可变值对象ValueObject-1" class="headerlink" title="2.3.2 不可变值对象ValueObject"></a>2.3.2 不可变值对象ValueObject</h4><p>说实在先讲实体还是先讲 <code>ValueObject</code> 我没什么底，不过文章并没有并行的概念而且是先有实体后有值对象，所以就实体先说了。 值对象需要结合 <code>Java</code> 中的 <code>String</code> <code>Integer</code> 来说，很快就能获得灵感。 我们知道编程语言他只能提供给我们一些数据的值对象，比如字符串 <code>String</code> 以及数值 <code>Integer</code> 等等，那么我们业务的值对象就是需要辨认出来，哪个部分他一旦创建了就不可改变从而组合这些基础数值对象，不提供 <code>setter</code> 來达到业务值对象的目的。 还是以订单业务作为例子，我们知道订单业务中，下单者和下单时间，一旦建立了就不可改变。所以我们的订单中有个这样的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCreateInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String userUID;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date createDateTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderCreateInfo</span><span class="params">(String userUID, Date createDateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userUID = userUID;</span><br><span class="line">        <span class="keyword">this</span>.createDateTime = createDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getUserUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title">getCreateDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果下单用户以及下单时间相同的话，那么视两个创建信息为同一个对象 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="function"><span class="keyword">null</span>  <span class="title">getClass</span><span class="params">()</span> !</span>= o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        OrderCreateInfo that = (OrderCreateInfo) o;</span><br><span class="line">        <span class="keyword">return</span> userUID.equals(that.userUID) &amp;&amp;</span><br><span class="line">                        createDateTime.equals(that.createDateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(userUID, createDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HashCode &amp; equals Ends */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OrderCreateInfo&#123;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;userUID=&#x27;&quot;</span> + userUID + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                        <span class="string">&quot;, createDateTime=&quot;</span> + createDateTime +</span><br><span class="line">                        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而因为我们需要使用 <code>ORM</code> 框架与数据库打交道，所以以上的代码兵不兼容现在市面上的 <code>ORM</code> 框架，我们需要稍加修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCreateInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userUID;</span><br><span class="line">    <span class="keyword">private</span> Date createDateTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderCreateInfo</span><span class="params">(String userUID, Date createDateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userUID = userUID;</span><br><span class="line">        <span class="keyword">this</span>.createDateTime = createDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** protected 权限，目的是不是任何人就可以创建空对象，并且最小权限。 */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">OrderCreateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getUserUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title">getCreateDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 如果下单用户以及下单时间相同的话，那么视两个创建信息为同一个对象 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="function"><span class="keyword">null</span>  <span class="title">getClass</span><span class="params">()</span> !</span>= o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        OrderCreateInfo that = (OrderCreateInfo) o;</span><br><span class="line">        <span class="keyword">return</span> userUID.equals(that.userUID) &amp;&amp;</span><br><span class="line">                        createDateTime.equals(that.createDateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(userUID, createDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** HashCode &amp; equals Ends */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OrderCreateInfo&#123;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;userUID=&#x27;&quot;</span> + userUID + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                        <span class="string">&quot;, createDateTime=&quot;</span> + createDateTime +</span><br><span class="line">                        <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，完成了订单创建信息的 <code>ValueObject</code>，那么订单对象 <code>Order</code> 中就应该有这样一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OrderCreateInfo orderCreateInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然订单对象中还有其他的业务 <code>ValueObject</code> 类，基本很少有 <code>String</code> <code>Integer</code> 等这样的 <code>Java</code> 提供的基础数据类型。 而至于需不需要提供 <code>setter</code> 方法，这就需要视业务规则而定，基本上很少有属性需要单独提供 <code>setter</code> 方法，因为基本对订单的每一个业务操作都需要修改多个属性，那么在 <code>Order</code> 中提供业务方法即可。 而对于集合类型而言，比如订单明细，则需要用另外方式保证订单明细不被修改： 1. 返回 <code>Guava</code> 中的 <code>ImmutableList</code> 副本； 2. 返回另外一个重新拷贝的集合对象； 我个人而言偏喜欢第一种，比较方便。这么做的目的是防止将订单明细的可变集合暴露到外部，导致外部修改了。</p>
<h4 id="2-3-3-领域仓库-1"><a href="#2-3-3-领域仓库-1" class="headerlink" title="2.3.3 领域仓库"></a>2.3.3 领域仓库</h4><p>现在 <code>ORM</code> 框架这么成熟，一般来说，仓库都不需要我们自己编写，只需要提供 <code>Spring Data JPA</code> 中的仓库接口实现。 当然仓库我们可以通过 <code>命令查询CQRS</code> 的原则进行分割。</p>
<ol>
<li>命令仓库：一般只有增删改以及根据 <code>uid</code> 查询获取对象方法；</li>
<li>查询仓库：根据业务需求，不同条件查询列表；</li>
</ol>
<h4 id="2-3-4-领域事件-1"><a href="#2-3-4-领域事件-1" class="headerlink" title="2.3.4 领域事件"></a>2.3.4 领域事件</h4><p>这里涉及一个对象生命周期的概念：一个业务对象，从他诞生到死亡，一般经历了很多次修改，才会演变为死亡状态（当然也不是说就删掉，就是他已经进入一个稳定的状态，比如已经支付的订单） 举个例子，一个订单，从他创建的，到支付，到发货，到用户收货，评价等等经理了不同的历程。那么这些历程，均可以编写对应的领域事件来表达。比如： 1. 订单已创建，<code>new</code> 出来一个 <code>Order</code> 对象，存储数据库，并且发布 <code>OrderCreated</code> 事件将订单信息发布出去，其他业务需要的话就进行订阅，并做相对应的业务处理（比如积分奖励，发送短信）； 2. 订单支付，系统受到用户支付的费用，并且开始调用订单对象的 <code>finishPay()</code> 方法，修改订单状态，这时候可以发布 <code>OrderPaied</code> 事件，同上进行不同的业务处理； 3. …… 事件的定义：基本是领域自己事情完成以后发布，事件的名称均是过去式的形式，表示 <code>XXX已做好XXX</code>。这时候其他业务很方便的进行订阅集成，主领域也不需要去关注其他业务的动作，只要发布事件就好了，后期也可以很简单的进行集成。 可以说，一个业务牵连的另外一个业务的修改，均可以通过事件来发布。事件在内存中或者消息中间件中排队，依次做修改，是不是很熟悉，这就是分布式事务了，一般来说，大部分业务的分布式事务并不需要追求强一致性的概念，而只要最终一致性即可，即用户在做完一个业务以后，可以在允许时间内，奖励用户或者其他动作，只要用户可以收到结果即可。</p>
<h4 id="2-3-5-聚合-1"><a href="#2-3-5-聚合-1" class="headerlink" title="2.3.5 聚合"></a>2.3.5 聚合</h4><p>聚合可以说是领域设计中的重点所在了。 聚合有两个作用，其实就是个组合的类对象： 1. 组合实体以及 <code>ValueObject</code>； 2. 将领域范围内，设计数据库事务的操作，合并起来，共处在同一个事务中。 在现实编码中，我也是经常将实体 <code>Entity</code> 和聚合放在一起使用。 举个例子： 在订单的聚合类中，包含创建者信息，订单明细，支付单（另外一个聚合，可以通过 <code>ObjectID</code> 关联）等等。 这里有一篇不错的设计聚合文章，推荐进入查看：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/netfocus/p/3307971.html">关于领域驱动设计（DDD）中聚合设计的一些思考</a></p>
<h4 id="2-3-6-领域工厂-1"><a href="#2-3-6-领域工厂-1" class="headerlink" title="2.3.6 领域工厂"></a>2.3.6 领域工厂</h4><p>简单说是工厂模式，业务对象或者聚合对象出生地。 如果说对象只有一种状态，那么简单工厂模式即可。 但是如果说业务对象有多重不同的条件而出生的存在，抽象工厂就必不可少了。比如普通订单、<code>vip</code> 订单、预售订单。 那么根据参数，创建一个领域对象，只需要封装创建过程，比如调用领域服务创建订单的 <code>ValueObject</code> 或计算订单总价，创建出来的订单聚合返回，存入数据库即可。</p>
<h2 id="三-微服务和DDD的关系-1"><a href="#三-微服务和DDD的关系-1" class="headerlink" title="三. 微服务和DDD的关系"></a>三. 微服务和DDD的关系</h2><p>以上设计基本单体很容易实现，但是用在微服务上，就需要一些更改了。</p>
<h3 id="3-1-SpringCloud组件使用-1"><a href="#3-1-SpringCloud组件使用-1" class="headerlink" title="3.1 SpringCloud组件使用"></a>3.1 SpringCloud组件使用</h3><p>OK，我就使用最属性的 <code>SpringCloud</code> 来说吧。 <code>Eureka</code>：协调服务执行，心跳服务所需要的其他服务的调用信息更新； <code>Gateway</code>：系统总入口，对外提供服务，一套微服务就像单体一样，只需要调用必需的服务即可； <code>Feign</code>：聚合一般都需要其他服务的信息，比如产品信息，调用返回到仓储变成另外一个意思 <code>仓储物品</code>，那么可以使用 <code>Feign</code> 调用第三方，也可以配合 <code>ObjectMapper</code> 的注解配合使用，让客户端自动封装所需要的 <code>ValueObject</code> 或者 <code>Entity</code>，也可以修改其封装的数据形式使其更快传递数据：<a target="_blank" rel="noopener" href="https://liweidan.cn/java/frame/spring-cloud/2019/04/16/294/">SpringCloud服务使用ProtolBuffer编码进行传值</a>； <code>Stream</code>：<code>SpringCloud</code> 使用的连接第三方消息队列的工具，提供分组功能，此工具一般用来发送领域事件； <code>SpringDataJPA</code>：严格来说这部分不属于 <code>SpringCloud</code> 的内容，不过需要对象和数据库保持同步的时候，使用这个框架是比较舒服的，也可以在聚合类发送领域事件，但是缺乏灵活性<a target="_blank" rel="noopener" href="https://liweidan.cn/java/frame/spring-boot/2018/12/20/225/">SpringBootJpa 与 DDD 开发</a>；</p>
<h3 id="3-2-SpringCloud服务分层-1"><a href="#3-2-SpringCloud服务分层-1" class="headerlink" title="3.2 SpringCloud服务分层"></a>3.2 SpringCloud服务分层</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110161134.png"></p>
<p> 分层有以下元素： 1. 统一入口 <code>Gateway</code>：这是一个微服务系统的统一入口，只提供最简单的鉴权功能，以及分发请求到下一层的 <code>ResourceGateway</code>； 2. 聚合路由服务<code>ResourceGateway</code>：一般来说我们一个查询可以涉及到不同的服务参与，这里聚合服务路由可以提供一个聚合信息的功能（这个聚合和上面的聚合功能有部分重叠功能），此处聚合可以设计用来查询，也可以在聚合里边进行命令操作，不过命令操作的实现比较难以实现。查询的时候涉及多业务查询时可以使用 <code>jdk8</code> 的 <code>CompleteFuture</code> 进行查询 <a target="_blank" rel="noopener" href="https://liweidan.cn/java/jdk8/2017/10/25/141/">jdk8 多线程处理的使用</a> 3. 业务服务层：对聚合服务的更进一步切割，在业务说法上分开来，当某些业务不能放在一起的时候需要分开服务，并通过领域事件进行沟通（比如发布一个产品已下架，仓储系统、活动系统进行订阅完成接下去的业务，分布式最大通知型事务） 我们的领域事件可以在聚合服务发布也可以在业务服务发布，具体看业务需求了，当然如果在路由层进行发布，我们还可以使用 <code>SpringBoot</code> 最新的 <code>reactive</code> 模型进行查询订阅，当某个特定的业务数据处理完成以后再返回给用户。</p>
<h3 id="3-3-业务多元化查询"><a href="#3-3-业务多元化查询" class="headerlink" title="3.3 业务多元化查询"></a>3.3 业务多元化查询</h3><p><code>CRUD</code> 做完了，老板肯定想要一些方便的功能，这些查询不属于领域驱动设计的内容，如果只是简单的单服务查询，那么直接使用 <code>Endpoint</code> 查询 <code>领域仓库</code> 一般即可完成业务了。 那么如果是根据产品查询最近下单的情况呢，根据产品名字，供应商名字，品牌呢？ 我还没想出来什么好的办法，当然我们订单服务可以适当的保存一些冗余的、变化不大的信息，比如供应商的 <code>uid</code> 或者 产品的 <code>uid</code>，如果连产品名字、品牌信息也要保存，那么就需要订阅更多的信息来维护一致性。这时候我们可以使用视图层工具 <code>ElasticSearch</code> 或者其他搜索引擎来加快我们领域信息的查询。也可以使用 <code>Hadoop</code> 工具集等来查询，不过查询速度就需要机器跟上了。我现在还没使用到这部分，没有话语权。</p>
<h2 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h2><p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247488063&idx=1&sn=5d06c862eb91f902ae3c6f60d9b79721&chksm=e9292f30de5ea6261bd718bd76ce145edc83514faa38792bb2bf6f37741fb385c623aff75763&mpshare=1&scene=23&srcid=0825eM0dnkrnDw5KY1vpf4Ri%23rd">领域驱动设计，盒马技术团队这么做</a> </p>
<p>《领域驱动设计》 </p>
<p>《领域驱动开发》 </p>
<p>《微服务设计》 </p>
<p> 分层有以下元素： 1. 统一入口 <code>Gateway</code>：这是一个微服务系统的统一入口，只提供最简单的鉴权功能，以及分发请求到下一层的 <code>ResourceGateway</code>； 2. 聚合路由服务<code>ResourceGateway</code>：一般来说我们一个查询可以涉及到不同的服务参与，这里聚合服务路由可以提供一个聚合信息的功能（这个聚合和上面的聚合功能有部分重叠功能），此处聚合可以设计用来查询，也可以在聚合里边进行命令操作，不过命令操作的实现比较难以实现。查询的时候涉及多业务查询时可以使用 <code>jdk8</code> 的 <code>CompleteFuture</code> 进行查询 <a target="_blank" rel="noopener" href="https://liweidan.cn/java/jdk8/2017/10/25/141/">jdk8 多线程处理的使用</a> 3. 业务服务层：对聚合服务的更进一步切割，在业务说法上分开来，当某些业务不能放在一起的时候需要分开服务，并通过领域事件进行沟通（比如发布一个产品已下架，仓储系统、活动系统进行订阅完成接下去的业务，分布式最大通知型事务） 我们的领域事件可以在聚合服务发布也可以在业务服务发布，具体看业务需求了，当然如果在路由层进行发布，我们还可以使用 <code>SpringBoot</code> 最新的 <code>reactive</code> 模型进行查询订阅，当某个特定的业务数据处理完成以后再返回给用户。</p>
<h3 id="3-3-业务多元化查询-1"><a href="#3-3-业务多元化查询-1" class="headerlink" title="3.3 业务多元化查询"></a>3.3 业务多元化查询</h3><p><code>CRUD</code> 做完了，老板肯定想要一些方便的功能，这些查询不属于领域驱动设计的内容，如果只是简单的单服务查询，那么直接使用 <code>Endpoint</code> 查询 <code>领域仓库</code> 一般即可完成业务了。 那么如果是根据产品查询最近下单的情况呢，根据产品名字，供应商名字，品牌呢？ 我还没想出来什么好的办法，当然我们订单服务可以适当的保存一些冗余的、变化不大的信息，比如供应商的 <code>uid</code> 或者 产品的 <code>uid</code>，如果连产品名字、品牌信息也要保存，那么就需要订阅更多的信息来维护一致性。这时候我们可以使用视图层工具 <code>ElasticSearch</code> 或者其他搜索引擎来加快我们领域信息的查询。也可以使用 <code>Hadoop</code> 工具集等来查询，不过查询速度就需要机器跟上了。我现在还没使用到这部分，没有话语权。</p>
<h2 id="资料参考-1"><a href="#资料参考-1" class="headerlink" title="资料参考"></a>资料参考</h2><p> <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247488063&idx=1&sn=5d06c862eb91f902ae3c6f60d9b79721&chksm=e9292f30de5ea6261bd718bd76ce145edc83514faa38792bb2bf6f37741fb385c623aff75763&mpshare=1&scene=23&srcid=0825eM0dnkrnDw5KY1vpf4Ri%23rd">领域驱动设计，盒马技术团队这么做</a> </p>
<p>《领域驱动设计》 </p>
<p>《领域驱动开发》 </p>
<p>《微服务设计》 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
