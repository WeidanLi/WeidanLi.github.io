<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weidanli.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
<meta property="og:type" content="website">
<meta property="og:title" content="丹崽的技术博客">
<meta property="og:url" content="http://weidanli.github.io/page/2/index.html">
<meta property="og:site_name" content="丹崽的技术博客">
<meta property="og:description" content="计算机基础 计算机网络 Java Vue 前端 后端">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Weidan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://weidanli.github.io/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>丹崽的技术博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">丹崽的技术博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">丹崽的计算机知识博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weidan</p>
  <div class="site-description" itemprop="description">计算机基础 计算机网络 Java Vue 前端 后端</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/java/Tomcat/%E3%80%90tomcat%E3%80%91%E4%B8%89-tomcat%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/java/Tomcat/%E3%80%90tomcat%E3%80%91%E4%B8%89-tomcat%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">【Tomcat】三.Tomcat启动（下）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-19 17:28:02" itemprop="dateCreated datePublished" datetime="2020-04-19T17:28:02+08:00">2020-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 11:10:36" itemprop="dateModified" datetime="2020-11-10T11:10:36+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上一篇的时序图： </p>
<p>上一篇的时序图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109161155.jpeg"></p>
<h2 id="一-StandardRoot启动"><a href="#一-StandardRoot启动" class="headerlink" title="一. StandardRoot启动"></a>一. StandardRoot启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardRoot</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">WebResourceRoot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    mainResources.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型，创建对应的资源包实例</span></span><br><span class="line">    main = createMainResourceSet();</span><br><span class="line"></span><br><span class="line">    mainResources.add(main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次启动此类指定的资源</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;WebResourceSet&gt; list : allResources) &#123;</span><br><span class="line">      <span class="comment">// Skip class resources since they are started below</span></span><br><span class="line">      <span class="keyword">if</span> (list != classResources) &#123;</span><br><span class="line">        <span class="keyword">for</span> (WebResourceSet webResourceSet : list) &#123;</span><br><span class="line">          webResourceSet.start();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描lib下的所有jar包</span></span><br><span class="line">    processWebInfLib();</span><br><span class="line">    <span class="comment">// Need to start the newly found resources</span></span><br><span class="line">    <span class="keyword">for</span> (WebResourceSet classResource : classResources) &#123;</span><br><span class="line">      classResource.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.enforceObjectMaxSizeLimit();</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们知道，一个 <code>webapp</code> 入口是 <code>WEB-INF</code> ，因为里边包含了 <code>web.xml</code> 以及 <code>lib包</code>，所以此时就是扫描 <code>lib</code> 下所有的 <code>jar</code> 包，然后加载到 <code>webapp</code> 的 <code>ClassLoader</code> 中去。所以这个时候 <code>StandardRoot</code> 做的事情就是加载所有的 <code>jar</code> 包。</p>
<h2 id="二-发送事件通知加载web应用"><a href="#二-发送事件通知加载web应用" class="headerlink" title="二. 发送事件通知加载web应用"></a>二. 发送事件通知加载web应用</h2><p>上面图我们可以看到，<code>fireLifecycleEvent</code> 通知了 <code>ContextConfig</code> 加载 <code>webapp</code> 的配置、加载所有 <code>Pipeline</code>。 先看第一个：</p>
<h3 id="2-1-加载配置"><a href="#2-1-加载配置" class="headerlink" title="2.1 加载配置"></a>2.1 加载配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextConfig</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">configureStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Called from StandardContext.start()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.start&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.xmlSettings&quot;</span>,</span><br><span class="line">                             context.getName(),</span><br><span class="line">                             Boolean.valueOf(context.getXmlValidation()),</span><br><span class="line">                             Boolean.valueOf(context.getXmlNamespaceAware())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置webConfig，会将项目中的web.xml跟tomcat目录下的web.xml合并</span></span><br><span class="line">    <span class="comment">// 并且加载所有必要的jar包</span></span><br><span class="line">    webConfig();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!context.getIgnoreAnnotations()) &#123;</span><br><span class="line">      applicationAnnotationsConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// 一堆配置鉴权的东西，tomcat-users.xml配置的东西</span></span><br><span class="line">      validateSecurityRoles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      authenticatorConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Pipeline Configuration:&quot;</span>);</span><br><span class="line">      Pipeline pipeline = context.getPipeline();</span><br><span class="line">      Valve valves[] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (pipeline != <span class="keyword">null</span>) &#123;</span><br><span class="line">        valves = pipeline.getValves();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (valves != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valves.length; i++) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;  &quot;</span> + valves[i].getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.debug(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make our application available if no problems were encountered</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      context.setConfigured(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;contextConfig.unavailable&quot;</span>));</span><br><span class="line">      context.setConfigured(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">webConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebXmlParser webXmlParser = <span class="keyword">new</span> WebXmlParser(context.getXmlNamespaceAware(),</span><br><span class="line">                                                 context.getXmlValidation(), context.getXmlBlockExternal());</span><br><span class="line">    <span class="comment">// 加载全局的web.xml</span></span><br><span class="line">    Set&lt;WebXml&gt; defaults = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    defaults.add(getDefaultWebXmlFragment(webXmlParser));</span><br><span class="line"></span><br><span class="line">    WebXml webXml = createWebXml();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始解析webapp的web.xml</span></span><br><span class="line">    InputSource contextWebXml = getContextWebXmlSource();</span><br><span class="line">    <span class="keyword">if</span> (!webXmlParser.parseWebXml(contextWebXml, webXml, <span class="keyword">false</span>)) &#123;</span><br><span class="line">      ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServletContext sContext = context.getServletContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ordering is important here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1. 加载所有jar包的web-fragment.xml</span></span><br><span class="line">    Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2. 排序上面加载的web-fragment.xml.</span></span><br><span class="line">    Set&lt;WebXml&gt; orderedFragments = <span class="keyword">null</span>;</span><br><span class="line">    orderedFragments =</span><br><span class="line">      WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3. 查找ServletContainerInitializer接口实现类</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      processServletContainerInitializers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  (!webXml.isMetadataComplete()  typeInitializerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理web-fragment.xml</span></span><br><span class="line">      processClasses(webXml, orderedFragments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!webXml.isMetadataComplete()) &#123;</span><br><span class="line">      <span class="comment">// Step 6. 合并所有的web-fragment.xml</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        ok = webXml.merge(orderedFragments);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 7. 合并默认配置</span></span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 8. JSP转Servlet</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        convertJsps(webXml);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 9. 应用合并以后的web.xml对象</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        configureContext(webXml);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line">      convertJsps(webXml);</span><br><span class="line">      configureContext(webXml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getLogEffectiveWebXml()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;web.xml:\n&quot;</span> + webXml.toXml());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 10. 查找静态资源</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// Spec does not define an order.</span></span><br><span class="line">      <span class="comment">// Use ordered JARs followed by remaining JARs</span></span><br><span class="line">      Set&lt;WebXml&gt; resourceJars = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : orderedFragments) &#123;</span><br><span class="line">        resourceJars.add(fragment);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : fragments.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resourceJars.contains(fragment)) &#123;</span><br><span class="line">          resourceJars.add(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      processResourceJARs(resourceJars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 11. 应用ServletContainerInitializer配置</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">           initializerClassMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue().isEmpty()) &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-StandardPipeline初始化"><a href="#2-2-StandardPipeline初始化" class="headerlink" title="2.2 StandardPipeline初始化"></a>2.2 StandardPipeline初始化</h3><p><code>BasicAuthenticator</code> 和 <code>StandardContextValue</code> 分别初始化，<code>Pipeline</code> 的内容打算后面请求的时候再看…</p>
<h2 id="三-StandardManager启动"><a href="#三-StandardManager启动" class="headerlink" title="三. StandardManager启动"></a>三. StandardManager启动</h2><p><code>StandardManager</code> 就负责了 <code>Session</code> 的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardManager</span> <span class="keyword">extends</span> <span class="title">ManagerBase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        <span class="comment">// 在父级抽象，准备Session的一些工具容器</span></span><br><span class="line">    <span class="keyword">super</span>.startInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取被序列化到硬盘的session</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      load();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ExceptionUtils.handleThrowable(t);</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;standardManager.managerLoad&quot;</span>), t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止，所以异步启动容器的任务就都完成了，接下来就看看怎么处理请求。</p>
<h2 id="四-管理连接的类NioEndpoint"><a href="#四-管理连接的类NioEndpoint" class="headerlink" title="四. 管理连接的类NioEndpoint"></a>四. 管理连接的类NioEndpoint</h2><p>之前说过，在启动 <code>StandardService</code> 的时候，会初始化 <code>connectors</code>，这时候 <code>Connector[HTTP/1.1-8080]</code> 也会被初始化，这是一个处理 <code>HTTP请求</code> 的关键连接器。而这个连接器有一个 <code>protocolHandler</code>，也就是 <code>协议处理器</code>，现在 <code>8.5</code> 使用的是 <code>Http11NioProtocol</code> 这个处理类来处理。 <code>Connector[HTTP/1.1-8080]</code> 在初始化的时候，就会初始化 <code>Http11NioProtocol</code>，<code>Http11NioProtocol</code> 就包含了 <code>Endpoint</code>，理解为 <code>终端口</code> 吧，也就是请求进来的地方，在 <code>NioEndpoint</code> 初始化的时候，就会绑定到系统的端口里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      <span class="comment">// 打开ServerSocketChannel</span></span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">      <span class="comment">// 绑定端口</span></span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">      Channel ic = System.inheritedChannel();</span><br><span class="line">      <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">        serverSock = (ServerSocketChannel) ic;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (serverSock == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;endpoint.init.bind.inherited&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化acceptor、poller的线程数</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成以后，<code>StandardService</code> 会经过 <code>startInternal</code> 函数，即开启容器内部所有的组件，那么 <code>NioEndpoint</code> 相对应的组件 <code>Acceptor</code> <code>Poller</code> 即会被开启线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 启动Connector的时候顺带启动NioEndpoint</span></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">      running = <span class="keyword">true</span>;</span><br><span class="line">      paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                               socketProperties.getProcessorCache());</span><br><span class="line">      eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                           socketProperties.getEventCache());</span><br><span class="line">      nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                            socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建任务队列</span></span><br><span class="line">      <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        createExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化最大连接数，默认是10000</span></span><br><span class="line">      initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开启 poller 所有的线程</span></span><br><span class="line">      pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">        pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">        Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">        pollerThread.setPriority(threadPriority);</span><br><span class="line">        pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        pollerThread.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开启Acceptor所有的线程</span></span><br><span class="line">      startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> Acceptor[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      acceptors[i] = createAcceptor();</span><br><span class="line">      String threadName = getName() + <span class="string">&quot;-Acceptor-&quot;</span> + i;</span><br><span class="line">      acceptors[i].setThreadName(threadName);</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(acceptors[i], threadName);</span><br><span class="line">      t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">      t.setDaemon(getDaemon());</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建Worker线程，用来处理请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">    TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">    TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">    executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">    taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化连接限流器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> LimitLatch <span class="title">initializeConnectionLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxConnections==-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (connectionLimitLatch==<span class="keyword">null</span>) &#123;</span><br><span class="line">      connectionLimitLatch = <span class="keyword">new</span> LimitLatch(getMaxConnections());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connectionLimitLatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在这个开启中，启动了 <code>acceptors</code> <code>pollers</code> 以及 <code>workers</code> ，这些线程也是构成 <code>Tomcat</code> 处理请求返回响应的关键。</p>
<h2 id="一-StandardRoot启动-1"><a href="#一-StandardRoot启动-1" class="headerlink" title="一. StandardRoot启动"></a>一. StandardRoot启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardRoot</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">WebResourceRoot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    mainResources.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型，创建对应的资源包实例</span></span><br><span class="line">    main = createMainResourceSet();</span><br><span class="line"></span><br><span class="line">    mainResources.add(main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次启动此类指定的资源</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;WebResourceSet&gt; list : allResources) &#123;</span><br><span class="line">      <span class="comment">// Skip class resources since they are started below</span></span><br><span class="line">      <span class="keyword">if</span> (list != classResources) &#123;</span><br><span class="line">        <span class="keyword">for</span> (WebResourceSet webResourceSet : list) &#123;</span><br><span class="line">          webResourceSet.start();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描lib下的所有jar包</span></span><br><span class="line">    processWebInfLib();</span><br><span class="line">    <span class="comment">// Need to start the newly found resources</span></span><br><span class="line">    <span class="keyword">for</span> (WebResourceSet classResource : classResources) &#123;</span><br><span class="line">      classResource.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.enforceObjectMaxSizeLimit();</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们知道，一个 <code>webapp</code> 入口是 <code>WEB-INF</code> ，因为里边包含了 <code>web.xml</code> 以及 <code>lib包</code>，所以此时就是扫描 <code>lib</code> 下所有的 <code>jar</code> 包，然后加载到 <code>webapp</code> 的 <code>ClassLoader</code> 中去。所以这个时候 <code>StandardRoot</code> 做的事情就是加载所有的 <code>jar</code> 包。</p>
<h2 id="二-发送事件通知加载web应用-1"><a href="#二-发送事件通知加载web应用-1" class="headerlink" title="二. 发送事件通知加载web应用"></a>二. 发送事件通知加载web应用</h2><p>上面图我们可以看到，<code>fireLifecycleEvent</code> 通知了 <code>ContextConfig</code> 加载 <code>webapp</code> 的配置、加载所有 <code>Pipeline</code>。 先看第一个：</p>
<h3 id="2-1-加载配置-1"><a href="#2-1-加载配置-1" class="headerlink" title="2.1 加载配置"></a>2.1 加载配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextConfig</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">configureStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Called from StandardContext.start()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.start&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.xmlSettings&quot;</span>,</span><br><span class="line">                             context.getName(),</span><br><span class="line">                             Boolean.valueOf(context.getXmlValidation()),</span><br><span class="line">                             Boolean.valueOf(context.getXmlNamespaceAware())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置webConfig，会将项目中的web.xml跟tomcat目录下的web.xml合并</span></span><br><span class="line">    <span class="comment">// 并且加载所有必要的jar包</span></span><br><span class="line">    webConfig();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!context.getIgnoreAnnotations()) &#123;</span><br><span class="line">      applicationAnnotationsConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// 一堆配置鉴权的东西，tomcat-users.xml配置的东西</span></span><br><span class="line">      validateSecurityRoles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      authenticatorConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Pipeline Configuration:&quot;</span>);</span><br><span class="line">      Pipeline pipeline = context.getPipeline();</span><br><span class="line">      Valve valves[] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (pipeline != <span class="keyword">null</span>) &#123;</span><br><span class="line">        valves = pipeline.getValves();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (valves != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valves.length; i++) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;  &quot;</span> + valves[i].getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.debug(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make our application available if no problems were encountered</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      context.setConfigured(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;contextConfig.unavailable&quot;</span>));</span><br><span class="line">      context.setConfigured(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">webConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebXmlParser webXmlParser = <span class="keyword">new</span> WebXmlParser(context.getXmlNamespaceAware(),</span><br><span class="line">                                                 context.getXmlValidation(), context.getXmlBlockExternal());</span><br><span class="line">    <span class="comment">// 加载全局的web.xml</span></span><br><span class="line">    Set&lt;WebXml&gt; defaults = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    defaults.add(getDefaultWebXmlFragment(webXmlParser));</span><br><span class="line"></span><br><span class="line">    WebXml webXml = createWebXml();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始解析webapp的web.xml</span></span><br><span class="line">    InputSource contextWebXml = getContextWebXmlSource();</span><br><span class="line">    <span class="keyword">if</span> (!webXmlParser.parseWebXml(contextWebXml, webXml, <span class="keyword">false</span>)) &#123;</span><br><span class="line">      ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServletContext sContext = context.getServletContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ordering is important here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1. 加载所有jar包的web-fragment.xml</span></span><br><span class="line">    Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2. 排序上面加载的web-fragment.xml.</span></span><br><span class="line">    Set&lt;WebXml&gt; orderedFragments = <span class="keyword">null</span>;</span><br><span class="line">    orderedFragments =</span><br><span class="line">      WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3. 查找ServletContainerInitializer接口实现类</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      processServletContainerInitializers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  (!webXml.isMetadataComplete()  typeInitializerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理web-fragment.xml</span></span><br><span class="line">      processClasses(webXml, orderedFragments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!webXml.isMetadataComplete()) &#123;</span><br><span class="line">      <span class="comment">// Step 6. 合并所有的web-fragment.xml</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        ok = webXml.merge(orderedFragments);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 7. 合并默认配置</span></span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 8. JSP转Servlet</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        convertJsps(webXml);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 9. 应用合并以后的web.xml对象</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        configureContext(webXml);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line">      convertJsps(webXml);</span><br><span class="line">      configureContext(webXml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getLogEffectiveWebXml()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;web.xml:\n&quot;</span> + webXml.toXml());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 10. 查找静态资源</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// Spec does not define an order.</span></span><br><span class="line">      <span class="comment">// Use ordered JARs followed by remaining JARs</span></span><br><span class="line">      Set&lt;WebXml&gt; resourceJars = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : orderedFragments) &#123;</span><br><span class="line">        resourceJars.add(fragment);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : fragments.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resourceJars.contains(fragment)) &#123;</span><br><span class="line">          resourceJars.add(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      processResourceJARs(resourceJars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 11. 应用ServletContainerInitializer配置</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">           initializerClassMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue().isEmpty()) &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-StandardPipeline初始化-1"><a href="#2-2-StandardPipeline初始化-1" class="headerlink" title="2.2 StandardPipeline初始化"></a>2.2 StandardPipeline初始化</h3><p><code>BasicAuthenticator</code> 和 <code>StandardContextValue</code> 分别初始化，<code>Pipeline</code> 的内容打算后面请求的时候再看…</p>
<h2 id="三-StandardManager启动-1"><a href="#三-StandardManager启动-1" class="headerlink" title="三. StandardManager启动"></a>三. StandardManager启动</h2><p><code>StandardManager</code> 就负责了 <code>Session</code> 的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardManager</span> <span class="keyword">extends</span> <span class="title">ManagerBase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        <span class="comment">// 在父级抽象，准备Session的一些工具容器</span></span><br><span class="line">    <span class="keyword">super</span>.startInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取被序列化到硬盘的session</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      load();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ExceptionUtils.handleThrowable(t);</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;standardManager.managerLoad&quot;</span>), t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止，所以异步启动容器的任务就都完成了，接下来就看看怎么处理请求。</p>
<h2 id="四-管理连接的类NioEndpoint-1"><a href="#四-管理连接的类NioEndpoint-1" class="headerlink" title="四. 管理连接的类NioEndpoint"></a>四. 管理连接的类NioEndpoint</h2><p>之前说过，在启动 <code>StandardService</code> 的时候，会初始化 <code>connectors</code>，这时候 <code>Connector[HTTP/1.1-8080]</code> 也会被初始化，这是一个处理 <code>HTTP请求</code> 的关键连接器。而这个连接器有一个 <code>protocolHandler</code>，也就是 <code>协议处理器</code>，现在 <code>8.5</code> 使用的是 <code>Http11NioProtocol</code> 这个处理类来处理。 <code>Connector[HTTP/1.1-8080]</code> 在初始化的时候，就会初始化 <code>Http11NioProtocol</code>，<code>Http11NioProtocol</code> 就包含了 <code>Endpoint</code>，理解为 <code>终端口</code> 吧，也就是请求进来的地方，在 <code>NioEndpoint</code> 初始化的时候，就会绑定到系统的端口里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      <span class="comment">// 打开ServerSocketChannel</span></span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">      <span class="comment">// 绑定端口</span></span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">      Channel ic = System.inheritedChannel();</span><br><span class="line">      <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">        serverSock = (ServerSocketChannel) ic;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (serverSock == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;endpoint.init.bind.inherited&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化acceptor、poller的线程数</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成以后，<code>StandardService</code> 会经过 <code>startInternal</code> 函数，即开启容器内部所有的组件，那么 <code>NioEndpoint</code> 相对应的组件 <code>Acceptor</code> <code>Poller</code> 即会被开启线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 启动Connector的时候顺带启动NioEndpoint</span></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">      running = <span class="keyword">true</span>;</span><br><span class="line">      paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                               socketProperties.getProcessorCache());</span><br><span class="line">      eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                           socketProperties.getEventCache());</span><br><span class="line">      nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                            socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建任务队列</span></span><br><span class="line">      <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        createExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化最大连接数，默认是10000</span></span><br><span class="line">      initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开启 poller 所有的线程</span></span><br><span class="line">      pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">        pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">        Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">        pollerThread.setPriority(threadPriority);</span><br><span class="line">        pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        pollerThread.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开启Acceptor所有的线程</span></span><br><span class="line">      startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> Acceptor[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      acceptors[i] = createAcceptor();</span><br><span class="line">      String threadName = getName() + <span class="string">&quot;-Acceptor-&quot;</span> + i;</span><br><span class="line">      acceptors[i].setThreadName(threadName);</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(acceptors[i], threadName);</span><br><span class="line">      t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">      t.setDaemon(getDaemon());</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建Worker线程，用来处理请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">    TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">    TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">    executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">    taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化连接限流器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> LimitLatch <span class="title">initializeConnectionLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxConnections==-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (connectionLimitLatch==<span class="keyword">null</span>) &#123;</span><br><span class="line">      connectionLimitLatch = <span class="keyword">new</span> LimitLatch(getMaxConnections());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connectionLimitLatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在这个开启中，启动了 <code>acceptors</code> <code>pollers</code> 以及 <code>workers</code> ，这些线程也是构成 <code>Tomcat</code> 处理请求返回响应的关键。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/java/Tomcat/%E4%B8%89-tomcat%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/java/Tomcat/%E4%B8%89-tomcat%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">【Tomcat】三.Tomcat启动（上）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-19 17:26:27" itemprop="dateCreated datePublished" datetime="2020-04-19T17:26:27+08:00">2020-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 15:14:25" itemprop="dateModified" datetime="2020-11-10T15:14:25+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上一篇的时序图：<br>上一篇的时序图： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110151410.jpeg"></p>
<h2 id="一-StandardRoot启动"><a href="#一-StandardRoot启动" class="headerlink" title="一. StandardRoot启动"></a>一. StandardRoot启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardRoot</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">WebResourceRoot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    mainResources.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型，创建对应的资源包实例</span></span><br><span class="line">    main = createMainResourceSet();</span><br><span class="line"></span><br><span class="line">    mainResources.add(main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次启动此类指定的资源</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;WebResourceSet&gt; list : allResources) &#123;</span><br><span class="line">      <span class="comment">// Skip class resources since they are started below</span></span><br><span class="line">      <span class="keyword">if</span> (list != classResources) &#123;</span><br><span class="line">        <span class="keyword">for</span> (WebResourceSet webResourceSet : list) &#123;</span><br><span class="line">          webResourceSet.start();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描lib下的所有jar包</span></span><br><span class="line">    processWebInfLib();</span><br><span class="line">    <span class="comment">// Need to start the newly found resources</span></span><br><span class="line">    <span class="keyword">for</span> (WebResourceSet classResource : classResources) &#123;</span><br><span class="line">      classResource.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.enforceObjectMaxSizeLimit();</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们知道，一个 <code>webapp</code> 入口是 <code>WEB-INF</code> ，因为里边包含了 <code>web.xml</code> 以及 <code>lib包</code>，所以此时就是扫描 <code>lib</code> 下所有的 <code>jar</code> 包，然后加载到 <code>webapp</code> 的 <code>ClassLoader</code> 中去。所以这个时候 <code>StandardRoot</code> 做的事情就是加载所有的 <code>jar</code> 包。</p>
<h2 id="二-发送事件通知加载web应用"><a href="#二-发送事件通知加载web应用" class="headerlink" title="二. 发送事件通知加载web应用"></a>二. 发送事件通知加载web应用</h2><p>上面图我们可以看到，<code>fireLifecycleEvent</code> 通知了 <code>ContextConfig</code> 加载 <code>webapp</code> 的配置、加载所有 <code>Pipeline</code>。 先看第一个：</p>
<h3 id="2-1-加载配置"><a href="#2-1-加载配置" class="headerlink" title="2.1 加载配置"></a>2.1 加载配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextConfig</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">configureStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Called from StandardContext.start()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.start&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.xmlSettings&quot;</span>,</span><br><span class="line">                             context.getName(),</span><br><span class="line">                             Boolean.valueOf(context.getXmlValidation()),</span><br><span class="line">                             Boolean.valueOf(context.getXmlNamespaceAware())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置webConfig，会将项目中的web.xml跟tomcat目录下的web.xml合并</span></span><br><span class="line">    <span class="comment">// 并且加载所有必要的jar包</span></span><br><span class="line">    webConfig();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!context.getIgnoreAnnotations()) &#123;</span><br><span class="line">      applicationAnnotationsConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// 一堆配置鉴权的东西，tomcat-users.xml配置的东西</span></span><br><span class="line">      validateSecurityRoles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      authenticatorConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Pipeline Configuration:&quot;</span>);</span><br><span class="line">      Pipeline pipeline = context.getPipeline();</span><br><span class="line">      Valve valves[] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (pipeline != <span class="keyword">null</span>) &#123;</span><br><span class="line">        valves = pipeline.getValves();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (valves != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valves.length; i++) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;  &quot;</span> + valves[i].getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.debug(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make our application available if no problems were encountered</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      context.setConfigured(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;contextConfig.unavailable&quot;</span>));</span><br><span class="line">      context.setConfigured(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">webConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebXmlParser webXmlParser = <span class="keyword">new</span> WebXmlParser(context.getXmlNamespaceAware(),</span><br><span class="line">                                                 context.getXmlValidation(), context.getXmlBlockExternal());</span><br><span class="line">    <span class="comment">// 加载全局的web.xml</span></span><br><span class="line">    Set&lt;WebXml&gt; defaults = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    defaults.add(getDefaultWebXmlFragment(webXmlParser));</span><br><span class="line"></span><br><span class="line">    WebXml webXml = createWebXml();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始解析webapp的web.xml</span></span><br><span class="line">    InputSource contextWebXml = getContextWebXmlSource();</span><br><span class="line">    <span class="keyword">if</span> (!webXmlParser.parseWebXml(contextWebXml, webXml, <span class="keyword">false</span>)) &#123;</span><br><span class="line">      ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServletContext sContext = context.getServletContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ordering is important here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1. 加载所有jar包的web-fragment.xml</span></span><br><span class="line">    Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2. 排序上面加载的web-fragment.xml.</span></span><br><span class="line">    Set&lt;WebXml&gt; orderedFragments = <span class="keyword">null</span>;</span><br><span class="line">    orderedFragments =</span><br><span class="line">      WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3. 查找ServletContainerInitializer接口实现类</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      processServletContainerInitializers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  (!webXml.isMetadataComplete()  typeInitializerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理web-fragment.xml</span></span><br><span class="line">      processClasses(webXml, orderedFragments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!webXml.isMetadataComplete()) &#123;</span><br><span class="line">      <span class="comment">// Step 6. 合并所有的web-fragment.xml</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        ok = webXml.merge(orderedFragments);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 7. 合并默认配置</span></span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 8. JSP转Servlet</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        convertJsps(webXml);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 9. 应用合并以后的web.xml对象</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        configureContext(webXml);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line">      convertJsps(webXml);</span><br><span class="line">      configureContext(webXml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getLogEffectiveWebXml()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;web.xml:\n&quot;</span> + webXml.toXml());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 10. 查找静态资源</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// Spec does not define an order.</span></span><br><span class="line">      <span class="comment">// Use ordered JARs followed by remaining JARs</span></span><br><span class="line">      Set&lt;WebXml&gt; resourceJars = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : orderedFragments) &#123;</span><br><span class="line">        resourceJars.add(fragment);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : fragments.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resourceJars.contains(fragment)) &#123;</span><br><span class="line">          resourceJars.add(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      processResourceJARs(resourceJars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 11. 应用ServletContainerInitializer配置</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">           initializerClassMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue().isEmpty()) &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-StandardPipeline初始化"><a href="#2-2-StandardPipeline初始化" class="headerlink" title="2.2 StandardPipeline初始化"></a>2.2 StandardPipeline初始化</h3><p><code>BasicAuthenticator</code> 和 <code>StandardContextValue</code> 分别初始化，<code>Pipeline</code> 的内容打算后面请求的时候再看…</p>
<h2 id="三-StandardManager启动"><a href="#三-StandardManager启动" class="headerlink" title="三. StandardManager启动"></a>三. StandardManager启动</h2><p><code>StandardManager</code> 就负责了 <code>Session</code> 的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardManager</span> <span class="keyword">extends</span> <span class="title">ManagerBase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        <span class="comment">// 在父级抽象，准备Session的一些工具容器</span></span><br><span class="line">    <span class="keyword">super</span>.startInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取被序列化到硬盘的session</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      load();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ExceptionUtils.handleThrowable(t);</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;standardManager.managerLoad&quot;</span>), t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止，所以异步启动容器的任务就都完成了，接下来就看看怎么处理请求。</p>
<h2 id="四-管理连接的类NioEndpoint"><a href="#四-管理连接的类NioEndpoint" class="headerlink" title="四. 管理连接的类NioEndpoint"></a>四. 管理连接的类NioEndpoint</h2><p>之前说过，在启动 <code>StandardService</code> 的时候，会初始化 <code>connectors</code>，这时候 <code>Connector[HTTP/1.1-8080]</code> 也会被初始化，这是一个处理 <code>HTTP请求</code> 的关键连接器。而这个连接器有一个 <code>protocolHandler</code>，也就是 <code>协议处理器</code>，现在 <code>8.5</code> 使用的是 <code>Http11NioProtocol</code> 这个处理类来处理。 <code>Connector[HTTP/1.1-8080]</code> 在初始化的时候，就会初始化 <code>Http11NioProtocol</code>，<code>Http11NioProtocol</code> 就包含了 <code>Endpoint</code>，理解为 <code>终端口</code> 吧，也就是请求进来的地方，在 <code>NioEndpoint</code> 初始化的时候，就会绑定到系统的端口里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      <span class="comment">// 打开ServerSocketChannel</span></span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">      <span class="comment">// 绑定端口</span></span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">      Channel ic = System.inheritedChannel();</span><br><span class="line">      <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">        serverSock = (ServerSocketChannel) ic;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (serverSock == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;endpoint.init.bind.inherited&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化acceptor、poller的线程数</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成以后，<code>StandardService</code> 会经过 <code>startInternal</code> 函数，即开启容器内部所有的组件，那么 <code>NioEndpoint</code> 相对应的组件 <code>Acceptor</code> <code>Poller</code> 即会被开启线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 启动Connector的时候顺带启动NioEndpoint</span></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">      running = <span class="keyword">true</span>;</span><br><span class="line">      paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                               socketProperties.getProcessorCache());</span><br><span class="line">      eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                           socketProperties.getEventCache());</span><br><span class="line">      nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                            socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建任务队列</span></span><br><span class="line">      <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        createExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化最大连接数，默认是10000</span></span><br><span class="line">      initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开启 poller 所有的线程</span></span><br><span class="line">      pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">        pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">        Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">        pollerThread.setPriority(threadPriority);</span><br><span class="line">        pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        pollerThread.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开启Acceptor所有的线程</span></span><br><span class="line">      startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> Acceptor[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      acceptors[i] = createAcceptor();</span><br><span class="line">      String threadName = getName() + <span class="string">&quot;-Acceptor-&quot;</span> + i;</span><br><span class="line">      acceptors[i].setThreadName(threadName);</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(acceptors[i], threadName);</span><br><span class="line">      t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">      t.setDaemon(getDaemon());</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建Worker线程，用来处理请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">    TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">    TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">    executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">    taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化连接限流器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> LimitLatch <span class="title">initializeConnectionLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxConnections==-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (connectionLimitLatch==<span class="keyword">null</span>) &#123;</span><br><span class="line">      connectionLimitLatch = <span class="keyword">new</span> LimitLatch(getMaxConnections());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connectionLimitLatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在这个开启中，启动了 <code>acceptors</code> <code>pollers</code> 以及 <code>workers</code> ，这些线程也是构成 <code>Tomcat</code> 处理请求返回响应的关键。</p>
<h2 id="一-StandardRoot启动-1"><a href="#一-StandardRoot启动-1" class="headerlink" title="一. StandardRoot启动"></a>一. StandardRoot启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardRoot</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">WebResourceRoot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    mainResources.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型，创建对应的资源包实例</span></span><br><span class="line">    main = createMainResourceSet();</span><br><span class="line"></span><br><span class="line">    mainResources.add(main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次启动此类指定的资源</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;WebResourceSet&gt; list : allResources) &#123;</span><br><span class="line">      <span class="comment">// Skip class resources since they are started below</span></span><br><span class="line">      <span class="keyword">if</span> (list != classResources) &#123;</span><br><span class="line">        <span class="keyword">for</span> (WebResourceSet webResourceSet : list) &#123;</span><br><span class="line">          webResourceSet.start();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描lib下的所有jar包</span></span><br><span class="line">    processWebInfLib();</span><br><span class="line">    <span class="comment">// Need to start the newly found resources</span></span><br><span class="line">    <span class="keyword">for</span> (WebResourceSet classResource : classResources) &#123;</span><br><span class="line">      classResource.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.enforceObjectMaxSizeLimit();</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们知道，一个 <code>webapp</code> 入口是 <code>WEB-INF</code> ，因为里边包含了 <code>web.xml</code> 以及 <code>lib包</code>，所以此时就是扫描 <code>lib</code> 下所有的 <code>jar</code> 包，然后加载到 <code>webapp</code> 的 <code>ClassLoader</code> 中去。所以这个时候 <code>StandardRoot</code> 做的事情就是加载所有的 <code>jar</code> 包。</p>
<h2 id="二-发送事件通知加载web应用-1"><a href="#二-发送事件通知加载web应用-1" class="headerlink" title="二. 发送事件通知加载web应用"></a>二. 发送事件通知加载web应用</h2><p>上面图我们可以看到，<code>fireLifecycleEvent</code> 通知了 <code>ContextConfig</code> 加载 <code>webapp</code> 的配置、加载所有 <code>Pipeline</code>。 先看第一个：</p>
<h3 id="2-1-加载配置-1"><a href="#2-1-加载配置-1" class="headerlink" title="2.1 加载配置"></a>2.1 加载配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextConfig</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">configureStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Called from StandardContext.start()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.start&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(sm.getString(<span class="string">&quot;contextConfig.xmlSettings&quot;</span>,</span><br><span class="line">                             context.getName(),</span><br><span class="line">                             Boolean.valueOf(context.getXmlValidation()),</span><br><span class="line">                             Boolean.valueOf(context.getXmlNamespaceAware())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 配置webConfig，会将项目中的web.xml跟tomcat目录下的web.xml合并</span></span><br><span class="line">    <span class="comment">// 并且加载所有必要的jar包</span></span><br><span class="line">    webConfig();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!context.getIgnoreAnnotations()) &#123;</span><br><span class="line">      applicationAnnotationsConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// 一堆配置鉴权的东西，tomcat-users.xml配置的东西</span></span><br><span class="line">      validateSecurityRoles();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      authenticatorConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Pipeline Configuration:&quot;</span>);</span><br><span class="line">      Pipeline pipeline = context.getPipeline();</span><br><span class="line">      Valve valves[] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (pipeline != <span class="keyword">null</span>) &#123;</span><br><span class="line">        valves = pipeline.getValves();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (valves != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valves.length; i++) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;  &quot;</span> + valves[i].getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.debug(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make our application available if no problems were encountered</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      context.setConfigured(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;contextConfig.unavailable&quot;</span>));</span><br><span class="line">      context.setConfigured(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">webConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebXmlParser webXmlParser = <span class="keyword">new</span> WebXmlParser(context.getXmlNamespaceAware(),</span><br><span class="line">                                                 context.getXmlValidation(), context.getXmlBlockExternal());</span><br><span class="line">    <span class="comment">// 加载全局的web.xml</span></span><br><span class="line">    Set&lt;WebXml&gt; defaults = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    defaults.add(getDefaultWebXmlFragment(webXmlParser));</span><br><span class="line"></span><br><span class="line">    WebXml webXml = createWebXml();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始解析webapp的web.xml</span></span><br><span class="line">    InputSource contextWebXml = getContextWebXmlSource();</span><br><span class="line">    <span class="keyword">if</span> (!webXmlParser.parseWebXml(contextWebXml, webXml, <span class="keyword">false</span>)) &#123;</span><br><span class="line">      ok = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServletContext sContext = context.getServletContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ordering is important here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1. 加载所有jar包的web-fragment.xml</span></span><br><span class="line">    Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2. 排序上面加载的web-fragment.xml.</span></span><br><span class="line">    Set&lt;WebXml&gt; orderedFragments = <span class="keyword">null</span>;</span><br><span class="line">    orderedFragments =</span><br><span class="line">      WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3. 查找ServletContainerInitializer接口实现类</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      processServletContainerInitializers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>  (!webXml.isMetadataComplete()  typeInitializerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理web-fragment.xml</span></span><br><span class="line">      processClasses(webXml, orderedFragments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!webXml.isMetadataComplete()) &#123;</span><br><span class="line">      <span class="comment">// Step 6. 合并所有的web-fragment.xml</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        ok = webXml.merge(orderedFragments);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 7. 合并默认配置</span></span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 8. JSP转Servlet</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        convertJsps(webXml);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Step 9. 应用合并以后的web.xml对象</span></span><br><span class="line">      <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        configureContext(webXml);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      webXml.merge(defaults);</span><br><span class="line">      convertJsps(webXml);</span><br><span class="line">      configureContext(webXml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getLogEffectiveWebXml()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;web.xml:\n&quot;</span> + webXml.toXml());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 10. 查找静态资源</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="comment">// Spec does not define an order.</span></span><br><span class="line">      <span class="comment">// Use ordered JARs followed by remaining JARs</span></span><br><span class="line">      Set&lt;WebXml&gt; resourceJars = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : orderedFragments) &#123;</span><br><span class="line">        resourceJars.add(fragment);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (WebXml fragment : fragments.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resourceJars.contains(fragment)) &#123;</span><br><span class="line">          resourceJars.add(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      processResourceJARs(resourceJars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 11. 应用ServletContainerInitializer配置</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">           Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">           initializerClassMap.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue().isEmpty()) &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          context.addServletContainerInitializer(</span><br><span class="line">            entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-StandardPipeline初始化-1"><a href="#2-2-StandardPipeline初始化-1" class="headerlink" title="2.2 StandardPipeline初始化"></a>2.2 StandardPipeline初始化</h3><p><code>BasicAuthenticator</code> 和 <code>StandardContextValue</code> 分别初始化，<code>Pipeline</code> 的内容打算后面请求的时候再看…</p>
<h2 id="三-StandardManager启动-1"><a href="#三-StandardManager启动-1" class="headerlink" title="三. StandardManager启动"></a>三. StandardManager启动</h2><p><code>StandardManager</code> 就负责了 <code>Session</code> 的事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardManager</span> <span class="keyword">extends</span> <span class="title">ManagerBase</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">        <span class="comment">// 在父级抽象，准备Session的一些工具容器</span></span><br><span class="line">    <span class="keyword">super</span>.startInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取被序列化到硬盘的session</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      load();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ExceptionUtils.handleThrowable(t);</span><br><span class="line">      log.error(sm.getString(<span class="string">&quot;standardManager.managerLoad&quot;</span>), t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(LifecycleState.STARTING);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里为止，所以异步启动容器的任务就都完成了，接下来就看看怎么处理请求。</p>
<h2 id="四-管理连接的类NioEndpoint-1"><a href="#四-管理连接的类NioEndpoint-1" class="headerlink" title="四. 管理连接的类NioEndpoint"></a>四. 管理连接的类NioEndpoint</h2><p>之前说过，在启动 <code>StandardService</code> 的时候，会初始化 <code>connectors</code>，这时候 <code>Connector[HTTP/1.1-8080]</code> 也会被初始化，这是一个处理 <code>HTTP请求</code> 的关键连接器。而这个连接器有一个 <code>protocolHandler</code>，也就是 <code>协议处理器</code>，现在 <code>8.5</code> 使用的是 <code>Http11NioProtocol</code> 这个处理类来处理。 <code>Connector[HTTP/1.1-8080]</code> 在初始化的时候，就会初始化 <code>Http11NioProtocol</code>，<code>Http11NioProtocol</code> 就包含了 <code>Endpoint</code>，理解为 <code>终端口</code> 吧，也就是请求进来的地方，在 <code>NioEndpoint</code> 初始化的时候，就会绑定到系统的端口里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      <span class="comment">// 打开ServerSocketChannel</span></span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">      <span class="comment">// 绑定端口</span></span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Retrieve the channel provided by the OS</span></span><br><span class="line">      Channel ic = System.inheritedChannel();</span><br><span class="line">      <span class="keyword">if</span> (ic <span class="keyword">instanceof</span> ServerSocketChannel) &#123;</span><br><span class="line">        serverSock = (ServerSocketChannel) ic;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (serverSock == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;endpoint.init.bind.inherited&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化acceptor、poller的线程数</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成以后，<code>StandardService</code> 会经过 <code>startInternal</code> 函数，即开启容器内部所有的组件，那么 <code>NioEndpoint</code> 相对应的组件 <code>Acceptor</code> <code>Poller</code> 即会被开启线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 启动Connector的时候顺带启动NioEndpoint</span></span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">      running = <span class="keyword">true</span>;</span><br><span class="line">      paused = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      processorCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                               socketProperties.getProcessorCache());</span><br><span class="line">      eventCache = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                           socketProperties.getEventCache());</span><br><span class="line">      nioChannels = <span class="keyword">new</span> SynchronizedStack&lt;&gt;(SynchronizedStack.DEFAULT_SIZE,</span><br><span class="line">                                            socketProperties.getBufferPool());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建任务队列</span></span><br><span class="line">      <span class="keyword">if</span> ( getExecutor() == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        createExecutor();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化最大连接数，默认是10000</span></span><br><span class="line">      initializeConnectionLatch();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开启 poller 所有的线程</span></span><br><span class="line">      pollers = <span class="keyword">new</span> Poller[getPollerThreadCount()];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pollers.length; i++) &#123;</span><br><span class="line">        pollers[i] = <span class="keyword">new</span> Poller();</span><br><span class="line">        Thread pollerThread = <span class="keyword">new</span> Thread(pollers[i], getName() + <span class="string">&quot;-ClientPoller-&quot;</span>+i);</span><br><span class="line">        pollerThread.setPriority(threadPriority);</span><br><span class="line">        pollerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        pollerThread.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 开启Acceptor所有的线程</span></span><br><span class="line">      startAcceptorThreads();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startAcceptorThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getAcceptorThreadCount();</span><br><span class="line">    acceptors = <span class="keyword">new</span> Acceptor[count];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      acceptors[i] = createAcceptor();</span><br><span class="line">      String threadName = getName() + <span class="string">&quot;-Acceptor-&quot;</span> + i;</span><br><span class="line">      acceptors[i].setThreadName(threadName);</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(acceptors[i], threadName);</span><br><span class="line">      t.setPriority(getAcceptorThreadPriority());</span><br><span class="line">      t.setDaemon(getDaemon());</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建Worker线程，用来处理请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    internalExecutor = <span class="keyword">true</span>;</span><br><span class="line">    TaskQueue taskqueue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">    TaskThreadFactory tf = <span class="keyword">new</span> TaskThreadFactory(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">    executor = <span class="keyword">new</span> ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">    taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化连接限流器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> LimitLatch <span class="title">initializeConnectionLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxConnections==-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (connectionLimitLatch==<span class="keyword">null</span>) &#123;</span><br><span class="line">      connectionLimitLatch = <span class="keyword">new</span> LimitLatch(getMaxConnections());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connectionLimitLatch;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以在这个开启中，启动了 <code>acceptors</code> <code>pollers</code> 以及 <code>workers</code> ，这些线程也是构成 <code>Tomcat</code> 处理请求返回响应的关键。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/java/Tomcat/%E3%80%90tomcat%E3%80%91%E4%BA%8C-tomcat%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96boostrap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/java/Tomcat/%E3%80%90tomcat%E3%80%91%E4%BA%8C-tomcat%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96boostrap/" class="post-title-link" itemprop="url">【Tomcat】二.Tomcat启动初始化Boostrap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-19 17:24:05" itemprop="dateCreated datePublished" datetime="2020-04-19T17:24:05+08:00">2020-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 15:01:31" itemprop="dateModified" datetime="2020-11-10T15:01:31+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="零-Bootstrap初始化"><a href="#零-Bootstrap初始化" class="headerlink" title="零.Bootstrap初始化"></a>零.Bootstrap初始化</h2><p><code>Bootstrap</code> 可以看成是一个 <code>TomcatServer</code> 运行时需要的环境的准备，这里通过加载配置文件，设置全局数据以便让后面的 <code>组件</code> 初始化的时候可以使用到。</p>
<h2 id="一-获取Tomcat运行的配置目录"><a href="#一-获取Tomcat运行的配置目录" class="headerlink" title="一.获取Tomcat运行的配置目录"></a>一.获取Tomcat运行的配置目录</h2><p>那么首先是在 <code>static代码块</code> 中获取到运行环境的目录基础：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Bootstrap.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Daemon object used by main.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object daemonLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 声明一个Bootstrap静默线程的对象引用，main方法将会用到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Bootstrap daemon = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaBaseFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaHomeFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATH_PATTERN = Pattern.compile(<span class="string">&quot;(\&quot;.*?\&quot;)(([^,])*)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前运行的绝对路径</span></span><br><span class="line">        String userDir = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取catalina.home的值</span></span><br><span class="line">        String home = System.getProperty(Globals.CATALINA_HOME_PROP);</span><br><span class="line">        File homeFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (home != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(home);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两次尝试获取homeFile的值，不过刚开始我们就配置了，所以这两个判断直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            File bootstrapJar = <span class="keyword">new</span> File(userDir, <span class="string">&quot;bootstrap.jar&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (bootstrapJar.exists()) &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File(userDir, <span class="string">&quot;..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    homeFile = f.getCanonicalFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    homeFile = f.getAbsoluteFile();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Second fall-back. Use current directory</span></span><br><span class="line">            File f = <span class="keyword">new</span> File(userDir);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储到Boostrap的静态变量中.</span></span><br><span class="line">        catalinaHomeFile = homeFile;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_HOME_PROP, catalinaHomeFile.getPath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后获取catalina.base的值，也同样存储到System属性中</span></span><br><span class="line">        String base = System.getProperty(Globals.CATALINA_BASE_PROP);</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="keyword">null</span>) &#123;</span><br><span class="line">            catalinaBaseFile = catalinaHomeFile;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File baseFile = <span class="keyword">new</span> File(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baseFile = baseFile.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                baseFile = baseFile.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">            catalinaBaseFile = baseFile;</span><br><span class="line">        &#125;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_BASE_PROP, catalinaBaseFile.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// .......省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-读取运行参数"><a href="#二-读取运行参数" class="headerlink" title="二.读取运行参数"></a>二.读取运行参数</h2><p>既然第一步已经初始化好了运行时所需要使用的 <code>文件路径</code>，那么接下来肯定就是读取配置并且根据配置来初始化项目了。这一步就直接在 <code>main</code> 方法中进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁初始化 Boostrap 的静默引用</span></span><br><span class="line">        <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t set daemon until init() has completed</span></span><br><span class="line">                Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bootstrap.init();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    handleThrowable(t);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 持有引用</span></span><br><span class="line">                daemon = bootstrap;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据运行的命令做相对应的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String command = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">&quot;startd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stopd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">                daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;configtest&quot;</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Bootstrap: command \&quot;&quot;</span> + command + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                    t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-Bootstrap初始化"><a href="#2-1-Bootstrap初始化" class="headerlink" title="2.1 Bootstrap初始化"></a>2.1 Bootstrap初始化</h3><p>包括初始化自定义的 <code>ClassLoader</code> 以及 <code>Catalina</code> 的准备工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化三个ClassLoader</span></span><br><span class="line">  initClassLoaders();</span><br><span class="line">  <span class="comment">// 将当前线程的ClassLoader设置成Catalina的Loader</span></span><br><span class="line">  Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过反射，做 Catalina 的准备工作</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Loading startup class&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">&quot;org.apache.catalina.startup.Catalina&quot;</span>);</span><br><span class="line">  Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 sharedLoader 设置成 Catalina 的父级 ClassLoader</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Setting startup class properties&quot;</span>);</span><br><span class="line">  String methodName = <span class="string">&quot;setParentClassLoader&quot;</span>;</span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">&quot;java.lang.ClassLoader&quot;</span>);</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">  Method method =</span><br><span class="line">    startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">  method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">  catalinaDaemon = startupInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要初始化三个 <code>ClassLoader</code>（但其实到最后三个都指向 <code>commonLoader</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    commonLoader = createClassLoader(<span class="string">&quot;common&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (commonLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// no config file, default to this loader - we might be in a &#x27;single&#x27; env.</span></span><br><span class="line">      commonLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    catalinaLoader = createClassLoader(<span class="string">&quot;server&quot;</span>, commonLoader);</span><br><span class="line">    sharedLoader = createClassLoader(<span class="string">&quot;shared&quot;</span>, commonLoader);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    handleThrowable(t);</span><br><span class="line">    log.error(<span class="string">&quot;Class loader creation threw exception&quot;</span>, t);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们现在就有这些 <code>ClassLoader</code>： </p>
<h2 id="零-Bootstrap初始化-1"><a href="#零-Bootstrap初始化-1" class="headerlink" title="零.Bootstrap初始化"></a>零.Bootstrap初始化</h2><p><code>Bootstrap</code> 可以看成是一个 <code>TomcatServer</code> 运行时需要的环境的准备，这里通过加载配置文件，设置全局数据以便让后面的 <code>组件</code> 初始化的时候可以使用到。</p>
<h2 id="一-获取Tomcat运行的配置目录-1"><a href="#一-获取Tomcat运行的配置目录-1" class="headerlink" title="一.获取Tomcat运行的配置目录"></a>一.获取Tomcat运行的配置目录</h2><p>那么首先是在 <code>static代码块</code> 中获取到运行环境的目录基础：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Bootstrap.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Daemon object used by main.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object daemonLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 声明一个Bootstrap静默线程的对象引用，main方法将会用到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Bootstrap daemon = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaBaseFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaHomeFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATH_PATTERN = Pattern.compile(<span class="string">&quot;(\&quot;.*?\&quot;)(([^,])*)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前运行的绝对路径</span></span><br><span class="line">        String userDir = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取catalina.home的值</span></span><br><span class="line">        String home = System.getProperty(Globals.CATALINA_HOME_PROP);</span><br><span class="line">        File homeFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (home != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(home);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两次尝试获取homeFile的值，不过刚开始我们就配置了，所以这两个判断直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            File bootstrapJar = <span class="keyword">new</span> File(userDir, <span class="string">&quot;bootstrap.jar&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (bootstrapJar.exists()) &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File(userDir, <span class="string">&quot;..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    homeFile = f.getCanonicalFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    homeFile = f.getAbsoluteFile();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Second fall-back. Use current directory</span></span><br><span class="line">            File f = <span class="keyword">new</span> File(userDir);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储到Boostrap的静态变量中.</span></span><br><span class="line">        catalinaHomeFile = homeFile;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_HOME_PROP, catalinaHomeFile.getPath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后获取catalina.base的值，也同样存储到System属性中</span></span><br><span class="line">        String base = System.getProperty(Globals.CATALINA_BASE_PROP);</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="keyword">null</span>) &#123;</span><br><span class="line">            catalinaBaseFile = catalinaHomeFile;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File baseFile = <span class="keyword">new</span> File(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baseFile = baseFile.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                baseFile = baseFile.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">            catalinaBaseFile = baseFile;</span><br><span class="line">        &#125;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_BASE_PROP, catalinaBaseFile.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// .......省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-读取运行参数-1"><a href="#二-读取运行参数-1" class="headerlink" title="二.读取运行参数"></a>二.读取运行参数</h2><p>既然第一步已经初始化好了运行时所需要使用的 <code>文件路径</code>，那么接下来肯定就是读取配置并且根据配置来初始化项目了。这一步就直接在 <code>main</code> 方法中进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁初始化 Boostrap 的静默引用</span></span><br><span class="line">        <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t set daemon until init() has completed</span></span><br><span class="line">                Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bootstrap.init();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    handleThrowable(t);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 持有引用</span></span><br><span class="line">                daemon = bootstrap;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据运行的命令做相对应的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String command = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">&quot;startd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stopd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">                daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;configtest&quot;</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Bootstrap: command \&quot;&quot;</span> + command + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                    t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-Bootstrap初始化-1"><a href="#2-1-Bootstrap初始化-1" class="headerlink" title="2.1 Bootstrap初始化"></a>2.1 Bootstrap初始化</h3><p>包括初始化自定义的 <code>ClassLoader</code> 以及 <code>Catalina</code> 的准备工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化三个ClassLoader</span></span><br><span class="line">  initClassLoaders();</span><br><span class="line">  <span class="comment">// 将当前线程的ClassLoader设置成Catalina的Loader</span></span><br><span class="line">  Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过反射，做 Catalina 的准备工作</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Loading startup class&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">&quot;org.apache.catalina.startup.Catalina&quot;</span>);</span><br><span class="line">  Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 sharedLoader 设置成 Catalina 的父级 ClassLoader</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Setting startup class properties&quot;</span>);</span><br><span class="line">  String methodName = <span class="string">&quot;setParentClassLoader&quot;</span>;</span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">&quot;java.lang.ClassLoader&quot;</span>);</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">  Method method =</span><br><span class="line">    startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">  method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">  catalinaDaemon = startupInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要初始化三个 <code>ClassLoader</code>（但其实到最后三个都指向 <code>commonLoader</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    commonLoader = createClassLoader(<span class="string">&quot;common&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (commonLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// no config file, default to this loader - we might be in a &#x27;single&#x27; env.</span></span><br><span class="line">      commonLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    catalinaLoader = createClassLoader(<span class="string">&quot;server&quot;</span>, commonLoader);</span><br><span class="line">    sharedLoader = createClassLoader(<span class="string">&quot;shared&quot;</span>, commonLoader);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    handleThrowable(t);</span><br><span class="line">    log.error(<span class="string">&quot;Class loader creation threw exception&quot;</span>, t);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们现在就有这些 <code>ClassLoader</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160926.jpeg"> </p>
<p>每一层加载 <code>Class</code> 的时候， <code>Loader</code> 就都会说：<code>你去找你爷去</code>，找到最后没有找到，才退下来一层，如果找到了就返回，到最后都没有找到就会抛出 <code>ClassNotFoundException</code>。 所以这种方式可以很好的防止我们使用一个同样的类，对 <code>Tomcat</code> 造成破坏。 根据 <code>catalina-home/conf/catalina.properties</code> 的配置创建初始化 <code>ClassLoader</code>。我们使用的是默认配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">common.loader</span>=<span class="string">&quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span></span><br><span class="line"><span class="meta">server.loader</span>=<span class="string"></span></span><br><span class="line"><span class="meta">shared.loader</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>由于只有 <code>common.loader</code> 配置了规则，所以下面两个在创建的时候由于没有配置，直接将 <code>commonClassLoader</code> 返回了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 通过读取 catalina-home/conf/catalina.properties 的配置，</span></span><br><span class="line">  <span class="comment">// 如果没有配置，则返回直接返回父级的ClassLoader</span></span><br><span class="line">  String value = CatalinaProperties.getProperty(name + <span class="string">&quot;.loader&quot;</span>);</span><br><span class="line">  <span class="comment">// 默认情况下，shared和Catalina的ClassLoader都没有配置，直接返回了CommonLoader实例</span></span><br><span class="line">  <span class="keyword">if</span> ((value == <span class="keyword">null</span>)  (value.equals(<span class="string">&quot;&quot;</span>)))</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line"></span><br><span class="line">  value = replace(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在加载CommonLoader的时候加载了 lib 文件夹下的所有jar包.</span></span><br><span class="line">  List&lt;Repository&gt; repositories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  String[] repositoryPaths = getPaths(value);</span><br><span class="line">  <span class="comment">// 循环 catalina-home/catalina.properties 配置的规则的路径，</span></span><br><span class="line">  <span class="comment">// 使用 URL 加载 jar 包</span></span><br><span class="line">  <span class="keyword">for</span> (String repository : repositoryPaths) &#123;</span><br><span class="line">    <span class="comment">// Check for a JAR URL repository</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">      URL url = <span class="keyword">new</span> URL(repository);</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.URL));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local repository</span></span><br><span class="line">    <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;*.jar&quot;</span>)) &#123;</span><br><span class="line">      repository = repository.substring</span><br><span class="line">        (<span class="number">0</span>, repository.length() - <span class="string">&quot;*.jar&quot;</span>.length());</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.GLOB));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.JAR));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.DIR));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ClassLoaderFactory.createClassLoader(repositories, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步的就不打算走下去了，只要知道目前 <code>commonClassLoader</code> 加载了 <code>lib</code> 下的所有包就可以了。</p>
<h3 id="2-2-Bootstrap启动"><a href="#2-2-Bootstrap启动" class="headerlink" title="2.2 Bootstrap启动"></a>2.2 Bootstrap启动</h3><p>加载完 <code>jar</code> 包目录，接下来就是启动了，在 <code>main</code> 方法里面我们可以直接看这几句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">  daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">  daemon.load(args);</span><br><span class="line">  daemon.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，设置 <code>Catalina</code> 进行等候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAwait</span><span class="params">(<span class="keyword">boolean</span> await)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Boolean.TYPE;</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = Boolean.valueOf(await);</span><br><span class="line">  Method method =</span><br><span class="line">    catalinaDaemon.getClass().getMethod(<span class="string">&quot;setAwait&quot;</span>, paramTypes);</span><br><span class="line">  method.invoke(catalinaDaemon, paramValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>Bootstrap</code> 设置 <code>Catalina</code> 的时候，一直都是通过反射的形式调用，这是因为 <code>Boostrap</code> 要保证 <code>Catalina</code> 类和 <code>XML读取的相关工具</code> 在不同的 <code>ClassLoader</code> 中，从而可以保证 <code>Catalina</code> 加载的我们 <code>war</code> 项目不可以访问到 <code>Tomcat的关键类</code>。</p>
<blockquote>
<p>Catalina：蛮好听的名字，查了一下百度资料，Catalina 是美国西海岸靠近洛杉矶22英里的一个小岛，因为其风景秀丽而著名。 Servlet 运行模块的最早开发者 Craig McClanahan 因为喜欢 Catalina岛 故以 Catalina 命名他所开这个模块，尽管他从来也没有去过那里。 另外在开发的早期阶段，Tomcat是被搭建在一个叫 Avalon 的服务器框架上，而 Avalon 则是 Catalina 岛上的一个小镇的名字，于是想一个与小镇名字相关联的单词也是自然而然。还有一个原因来自于 Craig McClanahan 养的猫，他养的猫在他写程序的时候喜欢在电脑周围闲逛。</p>
</blockquote>
<p>那就想象成 <code>Bootstrap</code> 把这个岛建立起来了！。 那第二句 <code>daemon.load(args);</code> 也是通过反射调用，代码就不贴了，直接进入 <code>Catalina.class#load()</code>。</p>
<h2 id="三-Catalina加载配置"><a href="#三-Catalina加载配置" class="headerlink" title="三.Catalina加载配置"></a>三.Catalina加载配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Catalina</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装配 server.xml 的配置</span></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    initDirs();</span><br><span class="line">    initNaming();</span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line">    InputSource inputSource = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    File file = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        file = configFile();</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        inputSource = <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>, file), e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(getConfigFile());</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(getConfigFile()).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   getConfigFile()), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This should be included in catalina.jar</span></span><br><span class="line">      <span class="comment">// Alternative: don&#x27;t bother with xml, just create it manually.</span></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(<span class="string">&quot;server-embed.xml&quot;</span>);</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(<span class="string">&quot;server-embed.xml&quot;</span>).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   <span class="string">&quot;server-embed.xml&quot;</span>), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>  inputSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                getConfigFile() + <span class="string">&quot;] or [server-embed.xml]&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                file.getAbsolutePath()));</span><br><span class="line">          <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Permissions incorrect, read permission is not allowed on the file.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="keyword">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">                 spe.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> , e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存Server的一些信息：</span></span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将日志输出流从默认的 System.out 替换成 Tomcat 自己的实现.</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始初始化 Server，也就是最大的一层。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Catalina.start&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;Initialization processed in &quot;</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看人家配置解析，Emm还是蛮无聊的，直接跳过去了。只要知道是根据 <code>server.xml</code> 解析创建对象就可以了，在这个过程中，实例化了 <code>server</code> 对象。 那么接下来就需要初始化里面的内容了，我们大概还记得这个图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160954.jpeg"> <code>getServer().init();</code> 相当于初始化 <code>TomcatServer</code>。 我们知道一个 <code>Service</code> 包含了 <code>Connector</code> 和 <code>Engine</code>，所以初始化肯定涉及这两个鬼：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          String message = sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-StandardServer初始化"><a href="#四-StandardServer初始化" class="headerlink" title="四.StandardServer初始化"></a>四.StandardServer初始化</h2><h3 id="4-1-lifecycle生命周期转换"><a href="#4-1-lifecycle生命周期转换" class="headerlink" title="4.1 lifecycle生命周期转换"></a>4.1 lifecycle生命周期转换</h3><p><code>StandardServer</code> 就需要先看看 <code>Lifecycle</code> 接口了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109161015.jpeg"> </p>
<p>这个接口规范了在 <code>Tomcat</code> 运行期间的 <code>生命周期函数</code>。只要跟 <code>Tomcat</code> 一起运行的，就会有这些 <code>生命周期</code>。 与此同时还有个 <code>LifecycleBase</code> 实现了基本的生命周期转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBase</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">      invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      initInternal();</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      handleSubClassException(t, <span class="string">&quot;lifecycleBase.initFail&quot;</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类实现这个即可实现转换</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-StandardServer初始化"><a href="#4-2-StandardServer初始化" class="headerlink" title="4.2 StandardServer初始化"></a>4.2 StandardServer初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardServer</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String注册</span></span><br><span class="line">    onameStringCache = register(<span class="keyword">new</span> StringCache(), <span class="string">&quot;type=StringCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册MBeanFactory，用来创建</span></span><br><span class="line">    MBeanFactory factory = <span class="keyword">new</span> MBeanFactory();</span><br><span class="line">    factory.setContainer(<span class="keyword">this</span>);</span><br><span class="line">    onameMBeanFactory = register(factory, <span class="string">&quot;type=MBeanFactory&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局组件名字的组件</span></span><br><span class="line">    globalNamingResources.init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getCatalina() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ClassLoader cl = getCatalina().getParentClassLoader();</span><br><span class="line">      <span class="comment">// 加载 shared 和 common ClassLoader 的Jar包，一直到 SystemClassLoader</span></span><br><span class="line">      <span class="keyword">while</span> (cl != <span class="keyword">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">          URL[] urls = ((URLClassLoader) cl).getURLs();</span><br><span class="line">          <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File (url.toURI());</span><br><span class="line">                <span class="keyword">if</span> (f.isFile() &amp;&amp;</span><br><span class="line">                    f.getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                  ExtensionValidator.addSystemResource(f);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化Service</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">      services[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载了一些 <code>Jar</code> 包，然后就初始化我们最熟悉的 <code>Service</code>。</p>
<h2 id="五-StandardService初始化"><a href="#五-StandardService初始化" class="headerlink" title="五.StandardService初始化"></a>五.StandardService初始化</h2><p>同样的实现了 <code>Lifecycle</code> 接口，所以我们只需要关注 <code>initInternal</code> 即可。那我们知道 <code>Service</code> 是包含一个 <code>Engine</code> 和 <code>接收数据的 Connector</code> 的。所以他的初始化主要是关注这两者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          String message = sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-Engine初始化"><a href="#六-Engine初始化" class="headerlink" title="六.Engine初始化"></a>六.Engine初始化</h2><p><code>Engine</code> 默认实现是 <code>StandardEngine</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardEngine</span> <span class="keyword">extends</span> <span class="title">ContainerBase</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">// Realm，一个认证的东西，这里保证加载成功</span></span><br><span class="line">    getRealm();</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来瞄一下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server&gt;  </span><br><span class="line">  &lt;!-- 省略 --&gt;</span><br><span class="line">    &lt;Service name&#x3D;&quot;Catalina&quot;&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; secretRequired&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;</span><br><span class="line">        &lt;!-- 这是一个混合的Realm认证，可以包含其他的 Realm --&gt;</span><br><span class="line">      &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</span><br><span class="line">        &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span><br><span class="line">               resourceName&#x3D;&quot;UserDatabase&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Realm&gt;</span><br><span class="line">      &lt;Host name&#x3D;&quot;localhost&quot;  appBase&#x3D;&quot;webapps&quot;</span><br><span class="line">            unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;</span><br><span class="line">               prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;</span><br><span class="line">               pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Host&gt;</span><br><span class="line">    &lt;&#x2F;Engine&gt;</span><br><span class="line">  &lt;&#x2F;Service&gt;</span><br><span class="line">&lt;&#x2F;Server&gt;</span><br></pre></td></tr></table></figure>

<p><code>LockOutRealm</code> 是一个可以组合子 <code>Realm</code> 的类，规定了在一定时间内 <code>用户鉴权出错次数</code>，超出次数则会返回错误。不过项目中一般不用这个。 接下来 <code>super.initInternal()</code> ，父类不是 <code>LifecycleBase</code> 了，而是另外一个类：<code>ContainerBase</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerBase</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; startStopQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    startStopExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">      getStartStopThreadsInternal(),</span><br><span class="line">      getStartStopThreadsInternal(), <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">      startStopQueue,</span><br><span class="line">      <span class="keyword">new</span> StartStopThreadFactory(getName() + <span class="string">&quot;-startStop-&quot;</span>));</span><br><span class="line">    startStopExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是初始化线程池实例以便后续可以让项目可以并行执行部署。</p>
<h2 id="七-MapperListener初始化"><a href="#七-MapperListener初始化" class="headerlink" title="七.MapperListener初始化"></a>七.MapperListener初始化</h2><p>这个容器主要处理 <code>HOST</code> 以及 <code>URI</code> 映射的 <code>Servlet</code>。初始化没做什么事情，只是注册了个名字，先跳过不看。</p>
<h2 id="八-Connector初始化"><a href="#八-Connector初始化" class="headerlink" title="八.Connector初始化"></a>八.Connector初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span>  </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize adapter</span></span><br><span class="line">    adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">      <span class="comment">// 设置需要解析消息体的HTTPMethod</span></span><br><span class="line">      setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isInstanceCreated()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprListener&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprLibrary&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">        protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">      AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">        (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">      <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">          jsseProtocolHandler.getSslImplementationName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">        jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化协议处理器：Http11NIOProtocol</span></span><br><span class="line">      protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">        sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParseBodyMethods</span><span class="params">(String methods)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; methodSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != methods) &#123;</span><br><span class="line">      methodSet.addAll(Arrays.asList(methods.split(<span class="string">&quot;\\s*,\\s*&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (methodSet.contains(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;coyoteConnector.parseBodyMethodNoTrace&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseBodyMethods = methods;</span><br><span class="line">    <span class="keyword">this</span>.parseBodyMethodsSet = methodSet;</span><br><span class="line">    setProperty(<span class="string">&quot;parseBodyMethods&quot;</span>, methods);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九-Http11NIOProtocol初始化"><a href="#九-Http11NIOProtocol初始化" class="headerlink" title="九.Http11NIOProtocol初始化"></a>九.Http11NIOProtocol初始化</h2><p><code>Http11NIOProtocol</code> 是一个 <code>HTTP 1.1</code> 的解析器，所以他需要负责 <code>Request</code> 和 <code>Response</code> 的解析，所以，这里又通过一个 <code>Endpoint</code> 组件来做，所以需要初始化 <code>Endpont</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ProtocolHandler</span>, <span class="title">MBeanRegistration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">      getLog().info(sm.getString(<span class="string">&quot;abstractProtocolHandler.init&quot;</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">      oname = createObjectName();</span><br><span class="line">      <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 与域名绑定解析器</span></span><br><span class="line">      rgOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=GlobalRequestProcessor,name=&quot;</span> + getName());</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">        getHandler().getGlobal(), rgOname, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取接口名字并初始化，接口在这里的意思是管理Socket数据进出的意思</span></span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    <span class="comment">// Endpoint在解析server.xml被初始化，现在是设置一些数据</span></span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line"></span><br><span class="line">    endpoint.init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    testServerCipherSuitesOrderSupport();</span><br><span class="line">    <span class="keyword">super</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testServerCipherSuitesOrderSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK8下不支持使用SSLImplementation实现类，估计是修复Bug时需要hhh</span></span><br><span class="line">    <span class="keyword">if</span>(!JreCompat.isJre8Available() &amp;&amp;</span><br><span class="line">       !OpenSSLImplementation.class.getName().equals(getSslImplementationName())) &#123;</span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : sslHostConfigs.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sslHostConfig.getHonorCipherOrder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">            sm.getString(<span class="string">&quot;endpoint.jsse.cannotHonorServerCipherOrder&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">      bind();</span><br><span class="line">      bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Register endpoint (as ThreadPool - historical name)</span></span><br><span class="line">      oname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      ObjectName socketPropertiesOname = <span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                                                        <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;,subType=SocketProperties&quot;</span>);</span><br><span class="line">      socketProperties.setObjectName(socketPropertiesOname);</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) &#123;</span><br><span class="line">        registerJmx(sslHostConfig);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the endpoint.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用NIO的类库打开绑定端口</span></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于 <code>NIO内核</code> 后面再详细了解了。 一路跳出来，<code>Catalina</code> 的 <code>load()</code> 方法就走完了，至于 <code>start()</code> 丢下一篇。 </p>
<p>每一层加载 <code>Class</code> 的时候， <code>Loader</code> 就都会说：<code>你去找你爷去</code>，找到最后没有找到，才退下来一层，如果找到了就返回，到最后都没有找到就会抛出 <code>ClassNotFoundException</code>。 所以这种方式可以很好的防止我们使用一个同样的类，对 <code>Tomcat</code> 造成破坏。 根据 <code>catalina-home/conf/catalina.properties</code> 的配置创建初始化 <code>ClassLoader</code>。我们使用的是默认配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">common.loader</span>=<span class="string">&quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span></span><br><span class="line"><span class="meta">server.loader</span>=<span class="string"></span></span><br><span class="line"><span class="meta">shared.loader</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>由于只有 <code>common.loader</code> 配置了规则，所以下面两个在创建的时候由于没有配置，直接将 <code>commonClassLoader</code> 返回了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 通过读取 catalina-home/conf/catalina.properties 的配置，</span></span><br><span class="line">  <span class="comment">// 如果没有配置，则返回直接返回父级的ClassLoader</span></span><br><span class="line">  String value = CatalinaProperties.getProperty(name + <span class="string">&quot;.loader&quot;</span>);</span><br><span class="line">  <span class="comment">// 默认情况下，shared和Catalina的ClassLoader都没有配置，直接返回了CommonLoader实例</span></span><br><span class="line">  <span class="keyword">if</span> ((value == <span class="keyword">null</span>)  (value.equals(<span class="string">&quot;&quot;</span>)))</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line"></span><br><span class="line">  value = replace(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在加载CommonLoader的时候加载了 lib 文件夹下的所有jar包.</span></span><br><span class="line">  List&lt;Repository&gt; repositories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  String[] repositoryPaths = getPaths(value);</span><br><span class="line">  <span class="comment">// 循环 catalina-home/catalina.properties 配置的规则的路径，</span></span><br><span class="line">  <span class="comment">// 使用 URL 加载 jar 包</span></span><br><span class="line">  <span class="keyword">for</span> (String repository : repositoryPaths) &#123;</span><br><span class="line">    <span class="comment">// Check for a JAR URL repository</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">      URL url = <span class="keyword">new</span> URL(repository);</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.URL));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local repository</span></span><br><span class="line">    <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;*.jar&quot;</span>)) &#123;</span><br><span class="line">      repository = repository.substring</span><br><span class="line">        (<span class="number">0</span>, repository.length() - <span class="string">&quot;*.jar&quot;</span>.length());</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.GLOB));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.JAR));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.DIR));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ClassLoaderFactory.createClassLoader(repositories, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步的就不打算走下去了，只要知道目前 <code>commonClassLoader</code> 加载了 <code>lib</code> 下的所有包就可以了。</p>
<h3 id="2-2-Bootstrap启动-1"><a href="#2-2-Bootstrap启动-1" class="headerlink" title="2.2 Bootstrap启动"></a>2.2 Bootstrap启动</h3><p>加载完 <code>jar</code> 包目录，接下来就是启动了，在 <code>main</code> 方法里面我们可以直接看这几句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">  daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">  daemon.load(args);</span><br><span class="line">  daemon.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，设置 <code>Catalina</code> 进行等候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAwait</span><span class="params">(<span class="keyword">boolean</span> await)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Boolean.TYPE;</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = Boolean.valueOf(await);</span><br><span class="line">  Method method =</span><br><span class="line">    catalinaDaemon.getClass().getMethod(<span class="string">&quot;setAwait&quot;</span>, paramTypes);</span><br><span class="line">  method.invoke(catalinaDaemon, paramValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>Bootstrap</code> 设置 <code>Catalina</code> 的时候，一直都是通过反射的形式调用，这是因为 <code>Boostrap</code> 要保证 <code>Catalina</code> 类和 <code>XML读取的相关工具</code> 在不同的 <code>ClassLoader</code> 中，从而可以保证 <code>Catalina</code> 加载的我们 <code>war</code> 项目不可以访问到 <code>Tomcat的关键类</code>。</p>
<blockquote>
<p>Catalina：蛮好听的名字，查了一下百度资料，Catalina 是美国西海岸靠近洛杉矶22英里的一个小岛，因为其风景秀丽而著名。 Servlet 运行模块的最早开发者 Craig McClanahan 因为喜欢 Catalina岛 故以 Catalina 命名他所开这个模块，尽管他从来也没有去过那里。 另外在开发的早期阶段，Tomcat是被搭建在一个叫 Avalon 的服务器框架上，而 Avalon 则是 Catalina 岛上的一个小镇的名字，于是想一个与小镇名字相关联的单词也是自然而然。还有一个原因来自于 Craig McClanahan 养的猫，他养的猫在他写程序的时候喜欢在电脑周围闲逛。</p>
</blockquote>
<p>那就想象成 <code>Bootstrap</code> 把这个岛建立起来了！。 那第二句 <code>daemon.load(args);</code> 也是通过反射调用，代码就不贴了，直接进入 <code>Catalina.class#load()</code>。</p>
<h2 id="三-Catalina加载配置-1"><a href="#三-Catalina加载配置-1" class="headerlink" title="三.Catalina加载配置"></a>三.Catalina加载配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Catalina</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装配 server.xml 的配置</span></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    initDirs();</span><br><span class="line">    initNaming();</span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line">    InputSource inputSource = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    File file = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        file = configFile();</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        inputSource = <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>, file), e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(getConfigFile());</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(getConfigFile()).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   getConfigFile()), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This should be included in catalina.jar</span></span><br><span class="line">      <span class="comment">// Alternative: don&#x27;t bother with xml, just create it manually.</span></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(<span class="string">&quot;server-embed.xml&quot;</span>);</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(<span class="string">&quot;server-embed.xml&quot;</span>).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   <span class="string">&quot;server-embed.xml&quot;</span>), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>  inputSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                getConfigFile() + <span class="string">&quot;] or [server-embed.xml]&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                file.getAbsolutePath()));</span><br><span class="line">          <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Permissions incorrect, read permission is not allowed on the file.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="keyword">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">                 spe.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> , e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存Server的一些信息：</span></span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将日志输出流从默认的 System.out 替换成 Tomcat 自己的实现.</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始初始化 Server，也就是最大的一层。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Catalina.start&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;Initialization processed in &quot;</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看人家配置解析，Emm还是蛮无聊的，直接跳过去了。只要知道是根据 <code>server.xml</code> 解析创建对象就可以了，在这个过程中，实例化了 <code>server</code> 对象。 那么接下来就需要初始化里面的内容了，我们大概还记得这个图： </p>
<h2 id="零-Bootstrap初始化-2"><a href="#零-Bootstrap初始化-2" class="headerlink" title="零.Bootstrap初始化"></a>零.Bootstrap初始化</h2><p><code>Bootstrap</code> 可以看成是一个 <code>TomcatServer</code> 运行时需要的环境的准备，这里通过加载配置文件，设置全局数据以便让后面的 <code>组件</code> 初始化的时候可以使用到。</p>
<h2 id="一-获取Tomcat运行的配置目录-2"><a href="#一-获取Tomcat运行的配置目录-2" class="headerlink" title="一.获取Tomcat运行的配置目录"></a>一.获取Tomcat运行的配置目录</h2><p>那么首先是在 <code>static代码块</code> 中获取到运行环境的目录基础：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Bootstrap.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Daemon object used by main.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object daemonLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 声明一个Bootstrap静默线程的对象引用，main方法将会用到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Bootstrap daemon = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaBaseFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaHomeFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATH_PATTERN = Pattern.compile(<span class="string">&quot;(\&quot;.*?\&quot;)(([^,])*)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前运行的绝对路径</span></span><br><span class="line">        String userDir = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取catalina.home的值</span></span><br><span class="line">        String home = System.getProperty(Globals.CATALINA_HOME_PROP);</span><br><span class="line">        File homeFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (home != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(home);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两次尝试获取homeFile的值，不过刚开始我们就配置了，所以这两个判断直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            File bootstrapJar = <span class="keyword">new</span> File(userDir, <span class="string">&quot;bootstrap.jar&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (bootstrapJar.exists()) &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File(userDir, <span class="string">&quot;..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    homeFile = f.getCanonicalFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    homeFile = f.getAbsoluteFile();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Second fall-back. Use current directory</span></span><br><span class="line">            File f = <span class="keyword">new</span> File(userDir);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储到Boostrap的静态变量中.</span></span><br><span class="line">        catalinaHomeFile = homeFile;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_HOME_PROP, catalinaHomeFile.getPath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后获取catalina.base的值，也同样存储到System属性中</span></span><br><span class="line">        String base = System.getProperty(Globals.CATALINA_BASE_PROP);</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="keyword">null</span>) &#123;</span><br><span class="line">            catalinaBaseFile = catalinaHomeFile;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File baseFile = <span class="keyword">new</span> File(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baseFile = baseFile.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                baseFile = baseFile.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">            catalinaBaseFile = baseFile;</span><br><span class="line">        &#125;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_BASE_PROP, catalinaBaseFile.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// .......省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-读取运行参数-2"><a href="#二-读取运行参数-2" class="headerlink" title="二.读取运行参数"></a>二.读取运行参数</h2><p>既然第一步已经初始化好了运行时所需要使用的 <code>文件路径</code>，那么接下来肯定就是读取配置并且根据配置来初始化项目了。这一步就直接在 <code>main</code> 方法中进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁初始化 Boostrap 的静默引用</span></span><br><span class="line">        <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t set daemon until init() has completed</span></span><br><span class="line">                Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bootstrap.init();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    handleThrowable(t);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 持有引用</span></span><br><span class="line">                daemon = bootstrap;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据运行的命令做相对应的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String command = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">&quot;startd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stopd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">                daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;configtest&quot;</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Bootstrap: command \&quot;&quot;</span> + command + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                    t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-Bootstrap初始化-2"><a href="#2-1-Bootstrap初始化-2" class="headerlink" title="2.1 Bootstrap初始化"></a>2.1 Bootstrap初始化</h3><p>包括初始化自定义的 <code>ClassLoader</code> 以及 <code>Catalina</code> 的准备工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化三个ClassLoader</span></span><br><span class="line">  initClassLoaders();</span><br><span class="line">  <span class="comment">// 将当前线程的ClassLoader设置成Catalina的Loader</span></span><br><span class="line">  Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过反射，做 Catalina 的准备工作</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Loading startup class&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">&quot;org.apache.catalina.startup.Catalina&quot;</span>);</span><br><span class="line">  Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 sharedLoader 设置成 Catalina 的父级 ClassLoader</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Setting startup class properties&quot;</span>);</span><br><span class="line">  String methodName = <span class="string">&quot;setParentClassLoader&quot;</span>;</span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">&quot;java.lang.ClassLoader&quot;</span>);</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">  Method method =</span><br><span class="line">    startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">  method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">  catalinaDaemon = startupInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要初始化三个 <code>ClassLoader</code>（但其实到最后三个都指向 <code>commonLoader</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    commonLoader = createClassLoader(<span class="string">&quot;common&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (commonLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// no config file, default to this loader - we might be in a &#x27;single&#x27; env.</span></span><br><span class="line">      commonLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    catalinaLoader = createClassLoader(<span class="string">&quot;server&quot;</span>, commonLoader);</span><br><span class="line">    sharedLoader = createClassLoader(<span class="string">&quot;shared&quot;</span>, commonLoader);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    handleThrowable(t);</span><br><span class="line">    log.error(<span class="string">&quot;Class loader creation threw exception&quot;</span>, t);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们现在就有这些 <code>ClassLoader</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160926.jpeg"> </p>
<p>每一层加载 <code>Class</code> 的时候， <code>Loader</code> 就都会说：<code>你去找你爷去</code>，找到最后没有找到，才退下来一层，如果找到了就返回，到最后都没有找到就会抛出 <code>ClassNotFoundException</code>。 所以这种方式可以很好的防止我们使用一个同样的类，对 <code>Tomcat</code> 造成破坏。 根据 <code>catalina-home/conf/catalina.properties</code> 的配置创建初始化 <code>ClassLoader</code>。我们使用的是默认配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">common.loader</span>=<span class="string">&quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span></span><br><span class="line"><span class="meta">server.loader</span>=<span class="string"></span></span><br><span class="line"><span class="meta">shared.loader</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>由于只有 <code>common.loader</code> 配置了规则，所以下面两个在创建的时候由于没有配置，直接将 <code>commonClassLoader</code> 返回了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 通过读取 catalina-home/conf/catalina.properties 的配置，</span></span><br><span class="line">  <span class="comment">// 如果没有配置，则返回直接返回父级的ClassLoader</span></span><br><span class="line">  String value = CatalinaProperties.getProperty(name + <span class="string">&quot;.loader&quot;</span>);</span><br><span class="line">  <span class="comment">// 默认情况下，shared和Catalina的ClassLoader都没有配置，直接返回了CommonLoader实例</span></span><br><span class="line">  <span class="keyword">if</span> ((value == <span class="keyword">null</span>)  (value.equals(<span class="string">&quot;&quot;</span>)))</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line"></span><br><span class="line">  value = replace(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在加载CommonLoader的时候加载了 lib 文件夹下的所有jar包.</span></span><br><span class="line">  List&lt;Repository&gt; repositories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  String[] repositoryPaths = getPaths(value);</span><br><span class="line">  <span class="comment">// 循环 catalina-home/catalina.properties 配置的规则的路径，</span></span><br><span class="line">  <span class="comment">// 使用 URL 加载 jar 包</span></span><br><span class="line">  <span class="keyword">for</span> (String repository : repositoryPaths) &#123;</span><br><span class="line">    <span class="comment">// Check for a JAR URL repository</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">      URL url = <span class="keyword">new</span> URL(repository);</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.URL));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local repository</span></span><br><span class="line">    <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;*.jar&quot;</span>)) &#123;</span><br><span class="line">      repository = repository.substring</span><br><span class="line">        (<span class="number">0</span>, repository.length() - <span class="string">&quot;*.jar&quot;</span>.length());</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.GLOB));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.JAR));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.DIR));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ClassLoaderFactory.createClassLoader(repositories, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步的就不打算走下去了，只要知道目前 <code>commonClassLoader</code> 加载了 <code>lib</code> 下的所有包就可以了。</p>
<h3 id="2-2-Bootstrap启动-2"><a href="#2-2-Bootstrap启动-2" class="headerlink" title="2.2 Bootstrap启动"></a>2.2 Bootstrap启动</h3><p>加载完 <code>jar</code> 包目录，接下来就是启动了，在 <code>main</code> 方法里面我们可以直接看这几句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">  daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">  daemon.load(args);</span><br><span class="line">  daemon.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，设置 <code>Catalina</code> 进行等候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAwait</span><span class="params">(<span class="keyword">boolean</span> await)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Boolean.TYPE;</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = Boolean.valueOf(await);</span><br><span class="line">  Method method =</span><br><span class="line">    catalinaDaemon.getClass().getMethod(<span class="string">&quot;setAwait&quot;</span>, paramTypes);</span><br><span class="line">  method.invoke(catalinaDaemon, paramValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>Bootstrap</code> 设置 <code>Catalina</code> 的时候，一直都是通过反射的形式调用，这是因为 <code>Boostrap</code> 要保证 <code>Catalina</code> 类和 <code>XML读取的相关工具</code> 在不同的 <code>ClassLoader</code> 中，从而可以保证 <code>Catalina</code> 加载的我们 <code>war</code> 项目不可以访问到 <code>Tomcat的关键类</code>。</p>
<blockquote>
<p>Catalina：蛮好听的名字，查了一下百度资料，Catalina 是美国西海岸靠近洛杉矶22英里的一个小岛，因为其风景秀丽而著名。 Servlet 运行模块的最早开发者 Craig McClanahan 因为喜欢 Catalina岛 故以 Catalina 命名他所开这个模块，尽管他从来也没有去过那里。 另外在开发的早期阶段，Tomcat是被搭建在一个叫 Avalon 的服务器框架上，而 Avalon 则是 Catalina 岛上的一个小镇的名字，于是想一个与小镇名字相关联的单词也是自然而然。还有一个原因来自于 Craig McClanahan 养的猫，他养的猫在他写程序的时候喜欢在电脑周围闲逛。</p>
</blockquote>
<p>那就想象成 <code>Bootstrap</code> 把这个岛建立起来了！。 那第二句 <code>daemon.load(args);</code> 也是通过反射调用，代码就不贴了，直接进入 <code>Catalina.class#load()</code>。</p>
<h2 id="三-Catalina加载配置-2"><a href="#三-Catalina加载配置-2" class="headerlink" title="三.Catalina加载配置"></a>三.Catalina加载配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Catalina</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装配 server.xml 的配置</span></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    initDirs();</span><br><span class="line">    initNaming();</span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line">    InputSource inputSource = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    File file = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        file = configFile();</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        inputSource = <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>, file), e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(getConfigFile());</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(getConfigFile()).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   getConfigFile()), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This should be included in catalina.jar</span></span><br><span class="line">      <span class="comment">// Alternative: don&#x27;t bother with xml, just create it manually.</span></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(<span class="string">&quot;server-embed.xml&quot;</span>);</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(<span class="string">&quot;server-embed.xml&quot;</span>).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   <span class="string">&quot;server-embed.xml&quot;</span>), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>  inputSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                getConfigFile() + <span class="string">&quot;] or [server-embed.xml]&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                file.getAbsolutePath()));</span><br><span class="line">          <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Permissions incorrect, read permission is not allowed on the file.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="keyword">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">                 spe.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> , e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存Server的一些信息：</span></span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将日志输出流从默认的 System.out 替换成 Tomcat 自己的实现.</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始初始化 Server，也就是最大的一层。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Catalina.start&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;Initialization processed in &quot;</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看人家配置解析，Emm还是蛮无聊的，直接跳过去了。只要知道是根据 <code>server.xml</code> 解析创建对象就可以了，在这个过程中，实例化了 <code>server</code> 对象。 那么接下来就需要初始化里面的内容了，我们大概还记得这个图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160954.jpeg"> <code>getServer().init();</code> 相当于初始化 <code>TomcatServer</code>。 我们知道一个 <code>Service</code> 包含了 <code>Connector</code> 和 <code>Engine</code>，所以初始化肯定涉及这两个鬼：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          String message = sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-StandardServer初始化-1"><a href="#四-StandardServer初始化-1" class="headerlink" title="四.StandardServer初始化"></a>四.StandardServer初始化</h2><h3 id="4-1-lifecycle生命周期转换-1"><a href="#4-1-lifecycle生命周期转换-1" class="headerlink" title="4.1 lifecycle生命周期转换"></a>4.1 lifecycle生命周期转换</h3><p><code>StandardServer</code> 就需要先看看 <code>Lifecycle</code> 接口了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109161015.jpeg"> </p>
<p>这个接口规范了在 <code>Tomcat</code> 运行期间的 <code>生命周期函数</code>。只要跟 <code>Tomcat</code> 一起运行的，就会有这些 <code>生命周期</code>。 与此同时还有个 <code>LifecycleBase</code> 实现了基本的生命周期转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBase</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">      invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      initInternal();</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      handleSubClassException(t, <span class="string">&quot;lifecycleBase.initFail&quot;</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类实现这个即可实现转换</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-StandardServer初始化-1"><a href="#4-2-StandardServer初始化-1" class="headerlink" title="4.2 StandardServer初始化"></a>4.2 StandardServer初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardServer</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String注册</span></span><br><span class="line">    onameStringCache = register(<span class="keyword">new</span> StringCache(), <span class="string">&quot;type=StringCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册MBeanFactory，用来创建</span></span><br><span class="line">    MBeanFactory factory = <span class="keyword">new</span> MBeanFactory();</span><br><span class="line">    factory.setContainer(<span class="keyword">this</span>);</span><br><span class="line">    onameMBeanFactory = register(factory, <span class="string">&quot;type=MBeanFactory&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局组件名字的组件</span></span><br><span class="line">    globalNamingResources.init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getCatalina() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ClassLoader cl = getCatalina().getParentClassLoader();</span><br><span class="line">      <span class="comment">// 加载 shared 和 common ClassLoader 的Jar包，一直到 SystemClassLoader</span></span><br><span class="line">      <span class="keyword">while</span> (cl != <span class="keyword">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">          URL[] urls = ((URLClassLoader) cl).getURLs();</span><br><span class="line">          <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File (url.toURI());</span><br><span class="line">                <span class="keyword">if</span> (f.isFile() &amp;&amp;</span><br><span class="line">                    f.getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                  ExtensionValidator.addSystemResource(f);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化Service</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">      services[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载了一些 <code>Jar</code> 包，然后就初始化我们最熟悉的 <code>Service</code>。</p>
<h2 id="五-StandardService初始化-1"><a href="#五-StandardService初始化-1" class="headerlink" title="五.StandardService初始化"></a>五.StandardService初始化</h2><p>同样的实现了 <code>Lifecycle</code> 接口，所以我们只需要关注 <code>initInternal</code> 即可。那我们知道 <code>Service</code> 是包含一个 <code>Engine</code> 和 <code>接收数据的 Connector</code> 的。所以他的初始化主要是关注这两者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          String message = sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-Engine初始化-1"><a href="#六-Engine初始化-1" class="headerlink" title="六.Engine初始化"></a>六.Engine初始化</h2><p><code>Engine</code> 默认实现是 <code>StandardEngine</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardEngine</span> <span class="keyword">extends</span> <span class="title">ContainerBase</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">// Realm，一个认证的东西，这里保证加载成功</span></span><br><span class="line">    getRealm();</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来瞄一下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server&gt;  </span><br><span class="line">  &lt;!-- 省略 --&gt;</span><br><span class="line">    &lt;Service name&#x3D;&quot;Catalina&quot;&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; secretRequired&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;</span><br><span class="line">        &lt;!-- 这是一个混合的Realm认证，可以包含其他的 Realm --&gt;</span><br><span class="line">      &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</span><br><span class="line">        &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span><br><span class="line">               resourceName&#x3D;&quot;UserDatabase&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Realm&gt;</span><br><span class="line">      &lt;Host name&#x3D;&quot;localhost&quot;  appBase&#x3D;&quot;webapps&quot;</span><br><span class="line">            unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;</span><br><span class="line">               prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;</span><br><span class="line">               pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Host&gt;</span><br><span class="line">    &lt;&#x2F;Engine&gt;</span><br><span class="line">  &lt;&#x2F;Service&gt;</span><br><span class="line">&lt;&#x2F;Server&gt;</span><br></pre></td></tr></table></figure>

<p><code>LockOutRealm</code> 是一个可以组合子 <code>Realm</code> 的类，规定了在一定时间内 <code>用户鉴权出错次数</code>，超出次数则会返回错误。不过项目中一般不用这个。 接下来 <code>super.initInternal()</code> ，父类不是 <code>LifecycleBase</code> 了，而是另外一个类：<code>ContainerBase</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerBase</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; startStopQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    startStopExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">      getStartStopThreadsInternal(),</span><br><span class="line">      getStartStopThreadsInternal(), <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">      startStopQueue,</span><br><span class="line">      <span class="keyword">new</span> StartStopThreadFactory(getName() + <span class="string">&quot;-startStop-&quot;</span>));</span><br><span class="line">    startStopExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是初始化线程池实例以便后续可以让项目可以并行执行部署。</p>
<h2 id="七-MapperListener初始化-1"><a href="#七-MapperListener初始化-1" class="headerlink" title="七.MapperListener初始化"></a>七.MapperListener初始化</h2><p>这个容器主要处理 <code>HOST</code> 以及 <code>URI</code> 映射的 <code>Servlet</code>。初始化没做什么事情，只是注册了个名字，先跳过不看。</p>
<h2 id="八-Connector初始化-1"><a href="#八-Connector初始化-1" class="headerlink" title="八.Connector初始化"></a>八.Connector初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span>  </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize adapter</span></span><br><span class="line">    adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">      <span class="comment">// 设置需要解析消息体的HTTPMethod</span></span><br><span class="line">      setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isInstanceCreated()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprListener&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprLibrary&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">        protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">      AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">        (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">      <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">          jsseProtocolHandler.getSslImplementationName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">        jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化协议处理器：Http11NIOProtocol</span></span><br><span class="line">      protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">        sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParseBodyMethods</span><span class="params">(String methods)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; methodSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != methods) &#123;</span><br><span class="line">      methodSet.addAll(Arrays.asList(methods.split(<span class="string">&quot;\\s*,\\s*&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (methodSet.contains(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;coyoteConnector.parseBodyMethodNoTrace&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseBodyMethods = methods;</span><br><span class="line">    <span class="keyword">this</span>.parseBodyMethodsSet = methodSet;</span><br><span class="line">    setProperty(<span class="string">&quot;parseBodyMethods&quot;</span>, methods);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九-Http11NIOProtocol初始化-1"><a href="#九-Http11NIOProtocol初始化-1" class="headerlink" title="九.Http11NIOProtocol初始化"></a>九.Http11NIOProtocol初始化</h2><p><code>Http11NIOProtocol</code> 是一个 <code>HTTP 1.1</code> 的解析器，所以他需要负责 <code>Request</code> 和 <code>Response</code> 的解析，所以，这里又通过一个 <code>Endpoint</code> 组件来做，所以需要初始化 <code>Endpont</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ProtocolHandler</span>, <span class="title">MBeanRegistration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">      getLog().info(sm.getString(<span class="string">&quot;abstractProtocolHandler.init&quot;</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">      oname = createObjectName();</span><br><span class="line">      <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 与域名绑定解析器</span></span><br><span class="line">      rgOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=GlobalRequestProcessor,name=&quot;</span> + getName());</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">        getHandler().getGlobal(), rgOname, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取接口名字并初始化，接口在这里的意思是管理Socket数据进出的意思</span></span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    <span class="comment">// Endpoint在解析server.xml被初始化，现在是设置一些数据</span></span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line"></span><br><span class="line">    endpoint.init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    testServerCipherSuitesOrderSupport();</span><br><span class="line">    <span class="keyword">super</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testServerCipherSuitesOrderSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK8下不支持使用SSLImplementation实现类，估计是修复Bug时需要hhh</span></span><br><span class="line">    <span class="keyword">if</span>(!JreCompat.isJre8Available() &amp;&amp;</span><br><span class="line">       !OpenSSLImplementation.class.getName().equals(getSslImplementationName())) &#123;</span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : sslHostConfigs.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sslHostConfig.getHonorCipherOrder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">            sm.getString(<span class="string">&quot;endpoint.jsse.cannotHonorServerCipherOrder&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">      bind();</span><br><span class="line">      bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Register endpoint (as ThreadPool - historical name)</span></span><br><span class="line">      oname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      ObjectName socketPropertiesOname = <span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                                                        <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;,subType=SocketProperties&quot;</span>);</span><br><span class="line">      socketProperties.setObjectName(socketPropertiesOname);</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) &#123;</span><br><span class="line">        registerJmx(sslHostConfig);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the endpoint.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用NIO的类库打开绑定端口</span></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于 <code>NIO内核</code> 后面再详细了解了。 一路跳出来，<code>Catalina</code> 的 <code>load()</code> 方法就走完了，至于 <code>start()</code> 丢下一篇。;<code>相当于初始化</code>TomcatServer<code>。 我们知道一个 </code>Service<code>包含了</code>Connector<code>和</code>Engine`，所以初始化肯定涉及这两个鬼：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          String message = sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-StandardServer初始化-2"><a href="#四-StandardServer初始化-2" class="headerlink" title="四.StandardServer初始化"></a>四.StandardServer初始化</h2><h3 id="4-1-lifecycle生命周期转换-2"><a href="#4-1-lifecycle生命周期转换-2" class="headerlink" title="4.1 lifecycle生命周期转换"></a>4.1 lifecycle生命周期转换</h3><p><code>StandardServer</code> 就需要先看看 <code>Lifecycle</code> 接口了： </p>
<h2 id="零-Bootstrap初始化-3"><a href="#零-Bootstrap初始化-3" class="headerlink" title="零.Bootstrap初始化"></a>零.Bootstrap初始化</h2><p><code>Bootstrap</code> 可以看成是一个 <code>TomcatServer</code> 运行时需要的环境的准备，这里通过加载配置文件，设置全局数据以便让后面的 <code>组件</code> 初始化的时候可以使用到。</p>
<h2 id="一-获取Tomcat运行的配置目录-3"><a href="#一-获取Tomcat运行的配置目录-3" class="headerlink" title="一.获取Tomcat运行的配置目录"></a>一.获取Tomcat运行的配置目录</h2><p>那么首先是在 <code>static代码块</code> 中获取到运行环境的目录基础：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Bootstrap.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Daemon object used by main.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object daemonLock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// 声明一个Bootstrap静默线程的对象引用，main方法将会用到</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Bootstrap daemon = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaBaseFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File catalinaHomeFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATH_PATTERN = Pattern.compile(<span class="string">&quot;(\&quot;.*?\&quot;)(([^,])*)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前运行的绝对路径</span></span><br><span class="line">        String userDir = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取catalina.home的值</span></span><br><span class="line">        String home = System.getProperty(Globals.CATALINA_HOME_PROP);</span><br><span class="line">        File homeFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (home != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(home);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两次尝试获取homeFile的值，不过刚开始我们就配置了，所以这两个判断直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            File bootstrapJar = <span class="keyword">new</span> File(userDir, <span class="string">&quot;bootstrap.jar&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (bootstrapJar.exists()) &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File(userDir, <span class="string">&quot;..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    homeFile = f.getCanonicalFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    homeFile = f.getAbsoluteFile();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (homeFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Second fall-back. Use current directory</span></span><br><span class="line">            File f = <span class="keyword">new</span> File(userDir);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                homeFile = f.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                homeFile = f.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储到Boostrap的静态变量中.</span></span><br><span class="line">        catalinaHomeFile = homeFile;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_HOME_PROP, catalinaHomeFile.getPath());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后获取catalina.base的值，也同样存储到System属性中</span></span><br><span class="line">        String base = System.getProperty(Globals.CATALINA_BASE_PROP);</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="keyword">null</span>) &#123;</span><br><span class="line">            catalinaBaseFile = catalinaHomeFile;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File baseFile = <span class="keyword">new</span> File(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baseFile = baseFile.getCanonicalFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                baseFile = baseFile.getAbsoluteFile();</span><br><span class="line">            &#125;</span><br><span class="line">            catalinaBaseFile = baseFile;</span><br><span class="line">        &#125;</span><br><span class="line">        System.setProperty(</span><br><span class="line">                Globals.CATALINA_BASE_PROP, catalinaBaseFile.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// .......省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-读取运行参数-3"><a href="#二-读取运行参数-3" class="headerlink" title="二.读取运行参数"></a>二.读取运行参数</h2><p>既然第一步已经初始化好了运行时所需要使用的 <code>文件路径</code>，那么接下来肯定就是读取配置并且根据配置来初始化项目了。这一步就直接在 <code>main</code> 方法中进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁初始化 Boostrap 的静默引用</span></span><br><span class="line">        <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Don&#x27;t set daemon until init() has completed</span></span><br><span class="line">                Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bootstrap.init();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    handleThrowable(t);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 持有引用</span></span><br><span class="line">                daemon = bootstrap;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据运行的命令做相对应的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String command = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">&quot;startd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stopd&quot;</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">                daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;configtest&quot;</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;Bootstrap: command \&quot;&quot;</span> + command + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                    t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-Bootstrap初始化-3"><a href="#2-1-Bootstrap初始化-3" class="headerlink" title="2.1 Bootstrap初始化"></a>2.1 Bootstrap初始化</h3><p>包括初始化自定义的 <code>ClassLoader</code> 以及 <code>Catalina</code> 的准备工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化三个ClassLoader</span></span><br><span class="line">  initClassLoaders();</span><br><span class="line">  <span class="comment">// 将当前线程的ClassLoader设置成Catalina的Loader</span></span><br><span class="line">  Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过反射，做 Catalina 的准备工作</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Loading startup class&quot;</span>);</span><br><span class="line">  Class&lt;?&gt; startupClass = catalinaLoader.loadClass(<span class="string">&quot;org.apache.catalina.startup.Catalina&quot;</span>);</span><br><span class="line">  Object startupInstance = startupClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 sharedLoader 设置成 Catalina 的父级 ClassLoader</span></span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">    log.debug(<span class="string">&quot;Setting startup class properties&quot;</span>);</span><br><span class="line">  String methodName = <span class="string">&quot;setParentClassLoader&quot;</span>;</span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">&quot;java.lang.ClassLoader&quot;</span>);</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">  Method method =</span><br><span class="line">    startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">  method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">  catalinaDaemon = startupInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要初始化三个 <code>ClassLoader</code>（但其实到最后三个都指向 <code>commonLoader</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClassLoaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    commonLoader = createClassLoader(<span class="string">&quot;common&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (commonLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// no config file, default to this loader - we might be in a &#x27;single&#x27; env.</span></span><br><span class="line">      commonLoader = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    catalinaLoader = createClassLoader(<span class="string">&quot;server&quot;</span>, commonLoader);</span><br><span class="line">    sharedLoader = createClassLoader(<span class="string">&quot;shared&quot;</span>, commonLoader);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    handleThrowable(t);</span><br><span class="line">    log.error(<span class="string">&quot;Class loader creation threw exception&quot;</span>, t);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们现在就有这些 <code>ClassLoader</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160926.jpeg"> </p>
<p>每一层加载 <code>Class</code> 的时候， <code>Loader</code> 就都会说：<code>你去找你爷去</code>，找到最后没有找到，才退下来一层，如果找到了就返回，到最后都没有找到就会抛出 <code>ClassNotFoundException</code>。 所以这种方式可以很好的防止我们使用一个同样的类，对 <code>Tomcat</code> 造成破坏。 根据 <code>catalina-home/conf/catalina.properties</code> 的配置创建初始化 <code>ClassLoader</code>。我们使用的是默认配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">common.loader</span>=<span class="string">&quot;$&#123;catalina.base&#125;/lib&quot;,&quot;$&#123;catalina.base&#125;/lib/*.jar&quot;,&quot;$&#123;catalina.home&#125;/lib&quot;,&quot;$&#123;catalina.home&#125;/lib/*.jar&quot;</span></span><br><span class="line"><span class="meta">server.loader</span>=<span class="string"></span></span><br><span class="line"><span class="meta">shared.loader</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>由于只有 <code>common.loader</code> 配置了规则，所以下面两个在创建的时候由于没有配置，直接将 <code>commonClassLoader</code> 返回了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ClassLoader <span class="title">createClassLoader</span><span class="params">(String name, ClassLoader parent)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">// 通过读取 catalina-home/conf/catalina.properties 的配置，</span></span><br><span class="line">  <span class="comment">// 如果没有配置，则返回直接返回父级的ClassLoader</span></span><br><span class="line">  String value = CatalinaProperties.getProperty(name + <span class="string">&quot;.loader&quot;</span>);</span><br><span class="line">  <span class="comment">// 默认情况下，shared和Catalina的ClassLoader都没有配置，直接返回了CommonLoader实例</span></span><br><span class="line">  <span class="keyword">if</span> ((value == <span class="keyword">null</span>)  (value.equals(<span class="string">&quot;&quot;</span>)))</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line"></span><br><span class="line">  value = replace(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在加载CommonLoader的时候加载了 lib 文件夹下的所有jar包.</span></span><br><span class="line">  List&lt;Repository&gt; repositories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  String[] repositoryPaths = getPaths(value);</span><br><span class="line">  <span class="comment">// 循环 catalina-home/catalina.properties 配置的规则的路径，</span></span><br><span class="line">  <span class="comment">// 使用 URL 加载 jar 包</span></span><br><span class="line">  <span class="keyword">for</span> (String repository : repositoryPaths) &#123;</span><br><span class="line">    <span class="comment">// Check for a JAR URL repository</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">      URL url = <span class="keyword">new</span> URL(repository);</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.URL));</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">      <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local repository</span></span><br><span class="line">    <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;*.jar&quot;</span>)) &#123;</span><br><span class="line">      repository = repository.substring</span><br><span class="line">        (<span class="number">0</span>, repository.length() - <span class="string">&quot;*.jar&quot;</span>.length());</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.GLOB));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (repository.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.JAR));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      repositories.add(<span class="keyword">new</span> Repository(repository, RepositoryType.DIR));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ClassLoaderFactory.createClassLoader(repositories, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更进一步的就不打算走下去了，只要知道目前 <code>commonClassLoader</code> 加载了 <code>lib</code> 下的所有包就可以了。</p>
<h3 id="2-2-Bootstrap启动-3"><a href="#2-2-Bootstrap启动-3" class="headerlink" title="2.2 Bootstrap启动"></a>2.2 Bootstrap启动</h3><p>加载完 <code>jar</code> 包目录，接下来就是启动了，在 <code>main</code> 方法里面我们可以直接看这几句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">  <span class="comment">// init初始化以后就需要进入到这里来启动Tomcat服务</span></span><br><span class="line">  daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">  daemon.load(args);</span><br><span class="line">  daemon.start();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，设置 <code>Catalina</code> 进行等候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAwait</span><span class="params">(<span class="keyword">boolean</span> await)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">  paramTypes[<span class="number">0</span>] = Boolean.TYPE;</span><br><span class="line">  Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">  paramValues[<span class="number">0</span>] = Boolean.valueOf(await);</span><br><span class="line">  Method method =</span><br><span class="line">    catalinaDaemon.getClass().getMethod(<span class="string">&quot;setAwait&quot;</span>, paramTypes);</span><br><span class="line">  method.invoke(catalinaDaemon, paramValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 <code>Bootstrap</code> 设置 <code>Catalina</code> 的时候，一直都是通过反射的形式调用，这是因为 <code>Boostrap</code> 要保证 <code>Catalina</code> 类和 <code>XML读取的相关工具</code> 在不同的 <code>ClassLoader</code> 中，从而可以保证 <code>Catalina</code> 加载的我们 <code>war</code> 项目不可以访问到 <code>Tomcat的关键类</code>。</p>
<blockquote>
<p>Catalina：蛮好听的名字，查了一下百度资料，Catalina 是美国西海岸靠近洛杉矶22英里的一个小岛，因为其风景秀丽而著名。 Servlet 运行模块的最早开发者 Craig McClanahan 因为喜欢 Catalina岛 故以 Catalina 命名他所开这个模块，尽管他从来也没有去过那里。 另外在开发的早期阶段，Tomcat是被搭建在一个叫 Avalon 的服务器框架上，而 Avalon 则是 Catalina 岛上的一个小镇的名字，于是想一个与小镇名字相关联的单词也是自然而然。还有一个原因来自于 Craig McClanahan 养的猫，他养的猫在他写程序的时候喜欢在电脑周围闲逛。</p>
</blockquote>
<p>那就想象成 <code>Bootstrap</code> 把这个岛建立起来了！。 那第二句 <code>daemon.load(args);</code> 也是通过反射调用，代码就不贴了，直接进入 <code>Catalina.class#load()</code>。</p>
<h2 id="三-Catalina加载配置-3"><a href="#三-Catalina加载配置-3" class="headerlink" title="三.Catalina加载配置"></a>三.Catalina加载配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Catalina</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装配 server.xml 的配置</span></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    initDirs();</span><br><span class="line">    initNaming();</span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line">    InputSource inputSource = <span class="keyword">null</span>;</span><br><span class="line">    InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    File file = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        file = configFile();</span><br><span class="line">        inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        inputSource = <span class="keyword">new</span> InputSource(file.toURI().toURL().toString());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>, file), e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(getConfigFile());</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(getConfigFile()).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   getConfigFile()), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This should be included in catalina.jar</span></span><br><span class="line">      <span class="comment">// Alternative: don&#x27;t bother with xml, just create it manually.</span></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream = getClass().getClassLoader()</span><br><span class="line">            .getResourceAsStream(<span class="string">&quot;server-embed.xml&quot;</span>);</span><br><span class="line">          inputSource = <span class="keyword">new</span> InputSource</span><br><span class="line">            (getClass().getClassLoader()</span><br><span class="line">             .getResource(<span class="string">&quot;server-embed.xml&quot;</span>).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                   <span class="string">&quot;server-embed.xml&quot;</span>), e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>  inputSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                getConfigFile() + <span class="string">&quot;] or [server-embed.xml]&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.warn(sm.getString(<span class="string">&quot;catalina.configFail&quot;</span>,</span><br><span class="line">                                file.getAbsolutePath()));</span><br><span class="line">          <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Permissions incorrect, read permission is not allowed on the file.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="keyword">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SAXParseException spe) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> +</span><br><span class="line">                 spe.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;Catalina.start using &quot;</span> + getConfigFile() + <span class="string">&quot;: &quot;</span> , e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存Server的一些信息：</span></span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将日志输出流从默认的 System.out 替换成 Tomcat 自己的实现.</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始初始化 Server，也就是最大的一层。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Catalina.start&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;Initialization processed in &quot;</span> + ((t2 - t1) / <span class="number">1000000</span>) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看人家配置解析，Emm还是蛮无聊的，直接跳过去了。只要知道是根据 <code>server.xml</code> 解析创建对象就可以了，在这个过程中，实例化了 <code>server</code> 对象。 那么接下来就需要初始化里面的内容了，我们大概还记得这个图： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160954.jpeg"> <code>getServer().init();</code> 相当于初始化 <code>TomcatServer</code>。 我们知道一个 <code>Service</code> 包含了 <code>Connector</code> 和 <code>Engine</code>，所以初始化肯定涉及这两个鬼：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          String message = sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-StandardServer初始化-3"><a href="#四-StandardServer初始化-3" class="headerlink" title="四.StandardServer初始化"></a>四.StandardServer初始化</h2><h3 id="4-1-lifecycle生命周期转换-3"><a href="#4-1-lifecycle生命周期转换-3" class="headerlink" title="4.1 lifecycle生命周期转换"></a>4.1 lifecycle生命周期转换</h3><p><code>StandardServer</code> 就需要先看看 <code>Lifecycle</code> 接口了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109161015.jpeg"> </p>
<p>这个接口规范了在 <code>Tomcat</code> 运行期间的 <code>生命周期函数</code>。只要跟 <code>Tomcat</code> 一起运行的，就会有这些 <code>生命周期</code>。 与此同时还有个 <code>LifecycleBase</code> 实现了基本的生命周期转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBase</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">      invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      initInternal();</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      handleSubClassException(t, <span class="string">&quot;lifecycleBase.initFail&quot;</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类实现这个即可实现转换</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-StandardServer初始化-2"><a href="#4-2-StandardServer初始化-2" class="headerlink" title="4.2 StandardServer初始化"></a>4.2 StandardServer初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardServer</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String注册</span></span><br><span class="line">    onameStringCache = register(<span class="keyword">new</span> StringCache(), <span class="string">&quot;type=StringCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册MBeanFactory，用来创建</span></span><br><span class="line">    MBeanFactory factory = <span class="keyword">new</span> MBeanFactory();</span><br><span class="line">    factory.setContainer(<span class="keyword">this</span>);</span><br><span class="line">    onameMBeanFactory = register(factory, <span class="string">&quot;type=MBeanFactory&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局组件名字的组件</span></span><br><span class="line">    globalNamingResources.init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getCatalina() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ClassLoader cl = getCatalina().getParentClassLoader();</span><br><span class="line">      <span class="comment">// 加载 shared 和 common ClassLoader 的Jar包，一直到 SystemClassLoader</span></span><br><span class="line">      <span class="keyword">while</span> (cl != <span class="keyword">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">          URL[] urls = ((URLClassLoader) cl).getURLs();</span><br><span class="line">          <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File (url.toURI());</span><br><span class="line">                <span class="keyword">if</span> (f.isFile() &amp;&amp;</span><br><span class="line">                    f.getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                  ExtensionValidator.addSystemResource(f);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化Service</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">      services[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载了一些 <code>Jar</code> 包，然后就初始化我们最熟悉的 <code>Service</code>。</p>
<h2 id="五-StandardService初始化-2"><a href="#五-StandardService初始化-2" class="headerlink" title="五.StandardService初始化"></a>五.StandardService初始化</h2><p>同样的实现了 <code>Lifecycle</code> 接口，所以我们只需要关注 <code>initInternal</code> 即可。那我们知道 <code>Service</code> 是包含一个 <code>Engine</code> 和 <code>接收数据的 Connector</code> 的。所以他的初始化主要是关注这两者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          String message = sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-Engine初始化-2"><a href="#六-Engine初始化-2" class="headerlink" title="六.Engine初始化"></a>六.Engine初始化</h2><p><code>Engine</code> 默认实现是 <code>StandardEngine</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardEngine</span> <span class="keyword">extends</span> <span class="title">ContainerBase</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">// Realm，一个认证的东西，这里保证加载成功</span></span><br><span class="line">    getRealm();</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来瞄一下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server&gt;  </span><br><span class="line">  &lt;!-- 省略 --&gt;</span><br><span class="line">    &lt;Service name&#x3D;&quot;Catalina&quot;&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; secretRequired&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;</span><br><span class="line">        &lt;!-- 这是一个混合的Realm认证，可以包含其他的 Realm --&gt;</span><br><span class="line">      &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</span><br><span class="line">        &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span><br><span class="line">               resourceName&#x3D;&quot;UserDatabase&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Realm&gt;</span><br><span class="line">      &lt;Host name&#x3D;&quot;localhost&quot;  appBase&#x3D;&quot;webapps&quot;</span><br><span class="line">            unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;</span><br><span class="line">               prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;</span><br><span class="line">               pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Host&gt;</span><br><span class="line">    &lt;&#x2F;Engine&gt;</span><br><span class="line">  &lt;&#x2F;Service&gt;</span><br><span class="line">&lt;&#x2F;Server&gt;</span><br></pre></td></tr></table></figure>

<p><code>LockOutRealm</code> 是一个可以组合子 <code>Realm</code> 的类，规定了在一定时间内 <code>用户鉴权出错次数</code>，超出次数则会返回错误。不过项目中一般不用这个。 接下来 <code>super.initInternal()</code> ，父类不是 <code>LifecycleBase</code> 了，而是另外一个类：<code>ContainerBase</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerBase</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; startStopQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    startStopExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">      getStartStopThreadsInternal(),</span><br><span class="line">      getStartStopThreadsInternal(), <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">      startStopQueue,</span><br><span class="line">      <span class="keyword">new</span> StartStopThreadFactory(getName() + <span class="string">&quot;-startStop-&quot;</span>));</span><br><span class="line">    startStopExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是初始化线程池实例以便后续可以让项目可以并行执行部署。</p>
<h2 id="七-MapperListener初始化-2"><a href="#七-MapperListener初始化-2" class="headerlink" title="七.MapperListener初始化"></a>七.MapperListener初始化</h2><p>这个容器主要处理 <code>HOST</code> 以及 <code>URI</code> 映射的 <code>Servlet</code>。初始化没做什么事情，只是注册了个名字，先跳过不看。</p>
<h2 id="八-Connector初始化-2"><a href="#八-Connector初始化-2" class="headerlink" title="八.Connector初始化"></a>八.Connector初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span>  </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize adapter</span></span><br><span class="line">    adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">      <span class="comment">// 设置需要解析消息体的HTTPMethod</span></span><br><span class="line">      setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isInstanceCreated()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprListener&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprLibrary&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">        protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">      AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">        (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">      <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">          jsseProtocolHandler.getSslImplementationName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">        jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化协议处理器：Http11NIOProtocol</span></span><br><span class="line">      protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">        sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParseBodyMethods</span><span class="params">(String methods)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; methodSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != methods) &#123;</span><br><span class="line">      methodSet.addAll(Arrays.asList(methods.split(<span class="string">&quot;\\s*,\\s*&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (methodSet.contains(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;coyoteConnector.parseBodyMethodNoTrace&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseBodyMethods = methods;</span><br><span class="line">    <span class="keyword">this</span>.parseBodyMethodsSet = methodSet;</span><br><span class="line">    setProperty(<span class="string">&quot;parseBodyMethods&quot;</span>, methods);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九-Http11NIOProtocol初始化-2"><a href="#九-Http11NIOProtocol初始化-2" class="headerlink" title="九.Http11NIOProtocol初始化"></a>九.Http11NIOProtocol初始化</h2><p><code>Http11NIOProtocol</code> 是一个 <code>HTTP 1.1</code> 的解析器，所以他需要负责 <code>Request</code> 和 <code>Response</code> 的解析，所以，这里又通过一个 <code>Endpoint</code> 组件来做，所以需要初始化 <code>Endpont</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ProtocolHandler</span>, <span class="title">MBeanRegistration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">      getLog().info(sm.getString(<span class="string">&quot;abstractProtocolHandler.init&quot;</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">      oname = createObjectName();</span><br><span class="line">      <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 与域名绑定解析器</span></span><br><span class="line">      rgOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=GlobalRequestProcessor,name=&quot;</span> + getName());</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">        getHandler().getGlobal(), rgOname, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取接口名字并初始化，接口在这里的意思是管理Socket数据进出的意思</span></span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    <span class="comment">// Endpoint在解析server.xml被初始化，现在是设置一些数据</span></span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line"></span><br><span class="line">    endpoint.init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    testServerCipherSuitesOrderSupport();</span><br><span class="line">    <span class="keyword">super</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testServerCipherSuitesOrderSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK8下不支持使用SSLImplementation实现类，估计是修复Bug时需要hhh</span></span><br><span class="line">    <span class="keyword">if</span>(!JreCompat.isJre8Available() &amp;&amp;</span><br><span class="line">       !OpenSSLImplementation.class.getName().equals(getSslImplementationName())) &#123;</span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : sslHostConfigs.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sslHostConfig.getHonorCipherOrder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">            sm.getString(<span class="string">&quot;endpoint.jsse.cannotHonorServerCipherOrder&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">      bind();</span><br><span class="line">      bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Register endpoint (as ThreadPool - historical name)</span></span><br><span class="line">      oname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      ObjectName socketPropertiesOname = <span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                                                        <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;,subType=SocketProperties&quot;</span>);</span><br><span class="line">      socketProperties.setObjectName(socketPropertiesOname);</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) &#123;</span><br><span class="line">        registerJmx(sslHostConfig);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the endpoint.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用NIO的类库打开绑定端口</span></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于 <code>NIO内核</code> 后面再详细了解了。 一路跳出来，<code>Catalina</code> 的 <code>load()</code> 方法就走完了，至于 <code>start()</code> 丢下一篇。 </p>
<p>这个接口规范了在 <code>Tomcat</code> 运行期间的 <code>生命周期函数</code>。只要跟 <code>Tomcat</code> 一起运行的，就会有这些 <code>生命周期</code>。 与此同时还有个 <code>LifecycleBase</code> 实现了基本的生命周期转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleBase</span> <span class="keyword">implements</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">      invalidTransition(Lifecycle.BEFORE_INIT_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZING, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      initInternal();</span><br><span class="line">      setStateInternal(LifecycleState.INITIALIZED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      handleSubClassException(t, <span class="string">&quot;lifecycleBase.initFail&quot;</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子类实现这个即可实现转换</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-StandardServer初始化-3"><a href="#4-2-StandardServer初始化-3" class="headerlink" title="4.2 StandardServer初始化"></a>4.2 StandardServer初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardServer</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// String注册</span></span><br><span class="line">    onameStringCache = register(<span class="keyword">new</span> StringCache(), <span class="string">&quot;type=StringCache&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册MBeanFactory，用来创建</span></span><br><span class="line">    MBeanFactory factory = <span class="keyword">new</span> MBeanFactory();</span><br><span class="line">    factory.setContainer(<span class="keyword">this</span>);</span><br><span class="line">    onameMBeanFactory = register(factory, <span class="string">&quot;type=MBeanFactory&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化全局组件名字的组件</span></span><br><span class="line">    globalNamingResources.init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getCatalina() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ClassLoader cl = getCatalina().getParentClassLoader();</span><br><span class="line">      <span class="comment">// 加载 shared 和 common ClassLoader 的Jar包，一直到 SystemClassLoader</span></span><br><span class="line">      <span class="keyword">while</span> (cl != <span class="keyword">null</span> &amp;&amp; cl != ClassLoader.getSystemClassLoader()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cl <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">          URL[] urls = ((URLClassLoader) cl).getURLs();</span><br><span class="line">          <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.getProtocol().equals(<span class="string">&quot;file&quot;</span>)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                File f = <span class="keyword">new</span> File (url.toURI());</span><br><span class="line">                <span class="keyword">if</span> (f.isFile() &amp;&amp;</span><br><span class="line">                    f.getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                  ExtensionValidator.addSystemResource(f);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化Service</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">      services[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载了一些 <code>Jar</code> 包，然后就初始化我们最熟悉的 <code>Service</code>。</p>
<h2 id="五-StandardService初始化-3"><a href="#五-StandardService初始化-3" class="headerlink" title="五.StandardService初始化"></a>五.StandardService初始化</h2><p>同样的实现了 <code>Lifecycle</code> 接口，所以我们只需要关注 <code>initInternal</code> 即可。那我们知道 <code>Service</code> 是包含一个 <code>Engine</code> 和 <code>接收数据的 Connector</code> 的。所以他的初始化主要是关注这两者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardService</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span> <span class="keyword">implements</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Engine</span></span><br><span class="line">    <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">      engine.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是空的执行器</span></span><br><span class="line">    <span class="keyword">for</span> (Executor executor : findExecutors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> JmxEnabled) &#123;</span><br><span class="line">        ((JmxEnabled) executor).setDomain(getDomain());</span><br><span class="line">      &#125;</span><br><span class="line">      executor.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化监听器</span></span><br><span class="line">    mapperListener.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Connector</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Connector connector : connectors) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          connector.init();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          String message = sm.getString(</span><br><span class="line">            <span class="string">&quot;standardService.connector.initFailed&quot;</span>, connector);</span><br><span class="line">          log.error(message, e);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;org.apache.catalina.startup.EXIT_ON_INIT_FAILURE&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-Engine初始化-3"><a href="#六-Engine初始化-3" class="headerlink" title="六.Engine初始化"></a>六.Engine初始化</h2><p><code>Engine</code> 默认实现是 <code>StandardEngine</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardEngine</span> <span class="keyword">extends</span> <span class="title">ContainerBase</span> <span class="keyword">implements</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    <span class="comment">// Realm，一个认证的东西，这里保证加载成功</span></span><br><span class="line">    getRealm();</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来瞄一下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server&gt;  </span><br><span class="line">  &lt;!-- 省略 --&gt;</span><br><span class="line">    &lt;Service name&#x3D;&quot;Catalina&quot;&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</span><br><span class="line">    &lt;Connector port&#x3D;&quot;8009&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; secretRequired&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;Engine name&#x3D;&quot;Catalina&quot; defaultHost&#x3D;&quot;localhost&quot;&gt;</span><br><span class="line">        &lt;!-- 这是一个混合的Realm认证，可以包含其他的 Realm --&gt;</span><br><span class="line">      &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</span><br><span class="line">        &lt;Realm className&#x3D;&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span><br><span class="line">               resourceName&#x3D;&quot;UserDatabase&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Realm&gt;</span><br><span class="line">      &lt;Host name&#x3D;&quot;localhost&quot;  appBase&#x3D;&quot;webapps&quot;</span><br><span class="line">            unpackWARs&#x3D;&quot;true&quot; autoDeploy&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;Valve className&#x3D;&quot;org.apache.catalina.valves.AccessLogValve&quot; directory&#x3D;&quot;logs&quot;</span><br><span class="line">               prefix&#x3D;&quot;localhost_access_log&quot; suffix&#x3D;&quot;.txt&quot;</span><br><span class="line">               pattern&#x3D;&quot;%h %l %u %t &quot;%r&quot; %s %b&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;Host&gt;</span><br><span class="line">    &lt;&#x2F;Engine&gt;</span><br><span class="line">  &lt;&#x2F;Service&gt;</span><br><span class="line">&lt;&#x2F;Server&gt;</span><br></pre></td></tr></table></figure>

<p><code>LockOutRealm</code> 是一个可以组合子 <code>Realm</code> 的类，规定了在一定时间内 <code>用户鉴权出错次数</code>，超出次数则会返回错误。不过项目中一般不用这个。 接下来 <code>super.initInternal()</code> ，父类不是 <code>LifecycleBase</code> 了，而是另外一个类：<code>ContainerBase</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerBase</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; startStopQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    startStopExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">      getStartStopThreadsInternal(),</span><br><span class="line">      getStartStopThreadsInternal(), <span class="number">10</span>, TimeUnit.SECONDS,</span><br><span class="line">      startStopQueue,</span><br><span class="line">      <span class="keyword">new</span> StartStopThreadFactory(getName() + <span class="string">&quot;-startStop-&quot;</span>));</span><br><span class="line">    startStopExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是初始化线程池实例以便后续可以让项目可以并行执行部署。</p>
<h2 id="七-MapperListener初始化-3"><a href="#七-MapperListener初始化-3" class="headerlink" title="七.MapperListener初始化"></a>七.MapperListener初始化</h2><p>这个容器主要处理 <code>HOST</code> 以及 <code>URI</code> 映射的 <code>Servlet</code>。初始化没做什么事情，只是注册了个名字，先跳过不看。</p>
<h2 id="八-Connector初始化-3"><a href="#八-Connector初始化-3" class="headerlink" title="八.Connector初始化"></a>八.Connector初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connector</span> <span class="keyword">extends</span> <span class="title">LifecycleMBeanBase</span>  </span>&#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initInternal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize adapter</span></span><br><span class="line">    adapter = <span class="keyword">new</span> CoyoteAdapter(<span class="keyword">this</span>);</span><br><span class="line">    protocolHandler.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure parseBodyMethodsSet has a default</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == parseBodyMethodsSet) &#123;</span><br><span class="line">      <span class="comment">// 设置需要解析消息体的HTTPMethod</span></span><br><span class="line">      setParseBodyMethods(getParseBodyMethods());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isInstanceCreated()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprListener&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (protocolHandler.isAprRequired() &amp;&amp; !AprLifecycleListener.isAprAvailable()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerNoAprLibrary&quot;</span>,</span><br><span class="line">                                                getProtocolHandlerClassName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (AprLifecycleListener.isAprAvailable() &amp;&amp; AprLifecycleListener.getUseOpenSSL() &amp;&amp;</span><br><span class="line">        protocolHandler <span class="keyword">instanceof</span> AbstractHttp11JsseProtocol) &#123;</span><br><span class="line">      AbstractHttp11JsseProtocol&lt;?&gt; jsseProtocolHandler =</span><br><span class="line">        (AbstractHttp11JsseProtocol&lt;?&gt;) protocolHandler;</span><br><span class="line">      <span class="keyword">if</span> (jsseProtocolHandler.isSSLEnabled() &amp;&amp;</span><br><span class="line">          jsseProtocolHandler.getSslImplementationName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// OpenSSL is compatible with the JSSE configuration, so use it if APR is available</span></span><br><span class="line">        jsseProtocolHandler.setSslImplementationName(OpenSSLImplementation.class.getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化协议处理器：Http11NIOProtocol</span></span><br><span class="line">      protocolHandler.init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LifecycleException(</span><br><span class="line">        sm.getString(<span class="string">&quot;coyoteConnector.protocolHandlerInitializationFailed&quot;</span>), e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParseBodyMethods</span><span class="params">(String methods)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashSet&lt;String&gt; methodSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != methods) &#123;</span><br><span class="line">      methodSet.addAll(Arrays.asList(methods.split(<span class="string">&quot;\\s*,\\s*&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (methodSet.contains(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(sm.getString(<span class="string">&quot;coyoteConnector.parseBodyMethodNoTrace&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseBodyMethods = methods;</span><br><span class="line">    <span class="keyword">this</span>.parseBodyMethodsSet = methodSet;</span><br><span class="line">    setProperty(<span class="string">&quot;parseBodyMethods&quot;</span>, methods);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九-Http11NIOProtocol初始化-3"><a href="#九-Http11NIOProtocol初始化-3" class="headerlink" title="九.Http11NIOProtocol初始化"></a>九.Http11NIOProtocol初始化</h2><p><code>Http11NIOProtocol</code> 是一个 <code>HTTP 1.1</code> 的解析器，所以他需要负责 <code>Request</code> 和 <code>Response</code> 的解析，所以，这里又通过一个 <code>Endpoint</code> 组件来做，所以需要初始化 <code>Endpont</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProtocol</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">ProtocolHandler</span>, <span class="title">MBeanRegistration</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getLog().isInfoEnabled()) &#123;</span><br><span class="line">      getLog().info(sm.getString(<span class="string">&quot;abstractProtocolHandler.init&quot;</span>, getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oname == <span class="keyword">null</span>) &#123;</span><br><span class="line">      oname = createObjectName();</span><br><span class="line">      <span class="keyword">if</span> (oname != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 与域名绑定解析器</span></span><br><span class="line">      rgOname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=GlobalRequestProcessor,name=&quot;</span> + getName());</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(</span><br><span class="line">        getHandler().getGlobal(), rgOname, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取接口名字并初始化，接口在这里的意思是管理Socket数据进出的意思</span></span><br><span class="line">    String endpointName = getName();</span><br><span class="line">    <span class="comment">// Endpoint在解析server.xml被初始化，现在是设置一些数据</span></span><br><span class="line">    endpoint.setName(endpointName.substring(<span class="number">1</span>, endpointName.length()-<span class="number">1</span>));</span><br><span class="line">    endpoint.setDomain(domain);</span><br><span class="line"></span><br><span class="line">    endpoint.init();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    testServerCipherSuitesOrderSupport();</span><br><span class="line">    <span class="keyword">super</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testServerCipherSuitesOrderSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// JDK8下不支持使用SSLImplementation实现类，估计是修复Bug时需要hhh</span></span><br><span class="line">    <span class="keyword">if</span>(!JreCompat.isJre8Available() &amp;&amp;</span><br><span class="line">       !OpenSSLImplementation.class.getName().equals(getSslImplementationName())) &#123;</span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : sslHostConfigs.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sslHostConfig.getHonorCipherOrder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">            sm.getString(<span class="string">&quot;endpoint.jsse.cannotHonorServerCipherOrder&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindOnInit) &#123;</span><br><span class="line">      bind();</span><br><span class="line">      bindState = BindState.BOUND_ON_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.domain != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Register endpoint (as ThreadPool - historical name)</span></span><br><span class="line">      oname = <span class="keyword">new</span> ObjectName(domain + <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(<span class="keyword">this</span>, oname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      ObjectName socketPropertiesOname = <span class="keyword">new</span> ObjectName(domain +</span><br><span class="line">                                                        <span class="string">&quot;:type=ThreadPool,name=\&quot;&quot;</span> + getName() + <span class="string">&quot;\&quot;,subType=SocketProperties&quot;</span>);</span><br><span class="line">      socketProperties.setObjectName(socketPropertiesOname);</span><br><span class="line">      Registry.getRegistry(<span class="keyword">null</span>, <span class="keyword">null</span>).registerComponent(socketProperties, socketPropertiesOname, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (SSLHostConfig sslHostConfig : findSslHostConfigs()) &#123;</span><br><span class="line">        registerJmx(sslHostConfig);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractJsseEndpoint</span>&lt;<span class="title">NioChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the endpoint.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用NIO的类库打开绑定端口</span></span><br><span class="line">    <span class="keyword">if</span> (!getUseInheritedChannel()) &#123;</span><br><span class="line">      serverSock = ServerSocketChannel.open();</span><br><span class="line">      socketProperties.setProperties(serverSock.socket());</span><br><span class="line">      InetSocketAddress addr = (getAddress()!=<span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(getAddress(),getPort()):<span class="keyword">new</span> InetSocketAddress(getPort()));</span><br><span class="line">      serverSock.socket().bind(addr,getAcceptCount());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    serverSock.configureBlocking(<span class="keyword">true</span>); <span class="comment">//mimic APR behavior</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize thread count defaults for acceptor, poller</span></span><br><span class="line">    <span class="keyword">if</span> (acceptorThreadCount == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> Doesn&#x27;t seem to work that well with multiple accept threads</span></span><br><span class="line">      acceptorThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pollerThreadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//minimum one poller thread</span></span><br><span class="line">      pollerThreadCount = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setStopLatch(<span class="keyword">new</span> CountDownLatch(pollerThreadCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize SSL if needed</span></span><br><span class="line">    initialiseSsl();</span><br><span class="line"></span><br><span class="line">    selectorPool.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于 <code>NIO内核</code> 后面再详细了解了。 一路跳出来，<code>Catalina</code> 的 <code>load()</code> 方法就走完了，至于 <code>start()</code> 丢下一篇。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/java/Tomcat/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/java/Tomcat/%E3%80%90tomcat%E3%80%91%E4%B8%80-%E5%88%9D%E8%AF%86tomcat%E4%BB%A5%E5%8F%8A%E8%B0%83%E8%AF%95tomcat/" class="post-title-link" itemprop="url">【Tomcat】一.初识Tomcat以及调试Tomcat</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-19 17:17:12" itemprop="dateCreated datePublished" datetime="2020-04-19T17:17:12+08:00">2020-04-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 15:02:34" itemprop="dateModified" datetime="2020-11-10T15:02:34+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/Tomcat/" itemprop="url" rel="index"><span itemprop="name">Tomcat</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[toc]</p>
<h2 id="一-Tomcat服务器"><a href="#一-Tomcat服务器" class="headerlink" title="一.Tomcat服务器"></a>一.Tomcat服务器</h2><p>相信一直默默耕耘在 <code>JavaWEB</code> 的同学，肯定不会不认识 <code>Tomcat</code>。这可是世界一个著名的 <code>Web服务器</code> 之一，在之前动态 <code>Web服务</code> 还没有那么盛行的时候，<code>Tomcat</code> 依靠对 <code>Servlet</code> 的实现，让 <code>Web开发</code> 变得简单，<code>JSP诞生</code> 也是目前 <code>动态页面</code> 的始祖。 我不知道现在的同学还记不记得 <code>servlet</code> 的开发方法：</p>
<ol>
<li>创建自己的处理类，继承 <code>HttpServlet</code>，覆写 <code>doGet</code> <code>doPost</code> <code>doPut</code> 等不同 <code>HTTP Method</code> 的方法实现；</li>
<li>在 <code>WEB项目</code> 的 <code>web.xml</code> 文件中配置 <code>servlet</code> 的请求路径信息；</li>
<li>打包成 <code>war</code> 包，丢进 <code>Tomcat/webapp</code>；</li>
<li>启动 <code>Tomcat</code> 服务器，<code>Tomcat</code> 端口映射成功以后请求相对应的路径，即可访问到我们刚刚写的 <code>servlet</code> 中。</li>
</ol>
<p>而当我们需要配置 <code>Tomcat服务器</code> 的端口呀，以及一些其他信息的时候，这时候就需要到 <code>&#123;TomcatHome&#125;/conf/server.xml</code> 中去配置，不过搁以前，我都是找到我要改掉的参数，比如说我要把 <code>8080</code> 改成 <code>12345</code>，那就是先找到 <code>8080</code> 的字符，然后改成 <code>12345</code> ，赶紧保存，关掉编辑窗口，防止配置被我弄了其他的，导致整个服务器起不来。起不来就只好重新解压了hhh</p>
<h2 id="二-Tomcat架构"><a href="#二-Tomcat架构" class="headerlink" title="二.Tomcat架构"></a>二.Tomcat架构</h2><p>[toc]</p>
<h2 id="一-Tomcat服务器-1"><a href="#一-Tomcat服务器-1" class="headerlink" title="一.Tomcat服务器"></a>一.Tomcat服务器</h2><p>相信一直默默耕耘在 <code>JavaWEB</code> 的同学，肯定不会不认识 <code>Tomcat</code>。这可是世界一个著名的 <code>Web服务器</code> 之一，在之前动态 <code>Web服务</code> 还没有那么盛行的时候，<code>Tomcat</code> 依靠对 <code>Servlet</code> 的实现，让 <code>Web开发</code> 变得简单，<code>JSP诞生</code> 也是目前 <code>动态页面</code> 的始祖。 我不知道现在的同学还记不记得 <code>servlet</code> 的开发方法：</p>
<ol>
<li>创建自己的处理类，继承 <code>HttpServlet</code>，覆写 <code>doGet</code> <code>doPost</code> <code>doPut</code> 等不同 <code>HTTP Method</code> 的方法实现；</li>
<li>在 <code>WEB项目</code> 的 <code>web.xml</code> 文件中配置 <code>servlet</code> 的请求路径信息；</li>
<li>打包成 <code>war</code> 包，丢进 <code>Tomcat/webapp</code>；</li>
<li>启动 <code>Tomcat</code> 服务器，<code>Tomcat</code> 端口映射成功以后请求相对应的路径，即可访问到我们刚刚写的 <code>servlet</code> 中。</li>
</ol>
<p>而当我们需要配置 <code>Tomcat服务器</code> 的端口呀，以及一些其他信息的时候，这时候就需要到 <code>&#123;TomcatHome&#125;/conf/server.xml</code> 中去配置，不过搁以前，我都是找到我要改掉的参数，比如说我要把 <code>8080</code> 改成 <code>12345</code>，那就是先找到 <code>8080</code> 的字符，然后改成 <code>12345</code> ，赶紧保存，关掉编辑窗口，防止配置被我弄了其他的，导致整个服务器起不来。起不来就只好重新解压了hhh</p>
<h2 id="二-Tomcat架构-1"><a href="#二-Tomcat架构-1" class="headerlink" title="二.Tomcat架构"></a>二.Tomcat架构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160631.jpeg"></p>
<p>这个配置文件，用过 <code>Tomcat</code> 的应该都不会不认识，其实这里就已经能够很好的反应了 <code>Tomcat</code> 的架构了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160654.jpeg"> 所以，<code>Tomcat</code> 就有几个这样的元素：</p>
<ol>
<li><code>Server</code>：表示整个 <code>Tomcat容器</code>，这个容器可以配置多个 <code>Service</code> 呀，运行多个程序等等；</li>
<li><code>Service</code>：表示一个服务容器，可配置这个服务容器的 <code>Engine</code>、<code>Connector</code> 、<code>Host</code> 等等，在一个 <code>Server</code> 中允许配置多个 <code>Service</code>。</li>
<li><code>Connector</code>：负责解析数据，然后将数据交给 <code>Engine</code> 去处理，处理完成拿到 <code>响应数据</code> 再包装成对应的格式输出到客户端；</li>
<li><code>Engine</code>：处理引擎，代表一系列的数据转换链表，从多个 <code>Connector</code> 接收数据，处理数据输出出去；</li>
<li><code>Host</code>：代表一个域名，这个域名下可以存放多个 <code>Context</code>，也就是我们的 <code>war项目</code>，一个 <code>Service</code> 同样可以拥有多个 <code>Host</code>；</li>
<li><code>Context</code>：我们的 <code>Web上下文</code>，生命周期就跟 <code>Servlet</code> 项目一样了，存在于 <code>Host</code> 下，我们写的代码主要负责将接收的数据处理，处理完成返回 <code>响应数据</code> 出去即可。</li>
</ol>
<h2 id="三-导入IDEA"><a href="#三-导入IDEA" class="headerlink" title="三.导入IDEA"></a>三.导入IDEA</h2><p>不得不说，这玩意儿导入 <code>idea</code> 是真的麻烦，没有之一…. 首先，打开 <code>https://tomcat.apache.org/download-80.cgi</code> 下载源码，<code>Source Code</code> 那部分就是了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160712.jpeg"> 然后，别急着打开，创建一个 <code>pom.xml</code> 在项目根目录（对，就是用 <code>maven</code> 插件来编译 <code>ant</code> 项目，比较猥琐，但是能用啊~）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apache-tomcat-8.5.51&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;name&gt;apache-tomcat-8.5.51&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;version&gt;8.0&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.7&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-apache-log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-commons-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml.rpc&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.xml.rpc-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;apache-tomcat-8.5.51&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;&#x2F;sourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;&#x2F;directory&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.5&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                    &lt;source&gt;$&#123;java.version&#125;&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;$&#123;java.version&#125;&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>这时候可以通过 <code>idea</code> 打开 <code>pom.xml</code> 文件来加载项目了。 依赖下载完成以后，别急，先到我们平常使用的 <code>tomcat</code> 中把 <code>conf</code> <code>lib</code> <code>logs</code> <code>webapps</code> <code>work</code> 这几个文件夹拷贝出来，在项目根目录创建一个名为 <code>catalina-home</code> 的文件夹，把上面拷贝的文件夹粘贴进去。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160737.jpeg"> </p>
<p>然后，我们先找到 <code>Boostrap</code> 类，他是 <code>Tomcat服务器</code> 启动的主程序类，<code>main</code> 方法就在里边，启动他，反正起不来，也可以在启动过程中直接终止。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160803.jpeg"> 然后我们在第一处点击启动类的配置，将以下的代码拷贝到 <code>2</code> 处，再启动就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home&#x3D;catalina-home</span><br><span class="line">-Dcatalina.base&#x3D;catalina-home</span><br><span class="line">-Djava.endorsed.dirs&#x3D;catalina-home&#x2F;endorsed</span><br><span class="line">-Djava.io.tmpdir&#x3D;catalina-home&#x2F;temp</span><br><span class="line">-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file&#x3D;catalina-home&#x2F;conf&#x2F;logging.properties</span><br></pre></td></tr></table></figure>

<p>然后重新启动，访问 <code>http://localhost:8080</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160833.jpeg"></p>
<p>这个配置文件，用过 <code>Tomcat</code> 的应该都不会不认识，其实这里就已经能够很好的反应了 <code>Tomcat</code> 的架构了：<br>[toc]</p>
<h2 id="一-Tomcat服务器-2"><a href="#一-Tomcat服务器-2" class="headerlink" title="一.Tomcat服务器"></a>一.Tomcat服务器</h2><p>相信一直默默耕耘在 <code>JavaWEB</code> 的同学，肯定不会不认识 <code>Tomcat</code>。这可是世界一个著名的 <code>Web服务器</code> 之一，在之前动态 <code>Web服务</code> 还没有那么盛行的时候，<code>Tomcat</code> 依靠对 <code>Servlet</code> 的实现，让 <code>Web开发</code> 变得简单，<code>JSP诞生</code> 也是目前 <code>动态页面</code> 的始祖。 我不知道现在的同学还记不记得 <code>servlet</code> 的开发方法：</p>
<ol>
<li>创建自己的处理类，继承 <code>HttpServlet</code>，覆写 <code>doGet</code> <code>doPost</code> <code>doPut</code> 等不同 <code>HTTP Method</code> 的方法实现；</li>
<li>在 <code>WEB项目</code> 的 <code>web.xml</code> 文件中配置 <code>servlet</code> 的请求路径信息；</li>
<li>打包成 <code>war</code> 包，丢进 <code>Tomcat/webapp</code>；</li>
<li>启动 <code>Tomcat</code> 服务器，<code>Tomcat</code> 端口映射成功以后请求相对应的路径，即可访问到我们刚刚写的 <code>servlet</code> 中。</li>
</ol>
<p>而当我们需要配置 <code>Tomcat服务器</code> 的端口呀，以及一些其他信息的时候，这时候就需要到 <code>&#123;TomcatHome&#125;/conf/server.xml</code> 中去配置，不过搁以前，我都是找到我要改掉的参数，比如说我要把 <code>8080</code> 改成 <code>12345</code>，那就是先找到 <code>8080</code> 的字符，然后改成 <code>12345</code> ，赶紧保存，关掉编辑窗口，防止配置被我弄了其他的，导致整个服务器起不来。起不来就只好重新解压了hhh</p>
<h2 id="二-Tomcat架构-2"><a href="#二-Tomcat架构-2" class="headerlink" title="二.Tomcat架构"></a>二.Tomcat架构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160631.jpeg"></p>
<p>这个配置文件，用过 <code>Tomcat</code> 的应该都不会不认识，其实这里就已经能够很好的反应了 <code>Tomcat</code> 的架构了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160654.jpeg"> 所以，<code>Tomcat</code> 就有几个这样的元素：</p>
<ol>
<li><code>Server</code>：表示整个 <code>Tomcat容器</code>，这个容器可以配置多个 <code>Service</code> 呀，运行多个程序等等；</li>
<li><code>Service</code>：表示一个服务容器，可配置这个服务容器的 <code>Engine</code>、<code>Connector</code> 、<code>Host</code> 等等，在一个 <code>Server</code> 中允许配置多个 <code>Service</code>。</li>
<li><code>Connector</code>：负责解析数据，然后将数据交给 <code>Engine</code> 去处理，处理完成拿到 <code>响应数据</code> 再包装成对应的格式输出到客户端；</li>
<li><code>Engine</code>：处理引擎，代表一系列的数据转换链表，从多个 <code>Connector</code> 接收数据，处理数据输出出去；</li>
<li><code>Host</code>：代表一个域名，这个域名下可以存放多个 <code>Context</code>，也就是我们的 <code>war项目</code>，一个 <code>Service</code> 同样可以拥有多个 <code>Host</code>；</li>
<li><code>Context</code>：我们的 <code>Web上下文</code>，生命周期就跟 <code>Servlet</code> 项目一样了，存在于 <code>Host</code> 下，我们写的代码主要负责将接收的数据处理，处理完成返回 <code>响应数据</code> 出去即可。</li>
</ol>
<h2 id="三-导入IDEA-1"><a href="#三-导入IDEA-1" class="headerlink" title="三.导入IDEA"></a>三.导入IDEA</h2><p>不得不说，这玩意儿导入 <code>idea</code> 是真的麻烦，没有之一…. 首先，打开 <code>https://tomcat.apache.org/download-80.cgi</code> 下载源码，<code>Source Code</code> 那部分就是了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160712.jpeg"> 然后，别急着打开，创建一个 <code>pom.xml</code> 在项目根目录（对，就是用 <code>maven</code> 插件来编译 <code>ant</code> 项目，比较猥琐，但是能用啊~）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apache-tomcat-8.5.51&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;name&gt;apache-tomcat-8.5.51&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;version&gt;8.0&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.7&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-apache-log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-commons-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml.rpc&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.xml.rpc-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;apache-tomcat-8.5.51&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;&#x2F;sourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;&#x2F;directory&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.5&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                    &lt;source&gt;$&#123;java.version&#125;&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;$&#123;java.version&#125;&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>这时候可以通过 <code>idea</code> 打开 <code>pom.xml</code> 文件来加载项目了。 依赖下载完成以后，别急，先到我们平常使用的 <code>tomcat</code> 中把 <code>conf</code> <code>lib</code> <code>logs</code> <code>webapps</code> <code>work</code> 这几个文件夹拷贝出来，在项目根目录创建一个名为 <code>catalina-home</code> 的文件夹，把上面拷贝的文件夹粘贴进去。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160737.jpeg"> </p>
<p>然后，我们先找到 <code>Boostrap</code> 类，他是 <code>Tomcat服务器</code> 启动的主程序类，<code>main</code> 方法就在里边，启动他，反正起不来，也可以在启动过程中直接终止。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160803.jpeg"> 然后我们在第一处点击启动类的配置，将以下的代码拷贝到 <code>2</code> 处，再启动就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home&#x3D;catalina-home</span><br><span class="line">-Dcatalina.base&#x3D;catalina-home</span><br><span class="line">-Djava.endorsed.dirs&#x3D;catalina-home&#x2F;endorsed</span><br><span class="line">-Djava.io.tmpdir&#x3D;catalina-home&#x2F;temp</span><br><span class="line">-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file&#x3D;catalina-home&#x2F;conf&#x2F;logging.properties</span><br></pre></td></tr></table></figure>

<p>然后重新启动，访问 <code>http://localhost:8080</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160833.jpeg"> 所以，<code>Tomcat</code> 就有几个这样的元素：</p>
<ol>
<li><code>Server</code>：表示整个 <code>Tomcat容器</code>，这个容器可以配置多个 <code>Service</code> 呀，运行多个程序等等；</li>
<li><code>Service</code>：表示一个服务容器，可配置这个服务容器的 <code>Engine</code>、<code>Connector</code> 、<code>Host</code> 等等，在一个 <code>Server</code> 中允许配置多个 <code>Service</code>。</li>
<li><code>Connector</code>：负责解析数据，然后将数据交给 <code>Engine</code> 去处理，处理完成拿到 <code>响应数据</code> 再包装成对应的格式输出到客户端；</li>
<li><code>Engine</code>：处理引擎，代表一系列的数据转换链表，从多个 <code>Connector</code> 接收数据，处理数据输出出去；</li>
<li><code>Host</code>：代表一个域名，这个域名下可以存放多个 <code>Context</code>，也就是我们的 <code>war项目</code>，一个 <code>Service</code> 同样可以拥有多个 <code>Host</code>；</li>
<li><code>Context</code>：我们的 <code>Web上下文</code>，生命周期就跟 <code>Servlet</code> 项目一样了，存在于 <code>Host</code> 下，我们写的代码主要负责将接收的数据处理，处理完成返回 <code>响应数据</code> 出去即可。</li>
</ol>
<h2 id="三-导入IDEA-2"><a href="#三-导入IDEA-2" class="headerlink" title="三.导入IDEA"></a>三.导入IDEA</h2><p>不得不说，这玩意儿导入 <code>idea</code> 是真的麻烦，没有之一…. 首先，打开 <code>https://tomcat.apache.org/download-80.cgi</code> 下载源码，<code>Source Code</code> 那部分就是了：<br>[toc]</p>
<h2 id="一-Tomcat服务器-3"><a href="#一-Tomcat服务器-3" class="headerlink" title="一.Tomcat服务器"></a>一.Tomcat服务器</h2><p>相信一直默默耕耘在 <code>JavaWEB</code> 的同学，肯定不会不认识 <code>Tomcat</code>。这可是世界一个著名的 <code>Web服务器</code> 之一，在之前动态 <code>Web服务</code> 还没有那么盛行的时候，<code>Tomcat</code> 依靠对 <code>Servlet</code> 的实现，让 <code>Web开发</code> 变得简单，<code>JSP诞生</code> 也是目前 <code>动态页面</code> 的始祖。 我不知道现在的同学还记不记得 <code>servlet</code> 的开发方法：</p>
<ol>
<li>创建自己的处理类，继承 <code>HttpServlet</code>，覆写 <code>doGet</code> <code>doPost</code> <code>doPut</code> 等不同 <code>HTTP Method</code> 的方法实现；</li>
<li>在 <code>WEB项目</code> 的 <code>web.xml</code> 文件中配置 <code>servlet</code> 的请求路径信息；</li>
<li>打包成 <code>war</code> 包，丢进 <code>Tomcat/webapp</code>；</li>
<li>启动 <code>Tomcat</code> 服务器，<code>Tomcat</code> 端口映射成功以后请求相对应的路径，即可访问到我们刚刚写的 <code>servlet</code> 中。</li>
</ol>
<p>而当我们需要配置 <code>Tomcat服务器</code> 的端口呀，以及一些其他信息的时候，这时候就需要到 <code>&#123;TomcatHome&#125;/conf/server.xml</code> 中去配置，不过搁以前，我都是找到我要改掉的参数，比如说我要把 <code>8080</code> 改成 <code>12345</code>，那就是先找到 <code>8080</code> 的字符，然后改成 <code>12345</code> ，赶紧保存，关掉编辑窗口，防止配置被我弄了其他的，导致整个服务器起不来。起不来就只好重新解压了hhh</p>
<h2 id="二-Tomcat架构-3"><a href="#二-Tomcat架构-3" class="headerlink" title="二.Tomcat架构"></a>二.Tomcat架构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160631.jpeg"></p>
<p>这个配置文件，用过 <code>Tomcat</code> 的应该都不会不认识，其实这里就已经能够很好的反应了 <code>Tomcat</code> 的架构了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160654.jpeg"> 所以，<code>Tomcat</code> 就有几个这样的元素：</p>
<ol>
<li><code>Server</code>：表示整个 <code>Tomcat容器</code>，这个容器可以配置多个 <code>Service</code> 呀，运行多个程序等等；</li>
<li><code>Service</code>：表示一个服务容器，可配置这个服务容器的 <code>Engine</code>、<code>Connector</code> 、<code>Host</code> 等等，在一个 <code>Server</code> 中允许配置多个 <code>Service</code>。</li>
<li><code>Connector</code>：负责解析数据，然后将数据交给 <code>Engine</code> 去处理，处理完成拿到 <code>响应数据</code> 再包装成对应的格式输出到客户端；</li>
<li><code>Engine</code>：处理引擎，代表一系列的数据转换链表，从多个 <code>Connector</code> 接收数据，处理数据输出出去；</li>
<li><code>Host</code>：代表一个域名，这个域名下可以存放多个 <code>Context</code>，也就是我们的 <code>war项目</code>，一个 <code>Service</code> 同样可以拥有多个 <code>Host</code>；</li>
<li><code>Context</code>：我们的 <code>Web上下文</code>，生命周期就跟 <code>Servlet</code> 项目一样了，存在于 <code>Host</code> 下，我们写的代码主要负责将接收的数据处理，处理完成返回 <code>响应数据</code> 出去即可。</li>
</ol>
<h2 id="三-导入IDEA-3"><a href="#三-导入IDEA-3" class="headerlink" title="三.导入IDEA"></a>三.导入IDEA</h2><p>不得不说，这玩意儿导入 <code>idea</code> 是真的麻烦，没有之一…. 首先，打开 <code>https://tomcat.apache.org/download-80.cgi</code> 下载源码，<code>Source Code</code> 那部分就是了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160712.jpeg"> 然后，别急着打开，创建一个 <code>pom.xml</code> 在项目根目录（对，就是用 <code>maven</code> 插件来编译 <code>ant</code> 项目，比较猥琐，但是能用啊~）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apache-tomcat-8.5.51&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;name&gt;apache-tomcat-8.5.51&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;version&gt;8.0&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.7&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-apache-log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-commons-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml.rpc&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.xml.rpc-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;apache-tomcat-8.5.51&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;&#x2F;sourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;&#x2F;directory&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.5&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                    &lt;source&gt;$&#123;java.version&#125;&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;$&#123;java.version&#125;&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>这时候可以通过 <code>idea</code> 打开 <code>pom.xml</code> 文件来加载项目了。 依赖下载完成以后，别急，先到我们平常使用的 <code>tomcat</code> 中把 <code>conf</code> <code>lib</code> <code>logs</code> <code>webapps</code> <code>work</code> 这几个文件夹拷贝出来，在项目根目录创建一个名为 <code>catalina-home</code> 的文件夹，把上面拷贝的文件夹粘贴进去。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160737.jpeg"> </p>
<p>然后，我们先找到 <code>Boostrap</code> 类，他是 <code>Tomcat服务器</code> 启动的主程序类，<code>main</code> 方法就在里边，启动他，反正起不来，也可以在启动过程中直接终止。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160803.jpeg"> 然后我们在第一处点击启动类的配置，将以下的代码拷贝到 <code>2</code> 处，再启动就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home&#x3D;catalina-home</span><br><span class="line">-Dcatalina.base&#x3D;catalina-home</span><br><span class="line">-Djava.endorsed.dirs&#x3D;catalina-home&#x2F;endorsed</span><br><span class="line">-Djava.io.tmpdir&#x3D;catalina-home&#x2F;temp</span><br><span class="line">-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file&#x3D;catalina-home&#x2F;conf&#x2F;logging.properties</span><br></pre></td></tr></table></figure>

<p>然后重新启动，访问 <code>http://localhost:8080</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160833.jpeg"> 然后，别急着打开，创建一个 <code>pom.xml</code> 在项目根目录（对，就是用 <code>maven</code> 插件来编译 <code>ant</code> 项目，比较猥琐，但是能用啊~）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apache-tomcat-8.5.51&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;name&gt;apache-tomcat-8.5.51&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;version&gt;8.0&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.7&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-apache-log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-commons-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml.rpc&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.xml.rpc-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;apache-tomcat-8.5.51&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;&#x2F;sourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;&#x2F;directory&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.5&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                    &lt;source&gt;$&#123;java.version&#125;&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;$&#123;java.version&#125;&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>这时候可以通过 <code>idea</code> 打开 <code>pom.xml</code> 文件来加载项目了。 依赖下载完成以后，别急，先到我们平常使用的 <code>tomcat</code> 中把 <code>conf</code> <code>lib</code> <code>logs</code> <code>webapps</code> <code>work</code> 这几个文件夹拷贝出来，在项目根目录创建一个名为 <code>catalina-home</code> 的文件夹，把上面拷贝的文件夹粘贴进去。 </p>
<p>[toc]</p>
<h2 id="一-Tomcat服务器-4"><a href="#一-Tomcat服务器-4" class="headerlink" title="一.Tomcat服务器"></a>一.Tomcat服务器</h2><p>相信一直默默耕耘在 <code>JavaWEB</code> 的同学，肯定不会不认识 <code>Tomcat</code>。这可是世界一个著名的 <code>Web服务器</code> 之一，在之前动态 <code>Web服务</code> 还没有那么盛行的时候，<code>Tomcat</code> 依靠对 <code>Servlet</code> 的实现，让 <code>Web开发</code> 变得简单，<code>JSP诞生</code> 也是目前 <code>动态页面</code> 的始祖。 我不知道现在的同学还记不记得 <code>servlet</code> 的开发方法：</p>
<ol>
<li>创建自己的处理类，继承 <code>HttpServlet</code>，覆写 <code>doGet</code> <code>doPost</code> <code>doPut</code> 等不同 <code>HTTP Method</code> 的方法实现；</li>
<li>在 <code>WEB项目</code> 的 <code>web.xml</code> 文件中配置 <code>servlet</code> 的请求路径信息；</li>
<li>打包成 <code>war</code> 包，丢进 <code>Tomcat/webapp</code>；</li>
<li>启动 <code>Tomcat</code> 服务器，<code>Tomcat</code> 端口映射成功以后请求相对应的路径，即可访问到我们刚刚写的 <code>servlet</code> 中。</li>
</ol>
<p>而当我们需要配置 <code>Tomcat服务器</code> 的端口呀，以及一些其他信息的时候，这时候就需要到 <code>&#123;TomcatHome&#125;/conf/server.xml</code> 中去配置，不过搁以前，我都是找到我要改掉的参数，比如说我要把 <code>8080</code> 改成 <code>12345</code>，那就是先找到 <code>8080</code> 的字符，然后改成 <code>12345</code> ，赶紧保存，关掉编辑窗口，防止配置被我弄了其他的，导致整个服务器起不来。起不来就只好重新解压了hhh</p>
<h2 id="二-Tomcat架构-4"><a href="#二-Tomcat架构-4" class="headerlink" title="二.Tomcat架构"></a>二.Tomcat架构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160631.jpeg"></p>
<p>这个配置文件，用过 <code>Tomcat</code> 的应该都不会不认识，其实这里就已经能够很好的反应了 <code>Tomcat</code> 的架构了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160654.jpeg"> 所以，<code>Tomcat</code> 就有几个这样的元素：</p>
<ol>
<li><code>Server</code>：表示整个 <code>Tomcat容器</code>，这个容器可以配置多个 <code>Service</code> 呀，运行多个程序等等；</li>
<li><code>Service</code>：表示一个服务容器，可配置这个服务容器的 <code>Engine</code>、<code>Connector</code> 、<code>Host</code> 等等，在一个 <code>Server</code> 中允许配置多个 <code>Service</code>。</li>
<li><code>Connector</code>：负责解析数据，然后将数据交给 <code>Engine</code> 去处理，处理完成拿到 <code>响应数据</code> 再包装成对应的格式输出到客户端；</li>
<li><code>Engine</code>：处理引擎，代表一系列的数据转换链表，从多个 <code>Connector</code> 接收数据，处理数据输出出去；</li>
<li><code>Host</code>：代表一个域名，这个域名下可以存放多个 <code>Context</code>，也就是我们的 <code>war项目</code>，一个 <code>Service</code> 同样可以拥有多个 <code>Host</code>；</li>
<li><code>Context</code>：我们的 <code>Web上下文</code>，生命周期就跟 <code>Servlet</code> 项目一样了，存在于 <code>Host</code> 下，我们写的代码主要负责将接收的数据处理，处理完成返回 <code>响应数据</code> 出去即可。</li>
</ol>
<h2 id="三-导入IDEA-4"><a href="#三-导入IDEA-4" class="headerlink" title="三.导入IDEA"></a>三.导入IDEA</h2><p>不得不说，这玩意儿导入 <code>idea</code> 是真的麻烦，没有之一…. 首先，打开 <code>https://tomcat.apache.org/download-80.cgi</code> 下载源码，<code>Source Code</code> 那部分就是了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160712.jpeg"> 然后，别急着打开，创建一个 <code>pom.xml</code> 在项目根目录（对，就是用 <code>maven</code> 插件来编译 <code>ant</code> 项目，比较猥琐，但是能用啊~）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apache-tomcat-8.5.51&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;name&gt;apache-tomcat-8.5.51&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;version&gt;8.0&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.7&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-apache-log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-commons-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml.rpc&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.xml.rpc-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;apache-tomcat-8.5.51&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;&#x2F;sourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;&#x2F;directory&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.5&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                    &lt;source&gt;$&#123;java.version&#125;&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;$&#123;java.version&#125;&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>这时候可以通过 <code>idea</code> 打开 <code>pom.xml</code> 文件来加载项目了。 依赖下载完成以后，别急，先到我们平常使用的 <code>tomcat</code> 中把 <code>conf</code> <code>lib</code> <code>logs</code> <code>webapps</code> <code>work</code> 这几个文件夹拷贝出来，在项目根目录创建一个名为 <code>catalina-home</code> 的文件夹，把上面拷贝的文件夹粘贴进去。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160737.jpeg"> </p>
<p>然后，我们先找到 <code>Boostrap</code> 类，他是 <code>Tomcat服务器</code> 启动的主程序类，<code>main</code> 方法就在里边，启动他，反正起不来，也可以在启动过程中直接终止。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160803.jpeg"> 然后我们在第一处点击启动类的配置，将以下的代码拷贝到 <code>2</code> 处，再启动就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home&#x3D;catalina-home</span><br><span class="line">-Dcatalina.base&#x3D;catalina-home</span><br><span class="line">-Djava.endorsed.dirs&#x3D;catalina-home&#x2F;endorsed</span><br><span class="line">-Djava.io.tmpdir&#x3D;catalina-home&#x2F;temp</span><br><span class="line">-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file&#x3D;catalina-home&#x2F;conf&#x2F;logging.properties</span><br></pre></td></tr></table></figure>

<p>然后重新启动，访问 <code>http://localhost:8080</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160833.jpeg"> </p>
<p>然后，我们先找到 <code>Boostrap</code> 类，他是 <code>Tomcat服务器</code> 启动的主程序类，<code>main</code> 方法就在里边，启动他，反正起不来，也可以在启动过程中直接终止。 </p>
<p>[toc]</p>
<h2 id="一-Tomcat服务器-5"><a href="#一-Tomcat服务器-5" class="headerlink" title="一.Tomcat服务器"></a>一.Tomcat服务器</h2><p>相信一直默默耕耘在 <code>JavaWEB</code> 的同学，肯定不会不认识 <code>Tomcat</code>。这可是世界一个著名的 <code>Web服务器</code> 之一，在之前动态 <code>Web服务</code> 还没有那么盛行的时候，<code>Tomcat</code> 依靠对 <code>Servlet</code> 的实现，让 <code>Web开发</code> 变得简单，<code>JSP诞生</code> 也是目前 <code>动态页面</code> 的始祖。 我不知道现在的同学还记不记得 <code>servlet</code> 的开发方法：</p>
<ol>
<li>创建自己的处理类，继承 <code>HttpServlet</code>，覆写 <code>doGet</code> <code>doPost</code> <code>doPut</code> 等不同 <code>HTTP Method</code> 的方法实现；</li>
<li>在 <code>WEB项目</code> 的 <code>web.xml</code> 文件中配置 <code>servlet</code> 的请求路径信息；</li>
<li>打包成 <code>war</code> 包，丢进 <code>Tomcat/webapp</code>；</li>
<li>启动 <code>Tomcat</code> 服务器，<code>Tomcat</code> 端口映射成功以后请求相对应的路径，即可访问到我们刚刚写的 <code>servlet</code> 中。</li>
</ol>
<p>而当我们需要配置 <code>Tomcat服务器</code> 的端口呀，以及一些其他信息的时候，这时候就需要到 <code>&#123;TomcatHome&#125;/conf/server.xml</code> 中去配置，不过搁以前，我都是找到我要改掉的参数，比如说我要把 <code>8080</code> 改成 <code>12345</code>，那就是先找到 <code>8080</code> 的字符，然后改成 <code>12345</code> ，赶紧保存，关掉编辑窗口，防止配置被我弄了其他的，导致整个服务器起不来。起不来就只好重新解压了hhh</p>
<h2 id="二-Tomcat架构-5"><a href="#二-Tomcat架构-5" class="headerlink" title="二.Tomcat架构"></a>二.Tomcat架构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160631.jpeg"></p>
<p>这个配置文件，用过 <code>Tomcat</code> 的应该都不会不认识，其实这里就已经能够很好的反应了 <code>Tomcat</code> 的架构了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160654.jpeg"> 所以，<code>Tomcat</code> 就有几个这样的元素：</p>
<ol>
<li><code>Server</code>：表示整个 <code>Tomcat容器</code>，这个容器可以配置多个 <code>Service</code> 呀，运行多个程序等等；</li>
<li><code>Service</code>：表示一个服务容器，可配置这个服务容器的 <code>Engine</code>、<code>Connector</code> 、<code>Host</code> 等等，在一个 <code>Server</code> 中允许配置多个 <code>Service</code>。</li>
<li><code>Connector</code>：负责解析数据，然后将数据交给 <code>Engine</code> 去处理，处理完成拿到 <code>响应数据</code> 再包装成对应的格式输出到客户端；</li>
<li><code>Engine</code>：处理引擎，代表一系列的数据转换链表，从多个 <code>Connector</code> 接收数据，处理数据输出出去；</li>
<li><code>Host</code>：代表一个域名，这个域名下可以存放多个 <code>Context</code>，也就是我们的 <code>war项目</code>，一个 <code>Service</code> 同样可以拥有多个 <code>Host</code>；</li>
<li><code>Context</code>：我们的 <code>Web上下文</code>，生命周期就跟 <code>Servlet</code> 项目一样了，存在于 <code>Host</code> 下，我们写的代码主要负责将接收的数据处理，处理完成返回 <code>响应数据</code> 出去即可。</li>
</ol>
<h2 id="三-导入IDEA-5"><a href="#三-导入IDEA-5" class="headerlink" title="三.导入IDEA"></a>三.导入IDEA</h2><p>不得不说，这玩意儿导入 <code>idea</code> 是真的麻烦，没有之一…. 首先，打开 <code>https://tomcat.apache.org/download-80.cgi</code> 下载源码，<code>Source Code</code> 那部分就是了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160712.jpeg"> 然后，别急着打开，创建一个 <code>pom.xml</code> 在项目根目录（对，就是用 <code>maven</code> 插件来编译 <code>ant</code> 项目，比较猥琐，但是能用啊~）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apache-tomcat-8.5.51&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;name&gt;apache-tomcat-8.5.51&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;version&gt;8.0&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.7&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-apache-log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-commons-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml.rpc&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.xml.rpc-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;apache-tomcat-8.5.51&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;&#x2F;sourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;&#x2F;directory&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.5&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                    &lt;source&gt;$&#123;java.version&#125;&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;$&#123;java.version&#125;&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>这时候可以通过 <code>idea</code> 打开 <code>pom.xml</code> 文件来加载项目了。 依赖下载完成以后，别急，先到我们平常使用的 <code>tomcat</code> 中把 <code>conf</code> <code>lib</code> <code>logs</code> <code>webapps</code> <code>work</code> 这几个文件夹拷贝出来，在项目根目录创建一个名为 <code>catalina-home</code> 的文件夹，把上面拷贝的文件夹粘贴进去。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160737.jpeg"> </p>
<p>然后，我们先找到 <code>Boostrap</code> 类，他是 <code>Tomcat服务器</code> 启动的主程序类，<code>main</code> 方法就在里边，启动他，反正起不来，也可以在启动过程中直接终止。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160803.jpeg"> 然后我们在第一处点击启动类的配置，将以下的代码拷贝到 <code>2</code> 处，再启动就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home&#x3D;catalina-home</span><br><span class="line">-Dcatalina.base&#x3D;catalina-home</span><br><span class="line">-Djava.endorsed.dirs&#x3D;catalina-home&#x2F;endorsed</span><br><span class="line">-Djava.io.tmpdir&#x3D;catalina-home&#x2F;temp</span><br><span class="line">-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file&#x3D;catalina-home&#x2F;conf&#x2F;logging.properties</span><br></pre></td></tr></table></figure>

<p>然后重新启动，访问 <code>http://localhost:8080</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160833.jpeg"> 然后我们在第一处点击启动类的配置，将以下的代码拷贝到 <code>2</code> 处，再启动就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home&#x3D;catalina-home</span><br><span class="line">-Dcatalina.base&#x3D;catalina-home</span><br><span class="line">-Djava.endorsed.dirs&#x3D;catalina-home&#x2F;endorsed</span><br><span class="line">-Djava.io.tmpdir&#x3D;catalina-home&#x2F;temp</span><br><span class="line">-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file&#x3D;catalina-home&#x2F;conf&#x2F;logging.properties</span><br></pre></td></tr></table></figure>

<p>然后重新启动，访问 <code>http://localhost:8080</code> 就可以了： </p>
<p>[toc]</p>
<h2 id="一-Tomcat服务器-6"><a href="#一-Tomcat服务器-6" class="headerlink" title="一.Tomcat服务器"></a>一.Tomcat服务器</h2><p>相信一直默默耕耘在 <code>JavaWEB</code> 的同学，肯定不会不认识 <code>Tomcat</code>。这可是世界一个著名的 <code>Web服务器</code> 之一，在之前动态 <code>Web服务</code> 还没有那么盛行的时候，<code>Tomcat</code> 依靠对 <code>Servlet</code> 的实现，让 <code>Web开发</code> 变得简单，<code>JSP诞生</code> 也是目前 <code>动态页面</code> 的始祖。 我不知道现在的同学还记不记得 <code>servlet</code> 的开发方法：</p>
<ol>
<li>创建自己的处理类，继承 <code>HttpServlet</code>，覆写 <code>doGet</code> <code>doPost</code> <code>doPut</code> 等不同 <code>HTTP Method</code> 的方法实现；</li>
<li>在 <code>WEB项目</code> 的 <code>web.xml</code> 文件中配置 <code>servlet</code> 的请求路径信息；</li>
<li>打包成 <code>war</code> 包，丢进 <code>Tomcat/webapp</code>；</li>
<li>启动 <code>Tomcat</code> 服务器，<code>Tomcat</code> 端口映射成功以后请求相对应的路径，即可访问到我们刚刚写的 <code>servlet</code> 中。</li>
</ol>
<p>而当我们需要配置 <code>Tomcat服务器</code> 的端口呀，以及一些其他信息的时候，这时候就需要到 <code>&#123;TomcatHome&#125;/conf/server.xml</code> 中去配置，不过搁以前，我都是找到我要改掉的参数，比如说我要把 <code>8080</code> 改成 <code>12345</code>，那就是先找到 <code>8080</code> 的字符，然后改成 <code>12345</code> ，赶紧保存，关掉编辑窗口，防止配置被我弄了其他的，导致整个服务器起不来。起不来就只好重新解压了hhh</p>
<h2 id="二-Tomcat架构-6"><a href="#二-Tomcat架构-6" class="headerlink" title="二.Tomcat架构"></a>二.Tomcat架构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160631.jpeg"></p>
<p>这个配置文件，用过 <code>Tomcat</code> 的应该都不会不认识，其实这里就已经能够很好的反应了 <code>Tomcat</code> 的架构了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160654.jpeg"> 所以，<code>Tomcat</code> 就有几个这样的元素：</p>
<ol>
<li><code>Server</code>：表示整个 <code>Tomcat容器</code>，这个容器可以配置多个 <code>Service</code> 呀，运行多个程序等等；</li>
<li><code>Service</code>：表示一个服务容器，可配置这个服务容器的 <code>Engine</code>、<code>Connector</code> 、<code>Host</code> 等等，在一个 <code>Server</code> 中允许配置多个 <code>Service</code>。</li>
<li><code>Connector</code>：负责解析数据，然后将数据交给 <code>Engine</code> 去处理，处理完成拿到 <code>响应数据</code> 再包装成对应的格式输出到客户端；</li>
<li><code>Engine</code>：处理引擎，代表一系列的数据转换链表，从多个 <code>Connector</code> 接收数据，处理数据输出出去；</li>
<li><code>Host</code>：代表一个域名，这个域名下可以存放多个 <code>Context</code>，也就是我们的 <code>war项目</code>，一个 <code>Service</code> 同样可以拥有多个 <code>Host</code>；</li>
<li><code>Context</code>：我们的 <code>Web上下文</code>，生命周期就跟 <code>Servlet</code> 项目一样了，存在于 <code>Host</code> 下，我们写的代码主要负责将接收的数据处理，处理完成返回 <code>响应数据</code> 出去即可。</li>
</ol>
<h2 id="三-导入IDEA-6"><a href="#三-导入IDEA-6" class="headerlink" title="三.导入IDEA"></a>三.导入IDEA</h2><p>不得不说，这玩意儿导入 <code>idea</code> 是真的麻烦，没有之一…. 首先，打开 <code>https://tomcat.apache.org/download-80.cgi</code> 下载源码，<code>Source Code</code> 那部分就是了： <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160712.jpeg"> 然后，别急着打开，创建一个 <code>pom.xml</code> 在项目根目录（对，就是用 <code>maven</code> 插件来编译 <code>ant</code> 项目，比较猥琐，但是能用啊~）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apache-tomcat-8.5.51&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;name&gt;apache-tomcat-8.5.51&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;version&gt;8.0&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.7&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-apache-log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ant&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ant-commons-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;wsdl4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;wsdl4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.6.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.xml.rpc&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.xml.rpc-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ecj&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.5.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;apache-tomcat-8.5.51&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;java&lt;&#x2F;sourceDirectory&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;java&lt;&#x2F;directory&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.5&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                    &lt;source&gt;$&#123;java.version&#125;&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;$&#123;java.version&#125;&lt;&#x2F;target&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>这时候可以通过 <code>idea</code> 打开 <code>pom.xml</code> 文件来加载项目了。 依赖下载完成以后，别急，先到我们平常使用的 <code>tomcat</code> 中把 <code>conf</code> <code>lib</code> <code>logs</code> <code>webapps</code> <code>work</code> 这几个文件夹拷贝出来，在项目根目录创建一个名为 <code>catalina-home</code> 的文件夹，把上面拷贝的文件夹粘贴进去。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160737.jpeg"> </p>
<p>然后，我们先找到 <code>Boostrap</code> 类，他是 <code>Tomcat服务器</code> 启动的主程序类，<code>main</code> 方法就在里边，启动他，反正起不来，也可以在启动过程中直接终止。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160803.jpeg"> 然后我们在第一处点击启动类的配置，将以下的代码拷贝到 <code>2</code> 处，再启动就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Dcatalina.home&#x3D;catalina-home</span><br><span class="line">-Dcatalina.base&#x3D;catalina-home</span><br><span class="line">-Djava.endorsed.dirs&#x3D;catalina-home&#x2F;endorsed</span><br><span class="line">-Djava.io.tmpdir&#x3D;catalina-home&#x2F;temp</span><br><span class="line">-Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager</span><br><span class="line">-Djava.util.logging.config.file&#x3D;catalina-home&#x2F;conf&#x2F;logging.properties</span><br></pre></td></tr></table></figure>

<p>然后重新启动，访问 <code>http://localhost:8080</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201109160833.jpeg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81%E4%B8%80-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81%E4%B8%80-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%94%81/" class="post-title-link" itemprop="url">【聊聊MySQL】十一.MySQL-InnoDB的数据库事务锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-01 09:24:47" itemprop="dateCreated datePublished" datetime="2020-04-01T09:24:47+08:00">2020-04-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 12:02:35" itemprop="dateModified" datetime="2020-11-10T12:02:35+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-InnoDB锁"><a href="#一-InnoDB锁" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写"><a href="#1-1-写写" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<h2 id="一-InnoDB锁-1"><a href="#一-InnoDB锁-1" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-1"><a href="#1-1-写写-1" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写"><a href="#1-2-读和写" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型"><a href="#二-锁的类型" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁"><a href="#2-1-行级锁" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁"><a href="#2-2-表级锁" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁"><a href="#2-3-特殊的锁–AUTO-INC锁" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁"><a href="#三-深入行级锁" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks"><a href="#3-1-Record-Locks" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁"><a href="#3-2-GAP锁" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks："><a href="#3-3-Next-Key-Locks：" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁"><a href="#3-4-Insert-Intention-Locks-插入意向锁" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁"><a href="#3-5-隐形的锁" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构"><a href="#四-锁结构" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线"><a href="#五-手动分割线" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁"><a href="#六-SELECT语句加锁" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读"><a href="#6-1-普通读" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读"><a href="#6-2-等值锁定读" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读"><a href="#6-3-范围锁定读" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读"><a href="#6-4-全表扫描读" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读"><a href="#6-5-等值锁定读" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读"><a href="#6-6-范围锁定读" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描"><a href="#6-7-全表扫描" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况"><a href="#七-INSERT的情况" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁"><a href="#七-死锁" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁"><a href="#7-1-普通资源锁" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁"><a href="#7-2-插入GAP锁" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁"><a href="#7-3-更新索引锁" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<h2 id="一-InnoDB锁-2"><a href="#一-InnoDB锁-2" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-2"><a href="#1-1-写写-2" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-1"><a href="#1-2-读和写-1" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-1"><a href="#二-锁的类型-1" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-1"><a href="#2-1-行级锁-1" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-1"><a href="#2-2-表级锁-1" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-1"><a href="#2-3-特殊的锁–AUTO-INC锁-1" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-1"><a href="#三-深入行级锁-1" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-1"><a href="#3-1-Record-Locks-1" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-1"><a href="#3-2-GAP锁-1" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-1"><a href="#3-3-Next-Key-Locks：-1" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-1"><a href="#3-4-Insert-Intention-Locks-插入意向锁-1" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-1"><a href="#3-5-隐形的锁-1" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-1"><a href="#四-锁结构-1" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-1"><a href="#五-手动分割线-1" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-1"><a href="#六-SELECT语句加锁-1" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-1"><a href="#6-1-普通读-1" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-1"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-1" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-1"><a href="#6-2-等值锁定读-1" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-1"><a href="#6-3-范围锁定读-1" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-1"><a href="#6-4-全表扫描读-1" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-1"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-1" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-1"><a href="#6-5-等值锁定读-1" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-1"><a href="#6-6-范围锁定读-1" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-1"><a href="#6-7-全表扫描-1" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-1"><a href="#七-INSERT的情况-1" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-1"><a href="#七-死锁-1" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-1"><a href="#7-1-普通资源锁-1" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-1"><a href="#7-2-插入GAP锁-1" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-1"><a href="#7-3-更新索引锁-1" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<h2 id="一-InnoDB锁-3"><a href="#一-InnoDB锁-3" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-3"><a href="#1-1-写写-3" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-2"><a href="#1-2-读和写-2" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-2"><a href="#二-锁的类型-2" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-2"><a href="#2-1-行级锁-2" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-2"><a href="#2-2-表级锁-2" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-2"><a href="#2-3-特殊的锁–AUTO-INC锁-2" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-2"><a href="#三-深入行级锁-2" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-2"><a href="#3-1-Record-Locks-2" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-2"><a href="#3-2-GAP锁-2" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-2"><a href="#3-3-Next-Key-Locks：-2" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-2"><a href="#3-4-Insert-Intention-Locks-插入意向锁-2" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-2"><a href="#3-5-隐形的锁-2" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-2"><a href="#四-锁结构-2" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-2"><a href="#五-手动分割线-2" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-2"><a href="#六-SELECT语句加锁-2" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-2"><a href="#6-1-普通读-2" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-2"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-2" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-2"><a href="#6-2-等值锁定读-2" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-2"><a href="#6-3-范围锁定读-2" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-2"><a href="#6-4-全表扫描读-2" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-2"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-2" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-2"><a href="#6-5-等值锁定读-2" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-2"><a href="#6-6-范围锁定读-2" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-2"><a href="#6-7-全表扫描-2" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-2"><a href="#七-INSERT的情况-2" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-2"><a href="#七-死锁-2" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-2"><a href="#7-1-普通资源锁-2" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-2"><a href="#7-2-插入GAP锁-2" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-2"><a href="#7-3-更新索引锁-2" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<h3 id="1-2-读和写-3"><a href="#1-2-读和写-3" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-3"><a href="#二-锁的类型-3" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-3"><a href="#2-1-行级锁-3" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-3"><a href="#2-2-表级锁-3" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-3"><a href="#2-3-特殊的锁–AUTO-INC锁-3" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-3"><a href="#三-深入行级锁-3" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-3"><a href="#3-1-Record-Locks-3" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<h2 id="一-InnoDB锁-4"><a href="#一-InnoDB锁-4" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-4"><a href="#1-1-写写-4" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-4"><a href="#1-2-读和写-4" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-4"><a href="#二-锁的类型-4" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-4"><a href="#2-1-行级锁-4" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-4"><a href="#2-2-表级锁-4" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-4"><a href="#2-3-特殊的锁–AUTO-INC锁-4" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-4"><a href="#三-深入行级锁-4" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-4"><a href="#3-1-Record-Locks-4" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-3"><a href="#3-2-GAP锁-3" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-3"><a href="#3-3-Next-Key-Locks：-3" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-3"><a href="#3-4-Insert-Intention-Locks-插入意向锁-3" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-3"><a href="#3-5-隐形的锁-3" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-3"><a href="#四-锁结构-3" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-3"><a href="#五-手动分割线-3" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-3"><a href="#六-SELECT语句加锁-3" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-3"><a href="#6-1-普通读-3" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-3"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-3" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-3"><a href="#6-2-等值锁定读-3" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-3"><a href="#6-3-范围锁定读-3" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-3"><a href="#6-4-全表扫描读-3" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-3"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-3" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-3"><a href="#6-5-等值锁定读-3" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-3"><a href="#6-6-范围锁定读-3" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-3"><a href="#6-7-全表扫描-3" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-3"><a href="#七-INSERT的情况-3" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-3"><a href="#七-死锁-3" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-3"><a href="#7-1-普通资源锁-3" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-3"><a href="#7-2-插入GAP锁-3" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-3"><a href="#7-3-更新索引锁-3" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>不过为了简单点：</p>
<h2 id="一-InnoDB锁-5"><a href="#一-InnoDB锁-5" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-5"><a href="#1-1-写写-5" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-5"><a href="#1-2-读和写-5" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-5"><a href="#二-锁的类型-5" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-5"><a href="#2-1-行级锁-5" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-5"><a href="#2-2-表级锁-5" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-5"><a href="#2-3-特殊的锁–AUTO-INC锁-5" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-5"><a href="#三-深入行级锁-5" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-5"><a href="#3-1-Record-Locks-5" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-4"><a href="#3-2-GAP锁-4" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-4"><a href="#3-3-Next-Key-Locks：-4" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-4"><a href="#3-4-Insert-Intention-Locks-插入意向锁-4" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-4"><a href="#3-5-隐形的锁-4" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-4"><a href="#四-锁结构-4" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-4"><a href="#五-手动分割线-4" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-4"><a href="#六-SELECT语句加锁-4" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-4"><a href="#6-1-普通读-4" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-4"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-4" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-4"><a href="#6-2-等值锁定读-4" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-4"><a href="#6-3-范围锁定读-4" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-4"><a href="#6-4-全表扫描读-4" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-4"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-4" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-4"><a href="#6-5-等值锁定读-4" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-4"><a href="#6-6-范围锁定读-4" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-4"><a href="#6-7-全表扫描-4" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-4"><a href="#七-INSERT的情况-4" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-4"><a href="#七-死锁-4" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-4"><a href="#7-1-普通资源锁-4" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-4"><a href="#7-2-插入GAP锁-4" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-4"><a href="#7-3-更新索引锁-4" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<h2 id="一-InnoDB锁-6"><a href="#一-InnoDB锁-6" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-6"><a href="#1-1-写写-6" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-6"><a href="#1-2-读和写-6" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-6"><a href="#二-锁的类型-6" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-6"><a href="#2-1-行级锁-6" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-6"><a href="#2-2-表级锁-6" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-6"><a href="#2-3-特殊的锁–AUTO-INC锁-6" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-6"><a href="#三-深入行级锁-6" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-6"><a href="#3-1-Record-Locks-6" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-5"><a href="#3-2-GAP锁-5" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-5"><a href="#3-3-Next-Key-Locks：-5" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-5"><a href="#3-4-Insert-Intention-Locks-插入意向锁-5" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-5"><a href="#3-5-隐形的锁-5" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-5"><a href="#四-锁结构-5" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-5"><a href="#五-手动分割线-5" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-5"><a href="#六-SELECT语句加锁-5" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-5"><a href="#6-1-普通读-5" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-5"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-5" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-5"><a href="#6-2-等值锁定读-5" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-5"><a href="#6-3-范围锁定读-5" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-5"><a href="#6-4-全表扫描读-5" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-5"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-5" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-5"><a href="#6-5-等值锁定读-5" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-5"><a href="#6-6-范围锁定读-5" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-5"><a href="#6-7-全表扫描-5" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-5"><a href="#七-INSERT的情况-5" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-5"><a href="#七-死锁-5" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-5"><a href="#7-1-普通资源锁-5" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-5"><a href="#7-2-插入GAP锁-5" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-5"><a href="#7-3-更新索引锁-5" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-6"><a href="#3-2-GAP锁-6" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<h2 id="一-InnoDB锁-7"><a href="#一-InnoDB锁-7" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-7"><a href="#1-1-写写-7" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-7"><a href="#1-2-读和写-7" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-7"><a href="#二-锁的类型-7" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-7"><a href="#2-1-行级锁-7" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-7"><a href="#2-2-表级锁-7" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-7"><a href="#2-3-特殊的锁–AUTO-INC锁-7" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-7"><a href="#三-深入行级锁-7" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-7"><a href="#3-1-Record-Locks-7" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-7"><a href="#3-2-GAP锁-7" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-6"><a href="#3-3-Next-Key-Locks：-6" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-6"><a href="#3-4-Insert-Intention-Locks-插入意向锁-6" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-6"><a href="#3-5-隐形的锁-6" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-6"><a href="#四-锁结构-6" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-6"><a href="#五-手动分割线-6" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-6"><a href="#六-SELECT语句加锁-6" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-6"><a href="#6-1-普通读-6" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-6"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-6" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-6"><a href="#6-2-等值锁定读-6" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-6"><a href="#6-3-范围锁定读-6" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-6"><a href="#6-4-全表扫描读-6" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-6"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-6" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-6"><a href="#6-5-等值锁定读-6" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-6"><a href="#6-6-范围锁定读-6" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-6"><a href="#6-7-全表扫描-6" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-6"><a href="#七-INSERT的情况-6" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-6"><a href="#七-死锁-6" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-6"><a href="#7-1-普通资源锁-6" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-6"><a href="#7-2-插入GAP锁-6" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-6"><a href="#7-3-更新索引锁-6" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-7"><a href="#3-3-Next-Key-Locks：-7" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-7"><a href="#3-4-Insert-Intention-Locks-插入意向锁-7" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<h2 id="一-InnoDB锁-8"><a href="#一-InnoDB锁-8" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-8"><a href="#1-1-写写-8" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-8"><a href="#1-2-读和写-8" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-8"><a href="#二-锁的类型-8" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-8"><a href="#2-1-行级锁-8" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-8"><a href="#2-2-表级锁-8" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-8"><a href="#2-3-特殊的锁–AUTO-INC锁-8" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-8"><a href="#三-深入行级锁-8" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-8"><a href="#3-1-Record-Locks-8" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-8"><a href="#3-2-GAP锁-8" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-8"><a href="#3-3-Next-Key-Locks：-8" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-8"><a href="#3-4-Insert-Intention-Locks-插入意向锁-8" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-7"><a href="#3-5-隐形的锁-7" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-7"><a href="#四-锁结构-7" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-7"><a href="#五-手动分割线-7" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-7"><a href="#六-SELECT语句加锁-7" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-7"><a href="#6-1-普通读-7" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-7"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-7" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-7"><a href="#6-2-等值锁定读-7" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-7"><a href="#6-3-范围锁定读-7" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-7"><a href="#6-4-全表扫描读-7" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-7"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-7" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-7"><a href="#6-5-等值锁定读-7" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-7"><a href="#6-6-范围锁定读-7" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-7"><a href="#6-7-全表扫描-7" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-7"><a href="#七-INSERT的情况-7" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-7"><a href="#七-死锁-7" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-7"><a href="#7-1-普通资源锁-7" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-7"><a href="#7-2-插入GAP锁-7" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-7"><a href="#7-3-更新索引锁-7" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-8"><a href="#3-5-隐形的锁-8" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-8"><a href="#四-锁结构-8" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><h2 id="一-InnoDB锁-9"><a href="#一-InnoDB锁-9" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-9"><a href="#1-1-写写-9" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-9"><a href="#1-2-读和写-9" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-9"><a href="#二-锁的类型-9" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-9"><a href="#2-1-行级锁-9" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-9"><a href="#2-2-表级锁-9" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-9"><a href="#2-3-特殊的锁–AUTO-INC锁-9" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-9"><a href="#三-深入行级锁-9" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-9"><a href="#3-1-Record-Locks-9" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-9"><a href="#3-2-GAP锁-9" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-9"><a href="#3-3-Next-Key-Locks：-9" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-9"><a href="#3-4-Insert-Intention-Locks-插入意向锁-9" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-9"><a href="#3-5-隐形的锁-9" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-9"><a href="#四-锁结构-9" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-8"><a href="#五-手动分割线-8" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-8"><a href="#六-SELECT语句加锁-8" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-8"><a href="#6-1-普通读-8" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-8"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-8" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-8"><a href="#6-2-等值锁定读-8" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-8"><a href="#6-3-范围锁定读-8" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-8"><a href="#6-4-全表扫描读-8" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-8"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-8" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-8"><a href="#6-5-等值锁定读-8" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-8"><a href="#6-6-范围锁定读-8" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-8"><a href="#6-7-全表扫描-8" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-8"><a href="#七-INSERT的情况-8" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-8"><a href="#七-死锁-8" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-8"><a href="#7-1-普通资源锁-8" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-8"><a href="#7-2-插入GAP锁-8" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-8"><a href="#7-3-更新索引锁-8" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-9"><a href="#五-手动分割线-9" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-9"><a href="#六-SELECT语句加锁-9" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-9"><a href="#6-1-普通读-9" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<h2 id="一-InnoDB锁-10"><a href="#一-InnoDB锁-10" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-10"><a href="#1-1-写写-10" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-10"><a href="#1-2-读和写-10" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-10"><a href="#二-锁的类型-10" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-10"><a href="#2-1-行级锁-10" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-10"><a href="#2-2-表级锁-10" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-10"><a href="#2-3-特殊的锁–AUTO-INC锁-10" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-10"><a href="#三-深入行级锁-10" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-10"><a href="#3-1-Record-Locks-10" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-10"><a href="#3-2-GAP锁-10" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-10"><a href="#3-3-Next-Key-Locks：-10" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-10"><a href="#3-4-Insert-Intention-Locks-插入意向锁-10" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-10"><a href="#3-5-隐形的锁-10" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-10"><a href="#四-锁结构-10" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-10"><a href="#五-手动分割线-10" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-10"><a href="#六-SELECT语句加锁-10" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-10"><a href="#6-1-普通读-10" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-9"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-9" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-9"><a href="#6-2-等值锁定读-9" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-9"><a href="#6-3-范围锁定读-9" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-9"><a href="#6-4-全表扫描读-9" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-9"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-9" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-9"><a href="#6-5-等值锁定读-9" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-9"><a href="#6-6-范围锁定读-9" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-9"><a href="#6-7-全表扫描-9" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-9"><a href="#七-INSERT的情况-9" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-9"><a href="#七-死锁-9" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-9"><a href="#7-1-普通资源锁-9" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-9"><a href="#7-2-插入GAP锁-9" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-9"><a href="#7-3-更新索引锁-9" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-10"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-10" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-10"><a href="#6-2-等值锁定读-10" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<h2 id="一-InnoDB锁-11"><a href="#一-InnoDB锁-11" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-11"><a href="#1-1-写写-11" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-11"><a href="#1-2-读和写-11" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-11"><a href="#二-锁的类型-11" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-11"><a href="#2-1-行级锁-11" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-11"><a href="#2-2-表级锁-11" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-11"><a href="#2-3-特殊的锁–AUTO-INC锁-11" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-11"><a href="#三-深入行级锁-11" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-11"><a href="#3-1-Record-Locks-11" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-11"><a href="#3-2-GAP锁-11" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-11"><a href="#3-3-Next-Key-Locks：-11" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-11"><a href="#3-4-Insert-Intention-Locks-插入意向锁-11" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-11"><a href="#3-5-隐形的锁-11" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-11"><a href="#四-锁结构-11" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-11"><a href="#五-手动分割线-11" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-11"><a href="#六-SELECT语句加锁-11" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-11"><a href="#6-1-普通读-11" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-11"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-11" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-11"><a href="#6-2-等值锁定读-11" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-10"><a href="#6-3-范围锁定读-10" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-10"><a href="#6-4-全表扫描读-10" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-10"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-10" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-10"><a href="#6-5-等值锁定读-10" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-10"><a href="#6-6-范围锁定读-10" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-10"><a href="#6-7-全表扫描-10" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-10"><a href="#七-INSERT的情况-10" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-10"><a href="#七-死锁-10" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-10"><a href="#7-1-普通资源锁-10" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-10"><a href="#7-2-插入GAP锁-10" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-10"><a href="#7-3-更新索引锁-10" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>


<h2 id="一-InnoDB锁-12"><a href="#一-InnoDB锁-12" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-12"><a href="#1-1-写写-12" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-12"><a href="#1-2-读和写-12" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-12"><a href="#二-锁的类型-12" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-12"><a href="#2-1-行级锁-12" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-12"><a href="#2-2-表级锁-12" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-12"><a href="#2-3-特殊的锁–AUTO-INC锁-12" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-12"><a href="#三-深入行级锁-12" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-12"><a href="#3-1-Record-Locks-12" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-12"><a href="#3-2-GAP锁-12" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-12"><a href="#3-3-Next-Key-Locks：-12" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-12"><a href="#3-4-Insert-Intention-Locks-插入意向锁-12" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-12"><a href="#3-5-隐形的锁-12" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-12"><a href="#四-锁结构-12" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-12"><a href="#五-手动分割线-12" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-12"><a href="#六-SELECT语句加锁-12" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-12"><a href="#6-1-普通读-12" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-12"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-12" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-12"><a href="#6-2-等值锁定读-12" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-11"><a href="#6-3-范围锁定读-11" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-11"><a href="#6-4-全表扫描读-11" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-11"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-11" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-11"><a href="#6-5-等值锁定读-11" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-11"><a href="#6-6-范围锁定读-11" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-11"><a href="#6-7-全表扫描-11" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-11"><a href="#七-INSERT的情况-11" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-11"><a href="#七-死锁-11" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-11"><a href="#7-1-普通资源锁-11" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-11"><a href="#7-2-插入GAP锁-11" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-11"><a href="#7-3-更新索引锁-11" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<h2 id="一-InnoDB锁-13"><a href="#一-InnoDB锁-13" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-13"><a href="#1-1-写写-13" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-13"><a href="#1-2-读和写-13" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-13"><a href="#二-锁的类型-13" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-13"><a href="#2-1-行级锁-13" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-13"><a href="#2-2-表级锁-13" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-13"><a href="#2-3-特殊的锁–AUTO-INC锁-13" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-13"><a href="#三-深入行级锁-13" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-13"><a href="#3-1-Record-Locks-13" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-13"><a href="#3-2-GAP锁-13" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-13"><a href="#3-3-Next-Key-Locks：-13" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-13"><a href="#3-4-Insert-Intention-Locks-插入意向锁-13" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-13"><a href="#3-5-隐形的锁-13" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-13"><a href="#四-锁结构-13" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-13"><a href="#五-手动分割线-13" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-13"><a href="#六-SELECT语句加锁-13" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-13"><a href="#6-1-普通读-13" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-13"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-13" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-13"><a href="#6-2-等值锁定读-13" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-12"><a href="#6-3-范围锁定读-12" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-12"><a href="#6-4-全表扫描读-12" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-12"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-12" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-12"><a href="#6-5-等值锁定读-12" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-12"><a href="#6-6-范围锁定读-12" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-12"><a href="#6-7-全表扫描-12" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-12"><a href="#七-INSERT的情况-12" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-12"><a href="#七-死锁-12" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-12"><a href="#7-1-普通资源锁-12" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-12"><a href="#7-2-插入GAP锁-12" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-12"><a href="#7-3-更新索引锁-12" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<h2 id="一-InnoDB锁-14"><a href="#一-InnoDB锁-14" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-14"><a href="#1-1-写写-14" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-14"><a href="#1-2-读和写-14" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-14"><a href="#二-锁的类型-14" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-14"><a href="#2-1-行级锁-14" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-14"><a href="#2-2-表级锁-14" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-14"><a href="#2-3-特殊的锁–AUTO-INC锁-14" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-14"><a href="#三-深入行级锁-14" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-14"><a href="#3-1-Record-Locks-14" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-14"><a href="#3-2-GAP锁-14" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-14"><a href="#3-3-Next-Key-Locks：-14" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-14"><a href="#3-4-Insert-Intention-Locks-插入意向锁-14" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-14"><a href="#3-5-隐形的锁-14" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-14"><a href="#四-锁结构-14" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-14"><a href="#五-手动分割线-14" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-14"><a href="#六-SELECT语句加锁-14" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-14"><a href="#6-1-普通读-14" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-14"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-14" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-14"><a href="#6-2-等值锁定读-14" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-13"><a href="#6-3-范围锁定读-13" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-13"><a href="#6-4-全表扫描读-13" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-13"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-13" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-13"><a href="#6-5-等值锁定读-13" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-13"><a href="#6-6-范围锁定读-13" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-13"><a href="#6-7-全表扫描-13" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-13"><a href="#七-INSERT的情况-13" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-13"><a href="#七-死锁-13" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-13"><a href="#7-1-普通资源锁-13" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-13"><a href="#7-2-插入GAP锁-13" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-13"><a href="#7-3-更新索引锁-13" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-14"><a href="#6-3-范围锁定读-14" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-14"><a href="#6-4-全表扫描读-14" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-14"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-14" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-14"><a href="#6-5-等值锁定读-14" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<h2 id="一-InnoDB锁-15"><a href="#一-InnoDB锁-15" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-15"><a href="#1-1-写写-15" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-15"><a href="#1-2-读和写-15" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-15"><a href="#二-锁的类型-15" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-15"><a href="#2-1-行级锁-15" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-15"><a href="#2-2-表级锁-15" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-15"><a href="#2-3-特殊的锁–AUTO-INC锁-15" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-15"><a href="#三-深入行级锁-15" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-15"><a href="#3-1-Record-Locks-15" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-15"><a href="#3-2-GAP锁-15" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-15"><a href="#3-3-Next-Key-Locks：-15" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-15"><a href="#3-4-Insert-Intention-Locks-插入意向锁-15" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-15"><a href="#3-5-隐形的锁-15" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-15"><a href="#四-锁结构-15" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-15"><a href="#五-手动分割线-15" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-15"><a href="#六-SELECT语句加锁-15" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-15"><a href="#6-1-普通读-15" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-15"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-15" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-15"><a href="#6-2-等值锁定读-15" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-15"><a href="#6-3-范围锁定读-15" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-15"><a href="#6-4-全表扫描读-15" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-15"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-15" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-15"><a href="#6-5-等值锁定读-15" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-14"><a href="#6-6-范围锁定读-14" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-14"><a href="#6-7-全表扫描-14" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-14"><a href="#七-INSERT的情况-14" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-14"><a href="#七-死锁-14" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-14"><a href="#7-1-普通资源锁-14" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-14"><a href="#7-2-插入GAP锁-14" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-14"><a href="#7-3-更新索引锁-14" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<h2 id="一-InnoDB锁-16"><a href="#一-InnoDB锁-16" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-16"><a href="#1-1-写写-16" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-16"><a href="#1-2-读和写-16" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-16"><a href="#二-锁的类型-16" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-16"><a href="#2-1-行级锁-16" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-16"><a href="#2-2-表级锁-16" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-16"><a href="#2-3-特殊的锁–AUTO-INC锁-16" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-16"><a href="#三-深入行级锁-16" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-16"><a href="#3-1-Record-Locks-16" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-16"><a href="#3-2-GAP锁-16" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-16"><a href="#3-3-Next-Key-Locks：-16" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-16"><a href="#3-4-Insert-Intention-Locks-插入意向锁-16" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-16"><a href="#3-5-隐形的锁-16" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-16"><a href="#四-锁结构-16" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-16"><a href="#五-手动分割线-16" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-16"><a href="#六-SELECT语句加锁-16" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-16"><a href="#6-1-普通读-16" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-16"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-16" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-16"><a href="#6-2-等值锁定读-16" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-16"><a href="#6-3-范围锁定读-16" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-16"><a href="#6-4-全表扫描读-16" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-16"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-16" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-16"><a href="#6-5-等值锁定读-16" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-15"><a href="#6-6-范围锁定读-15" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-15"><a href="#6-7-全表扫描-15" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-15"><a href="#七-INSERT的情况-15" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-15"><a href="#七-死锁-15" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-15"><a href="#7-1-普通资源锁-15" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-15"><a href="#7-2-插入GAP锁-15" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-15"><a href="#7-3-更新索引锁-15" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-16"><a href="#6-6-范围锁定读-16" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<h2 id="一-InnoDB锁-17"><a href="#一-InnoDB锁-17" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-17"><a href="#1-1-写写-17" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-17"><a href="#1-2-读和写-17" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-17"><a href="#二-锁的类型-17" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-17"><a href="#2-1-行级锁-17" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-17"><a href="#2-2-表级锁-17" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-17"><a href="#2-3-特殊的锁–AUTO-INC锁-17" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-17"><a href="#三-深入行级锁-17" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-17"><a href="#3-1-Record-Locks-17" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-17"><a href="#3-2-GAP锁-17" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-17"><a href="#3-3-Next-Key-Locks：-17" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-17"><a href="#3-4-Insert-Intention-Locks-插入意向锁-17" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-17"><a href="#3-5-隐形的锁-17" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-17"><a href="#四-锁结构-17" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-17"><a href="#五-手动分割线-17" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-17"><a href="#六-SELECT语句加锁-17" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-17"><a href="#6-1-普通读-17" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-17"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-17" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-17"><a href="#6-2-等值锁定读-17" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-17"><a href="#6-3-范围锁定读-17" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-17"><a href="#6-4-全表扫描读-17" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-17"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-17" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-17"><a href="#6-5-等值锁定读-17" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-17"><a href="#6-6-范围锁定读-17" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-16"><a href="#6-7-全表扫描-16" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-16"><a href="#七-INSERT的情况-16" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-16"><a href="#七-死锁-16" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-16"><a href="#7-1-普通资源锁-16" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-16"><a href="#7-2-插入GAP锁-16" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-16"><a href="#7-3-更新索引锁-16" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-17"><a href="#6-7-全表扫描-17" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-17"><a href="#七-INSERT的情况-17" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<h2 id="一-InnoDB锁-18"><a href="#一-InnoDB锁-18" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-18"><a href="#1-1-写写-18" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-18"><a href="#1-2-读和写-18" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-18"><a href="#二-锁的类型-18" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-18"><a href="#2-1-行级锁-18" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-18"><a href="#2-2-表级锁-18" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-18"><a href="#2-3-特殊的锁–AUTO-INC锁-18" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-18"><a href="#三-深入行级锁-18" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-18"><a href="#3-1-Record-Locks-18" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-18"><a href="#3-2-GAP锁-18" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-18"><a href="#3-3-Next-Key-Locks：-18" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-18"><a href="#3-4-Insert-Intention-Locks-插入意向锁-18" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-18"><a href="#3-5-隐形的锁-18" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-18"><a href="#四-锁结构-18" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-18"><a href="#五-手动分割线-18" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-18"><a href="#六-SELECT语句加锁-18" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-18"><a href="#6-1-普通读-18" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-18"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-18" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-18"><a href="#6-2-等值锁定读-18" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-18"><a href="#6-3-范围锁定读-18" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-18"><a href="#6-4-全表扫描读-18" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-18"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-18" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-18"><a href="#6-5-等值锁定读-18" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-18"><a href="#6-6-范围锁定读-18" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-18"><a href="#6-7-全表扫描-18" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-18"><a href="#七-INSERT的情况-18" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-17"><a href="#七-死锁-17" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-17"><a href="#7-1-普通资源锁-17" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-17"><a href="#7-2-插入GAP锁-17" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-17"><a href="#7-3-更新索引锁-17" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-18"><a href="#七-死锁-18" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-18"><a href="#7-1-普通资源锁-18" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><h2 id="一-InnoDB锁-19"><a href="#一-InnoDB锁-19" class="headerlink" title="一.InnoDB锁"></a>一.InnoDB锁</h2><p>并发的世界里，就离不开锁这个东西，即使会降低一些执行效率，但是该锁住的还是得锁住。<code>MySQL</code> 也一样，当两个 <code>会话</code> 同时修改一条数据的时候，就需要通过锁机制来保证修改后数据的正确性。锁听起来很牛逼，但是简单的概括一下也就是对某个资源（一个变量）的修改操作撸成一条队列来执行，由于执行之前需要判断一些锁的信息，所以执行效率肯定是要低一点的。</p>
<p>不过由于学 <code>Java</code> 的，这个鬼东西也可以结合起来一起说说，反正原理都一样。</p>
<p>通常来说，对一个资源的操作会出现以下几个情况：</p>
<ol>
<li><code>读读</code>：不会对资源产生副作用，所以不需要加锁；</li>
<li><code>写写</code>：两个线程想要动手修改同一个资源，那不用说肯定先到先写；</li>
<li><code>读写</code>：一个读一个写的线程，那也是谁先到达现场，谁先锁定。</li>
</ol>
<h3 id="1-1-写写-19"><a href="#1-1-写写-19" class="headerlink" title="1.1 写写"></a>1.1 写写</h3><p>假设两个线程都要对同一个记录进行操作，那么就会产生锁的竞争了：</p>
<p>首先 <code>线程A</code> 先到达数据行现场：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115836.jpeg"></p>
<p>接下来，<code>线程B</code> 说我也要更新：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115837.jpeg"></p>
<p>但是发现 <code>线程A</code> 在做操作，这时候只能干巴巴的先等着，不过为了性能，会把线程给睡眠了（类似于 <code>await()</code>）</p>
<p>然后，<code>线程A</code> 做完了，<del>提起裤子准备要走</del>，这时候就跟 <code>线程B</code> 说，轮到你了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115838.jpeg"></p>
<h3 id="1-2-读和写-19"><a href="#1-2-读和写-19" class="headerlink" title="1.2 读和写"></a>1.2 读和写</h3><p>一个 <code>读线程</code> 和一个 <code>写线程</code>，为了防止 <code>脏读</code> <code>不可重复读</code> 等一些事务可能出现的问题，我们前边说过 <code>InnoDB</code> 使用 <code>MVCC</code> 来控制读取的东西，而另外一边，<code>写线程</code> 可以继续写的操作。</p>
<p>但是，<code>业务经理</code> 说，我就要读取的事务完成，才可以进行操作（例如银行这种比较高要求一致性的系统），那么 <code>读</code> 就需要用到锁了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; // 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;// 共享锁</span><br></pre></td></tr></table></figure>

<p>上面这句执行后，<code>事务的执行模型</code> 就会变成上面 <code>写写</code> 一样的形式了。</p>
<p>很多时候，使用 <code>MVCC</code> 更加的高效，不过如果业务是很高度准确性要求的话，就需要用到这种方式。</p>
<h2 id="二-锁的类型-19"><a href="#二-锁的类型-19" class="headerlink" title="二.锁的类型"></a>二.锁的类型</h2><h3 id="2-1-行级锁-19"><a href="#2-1-行级锁-19" class="headerlink" title="2.1 行级锁"></a>2.1 行级锁</h3><p>这个和 <code>ReentrantReadWriteLock</code> 可以相关联理解：</p>
<ol>
<li><code>排他锁</code>：<code>Shared Locks</code>，一般简称 <code>S锁</code> ，两个操作的排他锁不会阻塞，但是跟下面的 <code>排他锁</code> 使用的话，就会阻塞，等下说；</li>
<li><code>独占锁</code>：<code>Exclusive Locks</code>，一般简称 <code>X锁</code>，如果发生修改锁定的时候，使用的锁都是 <code>排他锁</code>。</li>
</ol>
<p>那么 <code>排他锁</code> 就是 <code>ReentrantReadWriteLock</code> 的 <code>readLock()</code>，而 <code>排他锁</code> 就是 <code>writeLock()</code> 了。</p>
<p>画个表看看兼容程度：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p>那么只需要记住一个 <code>S锁和S锁是兼容的</code> 就可以了。</p>
<h3 id="2-2-表级锁-19"><a href="#2-2-表级锁-19" class="headerlink" title="2.2 表级锁"></a>2.2 表级锁</h3><p>表级锁也有 <code>S锁</code> 和 <code>X锁</code>，兼容程度也和 <code>行级锁</code> 一致。不过如果一张表有 <code>锁</code>，此时如果需要对表中的某一行做操作，需要判断 <code>表级锁</code> 和将要加的 <code>行级锁</code> 是否兼容，不兼容就需要阻塞。反过来如果想要对表加 <code>表级锁</code>，同样也需要此时表中数据的 <code>行级锁</code> 和 <code>表级锁</code> 是否兼容。</p>
<p>所以有这样一个需求，当我需要对一张表加锁的时候，怎么知道这张表是否有 <code>行级锁</code>？简单想想的话，就是遍历这张表的所有记录了，但是我们生产一张表动不动就上千万个数据，遍历效率实在太低了，而且还要考虑遍历的时候需要对其他事务进行阻塞。所以，<code>InnoDB</code> 为了解决这个问题，又有一种锁 <code>意向锁（Intention Locks）</code>：</p>
<p>可以理解成一个标记，当需要对表中某条记录加 <code>S锁</code> 时，会先在 <code>表</code> 上挂一个 <code>Intention Shared Locks</code>，简称 <code>IS锁</code>，而当需要对表中某条记录加 <code>X锁</code> 时，则相对应的在 <code>表</code> 上挂一个 <code>Intention Exclusive Lock</code>，简称 <code>IX锁</code>。</p>
<p>而这两个锁，并没有相对应的 <code>锁逻辑</code>，只是为了快速判断一个 <code>数据表</code> 中，是否有 <code>S锁</code> 或者 <code>X锁</code> 记录而已，规避需要加 <code>表锁</code> 的时候，不得不循环遍历所有数据的低效。所以 <code>表级锁</code> 的兼容性如下：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center"><code>不兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
<td align="center"><code>兼容</code></td>
</tr>
</tbody></table>
<p> 那什么时候会发生表级锁，当然就是修改 <code>数据表</code> 结构的时候啦，或者在数据库崩溃的时候，恢复数据的时候会用一下 <code>表级锁</code>。</p>
<h3 id="2-3-特殊的锁–AUTO-INC锁-19"><a href="#2-3-特殊的锁–AUTO-INC锁-19" class="headerlink" title="2.3 特殊的锁–AUTO-INC锁"></a>2.3 特殊的锁–AUTO-INC锁</h3><p>当我们一个表的主键设置是 <code>数据库自增</code> 的时候，插入一条数据就需要为 <code>自增变量</code> 加锁，这个就是 <code>AUTO-INC锁</code>。</p>
<p>而 <code>AUTO-INC锁</code> 也有不同的类型，可以通过 <code>innodb_autoinc_lock_mode</code> 来控制不同的类型：</p>
<ol>
<li><code>innodb_autoinc_lock_mode = 0</code>：执行插入语句的时候，在表级加一个 <code>AUTO-INC锁</code>，为插入的数据分配递增的值，语句执行完毕即释放 <code>AUTO-INC锁</code>，如果插入语句遇到其他事务在使用这个锁的时候，就需要阻塞等待所释放；</li>
<li><code>innodb_autoinc_lock_mode = 1</code>：<code>1</code> 和 <code>3</code> 两种方式混合使用，当确定插入数据的数量的时候使用 <code>AUTO-INC锁</code>，不确定插入数量的时候（比如 <code>INSERT...SELECT</code> 等）使用轻量级锁。</li>
<li><code>innodb_autoinc_lock_mode = 2</code>：使用一个轻量级的锁，生成本次插入需要用到的所有值之后，释放锁，并不需要等待 <code>插入语句</code> 执行完成才释放。</li>
</ol>
<h2 id="三-深入行级锁-19"><a href="#三-深入行级锁-19" class="headerlink" title="三.深入行级锁"></a>三.深入行级锁</h2><p>那么行级锁只是简单的对一个数据行加锁吗，肯定不是的，因为需求总是那么多变，可能需要对范围加锁，可能需要对新插入的数据加锁等等的需求，所以行级锁下，又有一些分类：</p>
<h3 id="3-1-Record-Locks-19"><a href="#3-1-Record-Locks-19" class="headerlink" title="3.1 Record Locks"></a>3.1 Record Locks</h3><p>这个 <code>Record Locks</code>，就是真正意义上的行级锁了，意为锁住一条真正的数据。我们知道，<code>InnoDB</code> 把数据存储在一颗 <code>B+</code> 树上，称为 <code>聚簇索引</code>， <code>Record Locks</code> 就是加载 <code>聚簇索引</code> 上记录的一个锁：</p>
<ul>
<li>当一条记录有 <code>S锁</code>，那么其他事务可以继续获取 <code>S锁</code>，而不可以获取 <code>X锁</code>；</li>
<li>当一条记录有 <code>X锁</code>，其他事务无论想获取什么类型的 <code>锁</code>，都需要阻塞等待。</li>
</ul>
<p>我们知道一个数据页长这样子的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115839.jpeg"></p>
<p>不过为了简单点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115840.jpeg"></p>
<p>那比如说，我现在要操作 <code>prod_id=22</code> 的库存，需要加上一个 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115841.jpeg"></p>
<p>那么其他加锁的操作都会被阻塞。</p>
<h3 id="3-2-GAP锁-19"><a href="#3-2-GAP锁-19" class="headerlink" title="3.2 GAP锁"></a>3.2 GAP锁</h3><p><code>GAP锁</code> 是为了防止 <code>幻影记录</code> 而诞生的，我们知道 <code>REPEATABLE READ</code> 级别的隔离下，幻读是可以通过 <code>MVCC</code> 解决的，但是如果需要通过加锁的方式解决，就有个问题，不知道加哪个记录。</p>
<p>所以，我们就需要对数据页中的某个数据（边界）加上一个 <code>GAP锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115842.jpeg"></p>
<p>在这里，比方说查询库存小于 <code>200</code> 的 <code>prod_id</code> 集合，使用加锁的形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> quantity &lt; <span class="number">200</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个 <code>GAP锁</code> 就会被加在 <code>stock_id = 3</code> 的前面，这时候如果插入一条数据 <code>INSERT INTO stock_info values(null, 55, 200)</code>；那么这条插入语句将会被阻塞。</p>
<p>那如果想要锁住最小值或者最大值怎么办，别忘了一个数据页中有两个特殊的列：<code>Infimum</code> 和 <code>Supremum</code>。把这两个锁了是不是就完事了。</p>
<h3 id="3-3-Next-Key-Locks：-19"><a href="#3-3-Next-Key-Locks：-19" class="headerlink" title="3.3 Next-Key Locks："></a>3.3 Next-Key Locks：</h3><p>如果想要锁住记录并且也锁住间隙怎么办，就可以使用 <code>Next-Key Locks</code>。他是 <code>Record Locks</code> + <code>GAP锁</code> 的合体，锁住的那条记录即不允许在他前后插入数据，也不允许修改这条 <code>数据行</code> 的数据。</p>
<h3 id="3-4-Insert-Intention-Locks-插入意向锁-19"><a href="#3-4-Insert-Intention-Locks-插入意向锁-19" class="headerlink" title="3.4 Insert Intention Locks 插入意向锁"></a>3.4 Insert Intention Locks 插入意向锁</h3><p>那么在插入数据的时候，需要判断插入的位置是不是被 <code>GAP锁</code> 锁住了，如果有的话就需要阻塞当前事务，等待 <code>GAP锁</code> 的释放。那么 <code>InnoDB</code> 的大佬也规定，如果插入数据的时候进入阻塞状态，也需要生成一个 <code>Insert Intention Locks 插入意向锁</code> 挂在这条记录上边，表明在这个间隙目前有数据想要插入。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<blockquote>
<p>注意：意向锁并不会因为前边有个 GAP 锁就等待，而是直接锁住，再进入等待。事实上他也不介意其他锁进来。</p>
</blockquote>
<h3 id="3-5-隐形的锁-19"><a href="#3-5-隐形的锁-19" class="headerlink" title="3.5 隐形的锁"></a>3.5 隐形的锁</h3><p>那么如果一个事务首先插入一条数据，然后另外一个事务马上用到 <code>SELECT ... FOR UPDATE</code> 或者 <code>SELECT ... LOCK IN SHARE MODE</code> 想要读取这条数据咋办，亦或者想要修改这条数据，如果这两种情况都允许的话，那么就会出现 <code>脏读</code> 和 <code>脏写</code> 的问题了。</p>
<p>所以一个隐形的锁横空出世：<code>trx_id</code>（掀桌子）：</p>
<ul>
<li>对于 <code>聚簇索引</code>，该记录的 <code>trx_id</code> 表示当前 <code>事务ID</code>，如果当前事务想要给这一行加锁的时候，就会查看这个 <code>trx_id</code> 的事务在当前是否是活跃状态，如果是的话，就舔狗般的帮他创建一个锁（锁有个属性是 <code>isWaiting=false</code>）然后自己创建一个 <code>isWaiting=true</code> 的锁，然后进入等待状态；</li>
<li>对于 <code>非聚簇索引</code> 来说，因为没有 <code>trx_id</code> 隐藏列，不过 <code>非聚簇索引数据页</code> 的 <code>PageHeader</code> 有个 <code>PAGE_MAX_TRX_ID</code> 列，表示对这个页面做过改动的最大 <code>事务ID</code>，如果这个值小于当前活跃的 <code>事务ID</code>，那说明对这个页面修改的事务都已经提交了，否则就需要定位到记录，回表重复上面一步的流程。</li>
</ul>
<h2 id="四-锁结构-19"><a href="#四-锁结构-19" class="headerlink" title="四.锁结构"></a>四.锁结构</h2><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115844.jpeg"></p>
<p>加锁，那肯定是有事务对 <code>数据行</code> 发生了修改，所以就需要第一个属性记录必要的锁信息。</p>
<p>然后数据行都在 <code>索引树</code> 中，所以我们需要一些索引信息</p>
<p>第三个，<code>表锁</code> 就需要记录 <code>数据表</code> 的一些信息，而 <code>行锁</code> 就需要记录 <code>数据行</code> 的信息</p>
<p><code>type_mode</code> 则是记录锁的类型，比如 <code>IS锁</code> 或者 <code>IX锁</code> 啊等等信息，也记录了是 <code>表锁</code> 还是 <code>行锁</code>，而上面也说了 <code>GAP锁</code> 等类型，也记录在这里（注意，和 <code>IS锁</code> 的类型记录不在同一个地方）这个字段是由一堆 <code>比特位</code> 组成的，而这个锁是否在等待 <code>is_waiting</code> 也记录在这里（一般第一个加上的锁不需要等待，所以这个值是 <code>false</code>，后面进来的锁都是 <code>true</code>）</p>
<p>而类型的最后一个 <code>比特位</code> 则存储了数据的信息，包括 <code>最大值</code> 或者 <code>最小值</code>。</p>
<p>摊开说有点复杂也不需要记住，只要记住锁记录了上面的信息就可以了，所以我偷懒不说，等需要用到的时候再聊。</p>
<h2 id="五-手动分割线-19"><a href="#五-手动分割线-19" class="headerlink" title="五.手动分割线"></a>五.手动分割线</h2><p>上面说的都是 <code>数据库锁</code> 的一些结构，下面就要说 <code>SQL</code> 的加锁情况了。</p>
<h2 id="六-SELECT语句加锁-19"><a href="#六-SELECT语句加锁-19" class="headerlink" title="六.SELECT语句加锁"></a>六.SELECT语句加锁</h2><p>前面隔离级别和 <code>MVCC</code> 的时候也说过 <code>SELECT</code> 在不同的隔离级别下查询出来以及发生的问题是不同的：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>那么咋整呢，可以使用 <code>MVCC</code> 的方式来避免这些问题，但是为什么使用 <code>MVCC</code> 是因为它能够满足大部分的业务需求，并且执行效率要比 <code>加锁</code> 高很多，所以很多时候，我们 <code>SQL</code> 执行的时候使用的避免问题的方式都是 <code>MVCC</code>。</p>
<p>但是有时候我们的业务背景要求，一点错误或者小插曲都不能出现，这时候就需要对我们读取或者操作的数据进行 <code>加锁</code> 执行了。</p>
<p>而 <code>加锁</code> <code>加什么锁</code> 则不是必然的，因为 <code>加锁</code> 这个操作涉及到了很多客观元素，比方说 <code>隔离级别</code> 啊，<code>使用什么索引啊</code> <code>查询条件</code> 等等。</p>
<p>那首先，建个 <code>产品库存表stock_info</code> 来做示例吧：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一个库存表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stock_info (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">BIGINT</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">	prod_id <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	quantity <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> stock_info <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 建立产品ID的索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> stock_info_prod_idx <span class="keyword">ON</span> stock_info(prod_id);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stock_info <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="number">11</span>, <span class="number">32</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">22</span>, <span class="number">65</span>), (<span class="literal">NULL</span>, <span class="number">33</span>, <span class="number">213</span>), (<span class="literal">NULL</span>, <span class="number">44</span>, <span class="number">77</span>),</span><br><span class="line">(<span class="literal">NULL</span>, <span class="number">55</span>, <span class="number">20</span>), (<span class="literal">NULL</span>, <span class="number">66</span>, <span class="number">993</span>), (<span class="literal">NULL</span>, <span class="number">77</span>, <span class="number">142</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM stock_info;</span></span><br><span class="line">+----+---------+----------+</span><br><span class="line">| id | prod_id | quantity |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">|  1 |      11 |       32 |</span><br><span class="line">|  2 |      22 |       65 |</span><br><span class="line">|  3 |      33 |      213 |</span><br><span class="line">|  4 |      44 |       77 |</span><br><span class="line">|  5 |      55 |       20 |</span><br><span class="line">|  6 |      66 |      993 |</span><br><span class="line">|  7 |      77 |      142 |</span><br><span class="line">+----+---------+----------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-1-普通读-19"><a href="#6-1-普通读-19" class="headerlink" title="6.1 普通读"></a>6.1 普通读</h3><p>我们使用 <code>MySQL</code> 默认的隔离级别是 <code>REPEATABLE READ</code>，前面说过，解决了 <code>脏读</code>，<code>不可重复读</code> 和 <code>幻读</code> 的问题。但是吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115845.jpeg"></p>
<p>左边 <code>事务A</code> 第一次查询 <code>id = 9</code> 的数据，是空的，但是由于右边的 <code>事务B</code> 插入了 <code>id = 9</code> 的数据并 <code>提交</code>，<code>事务A</code> 又更新了 <code>id = 9</code> 的数据（所以此时 <code>数据行</code> 的 <code>trx_id</code> 列又变成了 <code>事务A</code> 的 <code>id</code>，又因为执行了 <code>UPDATE</code> 语句，所以 <code>ReadView</code> 被刷新了），并且读取，就可以返回数据啦。</p>
<p>所以，<code>REPEATABLE READ</code> 可以说并没有完完全全的解决 <code>幻读</code> 的问题。</p>
<p>那么怎么解决上面的问题，那就剩下 <code>加锁</code> 的方式了。</p>
<p>锁定读的语句：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE;</code></li>
<li><code>SELECT ... FOR UPDATE;</code></li>
<li><code>UPDATE ...;</code></li>
<li><code>DELETE ...;</code></li>
</ul>
<p>因为后面两种情况需要先读取 <code>数据行</code>，所以也属于 <code>锁定读</code> 的语句。</p>
<p>因为 <code>READ UNCOMMITTED</code> 和 <code>READ COMMITTED</code> 的加锁方式是一样的，所以，一起说就好了。</p>
<h3 id="6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-19"><a href="#6-xxxxx-分割线，以下属于-READ-UNCOMMITTED-READ-COMMITTED-加锁方式-19" class="headerlink" title="6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式"></a>6.xxxxx 分割线，以下属于 READ UNCOMMITTED/READ COMMITTED 加锁方式</h3><h3 id="6-2-等值锁定读-19"><a href="#6-2-等值锁定读-19" class="headerlink" title="6.2 等值锁定读"></a>6.2 等值锁定读</h3><p>针对 <code>SELECT</code> 语句，锁一般加在 <code>聚簇索引</code> 的数据行上面。比方说下面两个语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- X锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>一个加 <code>S锁</code>，一个加 <code>X锁</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115846.jpeg"></p>
<p>那么这条数据行就被加锁了。</p>
<p>而如果我更新这条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> quantity = <span class="number">200</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>如果这条数据没有索引，那加锁的状态和 <code>SELECT * FROM stock_info WHERE id = 3 FOR UPDATE;</code> 是一致的，就不再画出来了。</p>
<hr>
<p>而如果更新的列是有 <code>二级索引</code> 的话，那么两步走：</p>
<ol>
<li>先在 <code>聚簇索引</code> 上为这条记录加上锁；</li>
<li>再在 <code>二级索引</code> 上为对应的索引加锁。</li>
</ol>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stock_info <span class="keyword">SET</span> prod_id = <span class="number">99</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115847.jpeg"></p>
<p>而如果查询条件是先从 <code>二级索引</code> 出来的话，比如 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那加锁顺序又要反过来：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115848.jpeg"></p>
<p>而如果，同时有两个事务，一个 <code>UPDATE stock_info SET prod_id = 99 WHERE id = 3;</code> 另外一个 <code>UPDATE stock_info SET prod_id = 99 WHERE prod_id = 33;</code>，那么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115849.jpeg"></p>
<p>就 <code>死锁</code> 了，因为 <code>左事务</code> 先 <code>加锁</code> 了 <code>聚簇索引</code>，后 <code>加锁二级索引</code>，而 <code>右事务</code> 的 <code>加锁顺序</code> 反而是反过来的，这就导致了，<code>左事务</code> 在等待 <code>右事务</code> 释放 <code>二级索引锁</code>，而 <code>右事务</code> 在等待 <code>左事务</code> 释放 <code>聚簇索引锁</code>。所以导致死锁的发生。</p>
<p><code>UPDATE</code> 和 <code>DELETE</code> 是一样的，所以记住一个结论：</p>
<p><code>如果使用了索引加锁，则先加二级索引的锁再加聚簇索引的锁，如果使用了聚簇索引则先加聚簇索引的锁再加二级索引的锁。就是谁先到达先加谁的！</code></p>
<h3 id="6-3-范围锁定读-19"><a href="#6-3-范围锁定读-19" class="headerlink" title="6.3 范围锁定读"></a>6.3 范围锁定读</h3><p>那按照顺序，依然先看看走 <code>聚簇索引</code> 的流程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个看起来有点简单，无非就是把上面等值的所有列加锁就行了呗，其实 <code>不是的</code>，他是这样子走的：</p>
<ol>
<li>先拿到满足条件的第一条记录，也就是 <code>id = 1</code> 的记录，然后加锁；</li>
<li>判断是否符合 <code>索引条件下推</code> 的条件，<code>索引条件下推</code> 是为了减少回表次数，也就是减少 <code>IO</code> 次数，才会发生 <code>索引条件下推</code> 的现象，而  <code>索引条件下推</code> 主要用于 <code>二级索引</code>，所以这里并不需要判断；</li>
<li>判断是否符合 <code>范围查询</code> 的边界条件，因为 <code>id = 1 &lt; 5</code> 所以返回给 <code>server层</code> 继续处理，又因为 <code>聚簇索引</code> 是一个有序的 <code>树</code>，所以到了 <code>id = 5</code> 的时候，会释放掉当前循环到的 <code>数据行</code> 的锁，然后告诉 <code>server层</code> 已经 <code>查询完毕</code>；</li>
<li><code>server层</code> 继续判断，上一步中如果已经到达边界的话，会收到 <code>查询完毕</code> 的信号，返回数据给客户端。那如果没有收到 <code>查询完毕</code> 的信号的话，就需要继续重新判断数据有没有满足  <code>id = 1 &lt; 5</code> 这个条件（第二次判断，因为没有满足 <code>索引条件下推</code> 的条件，所以这一层又要判断一次），如果符合就加入到发送给客户端数据的 <code>结果集</code> 里边，如果不符合，要释放 <code>数据行</code> 的 <code>锁</code>；</li>
<li>拿当前 <code>数据行</code> 的下一条数据的指针，走到第二条数据，重复以上步骤，直到 <code>第4步</code> 查询结束为止。</li>
</ol>
<p>按照我们循环的习惯来说，<code>id &lt; 5</code> 还会走一下 <code>id = 5</code> 的数据进行判断，所以这条 <code>数据行</code> 会在 <code>第1步</code> 到 <code>第3步</code> 被短暂加一下 <code>锁</code>。</p>
<p>所以，又双叒叕可能会出现 <code>死锁</code> <code>锁竞争</code> 等问题。</p>
<p>而如果条件是 <code>id &gt; 5</code> 呢，首先拿到第一条数据也就是 <code>id = 6</code> 走走走走到了 <code>Supremum</code> 记录的时候，就不会再继续加锁了，直接返回给 <code>server层</code> 处理。</p>
<hr>
<p>那如果是修改到了 <code>索引数据</code> ，亦或者先通过 <code>索引</code> 找到需要加锁的记录呢，那就跟上面 <code>等值查询</code> 的索引加锁方式一样了，<code>先遍历到的，就先加锁</code>。</p>
<p>所以 <code>UPDATE stock_info SET prod_id = xxx WHERE id &lt; 5</code>，就是先找到 <code>id = 1</code> 的进行加锁，然后去索引再加锁，然后 <code>id = 2</code>、<code>id = 3</code> 依次循环下去。</p>
<p>而  <code>UPDATE stock_info SET prod_id = xxx WHERE prod_id &lt; 55</code> 则加锁顺序相反，其他一样。</p>
<p>依然记得 <code>最后一条边界记录要锁一下</code>。</p>
<h3 id="6-4-全表扫描读-19"><a href="#6-4-全表扫描读-19" class="headerlink" title="6.4 全表扫描读"></a>6.4 全表扫描读</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>这个加锁就简单粗暴了，每一条数据循环一次，然后在 <code>server层</code> 判断一下（因为没有 <code>条件下推</code>），满足即加入结果集，不满足则 <code>释放锁</code>。</p>
<h3 id="6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-19"><a href="#6-xxxxx-分割线，以下属于-REPEATABLE-READ-加锁方式-19" class="headerlink" title="6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式"></a>6.xxxxx 分割线，以下属于 REPEATABLE READ 加锁方式</h3><p>加锁之前，在 <code>6.1 普通读</code> 节说到的例子，<code>REPEATABLE READ</code> 可能还是会出现 <code>幻读</code> 的问题。<code>REPEATABLE READ</code> 加锁的方式则会比上面两种隔离级别要多样化，所以 <code>幻读</code> 问题也顺带解决了。</p>
<h3 id="6-5-等值锁定读-19"><a href="#6-5-等值锁定读-19" class="headerlink" title="6.5 等值锁定读"></a>6.5 等值锁定读</h3><p>如果查询的记录存在：<code>SELECT * FROM stock_info WHERE id = 5 FOR UPDATE</code>，那么加锁的形式跟之前是一样的，这里就不再重复。</p>
<p>那如果记录不存在的话比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>那么前面说了那么多的 <code>GAP锁</code> 就来了：</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115850.jpeg"></p>
<p>也就是说在 <code>(4, 6)</code> 区间范围内，有个 <code>GAP锁</code>，那其他事务想要把数据插入到这里的话，就要等我 <code>COMMIT</code> 事务以后才能够插入，也就可以防止上面 <code>6.1 普通读</code> 节说到的 <code>幻读</code> 问题。</p>
<hr>
<p>而如果用到了 <code>二级索引</code> 比方说 <code>SELECT * FROM stock_info WHERE prod_id = 55 FOR UPDATE</code> 的话，那二级索引对应的节点也会跟 <code>聚簇索引</code> 一样，加上 <code>GAP锁</code>。先后顺序也是取决于先到 <code>二级索引</code> 还是先到 <code>聚簇索引</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115851.jpeg"></p>
<p>这里还有一点主意的是，如果 <code>这个二级索引是一个唯一索引</code>，那么 <code>聚簇索引</code> 上的数据就不需要加锁了，因为 <code>二级索引</code> 的列是 <code>唯一的</code>，锁住那一个数据也就可以防止插入数据了。</p>
<h3 id="6-6-范围锁定读-19"><a href="#6-6-范围锁定读-19" class="headerlink" title="6.6 范围锁定读"></a>6.6 范围锁定读</h3><p>上面 <code>READ UNCOMMITTED/READ COMMITTED</code> 我们说，会为满足条件的 <code>数据行</code> 都加上锁，那么在这里为了防止 <code>幻读</code>，所以还要再加上一个锁：<code>next-key锁</code>。因为既要防止 <code>数据行</code> 被修改，也要防止在空隙里面被插入数据。</p>
<p>比方说 <code>SELECT * FROM stock_info WHERE id &lt; 4</code>，我们说了  <code>READ UNCOMMITTED/READ COMMITTED</code> 中 <code>id = 4</code> 加了一下锁，又会释放掉，但是在 <code>REPEATABLE READ下，他是不会释放的，并且还加上了 3 到 4 之间的 Next-Key 锁</code>。</p>
<p>而如果此时，我对 <code>id &lt; 4</code> 的数据都更新了 <code>prod_id</code> 的列，因为此时使用的是 <code>聚簇索引</code>，所以 <code>二级索引</code> 上 <code>id = 4</code> 的列不会被加锁。</p>
<p>那加锁顺序，肯定就是先 <code>聚簇</code> 再<code>二级</code> 了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115852.jpeg"></p>
<hr>
<p>而如果我们的范围查询发生在 <code>二级索引</code> 上面的话，取而代之的是 <code>二级索引</code> 上的每条记录都会被加 <code>Next-key锁</code>，<code>聚簇</code> 上的数据不加 <code>GAP锁</code>。</p>
<p>因为需要放置修改 <code>二级索引</code> 以及在 <code>二级索引</code> 间隙插入数据，所以 <code>锁</code> 发生在 <code>二级索引</code> 上，不画图了。</p>
<h3 id="6-7-全表扫描-19"><a href="#6-7-全表扫描-19" class="headerlink" title="6.7 全表扫描"></a>6.7 全表扫描</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> stock_info <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">WHERE</span> quantity &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>依然使用这条 <code>SQL</code> 查询，因为每读取一个记录就会给这个记录加上 <code>Next-Key锁</code>，返回 <code>server层</code>，判断满足条件则返回给客户端。而如果发生全表扫描并且加了 <code>锁</code>，因为 <code>REPEATABLE READ</code> <code>不会释放锁</code>，所以，发生这种情况的时候，<code>整个表都被锁住了！！！</code>。那其他的 <code>事务</code> 对这个表操作的时候均会被 <code>阻塞</code>。</p>
<h2 id="七-INSERT的情况-19"><a href="#七-INSERT的情况-19" class="headerlink" title="七.INSERT的情况"></a>七.INSERT的情况</h2><p><code>INSERT</code> 语句插入的时候，如果遇到上一条记录加了 <code>NextKey锁</code> 的话，那么会在该记录上加一个 <code>插入意向锁</code>，并且 <code>事务</code> 进入 <code>阻塞</code> 状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115843.jpeg"></p>
<p>而如果插入的时候遇见一些状况，也会 <code>加锁</code>：</p>
<ol>
<li>遇到重复值的时候，如果说在插入 <code>聚簇索引</code> 或者 <code>唯一二级索引</code> 的时候，发现 <code>INSERT</code> 语句中某个值冲突了（也就是说存在了 <code>索引</code> 中了），那么会对造成冲突的 <code>数据行</code> 加锁：<ol>
<li><code>READ UNCOMMITTED/READ COMMITTED</code> 加 <code>S型行锁</code>；</li>
<li><code>REPEATABLE READ/SERIALIZABLE</code> 加 <code>S型Next-Key锁</code>；</li>
<li><code>唯一二级索引</code> 统一加上 <code>Next-Key锁</code>。</li>
</ol>
</li>
<li>如果使用的是 <code>INSERT...ON DUPLICATE KEY</code> 语法，会在原来冲突的 <code>数据行</code> 上更新，所以，加什么 <code>锁</code> 肯定就一目了然了吧；</li>
<li>如果插入的数据带有 <code>外键检查</code>，那么关联到的 <code>数据行</code> 会被加上 <code>S行锁</code>，而如果查找不到 <code>外键记录</code>，则 <code>外键记录</code> 的空白位置在 <code>REPEATABLE READ/SERIALIZABLE</code> 会被加上 <code>GAP锁</code>，其他 <code>隔离级别</code> 则不会加锁。</li>
</ol>
<h2 id="七-死锁-19"><a href="#七-死锁-19" class="headerlink" title="七.死锁"></a>七.死锁</h2><p>似乎所有程序聊到 <code>锁</code> 的问题，就会有 <code>死锁</code> 的问题：</p>
<h3 id="7-1-普通资源锁-19"><a href="#7-1-普通资源锁-19" class="headerlink" title="7.1 普通资源锁"></a>7.1 普通资源锁</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110115853.jpeg"></p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-18"><a href="#7-2-插入GAP锁-18" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-18"><a href="#7-3-更新索引锁-18" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>
<p>当两个 <code>事务</code> 锁住的数据需要相互等待的时候，就会出现这种 <code>死锁</code> 的情况。</p>
<h3 id="7-2-插入GAP锁-19"><a href="#7-2-插入GAP锁-19" class="headerlink" title="7.2 插入GAP锁"></a>7.2 插入GAP锁</h3><p>是这样子的：</p>
<table>
<thead>
<tr>
<th align="center">T1</th>
<th align="center">T2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin；</td>
<td align="center">begin；</td>
</tr>
<tr>
<td align="center">delete from ta where a = 4;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">delete from ta where a = 4;</td>
</tr>
<tr>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into ta(a,b,c) values(4, 11, 3),(4, 2, 5);// 出现死锁</td>
</tr>
</tbody></table>
<p>这大概就是 <code>T1</code> 和 <code>T2</code> 两个执行了 <code>DELETE</code> 的时候都持有了 <code>GAP锁</code>，两个插入，<code>T1</code> 在等 <code>T2</code> 的 <code>GAP锁</code> 释放，<code>T2</code> 在等 <code>T1</code> 的 <code>插入意向锁</code> 释放，所以 <code>死锁</code> 了。</p>
<h3 id="7-3-更新索引锁-19"><a href="#7-3-更新索引锁-19" class="headerlink" title="7.3 更新索引锁"></a>7.3 更新索引锁</h3><p>这个在上面的 <code>6.2 等值锁定读</code> 已经说过，不在重复了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bmvcc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%8D%81-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bmvcc/" class="post-title-link" itemprop="url">【聊聊MySQL】十.MySQL-InnoDB的数据库事务的执行之MVCC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-20 17:31:19" itemprop="dateCreated datePublished" datetime="2020-03-20T17:31:19+08:00">2020-03-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 11:47:21" itemprop="dateModified" datetime="2020-11-10T11:47:21+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-事务的隔离"><a href="#一-事务的隔离" class="headerlink" title="一.事务的隔离"></a>一.事务的隔离</h2><p>刚开始我们说了事务的四个特性：<code>原子性</code> <code>一致性</code> <code>隔离性</code> <code>持久性</code>。</p>
<p>我们简单的分一下类： <code>redo log</code> 可以保证事务的 <code>原子性</code> 和 <code>持久性</code>，<code>undo log</code> 可以保证事务的 <code>一致性</code>，那么剩下的 <code>隔离性</code> 就由我们现在要说的 <code>MVCC</code> 来保证了。</p>
<p>那么隔离性是个啥，之前说过了，也就是可能出现 <code>脏写</code> <code>脏读</code> <code>幻读</code> <code>不可重复读</code> 等等这些状况。</p>
<p>简单回顾下：</p>
<ul>
<li>脏写：A事务提交的数据是B事务 <code>UPDATE</code> 的值 ，这个无论如何都不允许；</li>
<li>脏读：A事务中读取到了B事务中 <code>UPDATE</code> 的值（B事务未提交）；</li>
<li>不可重复读：A事务中两次读取，第二次读取到B事务已经提交的 <code>UPDATE</code> 的值（注意跟 <code>脏读</code> 的区别）；</li>
<li>幻读：A事务两次读取，第二次读取到B事务中提交的 <code>INSERT</code> 的值，但是如果A事务两次读取，第二次读不到B事务 <code>DELETE</code> 的数据，不属于幻读，幻读强调第二次读取的时候，多了数据；</li>
</ul>
<h2 id="二-MVCC"><a href="#二-MVCC" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><p><code>MVCC</code> 表示 <code>Multi-Version Concurrency Control</code>，<code>多版本并发控制</code>。也就是说在多个事务执行的情况下，可以控制事务读取到的数据版本的问题。</p>
<p>而 <code>MVCC</code> 的关键就在于之前 <code>undo log</code> 所说的 <code>版本链</code> 上。</p>
<h3 id="2-1-版本链"><a href="#2-1-版本链" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><h2 id="一-事务的隔离-1"><a href="#一-事务的隔离-1" class="headerlink" title="一.事务的隔离"></a>一.事务的隔离</h2><p>刚开始我们说了事务的四个特性：<code>原子性</code> <code>一致性</code> <code>隔离性</code> <code>持久性</code>。</p>
<p>我们简单的分一下类： <code>redo log</code> 可以保证事务的 <code>原子性</code> 和 <code>持久性</code>，<code>undo log</code> 可以保证事务的 <code>一致性</code>，那么剩下的 <code>隔离性</code> 就由我们现在要说的 <code>MVCC</code> 来保证了。</p>
<p>那么隔离性是个啥，之前说过了，也就是可能出现 <code>脏写</code> <code>脏读</code> <code>幻读</code> <code>不可重复读</code> 等等这些状况。</p>
<p>简单回顾下：</p>
<ul>
<li>脏写：A事务提交的数据是B事务 <code>UPDATE</code> 的值 ，这个无论如何都不允许；</li>
<li>脏读：A事务中读取到了B事务中 <code>UPDATE</code> 的值（B事务未提交）；</li>
<li>不可重复读：A事务中两次读取，第二次读取到B事务已经提交的 <code>UPDATE</code> 的值（注意跟 <code>脏读</code> 的区别）；</li>
<li>幻读：A事务两次读取，第二次读取到B事务中提交的 <code>INSERT</code> 的值，但是如果A事务两次读取，第二次读不到B事务 <code>DELETE</code> 的数据，不属于幻读，幻读强调第二次读取的时候，多了数据；</li>
</ul>
<h2 id="二-MVCC-1"><a href="#二-MVCC-1" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><p><code>MVCC</code> 表示 <code>Multi-Version Concurrency Control</code>，<code>多版本并发控制</code>。也就是说在多个事务执行的情况下，可以控制事务读取到的数据版本的问题。</p>
<p>而 <code>MVCC</code> 的关键就在于之前 <code>undo log</code> 所说的 <code>版本链</code> 上。</p>
<h3 id="2-1-版本链-1"><a href="#2-1-版本链-1" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114652.jpeg"></p>
<p>之前说过这个图，第一次插入的时候，生成了第一条 <code>undo_insert_rec</code>，而对这个数据行做删除的时候，就会把数据行中的 <code>roll_pointer</code> 打断，连接到删除的 <code>undo log</code> 上，而 <code>undo log</code> 中的 <code>old_roll_pointer</code> 又指向了前一个插入的 <code>undo log</code> 中。</p>
<p>由于上面太乱我重新画张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114653.jpeg"></p>
<p>OK，这是一个产品入库的过程。两个事务对这个条数据发生了更新，假设事务A和事务B（事务A的 <code>trx_id=20</code>，事务B的 <code>trx_id=10</code>）。事务B修改库存为 <code>600</code>，而事务A做了两次修改，第一次是 <code>850</code> 第二次是 <code>1000</code>。所以上图中，比较低层的是旧的数据，比较高层的是新的数据。这个列表串起来就是一条数据的 <code>版本链</code>。</p>
<p>有了这个版本链还不够，还需要一个 <code>ReadView</code> 来辅助查询。</p>
<h3 id="2-2-ReadView"><a href="#2-2-ReadView" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>这个名字也很好理解了：<code>读取视图</code>。他发生在 <code>SELECT</code> 的时候，每次 <code>SELECT</code> 都会从数据表中生成一个 <code>ReadView</code>。</p>
<p><code>ReadView</code> 有几个非常重要的属性：</p>
<ul>
<li><code>m_ids</code>：生成时活跃的读写事务 <code>trx_id</code> 列表；</li>
<li><code>min_trx_id</code>：上面 <code>m_ids</code> 最小的值；</li>
<li><code>max_trx_id</code>：生成时应该分配给下一个事务的 <code>trx_id值</code>；</li>
<li><code>creator_trx_id</code>：当前事务的 <code>trx_id值</code>；</li>
</ul>
<p>那我们要查询上面的某条记录的时候，就需要根据 <code>ReadView</code> 中的那些值与 <code>undo log</code> 或者 <code>数据行</code> 中的 <code>trx_id</code> 比较，来拿到满足条件的最新一条的记录，就是当前事务可以访问到的数据。</p>
<p>怎么判断：</p>
<ol>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 与当前事务 <code>id</code> 相等，也就是与 <code>creator_trx_id</code> 说明这条数据在当前事务发生更改，所以当前事务可以访问；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 小于 <code>min_trx_id</code> 说明这个数据的改动在这个事务之前已经提交，所以可以被访问到；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 大于或等于 <code>max_trx_id</code>，说明该版本在这个事务之后发生的更改，所以这个版本不可见，继续遍历下一个版本；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 介于 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则需要判断事务是否存在于 <code>m_ids</code> 中：<ol>
<li>如果存在，说明创建的时候事务还在活跃中，数据版本不可见；</li>
<li>如果不存在，说明已经提交了，则数据版本可见</li>
</ol>
</li>
</ol>
<p>然后我们知道，数据库有不同的隔离级别，<code>MySQL</code> 有 <code>READ UNCOMMITTED</code> <code>READ COMMITTED</code> <code>REPEATABLE READ</code> <code>SERIALIZABLE</code>：</p>
<p><code>READ UNCOMMITTED</code>：所有遇到的问题情况都允许，所以不用考虑；</p>
<p><code>SERIALIZABLE</code>：所有查询写入均需要串行执行，所以也不用考虑。</p>
<p>那么主要就是 <code>READ COMMITTED</code> <code>REPEATABLE READ</code> 这两个隔离级别通过不同的方式来使用 <code>ReadView</code>。<code>READ COMMITTED</code> 是在每一次 <code>SELECT</code> 的时候生成 <code>ReadView</code>，而 <code>REPEATABLE READ</code> 则是在每次事务开始的时候生成的。</p>
<h3 id="2-3-查询示例"><a href="#2-3-查询示例" class="headerlink" title="2.3 查询示例"></a>2.3 查询示例</h3><p>来举个栗子吧，我们假设当前的隔离级别是 <code>READ COMMITTED</code>：</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">事务A(trx=1)</th>
<th align="center">事务B(trx=2)</th>
<th align="center">事务C(trx=3)</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>BEGIN;INSERT INTO(1, 1, 0);COMMIT;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>BEGIN;</code> <code>trx=4</code></td>
<td align="center"><code>UPDATE quantity = 100</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"><code>UPDATE quantity = 200</code></td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"><code>UPDATE quantity = 300</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>200</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>300</code></td>
</tr>
</tbody></table>
<p>分步骤来说：</p>
<ol>
<li>第 <code>1</code> 步，<code>事务A</code> 开启一个事务插入一条数据，这时候 <code>数据行的 trx_id = 1</code>；</li>
<li>第 <code>2</code> 步，<code>事务B</code> 和 <code>事务C</code> 分别开启事务，准备对这条数据蠢蠢欲动；</li>
<li>第 <code>3</code> 步：<ul>
<li><code>事务A</code> 又开启一个事务，分配了 <code>trx_id =  4</code>；</li>
<li>同时 <code>事务B</code> 更新了数量 <code>100</code>；</li>
</ul>
</li>
<li>第 <code>4</code> 步：<ul>
<li><code>事务B</code> 又更新了数量 <code>200</code>；</li>
</ul>
</li>
<li>第 <code>5</code> 步：<code>事务C</code> 也更新了数量 <code>300</code>，<code>事务A</code> 查询了数量，这时候 <strong>结果是</strong> <code>0</code>；</li>
<li>第 <code>6</code> 步：<code>事务B</code> 进行了提交；</li>
<li>第 <code>7</code> 步：<code>事务A</code> 查询了数量，<strong>结果是</strong> <code>200</code>；</li>
<li>第 <code>8</code> 步：<code>事务C</code> 提交；</li>
<li>第 <code>9</code> 步：<code>事务A</code> 查询数量，<strong>结果是</strong> <code>300</code>。</li>
</ol>
<p>那接下来讨论的就是上面的步骤中，<code>三次查询</code> 的结果：</p>
<p>第一次，发生在第 <code>5</code> 步：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p><code>事务A</code> 查询的时候创建了 <code>ReadView</code>，这时候根据上面的判断，迭代目前的数据版本：</p>
<p>我们看看第一个结果 <code>0</code>，发生在 <code>第 5 步</code>：</p>
<ol>
<li><p>第一条数据：</p>
<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li><p>第二条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第三条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第四条数据</p>
<p><code>trx_id = 1</code> 明显小于 <code>min_trx_id</code>，所以这条数据可以被 <code>事务A</code> 访问，返回数据 <code>0</code>。</p>
</li>
</ol>
<p>接下来看看第二个结果 <code>200</code>，发生在 <code>第 7 步</code>，这时候，<code>事务B</code> 已经提交了，所以 <code>ReadView</code> 的情况就是下面这种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114655.jpeg"></p>
<ol>
<li>第一条数据：<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li>第二条数据：<ol>
<li><code>trx_id = 2</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以返回这条数据，所以查询到的 <code>quantity = 200</code></li>
</ol>
</li>
</ol>
<p>然后，随着 <code>事务C</code> 也提交了，这时候系统中没有正在运行的事务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114656.jpeg"></p>
<p>那么第一条数据做第一个判断的时候，发现当前已经没有事务在运行了，所以这条记录是这个事务之前提交的，就会被访问到，直接返回 <code>300</code>。</p>
<p><strong>所以需要注意的是： <code>READ COMMITTED</code> 每次查询都会生成一个新的 <code>ReadView</code> 所以就发生了 <code>不可重复读</code>。</strong></p>
<p>那如果是 <code>REPEATABLE READ</code> ，他会在查询的时候就根据目前事务的情况创建 <code>ReadView</code> 了，也就是说，查询的时候，创建 <code>ReadView</code>，然后三次查询，都使用下图这个 <code>ReadView</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p>所以在这个事务结束之前，每次查询的结果，都只能拿到 <code>quantity = 0</code> 这条数据。</p>
<p>那之前我们说过，这个级别 <code>InnoDB</code> 实际上已经解决了幻读的问题，也是因为这个 <code>ReadView</code> 的原因，思考下，创建 <code>ReadView</code> 的时候，查询过程中就已经被限制返回为 <code>NULL</code> 了，所以没有 <code>幻读</code> 问题。</p>
<h2 id="三-更新数据时undo-log的清理"><a href="#三-更新数据时undo-log的清理" class="headerlink" title="三.更新数据时undo_log的清理"></a>三.更新数据时undo_log的清理</h2><p>那么 <code>undo log</code> 的日志会越堆积越多，总不能没有被清理的时候把。这个时间点就要把握在，接下来所有事务 <code>都不需要</code> 再访问这个 <code>undo log</code> 版本的时候，后台线程会清理掉。大概什么时候，就是 <code>UPDATE</code> 提交以后，后面的事务已经一致返回的是比当前这个 <code>UPDATE</code> 数据还要新的数据的时候，就已经可以清理掉了。</p>
<h2 id="四-小小结"><a href="#四-小小结" class="headerlink" title="四.小小结"></a>四.小小结</h2><p>通过 <code>版本并发控制管理MVCC</code> 来隔离数据。</p>
<p>之前说过这个图，第一次插入的时候，生成了第一条 <code>undo_insert_rec</code>，而对这个数据行做删除的时候，就会把数据行中的 <code>roll_pointer</code> 打断，连接到删除的 <code>undo log</code> 上，而 <code>undo log</code> 中的 <code>old_roll_pointer</code> 又指向了前一个插入的 <code>undo log</code> 中。</p>
<p>由于上面太乱我重新画张图：</p>
<h2 id="一-事务的隔离-2"><a href="#一-事务的隔离-2" class="headerlink" title="一.事务的隔离"></a>一.事务的隔离</h2><p>刚开始我们说了事务的四个特性：<code>原子性</code> <code>一致性</code> <code>隔离性</code> <code>持久性</code>。</p>
<p>我们简单的分一下类： <code>redo log</code> 可以保证事务的 <code>原子性</code> 和 <code>持久性</code>，<code>undo log</code> 可以保证事务的 <code>一致性</code>，那么剩下的 <code>隔离性</code> 就由我们现在要说的 <code>MVCC</code> 来保证了。</p>
<p>那么隔离性是个啥，之前说过了，也就是可能出现 <code>脏写</code> <code>脏读</code> <code>幻读</code> <code>不可重复读</code> 等等这些状况。</p>
<p>简单回顾下：</p>
<ul>
<li>脏写：A事务提交的数据是B事务 <code>UPDATE</code> 的值 ，这个无论如何都不允许；</li>
<li>脏读：A事务中读取到了B事务中 <code>UPDATE</code> 的值（B事务未提交）；</li>
<li>不可重复读：A事务中两次读取，第二次读取到B事务已经提交的 <code>UPDATE</code> 的值（注意跟 <code>脏读</code> 的区别）；</li>
<li>幻读：A事务两次读取，第二次读取到B事务中提交的 <code>INSERT</code> 的值，但是如果A事务两次读取，第二次读不到B事务 <code>DELETE</code> 的数据，不属于幻读，幻读强调第二次读取的时候，多了数据；</li>
</ul>
<h2 id="二-MVCC-2"><a href="#二-MVCC-2" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><p><code>MVCC</code> 表示 <code>Multi-Version Concurrency Control</code>，<code>多版本并发控制</code>。也就是说在多个事务执行的情况下，可以控制事务读取到的数据版本的问题。</p>
<p>而 <code>MVCC</code> 的关键就在于之前 <code>undo log</code> 所说的 <code>版本链</code> 上。</p>
<h3 id="2-1-版本链-2"><a href="#2-1-版本链-2" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114652.jpeg"></p>
<p>之前说过这个图，第一次插入的时候，生成了第一条 <code>undo_insert_rec</code>，而对这个数据行做删除的时候，就会把数据行中的 <code>roll_pointer</code> 打断，连接到删除的 <code>undo log</code> 上，而 <code>undo log</code> 中的 <code>old_roll_pointer</code> 又指向了前一个插入的 <code>undo log</code> 中。</p>
<p>由于上面太乱我重新画张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114653.jpeg"></p>
<p>OK，这是一个产品入库的过程。两个事务对这个条数据发生了更新，假设事务A和事务B（事务A的 <code>trx_id=20</code>，事务B的 <code>trx_id=10</code>）。事务B修改库存为 <code>600</code>，而事务A做了两次修改，第一次是 <code>850</code> 第二次是 <code>1000</code>。所以上图中，比较低层的是旧的数据，比较高层的是新的数据。这个列表串起来就是一条数据的 <code>版本链</code>。</p>
<p>有了这个版本链还不够，还需要一个 <code>ReadView</code> 来辅助查询。</p>
<h3 id="2-2-ReadView-1"><a href="#2-2-ReadView-1" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>这个名字也很好理解了：<code>读取视图</code>。他发生在 <code>SELECT</code> 的时候，每次 <code>SELECT</code> 都会从数据表中生成一个 <code>ReadView</code>。</p>
<p><code>ReadView</code> 有几个非常重要的属性：</p>
<ul>
<li><code>m_ids</code>：生成时活跃的读写事务 <code>trx_id</code> 列表；</li>
<li><code>min_trx_id</code>：上面 <code>m_ids</code> 最小的值；</li>
<li><code>max_trx_id</code>：生成时应该分配给下一个事务的 <code>trx_id值</code>；</li>
<li><code>creator_trx_id</code>：当前事务的 <code>trx_id值</code>；</li>
</ul>
<p>那我们要查询上面的某条记录的时候，就需要根据 <code>ReadView</code> 中的那些值与 <code>undo log</code> 或者 <code>数据行</code> 中的 <code>trx_id</code> 比较，来拿到满足条件的最新一条的记录，就是当前事务可以访问到的数据。</p>
<p>怎么判断：</p>
<ol>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 与当前事务 <code>id</code> 相等，也就是与 <code>creator_trx_id</code> 说明这条数据在当前事务发生更改，所以当前事务可以访问；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 小于 <code>min_trx_id</code> 说明这个数据的改动在这个事务之前已经提交，所以可以被访问到；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 大于或等于 <code>max_trx_id</code>，说明该版本在这个事务之后发生的更改，所以这个版本不可见，继续遍历下一个版本；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 介于 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则需要判断事务是否存在于 <code>m_ids</code> 中：<ol>
<li>如果存在，说明创建的时候事务还在活跃中，数据版本不可见；</li>
<li>如果不存在，说明已经提交了，则数据版本可见</li>
</ol>
</li>
</ol>
<p>然后我们知道，数据库有不同的隔离级别，<code>MySQL</code> 有 <code>READ UNCOMMITTED</code> <code>READ COMMITTED</code> <code>REPEATABLE READ</code> <code>SERIALIZABLE</code>：</p>
<p><code>READ UNCOMMITTED</code>：所有遇到的问题情况都允许，所以不用考虑；</p>
<p><code>SERIALIZABLE</code>：所有查询写入均需要串行执行，所以也不用考虑。</p>
<p>那么主要就是 <code>READ COMMITTED</code> <code>REPEATABLE READ</code> 这两个隔离级别通过不同的方式来使用 <code>ReadView</code>。<code>READ COMMITTED</code> 是在每一次 <code>SELECT</code> 的时候生成 <code>ReadView</code>，而 <code>REPEATABLE READ</code> 则是在每次事务开始的时候生成的。</p>
<h3 id="2-3-查询示例-1"><a href="#2-3-查询示例-1" class="headerlink" title="2.3 查询示例"></a>2.3 查询示例</h3><p>来举个栗子吧，我们假设当前的隔离级别是 <code>READ COMMITTED</code>：</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">事务A(trx=1)</th>
<th align="center">事务B(trx=2)</th>
<th align="center">事务C(trx=3)</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>BEGIN;INSERT INTO(1, 1, 0);COMMIT;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>BEGIN;</code> <code>trx=4</code></td>
<td align="center"><code>UPDATE quantity = 100</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"><code>UPDATE quantity = 200</code></td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"><code>UPDATE quantity = 300</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>200</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>300</code></td>
</tr>
</tbody></table>
<p>分步骤来说：</p>
<ol>
<li>第 <code>1</code> 步，<code>事务A</code> 开启一个事务插入一条数据，这时候 <code>数据行的 trx_id = 1</code>；</li>
<li>第 <code>2</code> 步，<code>事务B</code> 和 <code>事务C</code> 分别开启事务，准备对这条数据蠢蠢欲动；</li>
<li>第 <code>3</code> 步：<ul>
<li><code>事务A</code> 又开启一个事务，分配了 <code>trx_id =  4</code>；</li>
<li>同时 <code>事务B</code> 更新了数量 <code>100</code>；</li>
</ul>
</li>
<li>第 <code>4</code> 步：<ul>
<li><code>事务B</code> 又更新了数量 <code>200</code>；</li>
</ul>
</li>
<li>第 <code>5</code> 步：<code>事务C</code> 也更新了数量 <code>300</code>，<code>事务A</code> 查询了数量，这时候 <strong>结果是</strong> <code>0</code>；</li>
<li>第 <code>6</code> 步：<code>事务B</code> 进行了提交；</li>
<li>第 <code>7</code> 步：<code>事务A</code> 查询了数量，<strong>结果是</strong> <code>200</code>；</li>
<li>第 <code>8</code> 步：<code>事务C</code> 提交；</li>
<li>第 <code>9</code> 步：<code>事务A</code> 查询数量，<strong>结果是</strong> <code>300</code>。</li>
</ol>
<p>那接下来讨论的就是上面的步骤中，<code>三次查询</code> 的结果：</p>
<p>第一次，发生在第 <code>5</code> 步：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p><code>事务A</code> 查询的时候创建了 <code>ReadView</code>，这时候根据上面的判断，迭代目前的数据版本：</p>
<p>我们看看第一个结果 <code>0</code>，发生在 <code>第 5 步</code>：</p>
<ol>
<li><p>第一条数据：</p>
<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li><p>第二条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第三条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第四条数据</p>
<p><code>trx_id = 1</code> 明显小于 <code>min_trx_id</code>，所以这条数据可以被 <code>事务A</code> 访问，返回数据 <code>0</code>。</p>
</li>
</ol>
<p>接下来看看第二个结果 <code>200</code>，发生在 <code>第 7 步</code>，这时候，<code>事务B</code> 已经提交了，所以 <code>ReadView</code> 的情况就是下面这种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114655.jpeg"></p>
<ol>
<li>第一条数据：<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li>第二条数据：<ol>
<li><code>trx_id = 2</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以返回这条数据，所以查询到的 <code>quantity = 200</code></li>
</ol>
</li>
</ol>
<p>然后，随着 <code>事务C</code> 也提交了，这时候系统中没有正在运行的事务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114656.jpeg"></p>
<p>那么第一条数据做第一个判断的时候，发现当前已经没有事务在运行了，所以这条记录是这个事务之前提交的，就会被访问到，直接返回 <code>300</code>。</p>
<p><strong>所以需要注意的是： <code>READ COMMITTED</code> 每次查询都会生成一个新的 <code>ReadView</code> 所以就发生了 <code>不可重复读</code>。</strong></p>
<p>那如果是 <code>REPEATABLE READ</code> ，他会在查询的时候就根据目前事务的情况创建 <code>ReadView</code> 了，也就是说，查询的时候，创建 <code>ReadView</code>，然后三次查询，都使用下图这个 <code>ReadView</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p>所以在这个事务结束之前，每次查询的结果，都只能拿到 <code>quantity = 0</code> 这条数据。</p>
<p>那之前我们说过，这个级别 <code>InnoDB</code> 实际上已经解决了幻读的问题，也是因为这个 <code>ReadView</code> 的原因，思考下，创建 <code>ReadView</code> 的时候，查询过程中就已经被限制返回为 <code>NULL</code> 了，所以没有 <code>幻读</code> 问题。</p>
<h2 id="三-更新数据时undo-log的清理-1"><a href="#三-更新数据时undo-log的清理-1" class="headerlink" title="三.更新数据时undo_log的清理"></a>三.更新数据时undo_log的清理</h2><p>那么 <code>undo log</code> 的日志会越堆积越多，总不能没有被清理的时候把。这个时间点就要把握在，接下来所有事务 <code>都不需要</code> 再访问这个 <code>undo log</code> 版本的时候，后台线程会清理掉。大概什么时候，就是 <code>UPDATE</code> 提交以后，后面的事务已经一致返回的是比当前这个 <code>UPDATE</code> 数据还要新的数据的时候，就已经可以清理掉了。</p>
<h2 id="四-小小结-1"><a href="#四-小小结-1" class="headerlink" title="四.小小结"></a>四.小小结</h2><p>通过 <code>版本并发控制管理MVCC</code> 来隔离数据。</p>
<p>OK，这是一个产品入库的过程。两个事务对这个条数据发生了更新，假设事务A和事务B（事务A的 <code>trx_id=20</code>，事务B的 <code>trx_id=10</code>）。事务B修改库存为 <code>600</code>，而事务A做了两次修改，第一次是 <code>850</code> 第二次是 <code>1000</code>。所以上图中，比较低层的是旧的数据，比较高层的是新的数据。这个列表串起来就是一条数据的 <code>版本链</code>。</p>
<p>有了这个版本链还不够，还需要一个 <code>ReadView</code> 来辅助查询。</p>
<h3 id="2-2-ReadView-2"><a href="#2-2-ReadView-2" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>这个名字也很好理解了：<code>读取视图</code>。他发生在 <code>SELECT</code> 的时候，每次 <code>SELECT</code> 都会从数据表中生成一个 <code>ReadView</code>。</p>
<p><code>ReadView</code> 有几个非常重要的属性：</p>
<ul>
<li><code>m_ids</code>：生成时活跃的读写事务 <code>trx_id</code> 列表；</li>
<li><code>min_trx_id</code>：上面 <code>m_ids</code> 最小的值；</li>
<li><code>max_trx_id</code>：生成时应该分配给下一个事务的 <code>trx_id值</code>；</li>
<li><code>creator_trx_id</code>：当前事务的 <code>trx_id值</code>；</li>
</ul>
<p>那我们要查询上面的某条记录的时候，就需要根据 <code>ReadView</code> 中的那些值与 <code>undo log</code> 或者 <code>数据行</code> 中的 <code>trx_id</code> 比较，来拿到满足条件的最新一条的记录，就是当前事务可以访问到的数据。</p>
<p>怎么判断：</p>
<ol>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 与当前事务 <code>id</code> 相等，也就是与 <code>creator_trx_id</code> 说明这条数据在当前事务发生更改，所以当前事务可以访问；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 小于 <code>min_trx_id</code> 说明这个数据的改动在这个事务之前已经提交，所以可以被访问到；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 大于或等于 <code>max_trx_id</code>，说明该版本在这个事务之后发生的更改，所以这个版本不可见，继续遍历下一个版本；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 介于 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则需要判断事务是否存在于 <code>m_ids</code> 中：<ol>
<li>如果存在，说明创建的时候事务还在活跃中，数据版本不可见；</li>
<li>如果不存在，说明已经提交了，则数据版本可见</li>
</ol>
</li>
</ol>
<p>然后我们知道，数据库有不同的隔离级别，<code>MySQL</code> 有 <code>READ UNCOMMITTED</code> <code>READ COMMITTED</code> <code>REPEATABLE READ</code> <code>SERIALIZABLE</code>：</p>
<p><code>READ UNCOMMITTED</code>：所有遇到的问题情况都允许，所以不用考虑；</p>
<p><code>SERIALIZABLE</code>：所有查询写入均需要串行执行，所以也不用考虑。</p>
<p>那么主要就是 <code>READ COMMITTED</code> <code>REPEATABLE READ</code> 这两个隔离级别通过不同的方式来使用 <code>ReadView</code>。<code>READ COMMITTED</code> 是在每一次 <code>SELECT</code> 的时候生成 <code>ReadView</code>，而 <code>REPEATABLE READ</code> 则是在每次事务开始的时候生成的。</p>
<h3 id="2-3-查询示例-2"><a href="#2-3-查询示例-2" class="headerlink" title="2.3 查询示例"></a>2.3 查询示例</h3><p>来举个栗子吧，我们假设当前的隔离级别是 <code>READ COMMITTED</code>：</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">事务A(trx=1)</th>
<th align="center">事务B(trx=2)</th>
<th align="center">事务C(trx=3)</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>BEGIN;INSERT INTO(1, 1, 0);COMMIT;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>BEGIN;</code> <code>trx=4</code></td>
<td align="center"><code>UPDATE quantity = 100</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"><code>UPDATE quantity = 200</code></td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"><code>UPDATE quantity = 300</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>200</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>300</code></td>
</tr>
</tbody></table>
<p>分步骤来说：</p>
<ol>
<li>第 <code>1</code> 步，<code>事务A</code> 开启一个事务插入一条数据，这时候 <code>数据行的 trx_id = 1</code>；</li>
<li>第 <code>2</code> 步，<code>事务B</code> 和 <code>事务C</code> 分别开启事务，准备对这条数据蠢蠢欲动；</li>
<li>第 <code>3</code> 步：<ul>
<li><code>事务A</code> 又开启一个事务，分配了 <code>trx_id =  4</code>；</li>
<li>同时 <code>事务B</code> 更新了数量 <code>100</code>；</li>
</ul>
</li>
<li>第 <code>4</code> 步：<ul>
<li><code>事务B</code> 又更新了数量 <code>200</code>；</li>
</ul>
</li>
<li>第 <code>5</code> 步：<code>事务C</code> 也更新了数量 <code>300</code>，<code>事务A</code> 查询了数量，这时候 <strong>结果是</strong> <code>0</code>；</li>
<li>第 <code>6</code> 步：<code>事务B</code> 进行了提交；</li>
<li>第 <code>7</code> 步：<code>事务A</code> 查询了数量，<strong>结果是</strong> <code>200</code>；</li>
<li>第 <code>8</code> 步：<code>事务C</code> 提交；</li>
<li>第 <code>9</code> 步：<code>事务A</code> 查询数量，<strong>结果是</strong> <code>300</code>。</li>
</ol>
<p>那接下来讨论的就是上面的步骤中，<code>三次查询</code> 的结果：</p>
<p>第一次，发生在第 <code>5</code> 步：</p>
<h2 id="一-事务的隔离-3"><a href="#一-事务的隔离-3" class="headerlink" title="一.事务的隔离"></a>一.事务的隔离</h2><p>刚开始我们说了事务的四个特性：<code>原子性</code> <code>一致性</code> <code>隔离性</code> <code>持久性</code>。</p>
<p>我们简单的分一下类： <code>redo log</code> 可以保证事务的 <code>原子性</code> 和 <code>持久性</code>，<code>undo log</code> 可以保证事务的 <code>一致性</code>，那么剩下的 <code>隔离性</code> 就由我们现在要说的 <code>MVCC</code> 来保证了。</p>
<p>那么隔离性是个啥，之前说过了，也就是可能出现 <code>脏写</code> <code>脏读</code> <code>幻读</code> <code>不可重复读</code> 等等这些状况。</p>
<p>简单回顾下：</p>
<ul>
<li>脏写：A事务提交的数据是B事务 <code>UPDATE</code> 的值 ，这个无论如何都不允许；</li>
<li>脏读：A事务中读取到了B事务中 <code>UPDATE</code> 的值（B事务未提交）；</li>
<li>不可重复读：A事务中两次读取，第二次读取到B事务已经提交的 <code>UPDATE</code> 的值（注意跟 <code>脏读</code> 的区别）；</li>
<li>幻读：A事务两次读取，第二次读取到B事务中提交的 <code>INSERT</code> 的值，但是如果A事务两次读取，第二次读不到B事务 <code>DELETE</code> 的数据，不属于幻读，幻读强调第二次读取的时候，多了数据；</li>
</ul>
<h2 id="二-MVCC-3"><a href="#二-MVCC-3" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><p><code>MVCC</code> 表示 <code>Multi-Version Concurrency Control</code>，<code>多版本并发控制</code>。也就是说在多个事务执行的情况下，可以控制事务读取到的数据版本的问题。</p>
<p>而 <code>MVCC</code> 的关键就在于之前 <code>undo log</code> 所说的 <code>版本链</code> 上。</p>
<h3 id="2-1-版本链-3"><a href="#2-1-版本链-3" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114652.jpeg"></p>
<p>之前说过这个图，第一次插入的时候，生成了第一条 <code>undo_insert_rec</code>，而对这个数据行做删除的时候，就会把数据行中的 <code>roll_pointer</code> 打断，连接到删除的 <code>undo log</code> 上，而 <code>undo log</code> 中的 <code>old_roll_pointer</code> 又指向了前一个插入的 <code>undo log</code> 中。</p>
<p>由于上面太乱我重新画张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114653.jpeg"></p>
<p>OK，这是一个产品入库的过程。两个事务对这个条数据发生了更新，假设事务A和事务B（事务A的 <code>trx_id=20</code>，事务B的 <code>trx_id=10</code>）。事务B修改库存为 <code>600</code>，而事务A做了两次修改，第一次是 <code>850</code> 第二次是 <code>1000</code>。所以上图中，比较低层的是旧的数据，比较高层的是新的数据。这个列表串起来就是一条数据的 <code>版本链</code>。</p>
<p>有了这个版本链还不够，还需要一个 <code>ReadView</code> 来辅助查询。</p>
<h3 id="2-2-ReadView-3"><a href="#2-2-ReadView-3" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>这个名字也很好理解了：<code>读取视图</code>。他发生在 <code>SELECT</code> 的时候，每次 <code>SELECT</code> 都会从数据表中生成一个 <code>ReadView</code>。</p>
<p><code>ReadView</code> 有几个非常重要的属性：</p>
<ul>
<li><code>m_ids</code>：生成时活跃的读写事务 <code>trx_id</code> 列表；</li>
<li><code>min_trx_id</code>：上面 <code>m_ids</code> 最小的值；</li>
<li><code>max_trx_id</code>：生成时应该分配给下一个事务的 <code>trx_id值</code>；</li>
<li><code>creator_trx_id</code>：当前事务的 <code>trx_id值</code>；</li>
</ul>
<p>那我们要查询上面的某条记录的时候，就需要根据 <code>ReadView</code> 中的那些值与 <code>undo log</code> 或者 <code>数据行</code> 中的 <code>trx_id</code> 比较，来拿到满足条件的最新一条的记录，就是当前事务可以访问到的数据。</p>
<p>怎么判断：</p>
<ol>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 与当前事务 <code>id</code> 相等，也就是与 <code>creator_trx_id</code> 说明这条数据在当前事务发生更改，所以当前事务可以访问；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 小于 <code>min_trx_id</code> 说明这个数据的改动在这个事务之前已经提交，所以可以被访问到；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 大于或等于 <code>max_trx_id</code>，说明该版本在这个事务之后发生的更改，所以这个版本不可见，继续遍历下一个版本；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 介于 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则需要判断事务是否存在于 <code>m_ids</code> 中：<ol>
<li>如果存在，说明创建的时候事务还在活跃中，数据版本不可见；</li>
<li>如果不存在，说明已经提交了，则数据版本可见</li>
</ol>
</li>
</ol>
<p>然后我们知道，数据库有不同的隔离级别，<code>MySQL</code> 有 <code>READ UNCOMMITTED</code> <code>READ COMMITTED</code> <code>REPEATABLE READ</code> <code>SERIALIZABLE</code>：</p>
<p><code>READ UNCOMMITTED</code>：所有遇到的问题情况都允许，所以不用考虑；</p>
<p><code>SERIALIZABLE</code>：所有查询写入均需要串行执行，所以也不用考虑。</p>
<p>那么主要就是 <code>READ COMMITTED</code> <code>REPEATABLE READ</code> 这两个隔离级别通过不同的方式来使用 <code>ReadView</code>。<code>READ COMMITTED</code> 是在每一次 <code>SELECT</code> 的时候生成 <code>ReadView</code>，而 <code>REPEATABLE READ</code> 则是在每次事务开始的时候生成的。</p>
<h3 id="2-3-查询示例-3"><a href="#2-3-查询示例-3" class="headerlink" title="2.3 查询示例"></a>2.3 查询示例</h3><p>来举个栗子吧，我们假设当前的隔离级别是 <code>READ COMMITTED</code>：</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">事务A(trx=1)</th>
<th align="center">事务B(trx=2)</th>
<th align="center">事务C(trx=3)</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>BEGIN;INSERT INTO(1, 1, 0);COMMIT;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>BEGIN;</code> <code>trx=4</code></td>
<td align="center"><code>UPDATE quantity = 100</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"><code>UPDATE quantity = 200</code></td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"><code>UPDATE quantity = 300</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>200</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>300</code></td>
</tr>
</tbody></table>
<p>分步骤来说：</p>
<ol>
<li>第 <code>1</code> 步，<code>事务A</code> 开启一个事务插入一条数据，这时候 <code>数据行的 trx_id = 1</code>；</li>
<li>第 <code>2</code> 步，<code>事务B</code> 和 <code>事务C</code> 分别开启事务，准备对这条数据蠢蠢欲动；</li>
<li>第 <code>3</code> 步：<ul>
<li><code>事务A</code> 又开启一个事务，分配了 <code>trx_id =  4</code>；</li>
<li>同时 <code>事务B</code> 更新了数量 <code>100</code>；</li>
</ul>
</li>
<li>第 <code>4</code> 步：<ul>
<li><code>事务B</code> 又更新了数量 <code>200</code>；</li>
</ul>
</li>
<li>第 <code>5</code> 步：<code>事务C</code> 也更新了数量 <code>300</code>，<code>事务A</code> 查询了数量，这时候 <strong>结果是</strong> <code>0</code>；</li>
<li>第 <code>6</code> 步：<code>事务B</code> 进行了提交；</li>
<li>第 <code>7</code> 步：<code>事务A</code> 查询了数量，<strong>结果是</strong> <code>200</code>；</li>
<li>第 <code>8</code> 步：<code>事务C</code> 提交；</li>
<li>第 <code>9</code> 步：<code>事务A</code> 查询数量，<strong>结果是</strong> <code>300</code>。</li>
</ol>
<p>那接下来讨论的就是上面的步骤中，<code>三次查询</code> 的结果：</p>
<p>第一次，发生在第 <code>5</code> 步：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p><code>事务A</code> 查询的时候创建了 <code>ReadView</code>，这时候根据上面的判断，迭代目前的数据版本：</p>
<p>我们看看第一个结果 <code>0</code>，发生在 <code>第 5 步</code>：</p>
<ol>
<li><p>第一条数据：</p>
<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li><p>第二条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第三条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第四条数据</p>
<p><code>trx_id = 1</code> 明显小于 <code>min_trx_id</code>，所以这条数据可以被 <code>事务A</code> 访问，返回数据 <code>0</code>。</p>
</li>
</ol>
<p>接下来看看第二个结果 <code>200</code>，发生在 <code>第 7 步</code>，这时候，<code>事务B</code> 已经提交了，所以 <code>ReadView</code> 的情况就是下面这种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114655.jpeg"></p>
<ol>
<li>第一条数据：<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li>第二条数据：<ol>
<li><code>trx_id = 2</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以返回这条数据，所以查询到的 <code>quantity = 200</code></li>
</ol>
</li>
</ol>
<p>然后，随着 <code>事务C</code> 也提交了，这时候系统中没有正在运行的事务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114656.jpeg"></p>
<p>那么第一条数据做第一个判断的时候，发现当前已经没有事务在运行了，所以这条记录是这个事务之前提交的，就会被访问到，直接返回 <code>300</code>。</p>
<p><strong>所以需要注意的是： <code>READ COMMITTED</code> 每次查询都会生成一个新的 <code>ReadView</code> 所以就发生了 <code>不可重复读</code>。</strong></p>
<p>那如果是 <code>REPEATABLE READ</code> ，他会在查询的时候就根据目前事务的情况创建 <code>ReadView</code> 了，也就是说，查询的时候，创建 <code>ReadView</code>，然后三次查询，都使用下图这个 <code>ReadView</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p>所以在这个事务结束之前，每次查询的结果，都只能拿到 <code>quantity = 0</code> 这条数据。</p>
<p>那之前我们说过，这个级别 <code>InnoDB</code> 实际上已经解决了幻读的问题，也是因为这个 <code>ReadView</code> 的原因，思考下，创建 <code>ReadView</code> 的时候，查询过程中就已经被限制返回为 <code>NULL</code> 了，所以没有 <code>幻读</code> 问题。</p>
<h2 id="三-更新数据时undo-log的清理-2"><a href="#三-更新数据时undo-log的清理-2" class="headerlink" title="三.更新数据时undo_log的清理"></a>三.更新数据时undo_log的清理</h2><p>那么 <code>undo log</code> 的日志会越堆积越多，总不能没有被清理的时候把。这个时间点就要把握在，接下来所有事务 <code>都不需要</code> 再访问这个 <code>undo log</code> 版本的时候，后台线程会清理掉。大概什么时候，就是 <code>UPDATE</code> 提交以后，后面的事务已经一致返回的是比当前这个 <code>UPDATE</code> 数据还要新的数据的时候，就已经可以清理掉了。</p>
<h2 id="四-小小结-2"><a href="#四-小小结-2" class="headerlink" title="四.小小结"></a>四.小小结</h2><p>通过 <code>版本并发控制管理MVCC</code> 来隔离数据。</p>
<p><code>事务A</code> 查询的时候创建了 <code>ReadView</code>，这时候根据上面的判断，迭代目前的数据版本：</p>
<p>我们看看第一个结果 <code>0</code>，发生在 <code>第 5 步</code>：</p>
<ol>
<li><p>第一条数据：</p>
<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li><p>第二条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第三条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第四条数据</p>
<p><code>trx_id = 1</code> 明显小于 <code>min_trx_id</code>，所以这条数据可以被 <code>事务A</code> 访问，返回数据 <code>0</code>。</p>
</li>
</ol>
<p>接下来看看第二个结果 <code>200</code>，发生在 <code>第 7 步</code>，这时候，<code>事务B</code> 已经提交了，所以 <code>ReadView</code> 的情况就是下面这种：</p>
<h2 id="一-事务的隔离-4"><a href="#一-事务的隔离-4" class="headerlink" title="一.事务的隔离"></a>一.事务的隔离</h2><p>刚开始我们说了事务的四个特性：<code>原子性</code> <code>一致性</code> <code>隔离性</code> <code>持久性</code>。</p>
<p>我们简单的分一下类： <code>redo log</code> 可以保证事务的 <code>原子性</code> 和 <code>持久性</code>，<code>undo log</code> 可以保证事务的 <code>一致性</code>，那么剩下的 <code>隔离性</code> 就由我们现在要说的 <code>MVCC</code> 来保证了。</p>
<p>那么隔离性是个啥，之前说过了，也就是可能出现 <code>脏写</code> <code>脏读</code> <code>幻读</code> <code>不可重复读</code> 等等这些状况。</p>
<p>简单回顾下：</p>
<ul>
<li>脏写：A事务提交的数据是B事务 <code>UPDATE</code> 的值 ，这个无论如何都不允许；</li>
<li>脏读：A事务中读取到了B事务中 <code>UPDATE</code> 的值（B事务未提交）；</li>
<li>不可重复读：A事务中两次读取，第二次读取到B事务已经提交的 <code>UPDATE</code> 的值（注意跟 <code>脏读</code> 的区别）；</li>
<li>幻读：A事务两次读取，第二次读取到B事务中提交的 <code>INSERT</code> 的值，但是如果A事务两次读取，第二次读不到B事务 <code>DELETE</code> 的数据，不属于幻读，幻读强调第二次读取的时候，多了数据；</li>
</ul>
<h2 id="二-MVCC-4"><a href="#二-MVCC-4" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><p><code>MVCC</code> 表示 <code>Multi-Version Concurrency Control</code>，<code>多版本并发控制</code>。也就是说在多个事务执行的情况下，可以控制事务读取到的数据版本的问题。</p>
<p>而 <code>MVCC</code> 的关键就在于之前 <code>undo log</code> 所说的 <code>版本链</code> 上。</p>
<h3 id="2-1-版本链-4"><a href="#2-1-版本链-4" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114652.jpeg"></p>
<p>之前说过这个图，第一次插入的时候，生成了第一条 <code>undo_insert_rec</code>，而对这个数据行做删除的时候，就会把数据行中的 <code>roll_pointer</code> 打断，连接到删除的 <code>undo log</code> 上，而 <code>undo log</code> 中的 <code>old_roll_pointer</code> 又指向了前一个插入的 <code>undo log</code> 中。</p>
<p>由于上面太乱我重新画张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114653.jpeg"></p>
<p>OK，这是一个产品入库的过程。两个事务对这个条数据发生了更新，假设事务A和事务B（事务A的 <code>trx_id=20</code>，事务B的 <code>trx_id=10</code>）。事务B修改库存为 <code>600</code>，而事务A做了两次修改，第一次是 <code>850</code> 第二次是 <code>1000</code>。所以上图中，比较低层的是旧的数据，比较高层的是新的数据。这个列表串起来就是一条数据的 <code>版本链</code>。</p>
<p>有了这个版本链还不够，还需要一个 <code>ReadView</code> 来辅助查询。</p>
<h3 id="2-2-ReadView-4"><a href="#2-2-ReadView-4" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>这个名字也很好理解了：<code>读取视图</code>。他发生在 <code>SELECT</code> 的时候，每次 <code>SELECT</code> 都会从数据表中生成一个 <code>ReadView</code>。</p>
<p><code>ReadView</code> 有几个非常重要的属性：</p>
<ul>
<li><code>m_ids</code>：生成时活跃的读写事务 <code>trx_id</code> 列表；</li>
<li><code>min_trx_id</code>：上面 <code>m_ids</code> 最小的值；</li>
<li><code>max_trx_id</code>：生成时应该分配给下一个事务的 <code>trx_id值</code>；</li>
<li><code>creator_trx_id</code>：当前事务的 <code>trx_id值</code>；</li>
</ul>
<p>那我们要查询上面的某条记录的时候，就需要根据 <code>ReadView</code> 中的那些值与 <code>undo log</code> 或者 <code>数据行</code> 中的 <code>trx_id</code> 比较，来拿到满足条件的最新一条的记录，就是当前事务可以访问到的数据。</p>
<p>怎么判断：</p>
<ol>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 与当前事务 <code>id</code> 相等，也就是与 <code>creator_trx_id</code> 说明这条数据在当前事务发生更改，所以当前事务可以访问；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 小于 <code>min_trx_id</code> 说明这个数据的改动在这个事务之前已经提交，所以可以被访问到；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 大于或等于 <code>max_trx_id</code>，说明该版本在这个事务之后发生的更改，所以这个版本不可见，继续遍历下一个版本；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 介于 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则需要判断事务是否存在于 <code>m_ids</code> 中：<ol>
<li>如果存在，说明创建的时候事务还在活跃中，数据版本不可见；</li>
<li>如果不存在，说明已经提交了，则数据版本可见</li>
</ol>
</li>
</ol>
<p>然后我们知道，数据库有不同的隔离级别，<code>MySQL</code> 有 <code>READ UNCOMMITTED</code> <code>READ COMMITTED</code> <code>REPEATABLE READ</code> <code>SERIALIZABLE</code>：</p>
<p><code>READ UNCOMMITTED</code>：所有遇到的问题情况都允许，所以不用考虑；</p>
<p><code>SERIALIZABLE</code>：所有查询写入均需要串行执行，所以也不用考虑。</p>
<p>那么主要就是 <code>READ COMMITTED</code> <code>REPEATABLE READ</code> 这两个隔离级别通过不同的方式来使用 <code>ReadView</code>。<code>READ COMMITTED</code> 是在每一次 <code>SELECT</code> 的时候生成 <code>ReadView</code>，而 <code>REPEATABLE READ</code> 则是在每次事务开始的时候生成的。</p>
<h3 id="2-3-查询示例-4"><a href="#2-3-查询示例-4" class="headerlink" title="2.3 查询示例"></a>2.3 查询示例</h3><p>来举个栗子吧，我们假设当前的隔离级别是 <code>READ COMMITTED</code>：</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">事务A(trx=1)</th>
<th align="center">事务B(trx=2)</th>
<th align="center">事务C(trx=3)</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>BEGIN;INSERT INTO(1, 1, 0);COMMIT;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>BEGIN;</code> <code>trx=4</code></td>
<td align="center"><code>UPDATE quantity = 100</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"><code>UPDATE quantity = 200</code></td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"><code>UPDATE quantity = 300</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>200</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>300</code></td>
</tr>
</tbody></table>
<p>分步骤来说：</p>
<ol>
<li>第 <code>1</code> 步，<code>事务A</code> 开启一个事务插入一条数据，这时候 <code>数据行的 trx_id = 1</code>；</li>
<li>第 <code>2</code> 步，<code>事务B</code> 和 <code>事务C</code> 分别开启事务，准备对这条数据蠢蠢欲动；</li>
<li>第 <code>3</code> 步：<ul>
<li><code>事务A</code> 又开启一个事务，分配了 <code>trx_id =  4</code>；</li>
<li>同时 <code>事务B</code> 更新了数量 <code>100</code>；</li>
</ul>
</li>
<li>第 <code>4</code> 步：<ul>
<li><code>事务B</code> 又更新了数量 <code>200</code>；</li>
</ul>
</li>
<li>第 <code>5</code> 步：<code>事务C</code> 也更新了数量 <code>300</code>，<code>事务A</code> 查询了数量，这时候 <strong>结果是</strong> <code>0</code>；</li>
<li>第 <code>6</code> 步：<code>事务B</code> 进行了提交；</li>
<li>第 <code>7</code> 步：<code>事务A</code> 查询了数量，<strong>结果是</strong> <code>200</code>；</li>
<li>第 <code>8</code> 步：<code>事务C</code> 提交；</li>
<li>第 <code>9</code> 步：<code>事务A</code> 查询数量，<strong>结果是</strong> <code>300</code>。</li>
</ol>
<p>那接下来讨论的就是上面的步骤中，<code>三次查询</code> 的结果：</p>
<p>第一次，发生在第 <code>5</code> 步：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p><code>事务A</code> 查询的时候创建了 <code>ReadView</code>，这时候根据上面的判断，迭代目前的数据版本：</p>
<p>我们看看第一个结果 <code>0</code>，发生在 <code>第 5 步</code>：</p>
<ol>
<li><p>第一条数据：</p>
<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li><p>第二条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第三条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第四条数据</p>
<p><code>trx_id = 1</code> 明显小于 <code>min_trx_id</code>，所以这条数据可以被 <code>事务A</code> 访问，返回数据 <code>0</code>。</p>
</li>
</ol>
<p>接下来看看第二个结果 <code>200</code>，发生在 <code>第 7 步</code>，这时候，<code>事务B</code> 已经提交了，所以 <code>ReadView</code> 的情况就是下面这种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114655.jpeg"></p>
<ol>
<li>第一条数据：<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li>第二条数据：<ol>
<li><code>trx_id = 2</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以返回这条数据，所以查询到的 <code>quantity = 200</code></li>
</ol>
</li>
</ol>
<p>然后，随着 <code>事务C</code> 也提交了，这时候系统中没有正在运行的事务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114656.jpeg"></p>
<p>那么第一条数据做第一个判断的时候，发现当前已经没有事务在运行了，所以这条记录是这个事务之前提交的，就会被访问到，直接返回 <code>300</code>。</p>
<p><strong>所以需要注意的是： <code>READ COMMITTED</code> 每次查询都会生成一个新的 <code>ReadView</code> 所以就发生了 <code>不可重复读</code>。</strong></p>
<p>那如果是 <code>REPEATABLE READ</code> ，他会在查询的时候就根据目前事务的情况创建 <code>ReadView</code> 了，也就是说，查询的时候，创建 <code>ReadView</code>，然后三次查询，都使用下图这个 <code>ReadView</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p>所以在这个事务结束之前，每次查询的结果，都只能拿到 <code>quantity = 0</code> 这条数据。</p>
<p>那之前我们说过，这个级别 <code>InnoDB</code> 实际上已经解决了幻读的问题，也是因为这个 <code>ReadView</code> 的原因，思考下，创建 <code>ReadView</code> 的时候，查询过程中就已经被限制返回为 <code>NULL</code> 了，所以没有 <code>幻读</code> 问题。</p>
<h2 id="三-更新数据时undo-log的清理-3"><a href="#三-更新数据时undo-log的清理-3" class="headerlink" title="三.更新数据时undo_log的清理"></a>三.更新数据时undo_log的清理</h2><p>那么 <code>undo log</code> 的日志会越堆积越多，总不能没有被清理的时候把。这个时间点就要把握在，接下来所有事务 <code>都不需要</code> 再访问这个 <code>undo log</code> 版本的时候，后台线程会清理掉。大概什么时候，就是 <code>UPDATE</code> 提交以后，后面的事务已经一致返回的是比当前这个 <code>UPDATE</code> 数据还要新的数据的时候，就已经可以清理掉了。</p>
<h2 id="四-小小结-3"><a href="#四-小小结-3" class="headerlink" title="四.小小结"></a>四.小小结</h2><p>通过 <code>版本并发控制管理MVCC</code> 来隔离数据。</p>
<ol>
<li>第一条数据：<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li>第二条数据：<ol>
<li><code>trx_id = 2</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以返回这条数据，所以查询到的 <code>quantity = 200</code></li>
</ol>
</li>
</ol>
<p>然后，随着 <code>事务C</code> 也提交了，这时候系统中没有正在运行的事务：</p>
<h2 id="一-事务的隔离-5"><a href="#一-事务的隔离-5" class="headerlink" title="一.事务的隔离"></a>一.事务的隔离</h2><p>刚开始我们说了事务的四个特性：<code>原子性</code> <code>一致性</code> <code>隔离性</code> <code>持久性</code>。</p>
<p>我们简单的分一下类： <code>redo log</code> 可以保证事务的 <code>原子性</code> 和 <code>持久性</code>，<code>undo log</code> 可以保证事务的 <code>一致性</code>，那么剩下的 <code>隔离性</code> 就由我们现在要说的 <code>MVCC</code> 来保证了。</p>
<p>那么隔离性是个啥，之前说过了，也就是可能出现 <code>脏写</code> <code>脏读</code> <code>幻读</code> <code>不可重复读</code> 等等这些状况。</p>
<p>简单回顾下：</p>
<ul>
<li>脏写：A事务提交的数据是B事务 <code>UPDATE</code> 的值 ，这个无论如何都不允许；</li>
<li>脏读：A事务中读取到了B事务中 <code>UPDATE</code> 的值（B事务未提交）；</li>
<li>不可重复读：A事务中两次读取，第二次读取到B事务已经提交的 <code>UPDATE</code> 的值（注意跟 <code>脏读</code> 的区别）；</li>
<li>幻读：A事务两次读取，第二次读取到B事务中提交的 <code>INSERT</code> 的值，但是如果A事务两次读取，第二次读不到B事务 <code>DELETE</code> 的数据，不属于幻读，幻读强调第二次读取的时候，多了数据；</li>
</ul>
<h2 id="二-MVCC-5"><a href="#二-MVCC-5" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><p><code>MVCC</code> 表示 <code>Multi-Version Concurrency Control</code>，<code>多版本并发控制</code>。也就是说在多个事务执行的情况下，可以控制事务读取到的数据版本的问题。</p>
<p>而 <code>MVCC</code> 的关键就在于之前 <code>undo log</code> 所说的 <code>版本链</code> 上。</p>
<h3 id="2-1-版本链-5"><a href="#2-1-版本链-5" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114652.jpeg"></p>
<p>之前说过这个图，第一次插入的时候，生成了第一条 <code>undo_insert_rec</code>，而对这个数据行做删除的时候，就会把数据行中的 <code>roll_pointer</code> 打断，连接到删除的 <code>undo log</code> 上，而 <code>undo log</code> 中的 <code>old_roll_pointer</code> 又指向了前一个插入的 <code>undo log</code> 中。</p>
<p>由于上面太乱我重新画张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114653.jpeg"></p>
<p>OK，这是一个产品入库的过程。两个事务对这个条数据发生了更新，假设事务A和事务B（事务A的 <code>trx_id=20</code>，事务B的 <code>trx_id=10</code>）。事务B修改库存为 <code>600</code>，而事务A做了两次修改，第一次是 <code>850</code> 第二次是 <code>1000</code>。所以上图中，比较低层的是旧的数据，比较高层的是新的数据。这个列表串起来就是一条数据的 <code>版本链</code>。</p>
<p>有了这个版本链还不够，还需要一个 <code>ReadView</code> 来辅助查询。</p>
<h3 id="2-2-ReadView-5"><a href="#2-2-ReadView-5" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>这个名字也很好理解了：<code>读取视图</code>。他发生在 <code>SELECT</code> 的时候，每次 <code>SELECT</code> 都会从数据表中生成一个 <code>ReadView</code>。</p>
<p><code>ReadView</code> 有几个非常重要的属性：</p>
<ul>
<li><code>m_ids</code>：生成时活跃的读写事务 <code>trx_id</code> 列表；</li>
<li><code>min_trx_id</code>：上面 <code>m_ids</code> 最小的值；</li>
<li><code>max_trx_id</code>：生成时应该分配给下一个事务的 <code>trx_id值</code>；</li>
<li><code>creator_trx_id</code>：当前事务的 <code>trx_id值</code>；</li>
</ul>
<p>那我们要查询上面的某条记录的时候，就需要根据 <code>ReadView</code> 中的那些值与 <code>undo log</code> 或者 <code>数据行</code> 中的 <code>trx_id</code> 比较，来拿到满足条件的最新一条的记录，就是当前事务可以访问到的数据。</p>
<p>怎么判断：</p>
<ol>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 与当前事务 <code>id</code> 相等，也就是与 <code>creator_trx_id</code> 说明这条数据在当前事务发生更改，所以当前事务可以访问；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 小于 <code>min_trx_id</code> 说明这个数据的改动在这个事务之前已经提交，所以可以被访问到；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 大于或等于 <code>max_trx_id</code>，说明该版本在这个事务之后发生的更改，所以这个版本不可见，继续遍历下一个版本；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 介于 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则需要判断事务是否存在于 <code>m_ids</code> 中：<ol>
<li>如果存在，说明创建的时候事务还在活跃中，数据版本不可见；</li>
<li>如果不存在，说明已经提交了，则数据版本可见</li>
</ol>
</li>
</ol>
<p>然后我们知道，数据库有不同的隔离级别，<code>MySQL</code> 有 <code>READ UNCOMMITTED</code> <code>READ COMMITTED</code> <code>REPEATABLE READ</code> <code>SERIALIZABLE</code>：</p>
<p><code>READ UNCOMMITTED</code>：所有遇到的问题情况都允许，所以不用考虑；</p>
<p><code>SERIALIZABLE</code>：所有查询写入均需要串行执行，所以也不用考虑。</p>
<p>那么主要就是 <code>READ COMMITTED</code> <code>REPEATABLE READ</code> 这两个隔离级别通过不同的方式来使用 <code>ReadView</code>。<code>READ COMMITTED</code> 是在每一次 <code>SELECT</code> 的时候生成 <code>ReadView</code>，而 <code>REPEATABLE READ</code> 则是在每次事务开始的时候生成的。</p>
<h3 id="2-3-查询示例-5"><a href="#2-3-查询示例-5" class="headerlink" title="2.3 查询示例"></a>2.3 查询示例</h3><p>来举个栗子吧，我们假设当前的隔离级别是 <code>READ COMMITTED</code>：</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">事务A(trx=1)</th>
<th align="center">事务B(trx=2)</th>
<th align="center">事务C(trx=3)</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>BEGIN;INSERT INTO(1, 1, 0);COMMIT;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>BEGIN;</code> <code>trx=4</code></td>
<td align="center"><code>UPDATE quantity = 100</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"><code>UPDATE quantity = 200</code></td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"><code>UPDATE quantity = 300</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>200</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>300</code></td>
</tr>
</tbody></table>
<p>分步骤来说：</p>
<ol>
<li>第 <code>1</code> 步，<code>事务A</code> 开启一个事务插入一条数据，这时候 <code>数据行的 trx_id = 1</code>；</li>
<li>第 <code>2</code> 步，<code>事务B</code> 和 <code>事务C</code> 分别开启事务，准备对这条数据蠢蠢欲动；</li>
<li>第 <code>3</code> 步：<ul>
<li><code>事务A</code> 又开启一个事务，分配了 <code>trx_id =  4</code>；</li>
<li>同时 <code>事务B</code> 更新了数量 <code>100</code>；</li>
</ul>
</li>
<li>第 <code>4</code> 步：<ul>
<li><code>事务B</code> 又更新了数量 <code>200</code>；</li>
</ul>
</li>
<li>第 <code>5</code> 步：<code>事务C</code> 也更新了数量 <code>300</code>，<code>事务A</code> 查询了数量，这时候 <strong>结果是</strong> <code>0</code>；</li>
<li>第 <code>6</code> 步：<code>事务B</code> 进行了提交；</li>
<li>第 <code>7</code> 步：<code>事务A</code> 查询了数量，<strong>结果是</strong> <code>200</code>；</li>
<li>第 <code>8</code> 步：<code>事务C</code> 提交；</li>
<li>第 <code>9</code> 步：<code>事务A</code> 查询数量，<strong>结果是</strong> <code>300</code>。</li>
</ol>
<p>那接下来讨论的就是上面的步骤中，<code>三次查询</code> 的结果：</p>
<p>第一次，发生在第 <code>5</code> 步：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p><code>事务A</code> 查询的时候创建了 <code>ReadView</code>，这时候根据上面的判断，迭代目前的数据版本：</p>
<p>我们看看第一个结果 <code>0</code>，发生在 <code>第 5 步</code>：</p>
<ol>
<li><p>第一条数据：</p>
<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li><p>第二条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第三条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第四条数据</p>
<p><code>trx_id = 1</code> 明显小于 <code>min_trx_id</code>，所以这条数据可以被 <code>事务A</code> 访问，返回数据 <code>0</code>。</p>
</li>
</ol>
<p>接下来看看第二个结果 <code>200</code>，发生在 <code>第 7 步</code>，这时候，<code>事务B</code> 已经提交了，所以 <code>ReadView</code> 的情况就是下面这种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114655.jpeg"></p>
<ol>
<li>第一条数据：<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li>第二条数据：<ol>
<li><code>trx_id = 2</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以返回这条数据，所以查询到的 <code>quantity = 200</code></li>
</ol>
</li>
</ol>
<p>然后，随着 <code>事务C</code> 也提交了，这时候系统中没有正在运行的事务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114656.jpeg"></p>
<p>那么第一条数据做第一个判断的时候，发现当前已经没有事务在运行了，所以这条记录是这个事务之前提交的，就会被访问到，直接返回 <code>300</code>。</p>
<p><strong>所以需要注意的是： <code>READ COMMITTED</code> 每次查询都会生成一个新的 <code>ReadView</code> 所以就发生了 <code>不可重复读</code>。</strong></p>
<p>那如果是 <code>REPEATABLE READ</code> ，他会在查询的时候就根据目前事务的情况创建 <code>ReadView</code> 了，也就是说，查询的时候，创建 <code>ReadView</code>，然后三次查询，都使用下图这个 <code>ReadView</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p>所以在这个事务结束之前，每次查询的结果，都只能拿到 <code>quantity = 0</code> 这条数据。</p>
<p>那之前我们说过，这个级别 <code>InnoDB</code> 实际上已经解决了幻读的问题，也是因为这个 <code>ReadView</code> 的原因，思考下，创建 <code>ReadView</code> 的时候，查询过程中就已经被限制返回为 <code>NULL</code> 了，所以没有 <code>幻读</code> 问题。</p>
<h2 id="三-更新数据时undo-log的清理-4"><a href="#三-更新数据时undo-log的清理-4" class="headerlink" title="三.更新数据时undo_log的清理"></a>三.更新数据时undo_log的清理</h2><p>那么 <code>undo log</code> 的日志会越堆积越多，总不能没有被清理的时候把。这个时间点就要把握在，接下来所有事务 <code>都不需要</code> 再访问这个 <code>undo log</code> 版本的时候，后台线程会清理掉。大概什么时候，就是 <code>UPDATE</code> 提交以后，后面的事务已经一致返回的是比当前这个 <code>UPDATE</code> 数据还要新的数据的时候，就已经可以清理掉了。</p>
<h2 id="四-小小结-4"><a href="#四-小小结-4" class="headerlink" title="四.小小结"></a>四.小小结</h2><p>通过 <code>版本并发控制管理MVCC</code> 来隔离数据。</p>
<p>那么第一条数据做第一个判断的时候，发现当前已经没有事务在运行了，所以这条记录是这个事务之前提交的，就会被访问到，直接返回 <code>300</code>。</p>
<p><strong>所以需要注意的是： <code>READ COMMITTED</code> 每次查询都会生成一个新的 <code>ReadView</code> 所以就发生了 <code>不可重复读</code>。</strong></p>
<p>那如果是 <code>REPEATABLE READ</code> ，他会在查询的时候就根据目前事务的情况创建 <code>ReadView</code> 了，也就是说，查询的时候，创建 <code>ReadView</code>，然后三次查询，都使用下图这个 <code>ReadView</code>：</p>
<h2 id="一-事务的隔离-6"><a href="#一-事务的隔离-6" class="headerlink" title="一.事务的隔离"></a>一.事务的隔离</h2><p>刚开始我们说了事务的四个特性：<code>原子性</code> <code>一致性</code> <code>隔离性</code> <code>持久性</code>。</p>
<p>我们简单的分一下类： <code>redo log</code> 可以保证事务的 <code>原子性</code> 和 <code>持久性</code>，<code>undo log</code> 可以保证事务的 <code>一致性</code>，那么剩下的 <code>隔离性</code> 就由我们现在要说的 <code>MVCC</code> 来保证了。</p>
<p>那么隔离性是个啥，之前说过了，也就是可能出现 <code>脏写</code> <code>脏读</code> <code>幻读</code> <code>不可重复读</code> 等等这些状况。</p>
<p>简单回顾下：</p>
<ul>
<li>脏写：A事务提交的数据是B事务 <code>UPDATE</code> 的值 ，这个无论如何都不允许；</li>
<li>脏读：A事务中读取到了B事务中 <code>UPDATE</code> 的值（B事务未提交）；</li>
<li>不可重复读：A事务中两次读取，第二次读取到B事务已经提交的 <code>UPDATE</code> 的值（注意跟 <code>脏读</code> 的区别）；</li>
<li>幻读：A事务两次读取，第二次读取到B事务中提交的 <code>INSERT</code> 的值，但是如果A事务两次读取，第二次读不到B事务 <code>DELETE</code> 的数据，不属于幻读，幻读强调第二次读取的时候，多了数据；</li>
</ul>
<h2 id="二-MVCC-6"><a href="#二-MVCC-6" class="headerlink" title="二.MVCC"></a>二.MVCC</h2><p><code>MVCC</code> 表示 <code>Multi-Version Concurrency Control</code>，<code>多版本并发控制</code>。也就是说在多个事务执行的情况下，可以控制事务读取到的数据版本的问题。</p>
<p>而 <code>MVCC</code> 的关键就在于之前 <code>undo log</code> 所说的 <code>版本链</code> 上。</p>
<h3 id="2-1-版本链-6"><a href="#2-1-版本链-6" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114652.jpeg"></p>
<p>之前说过这个图，第一次插入的时候，生成了第一条 <code>undo_insert_rec</code>，而对这个数据行做删除的时候，就会把数据行中的 <code>roll_pointer</code> 打断，连接到删除的 <code>undo log</code> 上，而 <code>undo log</code> 中的 <code>old_roll_pointer</code> 又指向了前一个插入的 <code>undo log</code> 中。</p>
<p>由于上面太乱我重新画张图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114653.jpeg"></p>
<p>OK，这是一个产品入库的过程。两个事务对这个条数据发生了更新，假设事务A和事务B（事务A的 <code>trx_id=20</code>，事务B的 <code>trx_id=10</code>）。事务B修改库存为 <code>600</code>，而事务A做了两次修改，第一次是 <code>850</code> 第二次是 <code>1000</code>。所以上图中，比较低层的是旧的数据，比较高层的是新的数据。这个列表串起来就是一条数据的 <code>版本链</code>。</p>
<p>有了这个版本链还不够，还需要一个 <code>ReadView</code> 来辅助查询。</p>
<h3 id="2-2-ReadView-6"><a href="#2-2-ReadView-6" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>这个名字也很好理解了：<code>读取视图</code>。他发生在 <code>SELECT</code> 的时候，每次 <code>SELECT</code> 都会从数据表中生成一个 <code>ReadView</code>。</p>
<p><code>ReadView</code> 有几个非常重要的属性：</p>
<ul>
<li><code>m_ids</code>：生成时活跃的读写事务 <code>trx_id</code> 列表；</li>
<li><code>min_trx_id</code>：上面 <code>m_ids</code> 最小的值；</li>
<li><code>max_trx_id</code>：生成时应该分配给下一个事务的 <code>trx_id值</code>；</li>
<li><code>creator_trx_id</code>：当前事务的 <code>trx_id值</code>；</li>
</ul>
<p>那我们要查询上面的某条记录的时候，就需要根据 <code>ReadView</code> 中的那些值与 <code>undo log</code> 或者 <code>数据行</code> 中的 <code>trx_id</code> 比较，来拿到满足条件的最新一条的记录，就是当前事务可以访问到的数据。</p>
<p>怎么判断：</p>
<ol>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 与当前事务 <code>id</code> 相等，也就是与 <code>creator_trx_id</code> 说明这条数据在当前事务发生更改，所以当前事务可以访问；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 小于 <code>min_trx_id</code> 说明这个数据的改动在这个事务之前已经提交，所以可以被访问到；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 大于或等于 <code>max_trx_id</code>，说明该版本在这个事务之后发生的更改，所以这个版本不可见，继续遍历下一个版本；</li>
<li>如果 <code>数据行</code> 的 <code>trx_id</code> 介于 <code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，则需要判断事务是否存在于 <code>m_ids</code> 中：<ol>
<li>如果存在，说明创建的时候事务还在活跃中，数据版本不可见；</li>
<li>如果不存在，说明已经提交了，则数据版本可见</li>
</ol>
</li>
</ol>
<p>然后我们知道，数据库有不同的隔离级别，<code>MySQL</code> 有 <code>READ UNCOMMITTED</code> <code>READ COMMITTED</code> <code>REPEATABLE READ</code> <code>SERIALIZABLE</code>：</p>
<p><code>READ UNCOMMITTED</code>：所有遇到的问题情况都允许，所以不用考虑；</p>
<p><code>SERIALIZABLE</code>：所有查询写入均需要串行执行，所以也不用考虑。</p>
<p>那么主要就是 <code>READ COMMITTED</code> <code>REPEATABLE READ</code> 这两个隔离级别通过不同的方式来使用 <code>ReadView</code>。<code>READ COMMITTED</code> 是在每一次 <code>SELECT</code> 的时候生成 <code>ReadView</code>，而 <code>REPEATABLE READ</code> 则是在每次事务开始的时候生成的。</p>
<h3 id="2-3-查询示例-6"><a href="#2-3-查询示例-6" class="headerlink" title="2.3 查询示例"></a>2.3 查询示例</h3><p>来举个栗子吧，我们假设当前的隔离级别是 <code>READ COMMITTED</code>：</p>
<table>
<thead>
<tr>
<th align="center">步骤</th>
<th align="center">事务A(trx=1)</th>
<th align="center">事务B(trx=2)</th>
<th align="center">事务C(trx=3)</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>BEGIN;INSERT INTO(1, 1, 0);COMMIT;</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"><code>BEGIN;</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>BEGIN;</code> <code>trx=4</code></td>
<td align="center"><code>UPDATE quantity = 100</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"><code>UPDATE quantity = 200</code></td>
<td align="center"><code>UPDATE xxx(为了分配到trx_id)</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"><code>UPDATE quantity = 300</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>200</code></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>COMMIT</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><code>SELECT quantity</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>300</code></td>
</tr>
</tbody></table>
<p>分步骤来说：</p>
<ol>
<li>第 <code>1</code> 步，<code>事务A</code> 开启一个事务插入一条数据，这时候 <code>数据行的 trx_id = 1</code>；</li>
<li>第 <code>2</code> 步，<code>事务B</code> 和 <code>事务C</code> 分别开启事务，准备对这条数据蠢蠢欲动；</li>
<li>第 <code>3</code> 步：<ul>
<li><code>事务A</code> 又开启一个事务，分配了 <code>trx_id =  4</code>；</li>
<li>同时 <code>事务B</code> 更新了数量 <code>100</code>；</li>
</ul>
</li>
<li>第 <code>4</code> 步：<ul>
<li><code>事务B</code> 又更新了数量 <code>200</code>；</li>
</ul>
</li>
<li>第 <code>5</code> 步：<code>事务C</code> 也更新了数量 <code>300</code>，<code>事务A</code> 查询了数量，这时候 <strong>结果是</strong> <code>0</code>；</li>
<li>第 <code>6</code> 步：<code>事务B</code> 进行了提交；</li>
<li>第 <code>7</code> 步：<code>事务A</code> 查询了数量，<strong>结果是</strong> <code>200</code>；</li>
<li>第 <code>8</code> 步：<code>事务C</code> 提交；</li>
<li>第 <code>9</code> 步：<code>事务A</code> 查询数量，<strong>结果是</strong> <code>300</code>。</li>
</ol>
<p>那接下来讨论的就是上面的步骤中，<code>三次查询</code> 的结果：</p>
<p>第一次，发生在第 <code>5</code> 步：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p><code>事务A</code> 查询的时候创建了 <code>ReadView</code>，这时候根据上面的判断，迭代目前的数据版本：</p>
<p>我们看看第一个结果 <code>0</code>，发生在 <code>第 5 步</code>：</p>
<ol>
<li><p>第一条数据：</p>
<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li><p>第二条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第三条数据：</p>
<p>…【与上面一样】</p>
</li>
<li><p>第四条数据</p>
<p><code>trx_id = 1</code> 明显小于 <code>min_trx_id</code>，所以这条数据可以被 <code>事务A</code> 访问，返回数据 <code>0</code>。</p>
</li>
</ol>
<p>接下来看看第二个结果 <code>200</code>，发生在 <code>第 7 步</code>，这时候，<code>事务B</code> 已经提交了，所以 <code>ReadView</code> 的情况就是下面这种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114655.jpeg"></p>
<ol>
<li>第一条数据：<ol>
<li><code>trx_id = 3</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>明显当前 <code>trx_id</code> 大于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以继续下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>max_trx_id</code>，所以这个判断不执行；</li>
<li>当前 <code>trx_id</code> 存在于 <code>m_ids</code> 中，说明开启事务的时候，这个版本还在其他事务范围之内，所以这条不能被访问；</li>
</ol>
</li>
<li>第二条数据：<ol>
<li><code>trx_id = 2</code>，不等于 <code>ReadView</code> 的 <code>creator_trx_id</code>，所以这个条件不满足，下一个判断，</li>
<li>当前 <code>trx_id</code> 小于 <code>ReadView</code> 的 <code>min_trx_id</code>，所以返回这条数据，所以查询到的 <code>quantity = 200</code></li>
</ol>
</li>
</ol>
<p>然后，随着 <code>事务C</code> 也提交了，这时候系统中没有正在运行的事务：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114656.jpeg"></p>
<p>那么第一条数据做第一个判断的时候，发现当前已经没有事务在运行了，所以这条记录是这个事务之前提交的，就会被访问到，直接返回 <code>300</code>。</p>
<p><strong>所以需要注意的是： <code>READ COMMITTED</code> 每次查询都会生成一个新的 <code>ReadView</code> 所以就发生了 <code>不可重复读</code>。</strong></p>
<p>那如果是 <code>REPEATABLE READ</code> ，他会在查询的时候就根据目前事务的情况创建 <code>ReadView</code> 了，也就是说，查询的时候，创建 <code>ReadView</code>，然后三次查询，都使用下图这个 <code>ReadView</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114654.jpeg"></p>
<p>所以在这个事务结束之前，每次查询的结果，都只能拿到 <code>quantity = 0</code> 这条数据。</p>
<p>那之前我们说过，这个级别 <code>InnoDB</code> 实际上已经解决了幻读的问题，也是因为这个 <code>ReadView</code> 的原因，思考下，创建 <code>ReadView</code> 的时候，查询过程中就已经被限制返回为 <code>NULL</code> 了，所以没有 <code>幻读</code> 问题。</p>
<h2 id="三-更新数据时undo-log的清理-5"><a href="#三-更新数据时undo-log的清理-5" class="headerlink" title="三.更新数据时undo_log的清理"></a>三.更新数据时undo_log的清理</h2><p>那么 <code>undo log</code> 的日志会越堆积越多，总不能没有被清理的时候把。这个时间点就要把握在，接下来所有事务 <code>都不需要</code> 再访问这个 <code>undo log</code> 版本的时候，后台线程会清理掉。大概什么时候，就是 <code>UPDATE</code> 提交以后，后面的事务已经一致返回的是比当前这个 <code>UPDATE</code> 数据还要新的数据的时候，就已经可以清理掉了。</p>
<h2 id="四-小小结-5"><a href="#四-小小结-5" class="headerlink" title="四.小小结"></a>四.小小结</h2><p>通过 <code>版本并发控制管理MVCC</code> 来隔离数据。</p>
<p>所以在这个事务结束之前，每次查询的结果，都只能拿到 <code>quantity = 0</code> 这条数据。</p>
<p>那之前我们说过，这个级别 <code>InnoDB</code> 实际上已经解决了幻读的问题，也是因为这个 <code>ReadView</code> 的原因，思考下，创建 <code>ReadView</code> 的时候，查询过程中就已经被限制返回为 <code>NULL</code> 了，所以没有 <code>幻读</code> 问题。</p>
<h2 id="三-更新数据时undo-log的清理-6"><a href="#三-更新数据时undo-log的清理-6" class="headerlink" title="三.更新数据时undo_log的清理"></a>三.更新数据时undo_log的清理</h2><p>那么 <code>undo log</code> 的日志会越堆积越多，总不能没有被清理的时候把。这个时间点就要把握在，接下来所有事务 <code>都不需要</code> 再访问这个 <code>undo log</code> 版本的时候，后台线程会清理掉。大概什么时候，就是 <code>UPDATE</code> 提交以后，后面的事务已经一致返回的是比当前这个 <code>UPDATE</code> 数据还要新的数据的时候，就已经可以清理掉了。</p>
<h2 id="四-小小结-6"><a href="#四-小小结-6" class="headerlink" title="四.小小结"></a>四.小小结</h2><p>通过 <code>版本并发控制管理MVCC</code> 来隔离数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B9%9D-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bundo-log/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B9%9D-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bundo-log/" class="post-title-link" itemprop="url">【聊聊MySQL】九.MySQL-InnoDB的数据库事务的执行之UNDO_LOG</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-17 17:36:26" itemprop="dateCreated datePublished" datetime="2020-03-17T17:36:26+08:00">2020-03-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 11:39:17" itemprop="dateModified" datetime="2020-11-10T11:39:17+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-UNDO-LOG"><a href="#一-UNDO-LOG" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚"><a href="#二-想象中的回滚" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务"><a href="#三-找到对应的事务" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式"><a href="#四-UNDO通用日志格式" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<h2 id="一-UNDO-LOG-1"><a href="#一-UNDO-LOG-1" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-1"><a href="#二-想象中的回滚-1" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-1"><a href="#三-找到对应的事务-1" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-1"><a href="#四-UNDO通用日志格式-1" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类"><a href="#五-UNDO日志分类" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log"><a href="#5-1-insert-undo-log" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除"><a href="#5-2-update-undo-log-之删除" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）"><a href="#5-2-update-undo-log-之更新（更新主键的情况）" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表"><a href="#六-UNDO-LOG数据页链表" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构"><a href="#6-1-数据页链表结构" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页"><a href="#6-2-事务并发执行的链表页" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用"><a href="#6-3-undo-log页的重用" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段"><a href="#七-回滚段" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类"><a href="#回滚段分类" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结"><a href="#八-小结" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。 </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-1"><a href="#五-UNDO日志分类-1" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-1"><a href="#5-1-insert-undo-log-1" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<h2 id="一-UNDO-LOG-2"><a href="#一-UNDO-LOG-2" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-2"><a href="#二-想象中的回滚-2" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-2"><a href="#三-找到对应的事务-2" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-2"><a href="#四-UNDO通用日志格式-2" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-2"><a href="#五-UNDO日志分类-2" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-2"><a href="#5-1-insert-undo-log-2" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-1"><a href="#5-2-update-undo-log-之删除-1" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-1"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-1" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-1"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-1" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-1"><a href="#六-UNDO-LOG数据页链表-1" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-1"><a href="#6-1-数据页链表结构-1" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-1"><a href="#6-2-事务并发执行的链表页-1" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-1"><a href="#6-3-undo-log页的重用-1" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-1"><a href="#七-回滚段-1" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-1"><a href="#回滚段分类-1" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-1"><a href="#八-小结-1" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。 </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-2"><a href="#5-2-update-undo-log-之删除-2" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<h2 id="一-UNDO-LOG-3"><a href="#一-UNDO-LOG-3" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-3"><a href="#二-想象中的回滚-3" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-3"><a href="#三-找到对应的事务-3" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-3"><a href="#四-UNDO通用日志格式-3" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-3"><a href="#五-UNDO日志分类-3" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-3"><a href="#5-1-insert-undo-log-3" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-3"><a href="#5-2-update-undo-log-之删除-3" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-2"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-2" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-2"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-2" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-2"><a href="#六-UNDO-LOG数据页链表-2" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-2"><a href="#6-1-数据页链表结构-2" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-2"><a href="#6-2-事务并发执行的链表页-2" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-2"><a href="#6-3-undo-log页的重用-2" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-2"><a href="#七-回滚段-2" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-2"><a href="#回滚段分类-2" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-2"><a href="#八-小结-2" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。 </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<h2 id="一-UNDO-LOG-4"><a href="#一-UNDO-LOG-4" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-4"><a href="#二-想象中的回滚-4" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-4"><a href="#三-找到对应的事务-4" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-4"><a href="#四-UNDO通用日志格式-4" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-4"><a href="#五-UNDO日志分类-4" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-4"><a href="#5-1-insert-undo-log-4" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-4"><a href="#5-2-update-undo-log-之删除-4" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-3"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-3" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-3"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-3" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-3"><a href="#六-UNDO-LOG数据页链表-3" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-3"><a href="#6-1-数据页链表结构-3" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-3"><a href="#6-2-事务并发执行的链表页-3" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-3"><a href="#6-3-undo-log页的重用-3" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-3"><a href="#七-回滚段-3" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-3"><a href="#回滚段分类-3" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-3"><a href="#八-小结-3" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。 </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h2 id="一-UNDO-LOG-5"><a href="#一-UNDO-LOG-5" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-5"><a href="#二-想象中的回滚-5" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-5"><a href="#三-找到对应的事务-5" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-5"><a href="#四-UNDO通用日志格式-5" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-5"><a href="#五-UNDO日志分类-5" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-5"><a href="#5-1-insert-undo-log-5" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-5"><a href="#5-2-update-undo-log-之删除-5" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-4"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-4" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-4"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-4" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-4"><a href="#六-UNDO-LOG数据页链表-4" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-4"><a href="#6-1-数据页链表结构-4" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-4"><a href="#6-2-事务并发执行的链表页-4" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-4"><a href="#6-3-undo-log页的重用-4" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-4"><a href="#七-回滚段-4" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-4"><a href="#回滚段分类-4" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-4"><a href="#八-小结-4" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。 </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<h2 id="一-UNDO-LOG-6"><a href="#一-UNDO-LOG-6" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-6"><a href="#二-想象中的回滚-6" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-6"><a href="#三-找到对应的事务-6" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-6"><a href="#四-UNDO通用日志格式-6" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-6"><a href="#五-UNDO日志分类-6" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-6"><a href="#5-1-insert-undo-log-6" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-6"><a href="#5-2-update-undo-log-之删除-6" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-5"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-5" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-5"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-5" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-5"><a href="#六-UNDO-LOG数据页链表-5" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-5"><a href="#6-1-数据页链表结构-5" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-5"><a href="#6-2-事务并发执行的链表页-5" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-5"><a href="#6-3-undo-log页的重用-5" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-5"><a href="#七-回滚段-5" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-5"><a href="#回滚段分类-5" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-5"><a href="#八-小结-5" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。</p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-6"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-6" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<h2 id="一-UNDO-LOG-7"><a href="#一-UNDO-LOG-7" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-7"><a href="#二-想象中的回滚-7" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-7"><a href="#三-找到对应的事务-7" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-7"><a href="#四-UNDO通用日志格式-7" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-7"><a href="#五-UNDO日志分类-7" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-7"><a href="#5-1-insert-undo-log-7" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-7"><a href="#5-2-update-undo-log-之删除-7" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-7"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-7" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-6"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-6" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-6"><a href="#六-UNDO-LOG数据页链表-6" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-6"><a href="#6-1-数据页链表结构-6" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-6"><a href="#6-2-事务并发执行的链表页-6" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-6"><a href="#6-3-undo-log页的重用-6" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-6"><a href="#七-回滚段-6" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-6"><a href="#回滚段分类-6" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-6"><a href="#八-小结-6" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。 OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-7"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-7" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-7"><a href="#六-UNDO-LOG数据页链表-7" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-7"><a href="#6-1-数据页链表结构-7" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<h2 id="一-UNDO-LOG-8"><a href="#一-UNDO-LOG-8" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-8"><a href="#二-想象中的回滚-8" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-8"><a href="#三-找到对应的事务-8" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-8"><a href="#四-UNDO通用日志格式-8" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-8"><a href="#五-UNDO日志分类-8" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-8"><a href="#5-1-insert-undo-log-8" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-8"><a href="#5-2-update-undo-log-之删除-8" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-8"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-8" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-8"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-8" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-8"><a href="#六-UNDO-LOG数据页链表-8" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-8"><a href="#6-1-数据页链表结构-8" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-7"><a href="#6-2-事务并发执行的链表页-7" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-7"><a href="#6-3-undo-log页的重用-7" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-7"><a href="#七-回滚段-7" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-7"><a href="#回滚段分类-7" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-7"><a href="#八-小结-7" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。</p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-8"><a href="#6-2-事务并发执行的链表页-8" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<h2 id="一-UNDO-LOG-9"><a href="#一-UNDO-LOG-9" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-9"><a href="#二-想象中的回滚-9" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-9"><a href="#三-找到对应的事务-9" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-9"><a href="#四-UNDO通用日志格式-9" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-9"><a href="#五-UNDO日志分类-9" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-9"><a href="#5-1-insert-undo-log-9" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-9"><a href="#5-2-update-undo-log-之删除-9" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-9"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-9" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-9"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-9" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-9"><a href="#六-UNDO-LOG数据页链表-9" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-9"><a href="#6-1-数据页链表结构-9" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-9"><a href="#6-2-事务并发执行的链表页-9" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-8"><a href="#6-3-undo-log页的重用-8" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-8"><a href="#七-回滚段-8" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-8"><a href="#回滚段分类-8" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-8"><a href="#八-小结-8" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。</p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-9"><a href="#6-3-undo-log页的重用-9" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-9"><a href="#七-回滚段-9" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<h2 id="一-UNDO-LOG-10"><a href="#一-UNDO-LOG-10" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-10"><a href="#二-想象中的回滚-10" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-10"><a href="#三-找到对应的事务-10" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-10"><a href="#四-UNDO通用日志格式-10" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-10"><a href="#五-UNDO日志分类-10" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-10"><a href="#5-1-insert-undo-log-10" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-10"><a href="#5-2-update-undo-log-之删除-10" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-10"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-10" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-10"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-10" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-10"><a href="#六-UNDO-LOG数据页链表-10" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-10"><a href="#6-1-数据页链表结构-10" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-10"><a href="#6-2-事务并发执行的链表页-10" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-10"><a href="#6-3-undo-log页的重用-10" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-10"><a href="#七-回滚段-10" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-9"><a href="#回滚段分类-9" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-9"><a href="#八-小结-9" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。 </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<h2 id="一-UNDO-LOG-11"><a href="#一-UNDO-LOG-11" class="headerlink" title="一.UNDO LOG"></a>一.UNDO LOG</h2><p>之前说了数据库最重要的是持久化，那现在就需要来说 <code>原子性</code> 和 <code>隔离性</code> 了。实现这两个目标最重要的的元素就是 <code>undo log</code>。 在日常开发中，我们也有 <code>回滚</code> 数据的需求。比方说，插入的某条数据不符合数据库的长度要求，就会抛出异常，从而触发 <code>Spring框架事务</code> 发送一个 <code>ROLLBACK</code> 命令给数据库，数据库就会把前面做的修改给重新还原回来。所以也需要 <code>undo log</code>。<code>undo</code> 在中文不知道叫什么比较容易理解，后文就直接用这个英文名称吧。</p>
<h2 id="二-想象中的回滚-11"><a href="#二-想象中的回滚-11" class="headerlink" title="二.想象中的回滚"></a>二.想象中的回滚</h2><p>我们任何一次对数据库的改动，都会把就的数据信息记录起来，当遇到 <code>ROLLBACK</code> 指令的时候，就把记录起来的数据覆盖到目前的数据上就好了。<strong>比如新增，就删除掉，更新，就把它写成以前的数据，如果是删除，那就把记录重新放回去吧。</strong>好像蛮简单的，不过计算机可不同生活日常，需要考虑的东西有很多，考虑 <code>并发性</code> 呀，还有 <code>是否其他人可见</code> 啊等等这些资源共享问题。那为了提速，就需要一连串的操作来管理这些数据了，不仅仅有 <code>undo log</code>，还有 <code>数据库锁</code>。那接下来就来了解怎么实现这个功能的。</p>
<h2 id="三-找到对应的事务-11"><a href="#三-找到对应的事务-11" class="headerlink" title="三.找到对应的事务"></a>三.找到对应的事务</h2><p>为了能够管理不同 <code>事务</code> 的 <code>undo log</code>，所以起码我们需要先知道这段日志对应的是哪个 <code>事务</code> 的吧，所以就有了 <code>事务ID</code> 这个东东。 那么在开启一个 <code>事务</code> 的后，第一次对数据库中的表进行操作的时候，就会生成一个 <code>事务ID</code>，同样他也是一个全局变量，每当分配一次就会自增 <code>+1</code>。</p>
<blockquote>
<p>无论是只读事务对临时表的操作，还是读写事务对普通临时表的操作，只要有操作动作就会分配一个 <code>事务ID</code>.</p>
</blockquote>
<p>所以每个事务都拥有一个唯一的 <code>事务ID</code>，先知道这个事情先，后面要用。</p>
<h2 id="四-UNDO通用日志格式-11"><a href="#四-UNDO通用日志格式-11" class="headerlink" title="四.UNDO通用日志格式"></a>四.UNDO通用日志格式</h2><p>按照编程惯性，肯定是有一个差不多的类型，来封装管理不同的信息的： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113550.jpeg"> </p>
<p>这是一条 <code>undo log</code> 的通用格式，头尾两个指针互相指向，这样可以相互查找上一条或者下一条 <code>undo log</code>。 <code>类型</code> 和 <code>其他信息</code> 是需要对应起来的，不同的类型有不同的信息。 <code>table_id</code> 指的是哪张表的重做记录，每张表都有自己的 <code>id</code>。我们可以通过 <code>SELECT * FROM information_schema.innodb_sys_tables WHERE name = &#39;imopei/tbusiness_order_self_info&#39;</code> 来查询对应表的 <code>table_id</code>。</p>
<h2 id="五-UNDO日志分类-11"><a href="#五-UNDO日志分类-11" class="headerlink" title="五.UNDO日志分类"></a>五.UNDO日志分类</h2><p>虽然我们开发的时候对应的数据库操作有 <code>增</code> <code>删</code> <code>改</code>，但是在实际对 <code>undo log</code> 分类的时候却只有两大类，一类是 <code>insert undo log</code>，一类是 <code>update undo log</code>。 为啥只有两类，因为 <code>增</code> 是一个从 <code>0</code> 到 <code>1</code> 的过程，在实际做 <code>undo log</code> 的时候还要稍微简单一点，而 <code>改</code> 肯定是 <code>update undo log</code>，那 <code>删</code> 是怎样操作，其实就是把之前所说的 <code>数据行</code> 一个 <code>删除标记</code> 设置为 <code>true</code>，然后加入数据页的 <code>垃圾链表</code> 进行管理，后续如果需要重用空间，就可以直接在 <code>垃圾链表</code> 取出来使用。有点类似于我们业务开发的时候所说的 <code>逻辑删除</code>。 由于 <code>insert undo log</code> 要稍微简单一点，所以我们从这里开始说起。</p>
<h3 id="5-1-insert-undo-log-11"><a href="#5-1-insert-undo-log-11" class="headerlink" title="5.1 insert undo log"></a>5.1 insert undo log</h3><p>假设我们现在对一个表进行插入：<code>INSERT INTO product_info(prod_id, prod_name, prod_status) VALUES(10001, &#39;iPhoneSE 2020&#39;, &#39;VALID&#39;);</code>，<code>prod_id</code> 是一个 <code>INT</code> 类型的主键。 使用上面的通用日志类型存入数据，一个 <code>insert undo log</code> 的日志格式如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113609.jpeg"> </p>
<p>我们可以看到，新增的 <code>undo log</code> 是很简单的，只需要记录新增的数据的 <code>主键prod_id</code> 后续如果需要 <code>回滚数据</code>，直接拿到这段记录的 <code>主键值</code> 然后把对应的 <code>数据行</code> 删掉即可。</p>
<h3 id="5-2-update-undo-log-之删除-11"><a href="#5-2-update-undo-log-之删除-11" class="headerlink" title="5.2 update undo log 之删除"></a>5.2 update undo log 之删除</h3><p>之前说数据页的时候，数据页的 <code>Page Header</code> 有个属性，就是 <code>PAGE_FREE</code>，他代表的是这个数据页 <code>空闲列表</code> 的头部，所有被删除的数据行将会被串起来变成一个 <code>链表</code>，在需要重用这些空间的时候，就可以从这个 <code>空闲列表</code> 取出来使用了。 一个正常的数据页： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113624.jpeg"> </p>
<p>所以删除数据需要经历两个阶段，分割点就在 <code>COMMIT</code> 之前和之后：</p>
<ol>
<li>第一阶段：<code>标记删除</code>，在 <code>事务</code> 提交之前，一直都是这个状态，不算正常记录，也不算删除的数据；</li>
<li>第二阶段：<code>COMMIT</code> 之后，后台线程的 <code>PURGE</code> 阶段会来清理这条记录的状态，并且顺带修改 <code>数据页</code> 头部的一些重点参数</li>
</ol>
<p>所以其实删除只要一条 <code>del_mark_rec</code> 类型的 <code>undo log</code> 就可以了： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113646.jpeg"> </p>
<p>删除的 <code>undo log</code> 就要比插入的麻烦很多： <code>info bits</code>：数据行头信息的前 <code>4</code> 个字节信息，也就是：<code>2个字节</code> 的占位符，<code>delete_flag</code> 和 <code>min_rec_flag</code> <code>old_trx_id</code>：数据行上一个事务的 <code>ID</code>； <code>old_roll_pointer</code>：数据行上一个 <code>undo log</code> 的 <code>ID</code>； <code>主键各列信息</code>：这个是用来记录聚簇索引需要删除的信息； <code>index_col_len</code> 和 <code>索引各列信息</code>：那么第一个是记录第二个所占用的空间，方便查询第二个参数的内容，后台线程在清理 <code>二级索引</code> 的时候也会方便一些。而 <code>索引各列信息</code> 可以用来清理 <code>二级索引</code> 的数据内容。 那现在我们来和插入串起来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 建立一个用户表，指定一个二级索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_info</span><br><span class="line">(</span><br><span class="line">    s_uuid <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    s_code <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="literal">null</span> ,</span><br><span class="line">    s_username <span class="built_in">varchar</span>(<span class="number">36</span>) <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> datetime</span><br><span class="line">    <span class="keyword">on</span> user_info (s_username);</span><br></pre></td></tr></table></figure>

<p>那现在我们就来操作这个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info <span class="keyword">VALUES</span>(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;001&quot;</span>, <span class="string">&quot;Weidan&quot;</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> s_uuid = <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113715.gif"> </p>
<p>步骤：</p>
<ol>
<li>首先，执行了插入语句，<code>数据行</code> 有个列叫做 <code>roll_point</code>（图中简化成 <code>r_p</code>）指向了新增语句的 <code>undo_log</code>；</li>
<li>然后，执行了删除语句，那么数据行的指针就指向了新的删除 <code>undo_log</code>，然后 <code>undo_log</code> 的 <code>old_roll_pointer</code> 被指向第 <code>1</code> 步的插入语句，最后的情况：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113734.jpeg"></p>
<p> 那么我们可以初步的获取到一条记录由 <code>undo_log</code> 串起来的 <code>版本链</code>，这也就是一条记录的不同版本，在后面会说到。</p>
<h3 id="5-2-update-undo-log-之更新（不更新主键的情况）-11"><a href="#5-2-update-undo-log-之更新（不更新主键的情况）-11" class="headerlink" title="5.2 update undo log 之更新（不更新主键的情况）"></a>5.2 update undo log 之更新（不更新主键的情况）</h3><p><code>UPDATE</code> 的 <code>undo log</code> 内容有点多，分为 <code>更新主键的情况</code> 和 <code>不更新主键的情况</code>。这里先说说 <code>不更新主键的情况</code>。 那么 <code>不更新主键</code> 的地方又要视情况而定：</p>
<ol>
<li>更新后的值跟原来的值的长度一样：就地更新；</li>
<li>否则，先删除，再插入新的记录。（这个删除跟上面的删除不一样，而是在用户所在线程中删除，然后再立即插入新的记录&lt;而下面的 <code>完全更新</code> 就不一样了，是 <code>删除标记</code>，然后由 <code>后台线程</code> 来清理 &gt;）</li>
</ol>
<p>首先来看看 <code>undo log</code> 的格式： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113746.jpeg"> OK，其实上面两个是 <code>删除格式</code>，我用了小学的 <code>改错句</code> 方法把新的加上去了。 总的来说呢，跟 <code>删除undo log</code> 作比较，就是多了两个东西，一个是有多少列被更新，一个是这些列的 <code>旧长度</code> 和 <code>旧值</code></p>
<h3 id="5-2-update-undo-log-之更新（更新主键的情况）-11"><a href="#5-2-update-undo-log-之更新（更新主键的情况）-11" class="headerlink" title="5.2 update undo log 之更新（更新主键的情况）"></a>5.2 update undo log 之更新（更新主键的情况）</h3><p>唯一区别点也说了，就是在删除就记录的时候，会把 <code>需要删除的列进行标记</code>（因为其他事务可能还需要用到这条记录），然后提交的时候会重新变成新的记录 <code>插入</code>，因为主键更新了，就需要更新数据库的 <code>聚簇索引</code> 了，所以得重新当成新的记录看待。 更新内容的版本链表和删除的时候差不多，不演示了（懒…</p>
<hr>
<p>（我是分割线，上面是日志管理数据，下面是系统管理日志）</p>
<h2 id="六-UNDO-LOG数据页链表-11"><a href="#六-UNDO-LOG数据页链表-11" class="headerlink" title="六.UNDO LOG数据页链表"></a>六.UNDO LOG数据页链表</h2><h3 id="6-1-数据页链表结构-11"><a href="#6-1-数据页链表结构-11" class="headerlink" title="6.1 数据页链表结构"></a>6.1 数据页链表结构</h3><p>万物皆可 <code>链表</code>： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113807.jpeg"></p>
<ol>
<li>上面是一堆 <code>undo log</code> 页（<code>InnoDB</code> 与 <code>磁盘</code> 交互的基础）；</li>
<li><code>UndoPageHeader</code> 相互连接，也就是每个箭头都是双向 <code>指针</code>；</li>
<li>第一个 <code>undo log</code> 页有 <code>undo log segment header</code>，也就是 <code>undo页</code> 的段开头，这里记录了当前 <code>undo log</code> 页能否被重用，事务活跃状态等信息；</li>
<li>每个事务开始，<code>undo log header</code> 会记录事务的相关信息，也就是 <code>trx_id</code> <code>trx_no</code> <code>del_mark</code> <code>log_start</code> 等重要信息 ，分别用来记录 <code>事务ID</code> <code>事务编号（先开始的事务小，后的大）</code> <code>是否含有删除标记的undo log</code> <code>日志开始的位置</code>。</li>
</ol>
<h3 id="6-2-事务并发执行的链表页-11"><a href="#6-2-事务并发执行的链表页-11" class="headerlink" title="6.2 事务并发执行的链表页"></a>6.2 事务并发执行的链表页</h3><p>那么链表页其实是有分类的，并不会 <code>增删改</code> 都丢在同一个链表： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113822.jpeg"></p>
<p> 然后对 <code>普通表</code> <code>临时表</code> 的操作也要分开，也就是两组上面的图片，不画了。 不过并不是事务一开始就分配的，而是按需分配，比方说一个事务只有插入普通标，那就只有一个上面的链表了。</p>
<h3 id="6-3-undo-log页的重用-11"><a href="#6-3-undo-log页的重用-11" class="headerlink" title="6.3 undo log页的重用"></a>6.3 undo log页的重用</h3><p>那么了解到这里，感觉到为了能够 <code>回滚</code>，系统做的事情还是特别痛苦的，分配了一堆空间。 那重用这些空间就变得很迫切了，不然一个数据库系统占用的资源也就太多了吧。 什么时候可以重用：</p>
<ol>
<li><code>undo页</code> 只有一个的时候，事务提交完成（意味着不需要 <code>undo log</code> 了）那么可以重用这部分空间；</li>
<li>事务非常小，<code>undo log</code> 占用一个页面的空间不到 <code>3/4</code> 的时候，可以把新的 <code>undo log</code> 包括头信息插入到旧的页面里面去（也就是上面图片的绿色部分）；</li>
<li>只有一个页面，并且事务已经提交，并且 <code>只存储新增的undo log</code> 的时候；</li>
<li>而 <code>更新undo log</code> 不能删掉，后面还有用；</li>
</ol>
<h2 id="七-回滚段-11"><a href="#七-回滚段-11" class="headerlink" title="七.回滚段"></a>七.回滚段</h2><p>我们前面知道，数据多了以后，会再有一个 <code>段</code> 的概念来管理这些数据页。而 <code>回滚页</code> 也是同样的道理。这个段，关联着众多的 <code>回滚页头</code>，也就是上面那幅图的每个链表的第一个页。 那么这个段头其实他自己也是一个 <code>数据页</code>，也就是 <code>16kb</code>。所以他其实只是 <code>FileHeader</code> 里面的类型字段不同而已。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113851.jpeg"> </p>
<p>那么一个事务开始了，<code>InnoDB</code> 就可以找到这些 <code>回滚段</code> 类型的 <code>数据页</code>。如果能够申请到 <code>SLOT</code> 就可以继续执行，那如果申请不到的话，就说明系统已经无法再开启事务了。一个回滚段有 <code>1024个</code> <code>SLOT</code>，在目前我们可以使用的版本中，一般有 <code>128个</code> <code>回滚段</code>。所以一共有 <code>1024 * 128 =131072</code> 个 <code>SLOT</code>，基本可以满足目前业务需求。那这些 <code>回滚段</code> 又散落在不同的表空间：所以就可以出现一棵树：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113905.jpeg"></p>
<h3 id="回滚段分类-10"><a href="#回滚段分类-10" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-10"><a href="#八-小结-10" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。</p>
<h3 id="回滚段分类-11"><a href="#回滚段分类-11" class="headerlink" title="回滚段分类"></a>回滚段分类</h3><p>回滚段也会被分类，因为我们的事务可能只是操作 <code>临时表</code> 的事务，所以这些 <code>undo log</code> 在系统崩溃的时候，可以不用去管他，所以要跟重要的 <code>普通表</code> 的 <code>undo log</code> 分开来处理： 第 <code>1-32</code> 号回滚段就是用来存储 <code>临时表</code> 的 <code>日志</code> 的。</p>
<h2 id="八-小结-11"><a href="#八-小结-11" class="headerlink" title="八.小结"></a>八.小结</h2><p>这篇主要说了事务回滚中的 <code>undo log</code>，其中的 <code>版本链</code> 就是事务之间隔离的重要组成成分，接下来说。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%83-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E4%B8%83-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">【聊聊MySQL】七.MySQL-InnoDB的数据库事务介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-11 17:11:19" itemprop="dateCreated datePublished" datetime="2020-03-11T17:11:19+08:00">2020-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 11:42:32" itemprop="dateModified" datetime="2020-11-10T11:42:32+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-数据库事务"><a href="#一-数据库事务" class="headerlink" title="一.数据库事务"></a>一.数据库事务</h2><p>刚开始接触编程，要写业务代码的时候我们知道。某个业务动作必须通过 <code>事务</code> 完成对数据库的修改。那么这个事务是什么，<code>InnoDB</code> 是怎样实现事务的要求的，就是接下来老夫想说的内容。</p>
<p>那么事务是怎样的，也就是说，我们在做业务操作的时候，最简单的比如用户下单：</p>
<ol>
<li>用户按下下单的按钮，开始请求后端进行创建订单；</li>
<li><code>Java</code> 开始着手创建订单的信息对象；</li>
<li>与此同时，产品的库存需要扣减比如 iPhone 的库存需要减掉 10 个；</li>
<li>插入订单 + 扣减库存，在 <code>MySQL</code> 中开始执行；</li>
</ol>
<p>结果：此时针对最后一步来看，我们要求两个操作的 <code>SQL</code> 操作必须一并成功，或者一并失败，而且要求数据库发生故障重启的时候数据还存在，而且数据是准确的。</p>
<p>上面这句话包含太多数据库事务的内容了，我们需要一个一个来说。</p>
<p>这个数据库事务的概念就是我们常说的 <code>ACID</code>。</p>
<h3 id="1-1-A-Atomicity-原子性"><a href="#1-1-A-Atomicity-原子性" class="headerlink" title="1.1 A-Atomicity-原子性"></a>1.1 A-Atomicity-原子性</h3><p>每个点我打算拆分上面的执行结果来说，何为 <code>原子性</code>，对应我那句话：<code>插入订单 + 扣减库存必须一并成功，或者一并失败</code>。原子性就是两个操作，插入订单和扣减库存，对应数据库操作是一个 <code>INSERT</code> 和一个 <code>UPDATE</code>，那么这两个语句要么同时都对我们的数据表成功的修改，如果其中有一个失败了，另外一个语句<strong>必须不执行</strong>，<strong>或者已经执行了，必须把修改的数据还原成修改前的数据</strong>。这就说创建订单和扣减库存是一个原子操作。我们的业务不可能允许创建了订单但是没有扣减库存，这时候后续的用户下单了就没有库存发货了，那程序就没什么意义，也不允许扣减了库存但是没有创建订单，要不然赚什么钱。</p>
<p>所以开启事务后，我们必须满足，在这个事务里面执行的语句要么一并成功，要么全部回滚。</p>
<h3 id="1-2-C-Consistency-一致性"><a href="#1-2-C-Consistency-一致性" class="headerlink" title="1.2 C-Consistency-一致性"></a>1.2 C-Consistency-一致性</h3><p>我们知道，我们的业务代码是现实生活的映射，所以在上面扣减库存的动作中，订单下了 15 个 iPhone，那库存就应该扣减 15 个，而不是其他任何数字，更不可能是一个负数。当然现在的编码生活中，留给数据库处理的事情越来越少，所以这个一致性在某种意义上需要我们程序去保证，数据库只能够帮助我们同时执行一个语句并保证他们的执行是原子性的。</p>
<h3 id="1-3-I-Isolation-隔离性"><a href="#1-3-I-Isolation-隔离性" class="headerlink" title="1.3 I-Isolation-隔离性"></a>1.3 I-Isolation-隔离性</h3><p>这个东西可能我们在程序中最注重的了。上面的例子已经不足以说明。那就拓展一下这个例子。</p>
<p>iPhone 总库存只有 <code>15</code> 台，<code>A用户</code> 和 <code>B用户</code> 同时下单 <code>10台</code>。</p>
<p>那么按照我们现实生活中的例子，就是两个用户看谁先排队在前面，就可以先买到 <code>10</code> 台 iPhone。</p>
<p>而程序则不是，他有可能就是这样子：</p>
<h2 id="一-数据库事务-1"><a href="#一-数据库事务-1" class="headerlink" title="一.数据库事务"></a>一.数据库事务</h2><p>刚开始接触编程，要写业务代码的时候我们知道。某个业务动作必须通过 <code>事务</code> 完成对数据库的修改。那么这个事务是什么，<code>InnoDB</code> 是怎样实现事务的要求的，就是接下来老夫想说的内容。</p>
<p>那么事务是怎样的，也就是说，我们在做业务操作的时候，最简单的比如用户下单：</p>
<ol>
<li>用户按下下单的按钮，开始请求后端进行创建订单；</li>
<li><code>Java</code> 开始着手创建订单的信息对象；</li>
<li>与此同时，产品的库存需要扣减比如 iPhone 的库存需要减掉 10 个；</li>
<li>插入订单 + 扣减库存，在 <code>MySQL</code> 中开始执行；</li>
</ol>
<p>结果：此时针对最后一步来看，我们要求两个操作的 <code>SQL</code> 操作必须一并成功，或者一并失败，而且要求数据库发生故障重启的时候数据还存在，而且数据是准确的。</p>
<p>上面这句话包含太多数据库事务的内容了，我们需要一个一个来说。</p>
<p>这个数据库事务的概念就是我们常说的 <code>ACID</code>。</p>
<h3 id="1-1-A-Atomicity-原子性-1"><a href="#1-1-A-Atomicity-原子性-1" class="headerlink" title="1.1 A-Atomicity-原子性"></a>1.1 A-Atomicity-原子性</h3><p>每个点我打算拆分上面的执行结果来说，何为 <code>原子性</code>，对应我那句话：<code>插入订单 + 扣减库存必须一并成功，或者一并失败</code>。原子性就是两个操作，插入订单和扣减库存，对应数据库操作是一个 <code>INSERT</code> 和一个 <code>UPDATE</code>，那么这两个语句要么同时都对我们的数据表成功的修改，如果其中有一个失败了，另外一个语句<strong>必须不执行</strong>，<strong>或者已经执行了，必须把修改的数据还原成修改前的数据</strong>。这就说创建订单和扣减库存是一个原子操作。我们的业务不可能允许创建了订单但是没有扣减库存，这时候后续的用户下单了就没有库存发货了，那程序就没什么意义，也不允许扣减了库存但是没有创建订单，要不然赚什么钱。</p>
<p>所以开启事务后，我们必须满足，在这个事务里面执行的语句要么一并成功，要么全部回滚。</p>
<h3 id="1-2-C-Consistency-一致性-1"><a href="#1-2-C-Consistency-一致性-1" class="headerlink" title="1.2 C-Consistency-一致性"></a>1.2 C-Consistency-一致性</h3><p>我们知道，我们的业务代码是现实生活的映射，所以在上面扣减库存的动作中，订单下了 15 个 iPhone，那库存就应该扣减 15 个，而不是其他任何数字，更不可能是一个负数。当然现在的编码生活中，留给数据库处理的事情越来越少，所以这个一致性在某种意义上需要我们程序去保证，数据库只能够帮助我们同时执行一个语句并保证他们的执行是原子性的。</p>
<h3 id="1-3-I-Isolation-隔离性-1"><a href="#1-3-I-Isolation-隔离性-1" class="headerlink" title="1.3 I-Isolation-隔离性"></a>1.3 I-Isolation-隔离性</h3><p>这个东西可能我们在程序中最注重的了。上面的例子已经不足以说明。那就拓展一下这个例子。</p>
<p>iPhone 总库存只有 <code>15</code> 台，<code>A用户</code> 和 <code>B用户</code> 同时下单 <code>10台</code>。</p>
<p>那么按照我们现实生活中的例子，就是两个用户看谁先排队在前面，就可以先买到 <code>10</code> 台 iPhone。</p>
<p>而程序则不是，他有可能就是这样子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114225.jpeg"></p>
<p>OK，老板卖了 <code>20台</code> 还剩下 <code>5台</code> 可以卖！</p>
<p>所以，我们在处理这个问题的时候，思路又跟生活靠近，买同一个产品的客户，你们排队，这样上面的流程将会被撸成串行（即排队），而买一个 iPhone 和一个 小米，又可以使用上面的方式处理，即提高处理速度又不担心超卖的问题。</p>
<p>所以如果两个请求在操作同一条数据的时候，即库存这条数据，我们需要让这两个用户读取到的数据是具有隔离性质的，也就是 <code>A用户</code> 完成一系列原子性操作的时候，才可以让 <code>B用户</code> 来执行其他的操作。</p>
<h3 id="1-4-D-Durability-持久性"><a href="#1-4-D-Durability-持久性" class="headerlink" title="1.4 D-Durability-持久性"></a>1.4 D-Durability-持久性</h3><p>这个很好理解，我的业务进行后，数据状态被修改了，当系统关机或者因为其他原因导致突然暂停的时候，我的数据要恢复成宕机前的亚子。</p>
<h2 id="二-InnoDB事务状态"><a href="#二-InnoDB事务状态" class="headerlink" title="二.InnoDB事务状态"></a>二.InnoDB事务状态</h2><p><code>InnoDB</code> 将事务分为五个状态，分别是：<code>活动的</code>、<code>部分提交的</code>、<code>失败的</code>、<code>中止的</code>、<code>提交的</code>。</p>
<p>那这五个状态分别对应哪些事情，</p>
<p><code>活动的</code>：对应开启事务的时候，也就是 <code>START TRANSACTION;</code></p>
<p>此时，如果我们输入 <code>COMMIT</code>，那么该事务就是 <code>部分提交的</code>，为啥，因为在之前说过 <code>BufferPool</code> 的事情，就是说我们提交了修改，修改的还只是内存中的数据，还没有刷到硬盘，所以我们提交的时候就是 <code>部分提交的</code>。</p>
<p>那如果我们 <code>ROLLBACK</code> 呢，就是 <code>中止的</code> 的状态了，也就是回滚修改的时候。</p>
<p><code>失败的</code> 我们日常应该很少遇到，就是我们在事务处于 <code>活动的</code> 或者 <code>部分提交的</code> 状态，导致内存中的数据没有持久化到硬盘（注意是持久化，后面会说），那这个事务就是 <code>失败的</code>。</p>
<p><code>提交的</code> 数据已经完完全全被保存到硬盘中，就算重启或者宕机都不用害怕，就说这个事务是 <code>提交的</code>。</p>
<hr>
<h2 id="三-事务并发执行可能出现的问题"><a href="#三-事务并发执行可能出现的问题" class="headerlink" title="三.事务并发执行可能出现的问题"></a>三.事务并发执行可能出现的问题</h2><p>通常来说，我们的数据库不可能只有一条连接在执行业务。而一条连接就是一个会话（<code>Session</code>），所以下面遇到的问题基本是多个 <code>Session</code> 在同时操作数据库时可能会出现的问题。</p>
<p>那我依然使用上面下单扣库存的例子来说说这些问题：</p>
<h3 id="3-1-脏写（Dirty-Write）"><a href="#3-1-脏写（Dirty-Write）" class="headerlink" title="3.1 脏写（Dirty Write）"></a>3.1 脏写（<code>Dirty Write</code>）</h3><p>脏写基本是所有数据库都不允许的，但是为了完整还是说下。</p>
<p>脏写可以理解成两个用户同时下单一个产品时可能出现的问题：</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
<td align="center">其他操作</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>COMMIT;</code></td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center">由于其他操作失败 <code>ROLLBACK;</code></td>
</tr>
<tr>
<td align="center">此时，<code>A客户</code> 下单了 <code>10</code> 台 iPhone，并且顺利提交，但是 <code>B客户</code> 可能由于其他问题，比如是个黑号，下单失败，回滚了，那么导致 <code>A客户</code> 提交的库存只有 <code>10</code> 台 iPhone 这条修改也不见了，称为 <code>脏写</code>。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>那么怎么看，所有业务，基本都不可能容许这种错误的存在吧，所以下面聊隔离级别的时候，基本排除这个错误的发生。</p>
<h3 id="3-2-脏读（Dirty-Read）"><a href="#3-2-脏读（Dirty-Read）" class="headerlink" title="3.2 脏读（Dirty Read）"></a>3.2 脏读（<code>Dirty Read</code>）</h3><p>如果 <code>客户A</code> 读取到的数据是 <code>客户B</code> 未提交的数据，我们成为 <code>脏读</code>。乍一想扣库存的时候，好像挺好的，但是如果 <code>客户B</code> 回滚数据呢，那数据就完全混乱了呀：</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>10</code></td>
<td align="center">其他操作</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center">由于其他操作失败 <code>ROLLBACK;</code></td>
</tr>
</tbody></table>
<h3 id="3-3-不可重复读（Non-Repeatable-Read）"><a href="#3-3-不可重复读（Non-Repeatable-Read）" class="headerlink" title="3.3 不可重复读（Non-Repeatable Read）"></a>3.3 不可重复读（<code>Non-Repeatable Read</code>）</h3><p>指的是一个事务重复读取一个 <code>SQL</code> 时，因为其他事务提交了数据，导致在此次事务读取两次的数据不一样，成为 <code>不可重复读</code>。<br>| 执行步骤 |           Session_A_客户           |    Session_B客户     |<br>| :——: | :——————————–: | :——————: |<br>|    1     |        <code>START TRANSACTION;</code>        | <code>START TRANSACTION;</code> |<br>|    2     | <code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code> | — |<br>|    3     |        —        | <code>UPDATE prod_stock SET stock = 10</code> |<br>| 4 |     —       |  <code>COMMIT</code> |<br>| 5 | <code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>10</code> |  —|</p>
<h3 id="3-4-幻读（Phantom）"><a href="#3-4-幻读（Phantom）" class="headerlink" title="3.4 幻读（Phantom）"></a>3.4 幻读（<code>Phantom</code>）</h3><p>跟不可重复读有点相似，但是这个是由于另外的事务插入数据导致本事务相同条件读到的数据条目数不一样。</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code></td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">—</td>
<td align="center"><code>INSERT INTO prod_stock VALUES (XXX, 10)</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center"><code>COMMIT</code></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code> 和 <code>10</code></td>
<td align="center">—</td>
</tr>
</tbody></table>
<p><code>客户A</code> 准备下单在读取产品的库存数据，这时候 <code>客户B</code> 新增了一个其他类型的库存记录，<code>客户A</code> 重新查询的时候，被查出来了，所以就可以说这个事务产生了 <code>幻读</code>。</p>
<h2 id="三-InnDB事务隔离级别"><a href="#三-InnDB事务隔离级别" class="headerlink" title="三.InnDB事务隔离级别"></a>三.InnDB事务隔离级别</h2><p>那么 <code>SQL标准</code> 就规定了四种隔离机制，<code>InnoDB</code> 也同时对这几个隔离级别做了支持：</p>
<ol>
<li><code>READ UNCOMMITTED</code>：读未提交的</li>
<li><code>READ COMMITTED</code>：读已提交的</li>
<li><code>REPEATABLE READ</code>：可重复读</li>
<li><code>SERIALIZABLE</code>：串行化</li>
</ol>
<p>当然因为 <code>脏写</code> 产生的后果是 <code>所有业务都不允许发生</code> 的，所以并不在讨论范围之内，因为所有的级别都不允许发生 <code>脏写</code></p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>我们可以看到，<code>串行化</code> 是效果最好的，但是因为是 <code>串行化</code>（俗话说就是每个请求都要排队，等前面做好了再来做下一个），所以性能也是最低的。</p>
<p><code>MySQL_InnoDB</code> 的默认隔离机制是 <code>REPEATABLE READ</code>，也就是可重复读。</p>
<p>可重复读会出现幻读，但是 <code>InnoDB</code> 又把 <code>幻读</code> 的问题给解决了，所以可以说 <code>MySQL_InnoDB</code> 用了一些手段，将数据库事务的性能提高又不影响数据的准确性。</p>
<p>怎么解决的，简单的说在查询的时候判断当前事务开启时，会生成一个 <code>ReadView</code>，这个 <code>ReadView</code> 会记录当前事务的信息，然后在查询的时候，只需要判断查询到的数据的所有版本在当前 <code>ReadView</code> 中是否可见，如果可见就显示出来，不可见就隐藏掉。那么就相当于解决了 <code>REPEATABLE READ</code>：可重复读 这个级别的 <code>幻读</code> 问题。至于怎么比较的，现在还不是时候知道，因为需要先知道 <code>REDO</code> 和 <code>UNDO</code> 日志。</p>
<h2 id="四-完"><a href="#四-完" class="headerlink" title="四. 完"></a>四. 完</h2><p>OK，有了 <code>事务</code> 的一些相关内容以后，就可以来深入 <code>事务</code> 的执行原理了。</p>
<p>OK，老板卖了 <code>20台</code> 还剩下 <code>5台</code> 可以卖！</p>
<p>所以，我们在处理这个问题的时候，思路又跟生活靠近，买同一个产品的客户，你们排队，这样上面的流程将会被撸成串行（即排队），而买一个 iPhone 和一个 小米，又可以使用上面的方式处理，即提高处理速度又不担心超卖的问题。</p>
<p>所以如果两个请求在操作同一条数据的时候，即库存这条数据，我们需要让这两个用户读取到的数据是具有隔离性质的，也就是 <code>A用户</code> 完成一系列原子性操作的时候，才可以让 <code>B用户</code> 来执行其他的操作。</p>
<h3 id="1-4-D-Durability-持久性-1"><a href="#1-4-D-Durability-持久性-1" class="headerlink" title="1.4 D-Durability-持久性"></a>1.4 D-Durability-持久性</h3><p>这个很好理解，我的业务进行后，数据状态被修改了，当系统关机或者因为其他原因导致突然暂停的时候，我的数据要恢复成宕机前的亚子。</p>
<h2 id="二-InnoDB事务状态-1"><a href="#二-InnoDB事务状态-1" class="headerlink" title="二.InnoDB事务状态"></a>二.InnoDB事务状态</h2><p><code>InnoDB</code> 将事务分为五个状态，分别是：<code>活动的</code>、<code>部分提交的</code>、<code>失败的</code>、<code>中止的</code>、<code>提交的</code>。</p>
<p>那这五个状态分别对应哪些事情，</p>
<p><code>活动的</code>：对应开启事务的时候，也就是 <code>START TRANSACTION;</code></p>
<p>此时，如果我们输入 <code>COMMIT</code>，那么该事务就是 <code>部分提交的</code>，为啥，因为在之前说过 <code>BufferPool</code> 的事情，就是说我们提交了修改，修改的还只是内存中的数据，还没有刷到硬盘，所以我们提交的时候就是 <code>部分提交的</code>。</p>
<p>那如果我们 <code>ROLLBACK</code> 呢，就是 <code>中止的</code> 的状态了，也就是回滚修改的时候。</p>
<p><code>失败的</code> 我们日常应该很少遇到，就是我们在事务处于 <code>活动的</code> 或者 <code>部分提交的</code> 状态，导致内存中的数据没有持久化到硬盘（注意是持久化，后面会说），那这个事务就是 <code>失败的</code>。</p>
<p><code>提交的</code> 数据已经完完全全被保存到硬盘中，就算重启或者宕机都不用害怕，就说这个事务是 <code>提交的</code>。</p>
<hr>
<h2 id="三-事务并发执行可能出现的问题-1"><a href="#三-事务并发执行可能出现的问题-1" class="headerlink" title="三.事务并发执行可能出现的问题"></a>三.事务并发执行可能出现的问题</h2><p>通常来说，我们的数据库不可能只有一条连接在执行业务。而一条连接就是一个会话（<code>Session</code>），所以下面遇到的问题基本是多个 <code>Session</code> 在同时操作数据库时可能会出现的问题。</p>
<p>那我依然使用上面下单扣库存的例子来说说这些问题：</p>
<h3 id="3-1-脏写（Dirty-Write）-1"><a href="#3-1-脏写（Dirty-Write）-1" class="headerlink" title="3.1 脏写（Dirty Write）"></a>3.1 脏写（<code>Dirty Write</code>）</h3><p>脏写基本是所有数据库都不允许的，但是为了完整还是说下。</p>
<p>脏写可以理解成两个用户同时下单一个产品时可能出现的问题：</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
<td align="center">其他操作</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>COMMIT;</code></td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center">由于其他操作失败 <code>ROLLBACK;</code></td>
</tr>
<tr>
<td align="center">此时，<code>A客户</code> 下单了 <code>10</code> 台 iPhone，并且顺利提交，但是 <code>B客户</code> 可能由于其他问题，比如是个黑号，下单失败，回滚了，那么导致 <code>A客户</code> 提交的库存只有 <code>10</code> 台 iPhone 这条修改也不见了，称为 <code>脏写</code>。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>那么怎么看，所有业务，基本都不可能容许这种错误的存在吧，所以下面聊隔离级别的时候，基本排除这个错误的发生。</p>
<h3 id="3-2-脏读（Dirty-Read）-1"><a href="#3-2-脏读（Dirty-Read）-1" class="headerlink" title="3.2 脏读（Dirty Read）"></a>3.2 脏读（<code>Dirty Read</code>）</h3><p>如果 <code>客户A</code> 读取到的数据是 <code>客户B</code> 未提交的数据，我们成为 <code>脏读</code>。乍一想扣库存的时候，好像挺好的，但是如果 <code>客户B</code> 回滚数据呢，那数据就完全混乱了呀：</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"><code>UPDATE prod_stock SET stock = 10</code></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>10</code></td>
<td align="center">其他操作</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center">由于其他操作失败 <code>ROLLBACK;</code></td>
</tr>
</tbody></table>
<h3 id="3-3-不可重复读（Non-Repeatable-Read）-1"><a href="#3-3-不可重复读（Non-Repeatable-Read）-1" class="headerlink" title="3.3 不可重复读（Non-Repeatable Read）"></a>3.3 不可重复读（<code>Non-Repeatable Read</code>）</h3><p>指的是一个事务重复读取一个 <code>SQL</code> 时，因为其他事务提交了数据，导致在此次事务读取两次的数据不一样，成为 <code>不可重复读</code>。<br>| 执行步骤 |           Session_A_客户           |    Session_B客户     |<br>| :——: | :——————————–: | :——————: |<br>|    1     |        <code>START TRANSACTION;</code>        | <code>START TRANSACTION;</code> |<br>|    2     | <code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code> | — |<br>|    3     |        —        | <code>UPDATE prod_stock SET stock = 10</code> |<br>| 4 |     —       |  <code>COMMIT</code> |<br>| 5 | <code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>10</code> |  —|</p>
<h3 id="3-4-幻读（Phantom）-1"><a href="#3-4-幻读（Phantom）-1" class="headerlink" title="3.4 幻读（Phantom）"></a>3.4 幻读（<code>Phantom</code>）</h3><p>跟不可重复读有点相似，但是这个是由于另外的事务插入数据导致本事务相同条件读到的数据条目数不一样。</p>
<table>
<thead>
<tr>
<th align="center">执行步骤</th>
<th align="center">Session_A_客户</th>
<th align="center">Session_B客户</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><code>START TRANSACTION;</code></td>
<td align="center"><code>START TRANSACTION;</code></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code></td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">—</td>
<td align="center"><code>INSERT INTO prod_stock VALUES (XXX, 10)</code></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">—</td>
<td align="center"><code>COMMIT</code></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><code>SELECT * FROM prod_stock WHERE prod_id = XXX</code><br/>读取到 <code>15</code> 和 <code>10</code></td>
<td align="center">—</td>
</tr>
</tbody></table>
<p><code>客户A</code> 准备下单在读取产品的库存数据，这时候 <code>客户B</code> 新增了一个其他类型的库存记录，<code>客户A</code> 重新查询的时候，被查出来了，所以就可以说这个事务产生了 <code>幻读</code>。</p>
<h2 id="三-InnDB事务隔离级别-1"><a href="#三-InnDB事务隔离级别-1" class="headerlink" title="三.InnDB事务隔离级别"></a>三.InnDB事务隔离级别</h2><p>那么 <code>SQL标准</code> 就规定了四种隔离机制，<code>InnoDB</code> 也同时对这几个隔离级别做了支持：</p>
<ol>
<li><code>READ UNCOMMITTED</code>：读未提交的</li>
<li><code>READ COMMITTED</code>：读已提交的</li>
<li><code>REPEATABLE READ</code>：可重复读</li>
<li><code>SERIALIZABLE</code>：串行化</li>
</ol>
<p>当然因为 <code>脏写</code> 产生的后果是 <code>所有业务都不允许发生</code> 的，所以并不在讨论范围之内，因为所有的级别都不允许发生 <code>脏写</code></p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code>：读未提交的</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code>：读已提交的</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code>：可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code>：串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>我们可以看到，<code>串行化</code> 是效果最好的，但是因为是 <code>串行化</code>（俗话说就是每个请求都要排队，等前面做好了再来做下一个），所以性能也是最低的。</p>
<p><code>MySQL_InnoDB</code> 的默认隔离机制是 <code>REPEATABLE READ</code>，也就是可重复读。</p>
<p>可重复读会出现幻读，但是 <code>InnoDB</code> 又把 <code>幻读</code> 的问题给解决了，所以可以说 <code>MySQL_InnoDB</code> 用了一些手段，将数据库事务的性能提高又不影响数据的准确性。</p>
<p>怎么解决的，简单的说在查询的时候判断当前事务开启时，会生成一个 <code>ReadView</code>，这个 <code>ReadView</code> 会记录当前事务的信息，然后在查询的时候，只需要判断查询到的数据的所有版本在当前 <code>ReadView</code> 中是否可见，如果可见就显示出来，不可见就隐藏掉。那么就相当于解决了 <code>REPEATABLE READ</code>：可重复读 这个级别的 <code>幻读</code> 问题。至于怎么比较的，现在还不是时候知道，因为需要先知道 <code>REDO</code> 和 <code>UNDO</code> 日志。</p>
<h2 id="四-完-1"><a href="#四-完-1" class="headerlink" title="四. 完"></a>四. 完</h2><p>OK，有了 <code>事务</code> 的一些相关内容以后，就可以来深入 <code>事务</code> 的执行原理了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/uncategorized/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AB-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bredo-log/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/uncategorized/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AB-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B9%8Bredo-log/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-07 16:07:08" itemprop="dateCreated datePublished" datetime="2020-03-07T16:07:08+08:00">2020-03-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 11:34:32" itemprop="dateModified" datetime="2020-11-10T11:34:32+08:00">2020-11-10</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一-REDO-LOG"><a href="#一-REDO-LOG" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式"><a href="#二-高效且持久化的方式" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式"><a href="#三-日志格式" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式"><a href="#3-1-装载数据的通用格式" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><h2 id="一-REDO-LOG-1"><a href="#一-REDO-LOG-1" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-1"><a href="#二-高效且持久化的方式-1" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-1"><a href="#三-日志格式-1" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-1"><a href="#3-1-装载数据的通用格式-1" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式"><a href="#3-2-插入数据时日志格式" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容"><a href="#3-2-REDO-日志内容" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’"><a href="#四-重做LOG的’事务’" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区"><a href="#五-重做LOG缓冲区" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘"><a href="#六-触发重做LOG刷盘" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里"><a href="#七-重做LOG刷到哪些文件里" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系"><a href="#八-重做LOG缓冲页与日志文件的关系" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式"><a href="#8-1-重做日志文件的格式" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number"><a href="#8-2-LSN-Log-Swquence-Number" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘"><a href="#8-4-日志缓冲数据刷盘" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN"><a href="#8-5-flush链表和LSN" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint"><a href="#8-6-Checkpoint" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页"><a href="#九-崩溃重做数据页" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别"><a href="#十-配置重做日志的级别" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<h2 id="一-REDO-LOG-2"><a href="#一-REDO-LOG-2" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-2"><a href="#二-高效且持久化的方式-2" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-2"><a href="#三-日志格式-2" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-2"><a href="#3-1-装载数据的通用格式-2" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-1"><a href="#3-2-插入数据时日志格式-1" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-1"><a href="#3-2-REDO-日志内容-1" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-1"><a href="#四-重做LOG的’事务’-1" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-1"><a href="#五-重做LOG缓冲区-1" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-1"><a href="#六-触发重做LOG刷盘-1" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-1"><a href="#七-重做LOG刷到哪些文件里-1" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-1"><a href="#八-重做LOG缓冲页与日志文件的关系-1" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-1"><a href="#8-1-重做日志文件的格式-1" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-1"><a href="#8-2-LSN-Log-Swquence-Number-1" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-1"><a href="#8-4-日志缓冲数据刷盘-1" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-1"><a href="#8-5-flush链表和LSN-1" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-1"><a href="#8-6-Checkpoint-1" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-1"><a href="#九-崩溃重做数据页-1" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-1"><a href="#十-配置重做日志的级别-1" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-2"><a href="#3-2-插入数据时日志格式-2" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<h2 id="一-REDO-LOG-3"><a href="#一-REDO-LOG-3" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2></blockquote>
<p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-3"><a href="#二-高效且持久化的方式-3" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-3"><a href="#三-日志格式-3" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-3"><a href="#3-1-装载数据的通用格式-3" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-3"><a href="#3-2-插入数据时日志格式-3" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-2"><a href="#3-2-REDO-日志内容-2" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-2"><a href="#四-重做LOG的’事务’-2" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-2"><a href="#五-重做LOG缓冲区-2" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-2"><a href="#六-触发重做LOG刷盘-2" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-2"><a href="#七-重做LOG刷到哪些文件里-2" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-2"><a href="#八-重做LOG缓冲页与日志文件的关系-2" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-2"><a href="#8-1-重做日志文件的格式-2" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-2"><a href="#8-2-LSN-Log-Swquence-Number-2" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-2"><a href="#8-4-日志缓冲数据刷盘-2" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-2"><a href="#8-5-flush链表和LSN-2" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-2"><a href="#8-6-Checkpoint-2" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-2"><a href="#九-崩溃重做数据页-2" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-2"><a href="#十-配置重做日志的级别-2" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<h2 id="一-REDO-LOG-4"><a href="#一-REDO-LOG-4" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-4"><a href="#二-高效且持久化的方式-4" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-4"><a href="#三-日志格式-4" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-4"><a href="#3-1-装载数据的通用格式-4" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-4"><a href="#3-2-插入数据时日志格式-4" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-3"><a href="#3-2-REDO-日志内容-3" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-3"><a href="#四-重做LOG的’事务’-3" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-3"><a href="#五-重做LOG缓冲区-3" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-3"><a href="#六-触发重做LOG刷盘-3" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-3"><a href="#七-重做LOG刷到哪些文件里-3" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-3"><a href="#八-重做LOG缓冲页与日志文件的关系-3" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-3"><a href="#8-1-重做日志文件的格式-3" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-3"><a href="#8-2-LSN-Log-Swquence-Number-3" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-3"><a href="#8-4-日志缓冲数据刷盘-3" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-3"><a href="#8-5-flush链表和LSN-3" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-3"><a href="#8-6-Checkpoint-3" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-3"><a href="#九-崩溃重做数据页-3" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-3"><a href="#十-配置重做日志的级别-3" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-4"><a href="#3-2-REDO-日志内容-4" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<h2 id="一-REDO-LOG-5"><a href="#一-REDO-LOG-5" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-5"><a href="#二-高效且持久化的方式-5" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-5"><a href="#三-日志格式-5" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-5"><a href="#3-1-装载数据的通用格式-5" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-5"><a href="#3-2-插入数据时日志格式-5" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-5"><a href="#3-2-REDO-日志内容-5" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-4"><a href="#四-重做LOG的’事务’-4" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-4"><a href="#五-重做LOG缓冲区-4" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-4"><a href="#六-触发重做LOG刷盘-4" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-4"><a href="#七-重做LOG刷到哪些文件里-4" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-4"><a href="#八-重做LOG缓冲页与日志文件的关系-4" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-4"><a href="#8-1-重做日志文件的格式-4" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-4"><a href="#8-2-LSN-Log-Swquence-Number-4" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-4"><a href="#8-4-日志缓冲数据刷盘-4" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-4"><a href="#8-5-flush链表和LSN-4" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-4"><a href="#8-6-Checkpoint-4" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-4"><a href="#九-崩溃重做数据页-4" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-4"><a href="#十-配置重做日志的级别-4" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-5"><a href="#四-重做LOG的’事务’-5" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<h2 id="一-REDO-LOG-6"><a href="#一-REDO-LOG-6" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-6"><a href="#二-高效且持久化的方式-6" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-6"><a href="#三-日志格式-6" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-6"><a href="#3-1-装载数据的通用格式-6" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-6"><a href="#3-2-插入数据时日志格式-6" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-6"><a href="#3-2-REDO-日志内容-6" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-6"><a href="#四-重做LOG的’事务’-6" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-5"><a href="#五-重做LOG缓冲区-5" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-5"><a href="#六-触发重做LOG刷盘-5" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-5"><a href="#七-重做LOG刷到哪些文件里-5" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-5"><a href="#八-重做LOG缓冲页与日志文件的关系-5" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-5"><a href="#8-1-重做日志文件的格式-5" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-5"><a href="#8-2-LSN-Log-Swquence-Number-5" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-5"><a href="#8-4-日志缓冲数据刷盘-5" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-5"><a href="#8-5-flush链表和LSN-5" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-5"><a href="#8-6-Checkpoint-5" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-5"><a href="#九-崩溃重做数据页-5" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-5"><a href="#十-配置重做日志的级别-5" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-6"><a href="#五-重做LOG缓冲区-6" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<h2 id="一-REDO-LOG-7"><a href="#一-REDO-LOG-7" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-7"><a href="#二-高效且持久化的方式-7" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-7"><a href="#三-日志格式-7" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-7"><a href="#3-1-装载数据的通用格式-7" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-7"><a href="#3-2-插入数据时日志格式-7" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-7"><a href="#3-2-REDO-日志内容-7" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-7"><a href="#四-重做LOG的’事务’-7" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-7"><a href="#五-重做LOG缓冲区-7" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-6"><a href="#六-触发重做LOG刷盘-6" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-6"><a href="#七-重做LOG刷到哪些文件里-6" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-6"><a href="#八-重做LOG缓冲页与日志文件的关系-6" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-6"><a href="#8-1-重做日志文件的格式-6" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-6"><a href="#8-2-LSN-Log-Swquence-Number-6" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-6"><a href="#8-4-日志缓冲数据刷盘-6" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-6"><a href="#8-5-flush链表和LSN-6" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-6"><a href="#8-6-Checkpoint-6" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-6"><a href="#九-崩溃重做数据页-6" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-6"><a href="#十-配置重做日志的级别-6" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<h2 id="一-REDO-LOG-8"><a href="#一-REDO-LOG-8" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-8"><a href="#二-高效且持久化的方式-8" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-8"><a href="#三-日志格式-8" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-8"><a href="#3-1-装载数据的通用格式-8" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-8"><a href="#3-2-插入数据时日志格式-8" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-8"><a href="#3-2-REDO-日志内容-8" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-8"><a href="#四-重做LOG的’事务’-8" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-8"><a href="#五-重做LOG缓冲区-8" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-7"><a href="#六-触发重做LOG刷盘-7" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-7"><a href="#七-重做LOG刷到哪些文件里-7" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-7"><a href="#八-重做LOG缓冲页与日志文件的关系-7" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-7"><a href="#8-1-重做日志文件的格式-7" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-7"><a href="#8-2-LSN-Log-Swquence-Number-7" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-7"><a href="#8-4-日志缓冲数据刷盘-7" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-7"><a href="#8-5-flush链表和LSN-7" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-7"><a href="#8-6-Checkpoint-7" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-7"><a href="#九-崩溃重做数据页-7" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-7"><a href="#十-配置重做日志的级别-7" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-8"><a href="#六-触发重做LOG刷盘-8" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-8"><a href="#七-重做LOG刷到哪些文件里-8" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-8"><a href="#八-重做LOG缓冲页与日志文件的关系-8" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-8"><a href="#8-1-重做日志文件的格式-8" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><h2 id="一-REDO-LOG-9"><a href="#一-REDO-LOG-9" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-9"><a href="#二-高效且持久化的方式-9" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-9"><a href="#三-日志格式-9" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-9"><a href="#3-1-装载数据的通用格式-9" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-9"><a href="#3-2-插入数据时日志格式-9" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-9"><a href="#3-2-REDO-日志内容-9" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-9"><a href="#四-重做LOG的’事务’-9" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-9"><a href="#五-重做LOG缓冲区-9" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-9"><a href="#六-触发重做LOG刷盘-9" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-9"><a href="#七-重做LOG刷到哪些文件里-9" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-9"><a href="#八-重做LOG缓冲页与日志文件的关系-9" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-9"><a href="#8-1-重做日志文件的格式-9" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-8"><a href="#8-2-LSN-Log-Swquence-Number-8" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-8"><a href="#8-4-日志缓冲数据刷盘-8" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-8"><a href="#8-5-flush链表和LSN-8" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-8"><a href="#8-6-Checkpoint-8" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-8"><a href="#九-崩溃重做数据页-8" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-8"><a href="#十-配置重做日志的级别-8" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-9"><a href="#8-2-LSN-Log-Swquence-Number-9" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  ## 一.REDO LOG</p>
<p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-10"><a href="#二-高效且持久化的方式-10" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-10"><a href="#三-日志格式-10" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-10"><a href="#3-1-装载数据的通用格式-10" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-10"><a href="#3-2-插入数据时日志格式-10" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-10"><a href="#3-2-REDO-日志内容-10" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-10"><a href="#四-重做LOG的’事务’-10" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-10"><a href="#五-重做LOG缓冲区-10" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-10"><a href="#六-触发重做LOG刷盘-10" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-10"><a href="#七-重做LOG刷到哪些文件里-10" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-10"><a href="#八-重做LOG缓冲页与日志文件的关系-10" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-10"><a href="#8-1-重做日志文件的格式-10" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-10"><a href="#8-2-LSN-Log-Swquence-Number-10" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-9"><a href="#8-4-日志缓冲数据刷盘-9" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-9"><a href="#8-5-flush链表和LSN-9" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-9"><a href="#8-6-Checkpoint-9" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-9"><a href="#九-崩溃重做数据页-9" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-9"><a href="#十-配置重做日志的级别-9" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<h3 id="8-4-日志缓冲数据刷盘-10"><a href="#8-4-日志缓冲数据刷盘-10" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<h2 id="一-REDO-LOG-10"><a href="#一-REDO-LOG-10" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-11"><a href="#二-高效且持久化的方式-11" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-11"><a href="#三-日志格式-11" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-11"><a href="#3-1-装载数据的通用格式-11" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-11"><a href="#3-2-插入数据时日志格式-11" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-11"><a href="#3-2-REDO-日志内容-11" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-11"><a href="#四-重做LOG的’事务’-11" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-11"><a href="#五-重做LOG缓冲区-11" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-11"><a href="#六-触发重做LOG刷盘-11" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-11"><a href="#七-重做LOG刷到哪些文件里-11" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-11"><a href="#八-重做LOG缓冲页与日志文件的关系-11" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-11"><a href="#8-1-重做日志文件的格式-11" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-11"><a href="#8-2-LSN-Log-Swquence-Number-11" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-11"><a href="#8-4-日志缓冲数据刷盘-11" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-10"><a href="#8-5-flush链表和LSN-10" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-10"><a href="#8-6-Checkpoint-10" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-10"><a href="#九-崩溃重做数据页-10" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-10"><a href="#十-配置重做日志的级别-10" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-11"><a href="#8-5-flush链表和LSN-11" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<h2 id="一-REDO-LOG-11"><a href="#一-REDO-LOG-11" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2></blockquote>
<p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-12"><a href="#二-高效且持久化的方式-12" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-12"><a href="#三-日志格式-12" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-12"><a href="#3-1-装载数据的通用格式-12" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-12"><a href="#3-2-插入数据时日志格式-12" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-12"><a href="#3-2-REDO-日志内容-12" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-12"><a href="#四-重做LOG的’事务’-12" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-12"><a href="#五-重做LOG缓冲区-12" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-12"><a href="#六-触发重做LOG刷盘-12" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-12"><a href="#七-重做LOG刷到哪些文件里-12" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-12"><a href="#八-重做LOG缓冲页与日志文件的关系-12" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-12"><a href="#8-1-重做日志文件的格式-12" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-12"><a href="#8-2-LSN-Log-Swquence-Number-12" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-12"><a href="#8-4-日志缓冲数据刷盘-12" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-12"><a href="#8-5-flush链表和LSN-12" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-11"><a href="#8-6-Checkpoint-11" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-11"><a href="#九-崩溃重做数据页-11" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-11"><a href="#十-配置重做日志的级别-11" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<h2 id="一-REDO-LOG-12"><a href="#一-REDO-LOG-12" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-13"><a href="#二-高效且持久化的方式-13" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-13"><a href="#三-日志格式-13" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-13"><a href="#3-1-装载数据的通用格式-13" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-13"><a href="#3-2-插入数据时日志格式-13" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-13"><a href="#3-2-REDO-日志内容-13" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-13"><a href="#四-重做LOG的’事务’-13" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-13"><a href="#五-重做LOG缓冲区-13" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-13"><a href="#六-触发重做LOG刷盘-13" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-13"><a href="#七-重做LOG刷到哪些文件里-13" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-13"><a href="#八-重做LOG缓冲页与日志文件的关系-13" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-13"><a href="#8-1-重做日志文件的格式-13" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-13"><a href="#8-2-LSN-Log-Swquence-Number-13" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-13"><a href="#8-4-日志缓冲数据刷盘-13" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-13"><a href="#8-5-flush链表和LSN-13" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-12"><a href="#8-6-Checkpoint-12" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-12"><a href="#九-崩溃重做数据页-12" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-12"><a href="#十-配置重做日志的级别-12" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>最后的状态：</p>
<h2 id="一-REDO-LOG-13"><a href="#一-REDO-LOG-13" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-14"><a href="#二-高效且持久化的方式-14" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-14"><a href="#三-日志格式-14" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-14"><a href="#3-1-装载数据的通用格式-14" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-14"><a href="#3-2-插入数据时日志格式-14" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-14"><a href="#3-2-REDO-日志内容-14" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-14"><a href="#四-重做LOG的’事务’-14" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-14"><a href="#五-重做LOG缓冲区-14" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-14"><a href="#六-触发重做LOG刷盘-14" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-14"><a href="#七-重做LOG刷到哪些文件里-14" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-14"><a href="#八-重做LOG缓冲页与日志文件的关系-14" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-14"><a href="#8-1-重做日志文件的格式-14" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-14"><a href="#8-2-LSN-Log-Swquence-Number-14" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-14"><a href="#8-4-日志缓冲数据刷盘-14" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-14"><a href="#8-5-flush链表和LSN-14" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-13"><a href="#8-6-Checkpoint-13" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-13"><a href="#九-崩溃重做数据页-13" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-13"><a href="#十-配置重做日志的级别-13" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-14"><a href="#8-6-Checkpoint-14" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<h2 id="一-REDO-LOG-14"><a href="#一-REDO-LOG-14" class="headerlink" title="一.REDO LOG"></a>一.REDO LOG</h2><p>数据库最主要的特性是 <code>持久性</code>，即修改了数据库数据以后，无论发生什么事情，数据都不会丢失。<code>MySQL-InnDB</code> 就利用 <code>REDO LOG</code> 来满足持久性。<code>REDO LOG</code> 中文称为 <code>重做日志</code>，那也可以简洁一点叫做 <code>REDO 日志</code>。是数据库启动的时候，用于读取计算 <code>BufferPool</code> 中脏页数据的方式，这样可以避免由于其他原因导致数据库掉线但是脏页未刷新到硬盘，而导致数据丢失的尴尬局面。</p>
<h2 id="二-高效且持久化的方式-15"><a href="#二-高效且持久化的方式-15" class="headerlink" title="二.高效且持久化的方式"></a>二.高效且持久化的方式</h2><p>由于 <code>REDO 日志</code> 存在的意义就是，<strong>重启数据库的时候能够重新将数据恢复回来</strong>。所以在数据库没有发生重启或者异常宕机的时候，他是没有任何意义的，甚至还多了一些开销…</p>
<p>所以为了减少开销，<code>REDO 日志</code> 应当尽量轻巧，记录一些必要的信息就可以了，比如：<code>某个区，某个页号，的某一行，修改成xx</code>。第二个减少开销的方式就是顺序写入硬盘，先发生的事务，<code>REDO 日志</code> 先被写入硬盘，后边的排队顺序追加到后面去。</p>
<h2 id="三-日志格式-15"><a href="#三-日志格式-15" class="headerlink" title="三.日志格式"></a>三.日志格式</h2><p>首先明白一点，<code>REDO 日志</code> 所携带的数据是 <code>MySQL_InnoDB</code> 在重启系统的时候，需要调用某些函数进行恢复时所需要的参数。不过，为了减少容量的开销，又做了一些事情。</p>
<h3 id="3-1-装载数据的通用格式-15"><a href="#3-1-装载数据的通用格式-15" class="headerlink" title="3.1 装载数据的通用格式"></a>3.1 装载数据的通用格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113143.jpeg"></p>
<p>一条重做日志，肯定会包含上面这些信息。</p>
<p>日志类型，在现在常用的 <code>5.7</code> 中，有 <code>53</code> 种类型，这个类型字段就很重要了，决定着程序恢复数据的方式。</p>
<ol>
<li><code>MLOG_1BYTE</code>（<code>type = 1</code>）：表示在页面的某个偏移量写入 <code>1byte</code> 的数据的 <code>REDO 日志</code> 类型；</li>
<li><code>MLOG_2BYTE</code>（<code>type = 2</code>）：写入 <code>2byte</code> 的数据；</li>
<li><code>MLOG_4BYTE</code>（<code>type = 4</code>）：写入 <code>4byte</code> 的数据；</li>
<li><code>MLOG_8BYTE</code>（<code>type = 8</code>）：写入 <code>8byte</code> 的数据；</li>
<li><code>MLOG_WRITE_STRING</code>（<code>type = 30</code>）：写入一串数据，具体长度会放在上图中 <code>黄色</code> 的部分；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113159.jpeg"></p>
<p>可以看到第 <code>5</code> 中类型在具体内容中带有一个 <code>len</code> 表示数据的长度，也有点类似于我们做 <code>RPC</code> 的时候为了粘包写的长度。那我们业务中每次更新都会更新很多东西，可以说基本都是使用第 <code>5</code> 种日志类型了。</p>
<p>而 <code>偏移量在上面所有类型的日志中都有</code>。</p>
<h3 id="3-2-插入数据时日志格式-15"><a href="#3-2-插入数据时日志格式-15" class="headerlink" title="3.2 插入数据时日志格式"></a>3.2 插入数据时日志格式</h3><p>OK，现在我们来了解下日志存储哪些东西。</p>
<p>我们日常插入，比如说 <code>INSERT INTO student values(1, &#39;Weidan&#39;, &#39;BOY&#39;)</code> 这条插入语句，看似只需要插入一条数据即可，但是还记得吗，之前说过的页分裂问题呀，还有调整页参数信息的问题：</p>
<blockquote>
<p><strong>如果还记得这些内容的话，跳过我引用的内容</strong></p>
<p>页头信息主要包含以下几个部分：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">大小（字节数）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">FILE_PAGE_SPACE_OR_CHKSUM</td>
<td align="center">4</td>
<td><code>4.0.14</code> 之前存放在哪个表空间<br/>后面的版本存储 <code>checksum</code> 值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_OFFSET</td>
<td align="center">4</td>
<td>表空间中页的页号</td>
</tr>
<tr>
<td align="left">FILE_PAGE_PREV</td>
<td align="center">4</td>
<td>上一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_NEXT</td>
<td align="center">4</td>
<td>下一页</td>
</tr>
<tr>
<td align="left">FILE_PAGE_LSN</td>
<td align="center">8</td>
<td>最后修改的日志序号<br/><code>Log Swquence Number</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_TYPE</td>
<td align="center">2</td>
<td>页的类型：<code>在后面给出</code></td>
</tr>
<tr>
<td align="left">FILE_PAGE_FILE_FLUSH_LSN</td>
<td align="center">8</td>
<td>代表文件被更新到该指定的LSN值</td>
</tr>
<tr>
<td align="left">FILE_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td align="center">4</td>
<td>属于哪个表空间</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>如果说 <code>FileHeader</code> 是用来记录文件的信息，那 <code>PageHeader</code> 就是用来记录当前数据页的状态信息了。</p>
<p>同样也是一堆 <code>Key</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th align="center">大小（字节）</th>
<th>主要作用</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td align="center">2</td>
<td>Page Directory 页目录中的槽数</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td align="center">2</td>
<td>堆中第一个记录的指针</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td align="center">2</td>
<td>堆中记录数</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td align="center">2</td>
<td>空闲列表首指针</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td align="center">2</td>
<td>已删除的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td align="center">2</td>
<td>最后插入的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td align="center">2</td>
<td>插入数据的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td align="center">2</td>
<td>一个方向连续插入记录的数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td align="center">2</td>
<td>该页记录数</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td align="center">8</td>
<td>当前页最大事务ID</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td align="center">2</td>
<td>索引树中的位置 0x00代表叶节点</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td align="center">8</td>
<td>当前页属于哪个索引的id</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td align="center">10</td>
<td>叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td align="center">10</td>
<td>非叶子节点中文件段首指针位置（B+的Root页中定义）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><code>Infimum</code> 记录比当前页最小主键还要小的“值”，<code>Supremum</code> 记录比当前页最大值还要大的“值”。</p>
<p>值我打了双引号，并不是说他就是一个值，而是一个规定：<strong>一个页中，Infimum 记录的下一条记录就是本页中最小的记录，而本页中最大的记录的下一条记录就是 Supremum 记录 。</strong> （这里的下一条 <code>next_record</code> 的字段是 <code>Row Format</code> 规定的头，后面讲行信息的头部消息的时候我会重新说一下这句的）</p>
</blockquote>
<blockquote>
<p>页分裂：</p>
<p><img src="https://liweidan.cn/wp-content/uploads/2020/03/B_plus_tree_split.gif"></p>
</blockquote>
<p>好了，所以说，插入一条数据的时候需要调整的东西特别多，而且这些地方的调整都需要生成 <code>REDO 日志</code>。</p>
<p>但是这些需要修改的地方特别零散，他并不是聚集在一起的</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113210.jpeg"></p>
<p>上图黄色的地方就是被修改的数据。</p>
<p>那现在有两种解决方案，一种是修改多少个地方就记录多少条日志，这样就需要 <code>8</code> 条 <code>REDO 日志</code>。</p>
<p>那如果说将第一个修改的地方，和最后一个修改的地方，所有数据都进行记录的话，像上面那张图，最后一个因为拉的很远，中间那些没有修改的数据就都需要放到 <code>REDO 日志</code> 上去，那么这样又感觉不优雅（讲真我以前我还真的这么干过用户编辑信息）。</p>
<p>两种方案，一个太多，一个太大。所以就诞生了其他的 <code>REDO 日志</code> 类型：</p>
<ol>
<li><code>MLOG_COMP_REC_INSERT</code> （<code>type = 38</code>）：表示插入一条使用紧凑行格式的记录时的日志类型；</li>
<li><code>MLOG_COMP_PAGE_CREATE</code>（<code>type = 58</code>）：表示创建一个存储紧凑行格式记录的页面的日志类型；</li>
<li><code>MLOG_COMP_REC_DELETE</code>（<code>type = 42</code>）：表示删除一条紧凑型行格式的数据的日志类型；</li>
<li>……</li>
</ol>
<p>太多了，不过看第三个表示 <code>REC</code> 和 <code>PAGE</code> 分别表示对应的行还是页做操作，第四个就是增删查改了。</p>
<p>但是有个比较特殊，那就是 <code>批量删除</code> 了：</p>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type = 44</code>）和 <code>MLOG_COMP_LIST_END_DELETE</code> （<code>type = 43</code>）表示批量删除的时候，开始删除跟结束删除的两条范围记录。</p>
<h3 id="3-2-REDO-日志内容-15"><a href="#3-2-REDO-日志内容-15" class="headerlink" title="3.2 REDO 日志内容"></a>3.2 REDO 日志内容</h3><p>而一个 <code>REDO 日志</code> 包含了两个层面的东西：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113221.jpeg"></p>
<p>而逻辑层面的东西，并不是说在重启的时候直接回复到数据文件中，而是需要经过一系列的计算，然后再得出最后结果写入数据文件，类似于 <code>Java</code> 写 <code>方法</code> 的时候需要用到的一些参数信息。而上一节中的类型，指的是参数的不同，<code>InnoDB</code> 恰好可以根据这些参数计算出来对应的 <code>PAGE_N_DIR_SLOTS</code> <code>PAGE_N_HEAP</code> 等等信息，然后恢复到数据库中。</p>
<h2 id="四-重做LOG的’事务’-15"><a href="#四-重做LOG的’事务’-15" class="headerlink" title="四.重做LOG的’事务’"></a>四.重做LOG的’事务’</h2><p><code>重做LOG</code> 的’事务’ 也成为 <code>Mini-Transaction</code>，因为我们知道系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果 <code>重做LOG</code> 在写入硬盘的时候，写少了点东西，势必导致这部分的日志被破坏不可用了，所以 <code>InnoDB</code> 规定，某些修改数据页的 <code>重做LOG</code> 必须一起被写入硬盘，这部分的 <code>重做LOG</code> 才算真的有效。</p>
<p>我们上面已经知道，一条修改语句或者新增语句将会更多多个地方，就真的可能出现了多个 <code>重做LOG</code>，更何况我们一般开事务也不会无聊到只运行一条增删改语句，所以一个事务下来，就会出现很多条 <code>重做LOG</code>，那从上面又知道，因为各个硬件写入的速率不同，所以需要有些 <code>Mini-Transaction</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113229.jpeg"></p>
<p>以下这些常见情况，必须视为一个不可分割的 <code>Mini-Transaction</code>：</p>
<ol>
<li>没有指定 <code>主键</code> 的情况下，全局更新 <code>Max Row ID</code> 时候产生的 <code>重做LOG</code>；</li>
<li>向聚簇索引的 <code>B+树</code> 插入一条记录产生的 <code>重做LOG</code>；</li>
<li>向二级索引对应的 <code>B+树</code> 插入一条记录的日志；</li>
<li>……</li>
</ol>
<h2 id="五-重做LOG缓冲区-15"><a href="#五-重做LOG缓冲区-15" class="headerlink" title="五.重做LOG缓冲区"></a>五.重做LOG缓冲区</h2><p>日志已经生成，这时候需要考虑的就是怎么落地的问题了，所以就有了 <code>日志缓冲区</code>，<code>区</code> 放的是 <code>重做LOG数据页（跟数据的数据页不同）</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113237.jpeg"></p>
<p><code>HEADER</code> 和 <code>FOOTER</code> 并不打算细说了，主要就是为了校验，以及管理 <code>BODY</code> 中的内容。所以我们主要来说说 <code>BODY</code>。</p>
<p>那么 <code>重做LOG</code> 不可能是串行写入的，要不然速度就上不去了，所以运行时 <code>日志缓冲区</code> 就看起来可能是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113245.jpeg"></p>
<p>如图，<code>事务1</code> 和 <code>事务2</code> 的 <code>MiniTransaction</code> 是交叉运行的，而 <code>事务3</code> 更新的内容比较多，所以会占用多个 <code>缓冲页</code>，有些甚至更大，会占用多个 <code>缓冲页</code>。</p>
<h2 id="六-触发重做LOG刷盘-15"><a href="#六-触发重做LOG刷盘-15" class="headerlink" title="六.触发重做LOG刷盘"></a>六.触发重做LOG刷盘</h2><p>上面那张图引出另外一个问题，已经写入 <code>缓冲区</code> 的 <code>重做LOG</code> 需要怎么落地，如果不落地，那已关机，内存中的 <code>缓冲区</code> 一旦清空，<code>重做LOG</code> 就没有意义了。所以就需要有个机制来刷新这些 <code>重做LOG数据</code> 到硬盘中，那么刷盘的触发情况分为以下几种情况：</p>
<ol>
<li>空间不足，占用配置的 <code>innodb_log_buffer_size</code> <strong>一半左右</strong> 的时候，就会触发刷盘；</li>
<li>事务提交时刷盘，只有刷盘了，才能保证持久性；</li>
<li>后台线程，循环着做这件事情，这个前面已经有说过了；</li>
<li>关闭服务器；</li>
<li>…</li>
</ol>
<h2 id="七-重做LOG刷到哪些文件里-15"><a href="#七-重做LOG刷到哪些文件里-15" class="headerlink" title="七.重做LOG刷到哪些文件里"></a>七.重做LOG刷到哪些文件里</h2><p>既然要刷盘，那就肯定有对应的文件来接收这些数据，可以通过 <code>SHOW VARIABLES LIKE &#39;%datadir%&#39;</code> 来查看是哪些文件，默认是有 <code>ib_logfile0</code> 和 <code>ib_logfile1</code>。那如果我们需要调整，调大或者调小就使用下面的参数进行调整：</p>
<ol>
<li><code>innodb_log_group_home_dir</code>：存储日志的目录；</li>
<li><code>innodb_log_file_size</code>：每个文件的大小，感觉大小这个度需要把握好，太小会导致很多 <code>重做LOG</code> 不完整，太大又不利于 <code>防灾</code>；</li>
<li><code>innodb_log_files_in_group</code>：分割日志的个数，默认是 <code>2</code> 个；</li>
</ol>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
<p>循环从头开始写 <code>重做LOG</code> 的时候，那必须会碰到 <code>前面的重做LOG</code> 被覆盖的问题，那如何判断前面的 <code>重做LOG</code> 是否还有用，就是需要判断 <code>BufferPool</code> 中的 <code>脏页</code> 是否已经被刷新到硬盘了，如果已经刷新成功，那么这部分的 <code>重做LOG</code> 肯定是没有用的，可以放心的覆盖。这就回到了我们的初衷：<code>持久化且高效的保存数据</code>。</p>
<p>那如何判断咧，需要结合之前我们在 <code>BufferPool</code> 中说到的 <code>flush链表</code> 了。</p>
<h2 id="八-重做LOG缓冲页与日志文件的关系-15"><a href="#八-重做LOG缓冲页与日志文件的关系-15" class="headerlink" title="八.重做LOG缓冲页与日志文件的关系"></a>八.重做LOG缓冲页与日志文件的关系</h2><h3 id="8-1-重做日志文件的格式-15"><a href="#8-1-重做日志文件的格式-15" class="headerlink" title="8.1 重做日志文件的格式"></a>8.1 重做日志文件的格式</h3><p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113254.jpeg"></p>
<p>上面 <code>第一个管理单元</code> 和 <code>第二四管理单元</code> 里面涉及到的 <code>LSN</code> 和 <code>CheckPoint</code> 是重点。</p>
<h3 id="8-2-LSN-Log-Swquence-Number-15"><a href="#8-2-LSN-Log-Swquence-Number-15" class="headerlink" title="8.2 LSN - Log Swquence Number"></a>8.2 LSN - Log Swquence Number</h3><p><code>LSN</code> 是一个日志的序列号，这个值从开始有 <code>REDO</code> 开始，将会不停的自增，可以理解为数据表的主键一样，插入一条新的数据的 <code>自增ID</code> 变化情况。<code>InnoDB</code> 会有一个全局变量，专门用于记录这个值变化到哪个数据点，不过他不是从 <code>0</code> 开始而是从 <code>8704</code> 开始，也就是规定一条 <code>重做LOG</code> 都没有的情况下，这个 <code>全局变量</code> 的值就是 <code>8704</code>。</p>
<p>而 <code>LSN</code> 的增长，是会加上 <code>重做LOG页</code> 的头部和尾部的，就是说当一个 <code>MiniTransaction</code> 跨越几个区的时候，那这个值里面就包含了覆盖到的 <code>HEADER</code> 和 <code>FOOTER</code> 值。  <img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113308.jpeg"></p>
<h3 id="8-4-日志缓冲数据刷盘-15"><a href="#8-4-日志缓冲数据刷盘-15" class="headerlink" title="8.4 日志缓冲数据刷盘"></a>8.4 日志缓冲数据刷盘</h3><p>由于需要刷盘，并且记录哪些数据已经被刷新到硬盘了，这样才能够释放内存空间让后面的 <code>重做LOG</code> 来用。所以上面提到的 <code>LSN</code> 就开始有用处了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113316.jpeg"></p>
<p>这时候，<code>InnoDB</code> 中又出现了几个全局变量（可以理解为指针）：</p>
<ol>
<li><code>buf_next_to_write</code>：此指针之前的数据表示已经准备刷盘的日志数据，这部分的日志数据已经可以被复用的；</li>
<li><code>flushed_to_disk_lsn</code>：系统已经返回刷新成功的 <code>LSN</code> 的值；</li>
<li><code>buf_free</code>：此指针之后的内存空间表示是空闲的，如果有新的日志要进来，就需要追加到后面的内存中去，这个值其实就是跟上面提到的 <code>LSN</code> 一样的值。</li>
</ol>
<p>那 <code>buf_next_to_write</code> 到 <code>buf_free</code> 中间的数据就是已经存在于 <code>内存中的</code>，但是 <code>还没有提交刷入硬盘的请求给系统的数据</code>。</p>
<blockquote>
<p>刷新硬盘：我们需要将文件写入硬盘的时候，其实是提交请求给系统，系统将数据放入数据缓冲区，在某个时刻被刷盘，只有调用了 <code>fsync函数</code> 之后，数据才是真正的进入硬盘。所以这时候需要两个变量来弄清楚哪些数据已经提交给系统，哪些数据已经完完整整落在硬盘上的，就分别对应 <code>buf_next_to_write</code> 和 <code>flushed_to_disk_lsn</code> 两个变量参数。</p>
</blockquote>
<p>那我们就可以知道，刚开机的时候，<code>LSN</code> 的值和上面三个全局变量其实应该是相等的，随着系统的运行，<code>SQL</code> 不断的请求，这时候 <code>buf_free</code> 一定会跑得比别的参数快，然后随着写入硬盘的请求逐步完成，当四个值都相等的时候，就表示所有的日志已经刷入硬盘了。</p>
<h3 id="8-5-flush链表和LSN-15"><a href="#8-5-flush链表和LSN-15" class="headerlink" title="8.5 flush链表和LSN"></a>8.5 flush链表和LSN</h3><blockquote>
<p>flush链表：</p>
<p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。</p>
<p>但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113335.jpeg"></p>
</blockquote>
<p>我们在对数据进行修改的时候，一直处于 <code>重做LOG缓冲区</code> 的视觉，现在需要将视觉切换到 <code>BufferPool</code> 中去，<code>BufferPool</code> 还有个东西，叫做 <code>flush链表</code>，为了回忆我已经将上次写的东西放在了上面。</p>
<p>那我们需要结合 <code>MiniTransaction</code> 来说，每个控制块里面有两个属性，一个叫做 <code>oldest_modification</code> 一个叫做 <code>newest_modification</code>。<code>oldest_modification</code> 会记录在开始做修改时 <code>LSN</code> 的值，修改完成后，<code>newest_modification</code> 记录修改后的 <code>LSN</code> 的值。</p>
<p>那 <code>flush链表</code> 会发生哪些变化，我直接画个动态图来说吧：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113350.gif"></p>
<p>最后的状态：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113407.jpeg"></p>
<p>归纳几个特点：</p>
<ol>
<li>最新被修改的数据页，总是会被移动到链表的开始；</li>
<li>链表的尾部是比较早些时候发生修改的数据页；</li>
<li>如果一个数据页发生过修改已经存在于 <code>flush链表</code> 中的话，如果又有新的修改，<code>om</code> 保持不变，<code>nm</code> 会被修改成新的 <code>LSN</code> 值。</li>
</ol>
<h3 id="8-6-Checkpoint-15"><a href="#8-6-Checkpoint-15" class="headerlink" title="8.6 Checkpoint"></a>8.6 Checkpoint</h3><p>在 <code>第七节</code> 的时候说过：</p>
<blockquote>
<p>那 <code>InnoDB</code> 在写 <code>重做LOG</code> 的时候就从编号 <code>0</code> 开始，写到最后一个。如果到了最后一个并且已经用完了所有空间了，那就重新从 <code>0</code> 开始，依次类推循环的写入硬盘。</p>
</blockquote>
<p>所以我们的两个日志文件 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> ，<code>ib_logfile1</code> 在写到结尾的时候，会重新回到 <code>ib_logfile0</code> 开始写，那么 <code>Checkpoint</code> 的提出就是为了解决在回去写 <code>ib_logfile0</code> 的时候是否可以覆盖前面的日志的问题。</p>
<p>结合上面说的 <code>flush链表</code>，那就可以说了，<code>InnoDB</code> 只需要判断前面的 <code>重做LOG</code> 对应的数据页是否存在 <code>flush链表</code>，如果不存在，则表示这些数据页已经顺利写到数据页中去，也就表明前面的 <code>重做LOG</code> 已经可以覆盖掉了。</p>
<p>所以，<code>InnoDB</code> 又用了一个全局的变量 <code>checkpoint_lsn</code> 来表示数据页刷新到哪个 <code>LSN</code> 了，而这个值每次在脏页被写入硬盘的时候就会被修改成当前脏页的 <code>newest_modification</code>。也是下一个脏页的 <code>oldest_modification</code>。那么 <code>重做LOG</code> 刚开始的日志 <code>LSN</code> 如果小于这个 <code>checkpoint_lsn</code> 的话，表示这些日志已经没用了，可以被覆盖掉。而每进行一次 <code>checkpoint</code> 后，<code>checkpoint_lsn</code> 的值就会被写入日志实体文件的管理信息里面，就是下面蓝色部分：</p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113418.jpeg"></p>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-14"><a href="#九-崩溃重做数据页-14" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-14"><a href="#十-配置重做日志的级别-14" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>
<p>那这时候我们就可以来说说管理信息中两个 <code>Checkpoint</code> 块信息的事情了。</p>
<p><code>LOG_CHECKPOINT_NO</code> 是服务器做 <code>Checkpoint</code> 的次数，这个变量有个全局变量，每做一次，此变量就会自增加1，然后被一起写入到这个管理信息块中去。而 <code>LOG_CHECKPOINT_OFFSET</code> 则对应的日志数据的偏移量。那这个偏移量前面的数据就是可以丢弃的。而放入那个 <code>Checkpoint块</code> 中，<code>InnoDB</code> 会判断 <code>LOG_CHECKPOINT_NO</code>，如果这个数是 <code>偶数</code> 就写入 <code>第一个</code> 块中，如果是 <code>奇数</code> 就写入 <code>第二个</code> 块中。</p>
<h2 id="九-崩溃重做数据页-15"><a href="#九-崩溃重做数据页-15" class="headerlink" title="九.崩溃重做数据页"></a>九.崩溃重做数据页</h2><p><code>第八节</code> 说了这么多记录重做的事情，那如果系统发生崩溃需要重做，这时候 <code>重做LOG</code> 就发挥用处了。</p>
<p>那硬盘中的 <code>重做文件</code> 的 <code>头信息</code> 将起到计算从哪里开始恢复的作用：</p>
<ol>
<li>先读取两个文件的所有管理块信息；</li>
<li>从所有管理块信息中的两个 <code>Checkpoint</code> 信息中，确定哪个信息的 <code>checkpoint_no</code> 比较大，则表示上次 <code>checkpoint</code> 做到哪个信息中，这时候就可以顺势拿出 <code>checkpoint_log_offset</code> 之后的日志数据了，那这一步就可以确定恢复的日志起点；</li>
<li>确定哪个 <code>重做LOG数据页</code> 的 <code>BODY</code> 没有被写满，则这个地方就是最后需要恢复的地方了；</li>
<li>然后先排序所有的 <code>重做LOG</code> 数据，然后将相同 <code>表空间ID</code> 和 <code>页号</code> 的重做数据放在一起（<code>Hash</code> 的方式，可以想象成 <code>Map&lt;TableIdAndPage, List&lt;Log&gt;&gt;</code> 的结构）；</li>
<li>由于后台线程在不停的刷新脏页，可能发生数据页已经刷盘但是还没来得及写 <code>checkpoint</code> 的情况，所以现在所有日志并不是都需要重做一次，如果出现数据页结构中的 <code>File Header</code> 的 <code>FIL_PAGE_LSN</code> 值大于 <code>checkpoint_lsn</code> 的话，说明数据已经刷入硬盘了，就不需要再重做。否则，将 <code>重做LOG</code> 中的修改某某地方为某个值重新按顺序执行一遍，就可以恢复到奔溃前的数据了。</li>
</ol>
<h2 id="十-配置重做日志的级别-15"><a href="#十-配置重做日志的级别-15" class="headerlink" title="十.配置重做日志的级别"></a>十.配置重做日志的级别</h2><p>重做日志是为了 <code>持久化</code>，那总有一些业务要求的持久化没那么强烈。</p>
<p>如果不需要在每次提交的时候就刷新到硬盘的话，可以修改 <code>innodb_flush_log_at_trx_commit</code> 的值：</p>
<ul>
<li><code>0</code>：表示提交的时候不立即刷新日志，交给后台系统循环去刷新；</li>
<li><code>1</code>：默认值，表示每次提交需要同步到硬盘；</li>
<li><code>2</code>：表示提交加入 <code>系统缓冲区</code>，交给系统去刷新，这种情况下如果数据库挂了系统没挂的话，那日志一般不会丢失。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://weidanli.github.io/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AD-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E8%83%8C%E6%99%AF-bufferpool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weidan">
      <meta itemprop="description" content="计算机基础 计算机网络 Java Vue 前端 后端">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="丹崽的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/db/mysql/%E3%80%90%E8%81%8A%E8%81%8Amysql%E3%80%91%E5%85%AD-mysql-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E8%83%8C%E6%99%AF-bufferpool/" class="post-title-link" itemprop="url">【聊聊MySQL】六.MySQL-InnoDB的数据库事务背景_BufferPool</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-04 16:29:12" itemprop="dateCreated datePublished" datetime="2020-03-04T16:29:12+08:00">2020-03-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-11-10 11:41:33" itemprop="dateModified" datetime="2020-11-10T11:41:33+08:00">2020-11-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/" itemprop="url" rel="index"><span itemprop="name">db</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/db/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览"><a href="#一-BufferPool总览" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用"><a href="#二-BufferPool查询数据的作用" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用"><a href="#三-BufferPool更改数据的作用" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-1"><a href="#一-BufferPool总览-1" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-1"><a href="#二-BufferPool查询数据的作用-1" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-1"><a href="#三-BufferPool更改数据的作用-1" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成"><a href="#四-BufferPool内部组成" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表"><a href="#4-1-BufferPool数据页链表" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表"><a href="#4-2-BufferPool-的-free-数据缓存链表" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表"><a href="#4-4-BufferPool-的-flush-链表" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例"><a href="#五-配置多个BufferPool实例" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控"><a href="#六-BufferPool状态监控" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool"><a href="#七-配置BufferPool" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置"><a href="#7-1-总大小配置" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置"><a href="#7-2-预读配置" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置"><a href="#7-3-LRU配置" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结"><a href="#八-完结" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。 </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-1"><a href="#四-BufferPool内部组成-1" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-1"><a href="#4-1-BufferPool数据页链表-1" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-2"><a href="#一-BufferPool总览-2" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-2"><a href="#二-BufferPool查询数据的作用-2" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-2"><a href="#三-BufferPool更改数据的作用-2" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-2"><a href="#四-BufferPool内部组成-2" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-2"><a href="#4-1-BufferPool数据页链表-2" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-1"><a href="#4-2-BufferPool-的-free-数据缓存链表-1" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-1"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-1" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-1"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-1" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-1"><a href="#4-4-BufferPool-的-flush-链表-1" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-1"><a href="#五-配置多个BufferPool实例-1" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-1"><a href="#六-BufferPool状态监控-1" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-1"><a href="#七-配置BufferPool-1" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-1"><a href="#7-1-总大小配置-1" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-1"><a href="#7-2-预读配置-1" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-1"><a href="#7-3-LRU配置-1" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-1"><a href="#八-完结-1" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-3"><a href="#一-BufferPool总览-3" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-3"><a href="#二-BufferPool查询数据的作用-3" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-3"><a href="#三-BufferPool更改数据的作用-3" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-3"><a href="#四-BufferPool内部组成-3" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-3"><a href="#4-1-BufferPool数据页链表-3" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-2"><a href="#4-2-BufferPool-的-free-数据缓存链表-2" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-2"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-2" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-2"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-2" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-2"><a href="#4-4-BufferPool-的-flush-链表-2" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-2"><a href="#五-配置多个BufferPool实例-2" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-2"><a href="#六-BufferPool状态监控-2" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-2"><a href="#七-配置BufferPool-2" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-2"><a href="#7-1-总大小配置-2" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-2"><a href="#7-2-预读配置-2" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-2"><a href="#7-3-LRU配置-2" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-2"><a href="#八-完结-2" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-4"><a href="#一-BufferPool总览-4" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-4"><a href="#二-BufferPool查询数据的作用-4" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-4"><a href="#三-BufferPool更改数据的作用-4" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-4"><a href="#四-BufferPool内部组成-4" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-4"><a href="#4-1-BufferPool数据页链表-4" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-3"><a href="#4-2-BufferPool-的-free-数据缓存链表-3" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-3"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-3" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-3"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-3" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-3"><a href="#4-4-BufferPool-的-flush-链表-3" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-3"><a href="#五-配置多个BufferPool实例-3" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-3"><a href="#六-BufferPool状态监控-3" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-3"><a href="#七-配置BufferPool-3" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-3"><a href="#7-1-总大小配置-3" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-3"><a href="#7-2-预读配置-3" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-3"><a href="#7-3-LRU配置-3" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-3"><a href="#八-完结-3" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-4"><a href="#4-2-BufferPool-的-free-数据缓存链表-4" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-5"><a href="#一-BufferPool总览-5" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-5"><a href="#二-BufferPool查询数据的作用-5" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-5"><a href="#三-BufferPool更改数据的作用-5" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-5"><a href="#四-BufferPool内部组成-5" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-5"><a href="#4-1-BufferPool数据页链表-5" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-5"><a href="#4-2-BufferPool-的-free-数据缓存链表-5" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-4"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-4" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-4"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-4" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-4"><a href="#4-4-BufferPool-的-flush-链表-4" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-4"><a href="#五-配置多个BufferPool实例-4" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-4"><a href="#六-BufferPool状态监控-4" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-4"><a href="#七-配置BufferPool-4" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-4"><a href="#7-1-总大小配置-4" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-4"><a href="#7-2-预读配置-4" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-4"><a href="#7-3-LRU配置-4" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-4"><a href="#八-完结-4" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-5"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-5" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-5"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-5" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<blockquote>
<p>该文章采用先各个概念理解然后在最后可以配置各个不同参数的方式。所以如果想要配置的时候，可以直接看最后一个章节。</p>
</blockquote>
<h2 id="一-BufferPool总览-6"><a href="#一-BufferPool总览-6" class="headerlink" title="一. BufferPool总览"></a>一. BufferPool总览</h2><p>之前在 <a href="./%E4%BA%8C.MySQL-InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.md">MySQL-InnoDB体系结构</a> 中有说过，<code>InnoDB</code> 有一个一直在运行的后台线程在跑，目的简单的说就是 <code>异步的同步内存中的数据到硬盘上去</code>。 那进一步说为啥要同步，因为内存中的数据已经发生修改，所以这就是接下来的内容，从修改数据开始讲起。但是之前我们需要先了解一下 <code>BufferPool</code> 的出现。</p>
<h2 id="二-BufferPool查询数据的作用-6"><a href="#二-BufferPool查询数据的作用-6" class="headerlink" title="二. BufferPool查询数据的作用"></a>二. BufferPool查询数据的作用</h2><p>那为啥要使用 <code>BufferPool</code> 捏，这就是从 <code>BufferPool</code> 本质说起。我们在开发的时候，如果为了提速查询功能，通常会用到一个东西，叫做 <code>缓存</code>。 <code>缓存</code> 怎么理解，我们知道，硬盘里面存储着我们的文件，但是程序如果需要读取硬盘上的信息，就需要通过系统 <code>IO</code> 将硬盘上的数据放进去内存中，然后程序才可以使用。如果一个查询很频繁，每次都做这个动作的话，<code>IO</code> 消耗的时间将会很大，而且这个过程除了读取数据之外，其实没有多大的意义，它发生一次就好了，所以我们会把这部分程序经常要 <strong>读取的</strong> 数据放在 <code>内存</code> 中，程序通过 <strong>系统API - 电线</strong> 读取内存中这部分热数据就好了，这样就起到了提速的效果。那么这部分在内存中的热数据称之为 <code>缓存</code>。 那 <code>BufferPool</code> 就是这个缓存了。 前面我们唠叨那么多查询的过程，可以简单的认为就是我们业务查询逻辑的过程，查询到数据丢到缓存（<code>BufferPool</code>）在没有被缓存淘汰的情况下查询这部分数据，就可以直接的从缓存中捞出来返回了，所以第一次查询通常要比后面运行的查询慢，因为需要经历这个过程。</p>
<h2 id="三-BufferPool更改数据的作用-6"><a href="#三-BufferPool更改数据的作用-6" class="headerlink" title="三. BufferPool更改数据的作用"></a>三. BufferPool更改数据的作用</h2><p>那 <code>BufferPool</code> 在数据库中作为缓存的时候，在修改数据时发生的事情又跟我们的程序不一样。我们的程序通常是先修改数据库数据，保证成功以后，再清理缓存。这样就算缓存系统（通常是 <code>Redis</code>）崩了我们的程序还可以接着从数据库读取，并不会太大的影响程序的运行。 但是 <code>BufferPool</code> 就厉害了，他不仅在查询的时候当缓存的角色，在增删改的场景下也是一个当缓存的角色。 怎么做的，当客户端告诉数据库要更新的数据的时候，<code>BufferPool</code> 也是加载数据所在的页，将修改的数据更新到 <code>BufferPool</code> 中。在后面某个时刻需要同步 <code>BufferPool</code> 数据页到磁盘的时候，还发生一个动作，就是将修改后的数据页拷贝到内存中的日志缓冲之中，日志缓冲再按照 <code>一次 1m，两次写入</code> 将修改的数据同步写入<strong>共享表空间</strong>中（并不是表所在的表空间），而写共享表空间的时候，因为是<strong>顺序写入</strong>，不需要考虑调整 <code>索引B+树</code> 的平衡，所以写入将会<strong>很快</strong>。因为这个数据页被两次写入硬盘中，所以这个过程称为 <code>Double Write</code>。 那么我们修改数据的时候发生了什么事情：</p>
<ol>
<li>数据库接收到 <code>Commit</code> 命令（没手动开启事务的话系统也会自动加上去）的时候，将 <code>REDO LOG</code> 同步写入磁盘；</li>
<li><code>BufferPool</code> 加载需要修改的页，在 <code>BufferPool</code> 中发生修改，然后在前面文章所说的 <code>While-True</code> 循环中，在某个时刻写入磁盘；</li>
<li>在某个数据页需要写入磁盘的时候，执行 <code>Double Write</code> 的逻辑，就是先将数据页写入共享表空间中；</li>
<li>开始同步数据页到真正的表空间中，这时候需要同步到硬盘的数据是离散的，因为可能需要修改索引（非聚集+聚集）。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110113951.png"> </p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.itpub.net/29990276/viewspace-2285285/">MySQL double write</a> 那为啥有 <code>REDO LOG</code> 还需要这个 <code>Double Write</code> 呢，原因就是，<code>REDO LOG</code> 的日志格式，他记录着哪一页修改了什么东西，问题就出在数据页是 <code>16kb</code> 的，在写盘的时候，由于系统每次写一页是 <code>4kb</code>，磁盘一次 <code>IO</code> 是 <code>512 byte</code>。那如果在写入数据页的时候，突然发生意外，那磁盘中的数据页可能被破坏了（<code>16kb</code> 只完成了 <code>10kb</code> 的同步 ），而 <code>REDO LOG</code> 是针对数据页做修改做记录的（比如第几页将第一条记录的 <code>a</code> 列从 <code>1</code> 改成 <code>2</code>），那即使有 <code>REDO LOG</code> 他也不敢对一个坏的数据页做修复了。这时候 <code>Double Write</code> 写在表共享空间中的数据页就发生了作用，数据库可以将共享空间中的已经修改完成的数据页还原然后进行重做了。</p>
<h2 id="四-BufferPool内部组成-6"><a href="#四-BufferPool内部组成-6" class="headerlink" title="四. BufferPool内部组成"></a>四. BufferPool内部组成</h2><p>现在我们知道 <code>BufferPool</code> 在 <code>MySQL</code> 中他可是 <code>CRUD</code> 的主要主角，功能不局限于查询数据的时候，缓存数据页的功能，也包含了在修改数据的时候，先修改 <code>BufferPool</code> 中的数据，等待一个循环的线程在某个时刻将数据同步到真正的表空间中。 那么在 <code>BufferPool</code> 中存在哪些东西，我根据标题来展开说说：</p>
<h3 id="4-1-BufferPool数据页链表-6"><a href="#4-1-BufferPool数据页链表-6" class="headerlink" title="4.1 BufferPool数据页链表"></a>4.1 BufferPool数据页链表</h3><p>首先，<code>BufferPool</code> 有一块连续的内存空间： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114021.jpeg"></p>
<p> 空间里面，就被分割成几个部分：数据页控制块、缓存页、以及一些没有任何作用的内存碎片（就是剩余空间不足以分配一个数据页的内存空间）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114040.jpeg"></p>
<p> 控制块包含了很多信息（要不然为啥被独立出来）：包含数据页的表空间号、页号、缓存页的地址、锁信息、<code>LSN</code> 等等信息，我这里列了几个我们后面会用到的玩意儿。 因为有缓存页的地址，所以图会有个箭头（我只画了一个箭头）： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114054.jpeg"></p>
<p> 那数据库系统在启动的时候，就会自动的分配 <code>BufferPool</code> 空间，将控制块和数据页的位置规划好以备后续使用。</p>
<h3 id="4-2-BufferPool-的-free-数据缓存链表-6"><a href="#4-2-BufferPool-的-free-数据缓存链表-6" class="headerlink" title="4.2 BufferPool 的 free 数据缓存链表"></a>4.2 BufferPool 的 free 数据缓存链表</h3><p>OK，镜头深入一下控制块： </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114109.jpeg"></p>
<p> 那怎么管理链表呢，有个链表记录，记录谁有空，然后可以将空的控制块信息放入一个双向链表中，这时候如果数据库需要一个缓存页，可以从这个链表取出一个空闲的控制块进行操作，而管理空闲链表这边将会把这个控制块移除标（相当于记为已经使用） 那在查询数据的时候，我们知道查询的时候是加载索引来查询的，比方说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> stu_id = xxx;</span><br></pre></td></tr></table></figure>

<p>那 <code>MySQL</code> 肯定需要加载 <code>B+</code> 树来查询的嘛，那就需要先加载 <code>B+</code> 所在表的开始，那这时候就需要加载数据页了，因为每个表都有一个固定开始节点的记录，所以这时候就有了 <code>表空间号+页号</code> 的存在。 那 <code>MySQL</code> 因为读取数据的时候如果缓存页在 <code>BufferPool</code> 中的话就不用再 <code>IO</code> 加载了，那如何知道？ <code>BufferPool</code> 使用 <code>HASH</code> 索引来记录数据页的位置，可以假想成 <code>Java</code> 中的 <code>HashMap</code>，通过一定的算法计算一定能够拿到对应的 <code>value</code> 值对应的槽，进入可以快速的拿到 <code>value</code> 值，也就是缓存的数据页 ，而 <code>表空间号+页号</code> 就是一个 <code>key</code> 值了。</p>
<h3 id="4-3-BufferPool-的-LRU-管理（简单理解）-6"><a href="#4-3-BufferPool-的-LRU-管理（简单理解）-6" class="headerlink" title="4.3 BufferPool 的 LRU 管理（简单理解）"></a>4.3 BufferPool 的 LRU 管理（简单理解）</h3><p>上面已经说了，<code>MySQL</code> 查询数据的时候，会经过一系列的操作。但是，毕竟内存中的 <code>BufferPool</code> 容量肯定是有限的，没有硬盘那么大，所以不可能整个硬盘的数据库数据都缓存到 <code>BufferPool</code> 中去。那就需要淘汰一些不常用的数据了，这就是一个简单的 <code>LRU</code> 原理，那就有一个 <code>LRU链表</code> 来管理这些数据。</p>
<blockquote>
<p>LRU：链表管理数据，经常访问的数据会被放到链表头，而慢慢的，不常用的就会被排到链表后边去，发生空间不足的时候，链表尾部的数据将会被淘汰。</p>
</blockquote>
<p>那接下来我们结合一下修改数据，据我们所知，修改数据是先修改 <code>BufferPool</code> 中的数据页，然后再在某个时刻被后台线程刷新到硬盘的。 那如果说一个查询进来，<code>LRU</code> 链表空间已经不足，数据页是脏页（在 <code>flush</code> 链表中，下说）需要刷新，但是尾部的数据页已经是一个脏页（判断存不存在 <code>Flush链表</code> 中），那这个查询就会被<strong>阻塞</strong>，等到脏页被同步刷新到硬盘才可以接着进行查询。 所以为什么说，全表扫描会降低数据库的运行效率，因为全表的时候需要加载很多数据到 <code>BufferPool</code> 中去，很当前很可能 <code>BufferPool</code> 空间已经不足以容纳整个页，所以需要等待链表后续的脏页被同步写入硬盘才会去查询下一页的数据。</p>
<h3 id="4-4-BufferPool-的-LRU-深入管理（数据分区）-6"><a href="#4-4-BufferPool-的-LRU-深入管理（数据分区）-6" class="headerlink" title="4.4 BufferPool 的 LRU 深入管理（数据分区）"></a>4.4 BufferPool 的 LRU 深入管理（数据分区）</h3><p>一个 <code>LRU</code> 链表可不是什么都没有就一条链表那么简单，<code>MySQL</code> 将 <code>LRU链表</code> 划分为 <code>young区</code> 和 <code>old区</code>。那因为我们是 <code>JavaCoder</code>，就简单的说成是年轻代和老年代吧！ </p>
<p><img src="https://cdn.jsdelivr.net/gh/WeidanLi/image/20201110114119.jpeg"></p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-5"><a href="#4-4-BufferPool-的-flush-链表-5" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-5"><a href="#五-配置多个BufferPool实例-5" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-5"><a href="#六-BufferPool状态监控-5" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-5"><a href="#七-配置BufferPool-5" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-5"><a href="#7-1-总大小配置-5" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-5"><a href="#7-2-预读配置-5" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-5"><a href="#7-3-LRU配置-5" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-5"><a href="#八-完结-5" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>
<p> 但是但是，这个新生代和老年代和 <code>GC</code> 的可不一样。在 <code>MySQL</code> 中，老年代是用来存储使用 <code>频率不高</code> 的数据页的（<code>jvm</code> 是用来存储使用频率高常年不用清除的），而年轻代是用来存储使用 <code>频率很高</code> 的数据页的 为啥要这么设计呢，因为有两种情况：</p>
<ul>
<li>预读<ol>
<li>线性预读：当访问某个区的页面超过了配置的变量的时候，会触发异步读取下一个区所有的页到 <code>BufferPool</code> 中；</li>
<li>随机预读：如果某个区 <code>13</code> 个连续页面被读取，无论是不是顺序读取，会触发一次性加载本区所有的页，该配置默认是关闭的。</li>
</ol>
</li>
<li>全表扫描：一个全表扫描的语句会让 <code>BufferPool</code> 中所有的数据产生一次刷新，即变成当前读取表的所有数据，而那些本应该频繁被读取的数据页就被替换掉了，然后全表后这些数据又没啥用，又要重新读取前面说的频繁的数据来放进 <code>BufferPool</code></li>
</ul>
<p>OK，那上述的结构怎么解决这两个问题呢，其实很简单，就是这两个产生的数据页会先被放在了 <code>old区域</code> 也就是我们说的 <code>老年代</code>，然后，如果刚被放进去，在规定时间内被第二次访问发现少于系统参数设置的时间（后面配置会说哪个），就会将这个数据页从 <code>old区</code> 移动到 <code>young区</code>。</p>
<h3 id="4-4-BufferPool-的-flush-链表-6"><a href="#4-4-BufferPool-的-flush-链表-6" class="headerlink" title="4.4 BufferPool 的 flush 链表"></a>4.4 BufferPool 的 flush 链表</h3><p><code>flush链表</code> 主要是用来管理 <code>BufferPool</code> 中已经被修改的数据页，因为此时内存中的数据页已经发生修改，和硬盘上原有的数据页不同，所以就需要在某个时刻由 <code>后台线程</code> 刷新到硬盘上去。 但是，这个时候总不可能去循环所有数据页，然后判断是不是脏页吧，所以又有一条链表产生，就是 <code>flush链表</code>。这条链表没什么特殊的，长得和 <code>free链表</code> 也一样我就不画了。 那么什么时候会触发刷新脏页的机制：</p>
<ol>
<li>后台线程轮询到的时候；</li>
<li>查询需要 <code>BufferPool</code> 空间但是此时空间不足，从 <code>LRU链表的尾部</code> 刷新，判断有没有可以直接释放的，如果没有就会触发刷新的操作</li>
</ol>
<h2 id="五-配置多个BufferPool实例-6"><a href="#五-配置多个BufferPool实例-6" class="headerlink" title="五.配置多个BufferPool实例"></a>五.配置多个BufferPool实例</h2><p>多个 <code>BufferPool</code> 实例，可以提升速度，因为当有些操作需要加锁的时候，不需要加锁整个 <code>BufferPool</code> 而是加锁对应的实例就可以了，我们可以理解为 <code>ConcurrentHashMap</code> 中 <code>分桶</code> 的概念。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 8</span><br></pre></td></tr></table></figure>

<p>上面的配置即可将 <code>BufferPool</code> 分成 <code>8</code> 个实例。（该参数如果内存空间不足的时候，又会被程序自动修改成 <code>1</code>） 那每个 <code>BufferPool</code> 实例中都跟上面说的一样，该有的都会有。 修改 <code>innodb_buffer_pool_chunk_size</code> 参数可以修改每个实例运行占用的空间，默认是 <code>128m</code>，但是不允许在运行的时候进行修改，而是启动 <code>MySQL</code> 服务器的时候进行修改。在这里就需要注意一个问题，<code>BufferPool</code> 总大小需要算好，不然会出现一些奇奇怪怪的症状，也就是 <code>innodb_buffer_pool_size</code> = <code>innodb_buffer_pool_chunk_size</code> * <code>innodb_buffer_pool_instances</code>，也就是总大小 = 每个的大小 * 数量。当然如果这个等式不成立，那 <code>MySQL</code> 会直接使用总大小除以多少个实例的方式，来重置每个实例的空间大小。</p>
<h2 id="六-BufferPool状态监控-6"><a href="#六-BufferPool状态监控-6" class="headerlink" title="六.BufferPool状态监控"></a>六.BufferPool状态监控</h2><p>执行语句：<code>SHOW ENGINE INNODB STATUS\G;</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">..........省略其他内容</span><br><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 3298295808 // 向系统申请 BufferPool 总大小</span><br><span class="line">Dictionary memory allocated 2672815 // 数据字典分配的内存空间大小，这个内存是重新申请的，不在上面参数的内存中</span><br><span class="line">Buffer pool size   196584 // 当前 BufferPool 总页数</span><br><span class="line">Free buffers       8192 // free 链表中有多少空闲页</span><br><span class="line">Database pages     181326 // LRU 链表中 Young + old 一共有多少节点数量</span><br><span class="line">Old database pages 66771 // LRU 链表中 old 区有多少个节点</span><br><span class="line">Modified db pages  13056 // 当前 flush 链表中记录的脏页的页面数</span><br><span class="line">Pending reads      0 // 当前正在读取硬盘时，等待数据加载的数量</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0 // 即将从 BufferPool 中刷新到硬盘的页数</span><br><span class="line">Pages made young 2447992, not young 5080735 // LRU链表中，数据页从 old 移动到 young 区的数量</span><br><span class="line">12.24 youngs/s, 0.08 non-youngs/s // 继上面参数，每秒移动脏页的数量，第一个是移动到young的速率</span><br><span class="line">Pages read 333539, created 144753, written 850154 // 读取、创建、写入数据页的数量</span><br><span class="line">0.08 reads/s, 0.00 creates/s, 0.00 writes/s // 上面参数的速度</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 // 一千次访问中命中缓存的次数</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 181326, unzip_LRU len: 0 LRU // 节点数量</span><br><span class="line">I/O sum[32]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">// 近50秒读取硬盘页数当前正在读取的页数近50s压缩的页数正在解压的页面数</span><br><span class="line">----------------------</span><br><span class="line">INDIVIDUAL BUFFER POOL INFO // 有多个 BUFFER POOL 实例时的监控数据</span><br><span class="line">----------------------</span><br><span class="line">---BUFFER POOL 0</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22664</span><br><span class="line">Old database pages 8346</span><br><span class="line">Modified db pages  1614</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 257448, not young 513396</span><br><span class="line">0.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40501, created 16013, written 106562</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22664, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 1</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22654</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1518</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 319643, not young 644868</span><br><span class="line">1.68 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40879, created 18989, written 106056</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22654, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 2</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22682</span><br><span class="line">Old database pages 8352</span><br><span class="line">Modified db pages  1602</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 311448, not young 809147</span><br><span class="line">2.62 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 41561, created 18963, written 105852</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22682, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 3</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22648</span><br><span class="line">Old database pages 8340</span><br><span class="line">Modified db pages  1738</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 334107, not young 532202</span><br><span class="line">0.92 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40984, created 19273, written 106554</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22648, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 4</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22655</span><br><span class="line">Old database pages 8342</span><br><span class="line">Modified db pages  1646</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 381300, not young 703937</span><br><span class="line">2.41 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 45663, created 20331, written 106189</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22655, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 5</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22678</span><br><span class="line">Old database pages 8351</span><br><span class="line">Modified db pages  1544</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 298171, not young 685135</span><br><span class="line">2.86 youngs/s, 0.05 non-youngs/s</span><br><span class="line">Pages read 41962, created 18634, written 106267</span><br><span class="line">0.05 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22678, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 6</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22676</span><br><span class="line">Old database pages 8350</span><br><span class="line">Modified db pages  1807</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 275332, not young 599618</span><br><span class="line">0.68 youngs/s, 0.03 non-youngs/s</span><br><span class="line">Pages read 41591, created 16794, written 106230</span><br><span class="line">0.03 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22676, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">---BUFFER POOL 7</span><br><span class="line">Buffer pool size   24573</span><br><span class="line">Free buffers       1024</span><br><span class="line">Database pages     22669</span><br><span class="line">Old database pages 8348</span><br><span class="line">Modified db pages  1587</span><br><span class="line">Pending reads      0</span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line">Pages made young 270543, not young 592432</span><br><span class="line">0.46 youngs/s, 0.00 non-youngs/s</span><br><span class="line">Pages read 40398, created 15756, written 106444</span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="line">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="line">LRU len: 22669, unzip_LRU len: 0</span><br><span class="line">I/O sum[4]:cur[0], unzip sum[0]:cur[0]</span><br><span class="line">--------------</span><br><span class="line">..........省略其他内容</span><br></pre></td></tr></table></figure>

<h2 id="七-配置BufferPool-6"><a href="#七-配置BufferPool-6" class="headerlink" title="七. 配置BufferPool"></a>七. 配置BufferPool</h2><p>那就统一是写配置文件的方式来配置，有些参数可以直接在运行时配置。</p>
<h3 id="7-1-总大小配置-6"><a href="#7-1-总大小配置-6" class="headerlink" title="7.1 总大小配置"></a>7.1 总大小配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 3298295808</span><br></pre></td></tr></table></figure>

<p>该配置是配置 <code>BufferPool</code> 总大小，单位是 <code>byte</code>，上述的配置是 <code>3298295808 byte</code>，那 <code>3298295808 / 1024 / 1024 =3,145.5 m</code>。这个是线上阿里云数据库给的配置。这个配置并不包含 <code>控制块占用的内存空间</code>，所以实际申请的内存空间大概是 <code>3,145.5 m * 5% + 3,145.5 m =3,302.775m</code></p>
<h3 id="7-2-预读配置-6"><a href="#7-2-预读配置-6" class="headerlink" title="7.2 预读配置"></a>7.2 预读配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_read_ahead_threshold&#x3D;56 # 默认配置，设置顺序访问多少页时 线性预读当前区所有页面到BufferPool</span><br><span class="line">innodb_random_read_ahead&#x3D;off # 默认配置：命中某个区随机13个页面时会预读该区所有页面</span><br></pre></td></tr></table></figure>

<h3 id="7-3-LRU配置-6"><a href="#7-3-LRU配置-6" class="headerlink" title="7.3 LRU配置"></a>7.3 LRU配置</h3><p>两个配置均可运行时配置（<code>SET GLOBAL</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_old_blocks_pct &#x3D; 37 # 默认配置，设置old区域占比37%</span><br><span class="line">innodb_old_blocks_time&#x3D;1000 # 默认配置，全表扫描时，数据页在old区多少时间内被访问就会被移动到young区</span><br><span class="line">innodb_lru_scan_depth # 指定从尾部扫描脏页的数量</span><br></pre></td></tr></table></figure>

<h2 id="八-完结-6"><a href="#八-完结-6" class="headerlink" title="八.完结"></a>八.完结</h2><p>OK，<code>BufferPool</code> 的章节完结，接下来就是事务的事情了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weidan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
